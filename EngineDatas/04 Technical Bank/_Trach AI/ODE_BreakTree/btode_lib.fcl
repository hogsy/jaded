#include "btode_defs.var"

// ------- RETOURNE LE NOMBRE D'ELEMENTS ODE -------
procedure_local int BTODE_Structure_NumberOfBodyGet()
{
//--------------------------
	int				i, num
	int				flags
//--------------------------
		
	i = 0
	num = 0
	while(ao_ode_elements[i])
	{
		flags = @ao_ode_elements[i] ODE_Geti(0)
		
		if(flags & ODE_HasRigidBody)
		{
			num ++
		}

		i ++
	}
	
	return num
}

// ------- ACTIVATION DE TOUS LES JOINTS DE LA STRUCTURE
procedure_local void BTODE_Structure_Joint_Activation()
{
//----------------------
	int			i
//----------------------

	i = 0
	while(ao_ode_joints[i])
	{
		@ao_ode_joints[i] OBJ_FreezeModifier(29, 0)
		i ++
	}	
}

// ------- ACTIVATION/DESACTIVATION DE TOUS LES ELEMENTS ODE -------
procedure_local void BTODE_Structure_Activation_OnOFF(int on)
{
//----------------------
	int			i
//----------------------

	i = 0
	while(ao_ode_elements[i])
	{	
		// Element détruit, on skip ...
		if(ai_ode_elements_etat[i] == ODE_Element_Etat_Detruit)
		{
			i ++
			continue
		}
				
		@ao_ode_elements[i] ODE_Enable(on)
		
		if(on)
			ai_ode_elements_etat[i] = ODE_Element_Etat_Actif	
		else
			ai_ode_elements_etat[i] = ODE_Element_Etat_Inactif
		
		i++
	}	
}

// ------- FLAG FORCE IMMOVABLE
procedure_local void BTODE_Structure_Immovable_OnOFF(int on)
{
//--------------------------------
	int			i
	int			control_flag
//--------------------------------
	
	i = 0	
	while(ao_ode_elements[i])
	{	
		// Element détruit, on skip ...
		if(ai_ode_elements_etat[i] == ODE_Element_Etat_Detruit)
		{
			i ++
			continue
		}
				
		control_flag = @ao_ode_elements[i] ODE_Geti(0)
		
		if(on)
			control_flag |= 0x20
		else
			control_flag &= ~0x20
			
		@ao_ode_elements[i] ODE_Seti(0, control_flag)
				
		i++
	}	
}

// ------- FLAG PAUSE
procedure_local void BTODE_Structure_Pause_OnOFF(int on)
{
//--------------------------------
	int			i
	int			control_flag
//--------------------------------
	
	i = 0	
	while(ao_ode_elements[i])
	{	
		// Element détruit, on skip ...
		if(ai_ode_elements_etat[i] == ODE_Element_Etat_Detruit)
		{
			i ++
			continue
		}
							
		@ao_ode_elements[i] ODE_Pause(on)		
		ai_ode_elements_etat[i] = ODE_Element_Etat_Actif	
		
		i++
	}	
}

// ------- TEST ELEMENT INACTIF/INVISIBLE
procedure_local int BTODE_Structure_TestElementRemoved()
{
//--------------------------------	
	int 	i, flags
//--------------------------------	
	
	i = 0
	while(ao_ode_elements[i])
	{
		// On skip les élements déjà détruit ...
		if(ai_ode_elements_etat[i] == ODE_Element_Etat_Detruit) 
		{
			i++
			continue
		}
	
		flags = @ao_ode_elements[i] OBJ_FlagsStatusGet()
		if( ! (flags  & OBJ_C_StatusFlag_Visible) && ! (flags & OBJ_C_StatusFlag_Active))
		{
				// Tag l'élément comme détruit ...
				ai_ode_elements_etat[i] = ODE_Element_Etat_Detruit
				@ao_ode_elements[i] ODE_Enable(0)								
				return 1
		}
		i++
	}
	
	return 0
}

// ------- TEST ELEMENT INACTIF/INVISIBLE
procedure_local int BTODE_Structure_TestTotalDesactivation()
{
//--------------------------------		
	int					i
//--------------------------------		
	
	i = 0
	while(ao_ode_elements[i])
	{	
		// on ne teste pas le GO vase s'il fait partie de la structure ...
		if(ao_ode_elements[i] == o_vase)
		{
			i++
			continue
		}
		if
		(
			(ai_ode_elements_etat[i] == ODE_Element_Etat_Detruit)
		||   (ai_ode_elements_etat[i] == ODE_Element_Etat_Inactif)
		)
		{
			i ++
			continue
		}
			
		return 0
	}
	
	return 1
}
// ------- DETRUIT UN GAO PARTICULIER S'IL FAIT PARTIE DE LA STRUCTURE
procedure_local void BTODE_Object_Kill(object o_gao)
{
//--------------------------------		
	int					i
//--------------------------------		

	@o_gao ODE_Enable(0)
	
	i = 0
	while(ao_ode_elements[i])
	{	
		if(ao_ode_elements[i] == o_gao)
		{
			ai_ode_elements_etat[i] = ODE_Element_Etat_Detruit
			return
		}
		i ++
	}	
}

// ------- SET IMMOVABLE FLAG FOR ONE OBJECT
procedure void BTODE_Object_ImmovableOnOFF(object o_gao, int on)
{
//--------------------------------
		int			control_flag
//--------------------------------
	
		control_flag = @o_gao ODE_Geti(0)
		
		if(on)
			control_flag |= 0x20
		else
			control_flag &= ~0x20

		@o_gao ODE_Seti(0, control_flag)
}

// ------- CHECK IF ONE ELEMENT OF THE STRUCTURE IS UNPAUSED
procedure_local int BTODE_b_Structure_Is_UnPaused(byref int i_num_unpaused)
{
//----------------------
	int			i
	int			flags
//----------------------

	i_num_unpaused = 0
	i = 0
	while(ao_ode_elements[i])
	{	
		// Element détruit, on skip ...
		if(ai_ode_elements_etat[i] == ODE_Element_Etat_Detruit)
		{
			i ++
			continue
		}
		
		flags = @ao_ode_elements[i] ODE_Geti(0)
		
		if
		(
				  (flags & ODE_HasRigidBody)
		&&    ! (flags & ODE_ForceImmovable)
		&& 	  (@ao_ode_elements[i] ODE_Pause(-1) == 0)
		&&      (ai_ode_elements_etat[i] != ODE_Element_Etat_DansLaVase)
		)
		{
			i_num_unpaused ++
		}
		
		i++
	}
	
	return i_num_unpaused
}
// ---------------------------------------------------------------------------------------------------------------- 
// ---------------------------------------------------------------------------------------------------------------- 
// ----------------------------------------------SON----------------------------------------------------------- 
// ---------------------------------------------------------------------------------------------------------------- 
// ---------------------------------------------------------------------------------------------------------------- 

// ------- GESTION RUMBLE
procedure_local void BTODE_Structure_Sons_Rumble()
{
//------------------------------------	
int			ti_num_unpaused
float		f_percent_rumble_target
//------------------------------------	
	
	if(BTODE_b_Structure_Is_UnPaused(ti_num_unpaused))
	{
		if(i_instance_snd_rumble == -1)
		{
			i_instance_snd_rumble = SND_RequestPlayLoop(ODE_Sound_Rumble)
		}
		
		// Gestion du volume du rumble par rapport au nombre d'objects vraiment en mouvement
		f_percent_rumble_target = ti_num_unpaused 
		f_percent_rumble_target /= i_num_ode_elements
		
		f_percent_rumble = MATH_FloatBlend(f_percent_rumble, f_percent_rumble_target, 0.1)
		
		if(i_instance_snd_rumble != -1)
			SND_InsertVarSet(i_instance_snd_rumble,28, f_percent_rumble)
	}
	else
	{
		if(i_instance_snd_rumble != -1)
		{
			SND_Stop(i_instance_snd_rumble)
			i_instance_snd_rumble = -1
		}
	}

}


// ------- GESTION WHOOSH
procedure_local void BTODE_Structure_Sons_Whoosh()
{
//----------------------
	int			i, j
//----------------------
	i = 0
	while(ao_element_whooshable[i])
	{	
		j = 0
		while(ao_ode_elements[j])
		{
			if(ao_ode_elements[j] == ao_element_whooshable[i])
			{
				break
			}
			j ++			
		}
		
		// Pa trouvé cet élément whooshable dans la structure .. je le skip ...
		if(!ao_ode_elements[j])
		{
			i ++
			continue
		}
		
		if((f_linear_whoosh != 0.0) && (af_ode_deriveeL_frame[j] > f_linear_whoosh))
		{
			if(ai_instance_snd_whoosh[i] == -1)
			{
				ai_instance_snd_whoosh[i] = SND_Request(ODE_Sound_Whoosh, 0)
				if(ai_instance_snd_whoosh[i] != -1)
					@ao_element_whooshable[i] SND_Play(ai_instance_snd_whoosh[i])
			}			
		}
		else
		{
			if(ai_instance_snd_whoosh[i] != -1)
			{
				if(!SND_IsPlaying(ai_instance_snd_whoosh[i]))
				{
					SND_Stop(ai_instance_snd_whoosh[i])
					ai_instance_snd_whoosh[i] = -1
				}
			}
		}	
			
		i ++
	}	
}

// ------- GESTION DES CHOCS LOCAUX
procedure_local void BTODE_Structure_Sons_Chocs()
{
//----------------------
	int			i, j
	float		f_vel
	float		f_ang
	int			instance
	float		f_diffL
	float		f_diffA
	int			tai_Prio[16]
	int			ti_NumPrio
	int			sound
//----------------------
		
	tai_Prio[0] = 4		// Water
	tai_Prio[1] = 3		// Pierre
	tai_Prio[2] = 2		// Veget
	tai_Prio[3] = 1		// Terre
		
	ti_NumPrio = 4
	
	j = 0
	while(ao_ode_elements[j])
	{	
		// Element dans la vase ... ranafout
		if(ai_ode_elements_etat[j] == ODE_Element_Etat_DansLaVase)
		{
			j ++			
			continue			
		}
			
		// Dérivées  de vitesses linéraires et angulaires ont le même signe ... pas de choc
		if
		(
				( MATH_FloatSign(af_ode_deriveeL_frame[j]) == MATH_FloatSign(af_ode_deriveeL_old_frame[j]))
		&&	( MATH_FloatSign(af_ode_deriveeA_frame[j]) == MATH_FloatSign(af_ode_deriveeA_old_frame[j]))

		)
		{
			j ++			
			continue
		}
			
		
		// On veut une valeur positive à tester
		f_diffL = af_ode_deriveeL_frame[j]
		f_diffA = af_ode_deriveeA_frame[j]		
		
		if(f_diffL < 0.0)  f_diffL *= -1.0
		if(f_diffA < 0.0)  f_diffA *= -1.0
		
					
		if( (f_linear_threshold != 0.0) && (f_diffL < f_linear_threshold) && (f_angular_threshold != 0.0) && (f_diffA < f_angular_threshold))
		{
			j ++
			continue
		}
		
		sound = @ao_ode_elements[j] COL_ODE_PrioSoundGet(&tai_Prio[0], ti_NumPrio)
			
		instance = SND_Request(ODE_Sound_Choc_Local + sound, C_SND_Request_DestroyWhenFinished)								
		if(instance != -1)
			@ao_ode_elements[j] SND_Play(instance)
		
		j ++
	}
}
// ------- GESTION DES DERIVEES / VITESSE DE LA FRAME COURANTE
procedure_local void BTODE_Structure_UpdateCurrentFrameValues()
{
//----------------------
	int			i
//----------------------
	
	i = 0
	while(ao_ode_elements[i])
	{
		af_ode_vitesseL_frame[i] = @ao_ode_elements[i] ODE_Getf(2)
		af_ode_deriveeL_frame[i] = (af_ode_vitesseL_frame[i] - af_ode_vitesseL_old_frame[i]) / TIME_GetDt()
		
		af_ode_vitesseA_frame[i] = @ao_ode_elements[i] ODE_Getf(3)
		af_ode_deriveeA_frame[i] = (af_ode_vitesseA_frame[i] - af_ode_vitesseA_old_frame[i]) / TIME_GetDt()
	
		i ++
	}
}

// ------- GESTION DES DERIVEES / VITESSE DE LA FRAME D'AVANT
procedure_local void BTODE_Structure_UpdateOldFrameValues()
{
//----------------------
	int			i
//----------------------
	
	i = 0
	while(ao_ode_elements[i])
	{
		af_ode_vitesseL_old_frame[i] = af_ode_vitesseL_frame[i]
		af_ode_deriveeL_old_frame[i] = af_ode_deriveeL_frame[i]
		af_ode_vitesseA_old_frame[i] = af_ode_vitesseA_frame[i]
		af_ode_deriveeA_old_frame[i] = af_ode_deriveeA_frame[i]
		
		i ++
	}
}