// MY RAG DOLL
#include "H_defines.var"

int			ti_i
int			ti_index
int			ti_iterations
int			ti_bone_index[10]
int			ti_flag_up
int			ti_special_normalize

float		tf_norm
float		tf_hor_norm
float		tf_dist_min
float		taf_bone_length[10]
float		tf_angle
float		tf_length_1
float		tf_length_2
float		tf_length_3
float		tf_X
float		tf_Y
float		tf_Z_min

vector	tv_X
vector	tv_Y
vector	tv_add_speed
vector	tav_last_pos[Ci_nb_bone]
vector	tav_renormalisation[Ci_nb_bone]
vector	tv_precedent
vector	tv_precedent_Z0
vector	tv_temp
vector	tv_new_sight
vector	tv_new_banking

//object	to_head
object	to_bone
object	to_cuisse_gauche
object	tao_bones[Ci_nb_bone]

#define QUATERNION									1

ti_bone_index[0] = Anim_Canal_PiedGauche
ti_bone_index[1] = Anim_Canal_JambeGauche
ti_bone_index[2] = Anim_Canal_Bassin
ti_bone_index[3] = Anim_Canal_Ventre
ti_bone_index[4] = Anim_Canal_Torse
ti_bone_index[5] = Anim_Canal_Cou

for (ti_i = 0; ti_i < Ci_nb_bone; ti_i++)
{
	tao_bones[ti_i] = ANI_CanalObjectGet(ti_bone_index[ti_i])

	if (ti_i)
		taf_bone_length[ti_i] = MATH_VecNorm(@tao_bones[ti_i - 1] OBJ_PosGet() - @tao_bones[ti_i] OBJ_PosGet())
}

if (o_test)
	to_head = o_test

to_cuisse_gauche = ANI_CanalObjectGet(Anim_Canal_CuisseGauche)

if (MATH_VecNull(av_rd_pos[0]))
{
	for (ti_i = 0; ti_i < Ci_nb_bone; ti_i++)
		av_rd_pos[ti_i] = @tao_bones[ti_i] OBJ_PosGet()
}

//if (DBG_snap_bone)
//{
//	COL_RayObject_Dist(@DBG_snap_bone OBJ_PosGet() + cvector(0.0, 0.0, 100.0), cvector(0.0, 0.0, -1.0), 1000.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//	tf_Z_min = COL_RayObject_PosGet().z + 0.2
//
//	av_rd_pos[0] = @to_head OBJ_PosGet()
//	av_rd_pos[0].z = MATH_FloatMax(av_rd_pos[0].z, tf_Z_min)
//}
//else
//{
//	tf_Z_min = @o_grab_actor OBJ_PosGet().z + 0.2
//
//	av_rd_pos[0] = @to_head OBJ_PosGet()
//	av_rd_pos[0] += @to_head OBJ_BankingGet() * 0.5
//}
//
//OBJ_PosSet(av_rd_pos[0])
//
//tv_new_sight = av_rd_pos[0] - av_rd_pos[Ci_nb_bone - 1]
//tv_new_banking = MATH_VecCrossProduct(tv_new_sight, Cv_VerticalVector)
//tv_new_banking = MATH_VecCrossProduct(tv_new_banking, tv_new_sight)
//OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)

tf_Z_min = OBJ_PosGet().z - 1.0

// AJOUTER LA VITESSE ET LA GRAVITE
for (ti_i = 0; ti_i < Ci_nb_bone; ti_i++)
{
	tav_last_pos[ti_i] = av_rd_pos[ti_i]

	tv_add_speed = 0.75 * av_rd_speed[ti_i]
	tv_add_speed += cvector(0.0, 0.0, -2.0)
	tv_add_speed *= TIME_GetDt()

	av_rd_pos[ti_i] += tv_add_speed

	av_rd_pos[ti_i].z = MATH_FloatMax(av_rd_pos[ti_i].z, tf_Z_min)
}

// LES POINTS ONT BOUGE
for (ti_iterations = 0; ti_iterations < 10; ti_iterations++)
{
	for (ti_i = 1; ti_i < Ci_nb_bone; ti_i++)
	{
		// NORMALISATION VERS LE PRECEDENT
		tv_precedent = av_rd_pos[ti_i - 1] - av_rd_pos[ti_i] 
		tf_norm = MATH_VecNorm(tv_precedent)

		ti_special_normalize = faux
		
		if (!tf_norm)
			ti_special_normalize	= vrai
//		else if (tv_precedent.z < 0.01)
//		{
//			tf_dist_min = taf_bone_length[ti_i]
//			tf_dist_min *= 0.75
//
//			tv_precedent_Z0 = tv_precedent
//			tv_precedent_Z0.z = 0.0
//		
//			tf_hor_norm = MATH_VecNorm(tv_precedent_Z0) 
//			if (tf_hor_norm < tf_dist_min)
//				ti_special_normalize	= vrai
//		}

		if (ti_special_normalize)
		{
			tv_precedent = -OBJ_SightGet()
			
			tv_temp = tv_precedent
			tv_temp *= taf_bone_length[ti_i]
		}
		else
		{
			tv_precedent /= tf_norm
			
			tv_temp = tv_precedent
			tv_temp  *= tf_norm - taf_bone_length[ti_i]
		}

		tav_renormalisation[ti_i] = tv_temp // * 0.5
		
		// NORMALISATION VERS LE SUIVANT
		if (ti_i < Ci_nb_bone - 1)
		{
			tv_temp = av_rd_pos[ti_i + 1] - av_rd_pos[ti_i] 
			tf_norm = MATH_VecNorm(tv_temp)
	
			ti_special_normalize = faux
	
			if (!tf_norm)
				ti_special_normalize	= vrai
//			else if (tv_precedent.z < 0.01)
//			{
//				tf_dist_min = taf_bone_length[ti_i + 1]
//				tf_dist_min *= 0.75
//
//				tv_precedent_Z0 = tv_precedent
//				tv_precedent_Z0.z = 0.0
//		
//				tf_hor_norm = MATH_VecNorm(tv_precedent_Z0) 
//				if (tf_hor_norm < tf_dist_min)
//					ti_special_normalize	= vrai
//			}		

			if (ti_special_normalize)
			{
				tv_temp = -OBJ_SightGet()
				tv_temp *= taf_bone_length[ti_i + 1]
			}
			else
			{
				tv_temp /= tf_norm
				tv_temp *= tf_norm - taf_bone_length[ti_i + 1]
			}
	
			tav_renormalisation[ti_i] += tv_temp // * 0.5
		}
		
		av_rd_pos[ti_i] += tav_renormalisation[ti_i]
	}
}

// POSITIONNEMENT BASSIN QUI EST LE PERE DE TOUT
to_bone = tao_bones[2] 
@to_bone OBJ_PosSet(av_rd_pos[2])

#ifdef QUATERNION	
//tv_temp = MATH_VecCrossProduct(@to_bone OBJ_BankingGet(), MATH_VecNormalize(av_rd_pos[3] - av_rd_pos[2]))
//tf_angle = MATH_VecNorm(tv_temp)
//@to_bone OBJ_RotateAroundVec(@to_bone MATH_VecGlobalToLocal(tv_temp / tf_angle), MATH_ASin(tf_angle))
@to_bone OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @to_bone MATH_VecGlobalToLocal(av_rd_pos[3] - av_rd_pos[2]))
#endif

#ifndef QUATERNION
@to_bone OBJ_BankingSet(av_rd_pos[3] - av_rd_pos[2])
#endif

// CONTRAINTES
//av_rd_pos[1] = av_rd_pos[0]
//av_rd_pos[1] += @to_head OBJ_BankingGet() * taf_bone_length[1]
//
//av_rd_pos[2] -= av_rd_pos[0]
//av_rd_pos[2] = MATH_VecInCone(av_rd_pos[2], @to_head OBJ_BankingGet(), Cf_PiBy3, 0)
//av_rd_pos[2] += av_rd_pos[0]

for (ti_i = 3; ti_i < Ci_nb_bone; ti_i++)
{
	av_rd_pos[ti_i]  -= av_rd_pos[ti_i - 1]
	av_rd_pos[ti_i] = MATH_VecInCone(av_rd_pos[ti_i], av_rd_pos[ti_i - 1] - av_rd_pos[ti_i - 2], Cf_PiBy3, 0)
	av_rd_pos[ti_i] += av_rd_pos[ti_i - 1]
}

// CONSTRAINT SUR LA JAMBE POUR LE SENS DE TORSION
tf_length_1 = MATH_VecNorm(av_rd_pos[1] -  @to_cuisse_gauche OBJ_PosGet())
tf_length_2 = MATH_VecNorm(av_rd_pos[0] -  av_rd_pos[1])
tf_length_3 = MATH_VecNorm(av_rd_pos[0] -  @to_cuisse_gauche OBJ_PosGet())

tv_X = av_rd_pos[0] - @to_cuisse_gauche OBJ_PosGet()
MATH_VecSetNormalize(tv_X)

tv_Y = -@to_cuisse_gauche OBJ_HorizonGet()
tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)
MATH_VecSetNormalize(tv_Y)

tf_X = tf_length_2 * tf_length_2
tf_X -= tf_length_1 * tf_length_1
tf_X -= tf_length_3 * tf_length_3
tf_X /= -2.0 * tf_length_3

tf_Y = tf_length_1 * tf_length_1
tf_Y -= tf_X * tf_X
tf_Y = MATH_FloatMax(tf_Y, 0.0)
tf_Y = MATH_FloatSqrt(tf_Y)

av_rd_pos[1] = @to_cuisse_gauche OBJ_PosGet()
av_rd_pos[1] += tf_X * tv_X
av_rd_pos[1] += tf_Y * tv_Y

// PUTAIN DE HIERARCHIES
//ti_bone_index[0] = Anim_Canal_PiedGauche
//ti_bone_index[1] = Anim_Canal_JambeGauche
//ti_bone_index[2] = Anim_Canal_Bassin
//ti_bone_index[3] = Anim_Canal_Ventre
//ti_bone_index[4] = Anim_Canal_Torse
//ti_bone_index[5] = Anim_Canal_Cou

ti_bone_index[0] = 2
ti_bone_index[1] = 3
ti_bone_index[2] = 4
ti_bone_index[3] = 5
ti_bone_index[4] = 1
ti_bone_index[5] = 0

for (ti_i = 0; ti_i < Ci_nb_bone - 1; ti_i++)
	DBG_RenderVector(av_rd_pos[ti_i], av_rd_pos[ti_i + 1] - av_rd_pos[ti_i], color_bleu)
	
for (ti_i = 1; ti_i < Ci_nb_bone; ti_i++)
{
	ti_index = ti_bone_index[ti_i]

	// CAS PARTICULIER POUR LA CUISSE
	if (ti_index == 1)
	{

#ifdef QUATERNION	
//	tv_temp = MATH_VecCrossProduct(@to_cuisse_gauche OBJ_BankingGet(), MATH_VecNormalize(av_rd_pos[ti_index] - @to_cuisse_gauche OBJ_PosGet()))
//	tf_angle = MATH_VecNorm(tv_temp)
//	@to_cuisse_gauche OBJ_RotateAroundVec(@to_cuisse_gauche MATH_VecGlobalToLocal(tv_temp / tf_angle), MATH_ASin(tf_angle))
	@to_cuisse_gauche OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @to_cuisse_gauche MATH_VecGlobalToLocal(av_rd_pos[ti_index] - @to_cuisse_gauche OBJ_PosGet()))
#endif

#ifndef QUATERNION	
		@to_cuisse_gauche OBJ_BankingSet(av_rd_pos[ti_index] - @to_cuisse_gauche OBJ_PosGet())
#endif
	}

	to_bone = tao_bones[ti_index] 
	@to_bone OBJ_PosSet(av_rd_pos[ti_index])
	
	if (ti_index < Ci_nb_bone - 1)
	{

#ifdef QUATERNION	
		if (ti_index && ti_index < 2)
		{
//			tv_temp = MATH_VecCrossProduct(@to_bone OBJ_BankingGet(), MATH_VecNormalize(av_rd_pos[ti_index - 1] - av_rd_pos[ti_index]))
//			tf_angle = MATH_VecNorm(tv_temp)
//			@to_bone OBJ_RotateAroundVec(@to_bone MATH_VecGlobalToLocal(tv_temp / tf_angle), MATH_ASin(tf_angle))
			@to_bone OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @to_bone MATH_VecGlobalToLocal(av_rd_pos[ti_index - 1] - av_rd_pos[ti_index]))
		}
		else
		{
//			tv_temp = MATH_VecCrossProduct(@to_bone OBJ_BankingGet(), MATH_VecNormalize(av_rd_pos[ti_index + 1] - av_rd_pos[ti_index]))
//			tf_angle = MATH_VecNorm(tv_temp)
//			@to_bone OBJ_RotateAroundVec(@to_bone MATH_VecGlobalToLocal(tv_temp / tf_angle), MATH_ASin(tf_angle))
			@to_bone OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @to_bone MATH_VecGlobalToLocal(av_rd_pos[ti_index + 1] - av_rd_pos[ti_index]))
		}
#endif

#ifndef QUATERNION	
		if (ti_index && ti_index < 2)
			@to_bone OBJ_BankingSet(av_rd_pos[ti_index - 1] - av_rd_pos[ti_index])
		else
			@to_bone OBJ_BankingSet(av_rd_pos[ti_index + 1] - av_rd_pos[ti_index])
#endif
	}
}

@tao_bones[0] OBJ_BankingSet(av_rd_pos[0] - av_rd_pos[1])
//@tao_bones[0] OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @tao_bones[0] MATH_VecGlobalToLocal(av_rd_pos[0] - av_rd_pos[1]))

// CALCUL DES SPEED
for (ti_i = 1; ti_i < Ci_nb_bone; ti_i++)
{
	av_rd_speed[ti_i] = av_rd_pos[ti_i] - tav_last_pos[ti_i]
	av_rd_speed[ti_i] /= TIME_GetDt()
}

ti_i = ti_i
