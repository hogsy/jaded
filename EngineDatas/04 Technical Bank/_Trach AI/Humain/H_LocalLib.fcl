#include "H_defines.var"
#include "H_action.var"


procedure int GRID_PosValid(vector src, vector dst);
procedure int GRID_Blocked(vector v, int dyn);
procedure vector GRID_LastPosValid(vector src, vector dst, int dyn);
procedure vector GRID_PosValidSimplifie(vector src, vector dst, int dyn);
procedure int PeutSimplifierLeReseau( );
procedure void ForceCrouch( );
procedure int AnimWeapon( );
procedure vector CorrectShootSight( );
procedure void ACT_ActionSet1( int what );
procedure int BambouEnMain( );
procedure int JetableEnMain( );
//procedure int IsWater(int ground);
procedure int CacheTientLaPos(object cache);
procedure int IsLoadingWeapon( );
procedure int Humains_GetIndex( object	gao );
procedure void H_ActionCacheAtt( );
procedure_local vector H_BlendRotate(vector v1, vector v2, float speed, float disable);
procedure int H_RealCrouch( );
procedure int CaseBrulee(vector pos);
procedure object H_COL_RayObject_Dist(int what, vector sight, float dist);

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local void ForceRegardSur(object obj, float time)
{
	i_force_regard_toujours = faux
	o_force_regard_time = obj
	v_force_regard_time = Cv_NullVector
	f_force_regard_time = time
	i_flag_coup_oeil = faux		
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local void ForceRegardSurToujours(object obj, float time)
{
	i_force_regard_toujours = vrai
	o_force_regard_time = obj
	v_force_regard_time = Cv_NullVector
	f_force_regard_time = time
	i_flag_coup_oeil = faux		
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local void ForceRegardSurPos(vector pos, float time)
{
	o_force_regard_time = OBJ_Me()
	v_force_regard_time = pos
	f_force_regard_time = time
	i_flag_coup_oeil = faux		
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
// Peut on balancer une phrase sur to_obj ?
procedure_local int PeutParlerDe(object to_obj)
{
	vector	tv_temp
	
	if(to_obj == OBJ_Me()) return faux
	tv_temp = @to_obj OBJ_PosGet() - OBJ_PosGet()
	tv_temp.z = 0
	if(MATH_VecNullEpsilon(tv_temp)) return faux
	MATH_VecSetHorzNormalize(tv_temp)
	if(MATH_VecDotProduct(OBJ_SightGet(), tv_temp) < 0.1) return faux
	if(OBJ_SqrDist(to_obj) > 5 * 5) return faux
	return vrai
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void AskText(int wfreq, int txt, int freq, object who)
{
	if(freq == -1 || TIME_Elapsed(Humains_BlaBlaFreq[wfreq], freq))
	{
		if(who)
		{		
		 	if(!PeutParlerDe(who)) return
		 	if(!f_pilotage_bras_duration) ForceRegardSur(who, 3.0)
		}

		Humains_BlaBlaFreq[wfreq] = TIME_Get()
		i_request_txt = txt
	}
}

procedure_local void AskTextG(int wfreq, int txt, int freq, object who)
{
	if(freq == -1 || TIME_Elapsed(@"univ" Humains_BlaBlaFreq[wfreq], freq))
	{
		if(who)
		{		
		 	if(!PeutParlerDe(who)) return
		 	if(!f_pilotage_bras_duration) ForceRegardSur(who, 2.0)
		}

		@"univ" Humains_BlaBlaFreq[wfreq] = TIME_Get()
		i_request_txt = txt
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int GunEnPlace( )
{
	int	ti_weapon
	
	ti_weapon = @"univ" i_weapon_ID [i_id_humain]
	if(!ti_weapon) return faux
	if(!@"univ" i_weapon_ammunition[ti_weapon][i_id_humain] && !@"univ" i_weapon_ammunition_reserve[ti_weapon][i_id_humain])
	{
		if(!BambouEnMain())
			return faux
	}
	return vrai
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int GunEnPlaceSansReserve( )
{
	int	ti_weapon
	
	ti_weapon = @"univ" i_weapon_ID [i_id_humain]
	if(!ti_weapon) return faux
	if(BambouEnMain())		return vrai
	if(JetableEnMain())		return faux
	if( !@"univ" i_weapon_ammunition[ti_weapon][i_id_humain] )	return faux
	return vrai
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Vérifie si un event est dans un cone
procedure int	EnemyIsInCone( messageid EVT_ID, vector EVT_Sommet, vector EVT_Axe, float EVT_AngleCos, float EVT_Longueur, int EVT_LRay )
{
	vector		tv_center
	vector		tv_vct
	vector		tv_vct1
	vector		tv_vct2
	vector		tv_vct_ortho
	object		to_obj
	int				i_test
	int				ti_type
	float			tf_dist_carre
	float			tf_radius
	float			tf_norm			
	
	tf_dist_carre = EVT_Longueur * EVT_Longueur
	
	// Calcul du vecteur Sommet - Position de l EVENT
	to_obj = EVENT_PereGet( EVT_ID)
	tv_center = EVENT_PositionGet(EVT_ID)
	tv_vct = tv_center - EVT_Sommet

	// Test du dot product pour verifier si le Pt est suffisamment proche
	if ( MATH_VecDotProduct( tv_vct, tv_vct) < tf_dist_carre)
	{
		// dans le cone ??
		ti_type = EVENT_EnemyTypeGet( EVT_ID )
		if ( (ti_type < 0) || (ti_type >= C_ID_Number ))
			tf_radius = 0
		else
			tf_radius = @"univ" Enemy_af_Radius[ ti_type ]
			
		tv_vct_ortho.x  = -tv_vct.y
		tv_vct_ortho.y  = tv_vct.x
		tv_vct_ortho.z = 0
		tf_norm = MATH_VecNorm( tv_vct_ortho )
		if ( tf_norm == 0 )
		{
			tv_vct1 = tv_vct
			MATH_VecSetHorzNormalize( tv_vct1)
			tv_vct2 = tv_vct1
		}
		else
		{
			tv_vct_ortho *= tf_radius / tf_norm
			// Approximation des 2 points les plus extérieurs du cercle
			tv_vct1 = tv_vct  + tv_vct_ortho
			MATH_VecSetHorzNormalize( tv_vct1)
			tv_vct2 = tv_vct  - tv_vct_ortho
			MATH_VecSetHorzNormalize( tv_vct2)
		}

		MATH_VecSetHorzNormalize( EVT_Axe)
		// Test du dot product pour verifier si un des 2 extremums est dans le cone
		if ( MATH_VecDotProduct( EVT_Axe, tv_vct1) >= EVT_AngleCos || MATH_VecDotProduct( EVT_Axe, tv_vct2) >= EVT_AngleCos )	
		{
			i_test = vrai
			if ( !EVT_LRay)
				return( 1)		// La cible est visible
			else
			{
//				DBG_RenderVector(EVT_Sommet, tv_vct, 0xFF00FFFF)
				COL_SpecificCrossableSet(COL_CrossableGet() | Gmat_KK_Face_de_Bord) 
				to_obj = COL_RayObject_Vector( EVT_Sommet, tv_vct, all, none, 0, COL_C_Ray_on_ColMap_NoCrossable | COL_C_Ray_use_SpecificCrossableSet)
				if ( !to_obj || to_obj == EVENT_PereGet( EVT_ID))
					return(1)	// La cible est visible
			}		
		}
	}
	return(0)	// La cible n'est pas dans le cone
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void SwapArmeHayesBeg( )
//{
//	int		ti_mem_arme, ti_arme
//
//	if(JetableEnMain())
//	{
//		i_obj_lance_type_hayes = @"univ" i_weapon_ID[i_id_humain]
//		i_obj_lance_type_jack = 0
//		return
//	}	
//	
//	// Recup arme principale de hayes	
//	ti_mem_arme = @"univ" i_weapon_ID[i_id_humain]
//	if(ti_mem_arme != Ci_weapon_ID_tommy_gun && ti_mem_arme != Ci_weapon_ID_shotgun && ti_mem_arme != Ci_weapon_ID_sniper_rifle && ti_mem_arme != Ci_weapon_ID_colt)
//		ti_mem_arme = @"univ" i_weapon_ID_second[i_id_humain]
//	if(ti_mem_arme != Ci_weapon_ID_tommy_gun && ti_mem_arme != Ci_weapon_ID_shotgun && ti_mem_arme != Ci_weapon_ID_sniper_rifle && ti_mem_arme != Ci_weapon_ID_colt)
//		ti_mem_arme = @"univ" i_weapon_ID_Save[i_id_humain]
//	if(ti_mem_arme != Ci_weapon_ID_tommy_gun && ti_mem_arme != Ci_weapon_ID_shotgun && ti_mem_arme != Ci_weapon_ID_sniper_rifle && ti_mem_arme != Ci_weapon_ID_colt)
//		ti_mem_arme = 0
//	i_obj_lance_type_hayes = ti_mem_arme
//	
//	// Recup arme principale de jack
//	ti_arme = @"univ" i_weapon_ID[C_ID_Jack]
//	if(ti_arme != Ci_weapon_ID_tommy_gun && ti_arme != Ci_weapon_ID_shotgun && ti_arme != Ci_weapon_ID_sniper_rifle && ti_arme != Ci_weapon_ID_colt)
//		ti_arme = @"univ" i_weapon_ID_second[C_ID_Jack]
//	if(ti_arme != Ci_weapon_ID_tommy_gun && ti_arme != Ci_weapon_ID_shotgun && ti_arme != Ci_weapon_ID_sniper_rifle && ti_arme != Ci_weapon_ID_colt)
//		ti_arme = @"univ" i_weapon_ID_Save[C_ID_Jack]
//	if(ti_arme != Ci_weapon_ID_tommy_gun && ti_arme != Ci_weapon_ID_shotgun && ti_arme != Ci_weapon_ID_sniper_rifle && ti_arme != Ci_weapon_ID_colt)
//		ti_arme = 0
//	i_obj_lance_type_jack = ti_arme	
//}
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void SwapArmeHayesEnd( )
//{
//	int		ti_mem_arme, ti_arme, ti_mem_objenmainparam
//	int		ti_mem_ammo
//	int		ti_mem_reserve
//	
//	ti_mem_arme = i_obj_lance_type_hayes
//	
//	// BAMBOU
//	if(
//		ti_mem_arme == Ci_weapon_ID_bambou 
//	|| 	ti_mem_arme == Ci_weapon_ID_bambou_moy 
//	|| 	ti_mem_arme == Ci_weapon_ID_bambou_petit
//	|| 	ti_mem_arme == Ci_weapon_ID_grenade
//	|| 	ti_mem_arme == Ci_weapon_ID_crane
//	|| 	ti_mem_arme == Ci_weapon_ID_levier
//	)
//	{
//		if(ti_mem_arme == Ci_weapon_ID_bambou_petit)
//		{
//			@"univ" i_weapon_ID[i_id_humain] = @"univ" i_weapon_ID_Save[i_id_humain]
//			@"univ" i_weapon_ammunition[ti_mem_arme][C_ID_Jack] = @"univ" i_weapon_ammunition[ti_mem_arme][i_id_humain]
//			@"univ" i_weapon_ammunition[ti_mem_arme][i_id_humain] = 0
//			@"univ" i_weapon_ID_Save[C_ID_Jack] = @"univ" i_weapon_ID[C_ID_Jack]
//			@"univ" i_weapon_ID[C_ID_Jack] = i_obj_lance_type_hayes
//		}
//		else
//		{
//			@"univ" i_weapon_ID[i_id_humain] = @"univ" i_weapon_ID_Save[i_id_humain]
//			if(@"univ" i_weapon_ID[C_ID_Jack] == Ci_weapon_ID_levier)
//			{
//				@"univ" i_weapon_ID_second[C_ID_Jack] = Ci_weapon_ID_levier
//			}
//			else
//			{
//				if(@"univ" i_weapon_ID[C_ID_Jack]) @"univ" i_weapon_ID_Save[C_ID_Jack] = @"univ" i_weapon_ID[C_ID_Jack]
//			}
//			
//			@"univ" i_weapon_ID[C_ID_Jack] = i_obj_lance_type_hayes
//		}
//		
//		ti_mem_objenmainparam = @"univ" i_objenmain_param[ i_id_humain ]
//		@"univ" i_objenmain_param[ i_id_humain ] = @"univ" i_objenmain_param[ C_ID_Jack ]
//		@"univ" i_objenmain_param[ C_ID_Jack ] = ti_mem_objenmainparam
// 
//		macro_STATS_Dump( 4, OBJ_Me() )
//		return
//	}
//	
//	ti_arme = i_obj_lance_type_jack
//	
//	ti_mem_ammo = @"univ" i_weapon_ammunition[ti_mem_arme][i_id_humain]
//	ti_mem_reserve = @"univ" i_weapon_ammunition_reserve[ti_mem_arme][i_id_humain]
//	
//	// Met l'arme de jack au bon endroit chez hayes
//	if(@"univ" i_weapon_ID[i_id_humain] == ti_mem_arme)
//		@"univ" i_weapon_ID[i_id_humain] = ti_arme 
//	else if(@"univ" i_weapon_ID_second[i_id_humain] == ti_mem_arme)
//		@"univ" i_weapon_ID_second[i_id_humain] = ti_arme 
//	else
//		@"univ" i_weapon_ID_Save[i_id_humain] = ti_arme 
//	
//	// Si on enfle hayes (on lui prend son arme sans lui donner), hayes passe au colt
//	if(@"univ" i_weapon_ID[i_id_humain] == 0)
//	{
//		@"univ" i_weapon_ID[i_id_humain] = @"univ" i_weapon_ID_second[i_id_humain]
//		@"univ" i_weapon_ID_second[i_id_humain] = 0
//	}
//	
//	@"univ" i_weapon_ammunition[ti_mem_arme][i_id_humain] = 0
//	@"univ" i_weapon_ammunition_reserve[ti_mem_arme][i_id_humain] = 0
//	@"univ" i_weapon_ammunition[ti_arme][i_id_humain] = @"univ" i_weapon_ammunition[ti_arme][C_ID_Jack]
//	@"univ" i_weapon_ammunition_reserve[ti_arme][i_id_humain] = @"univ" i_weapon_ammunition_reserve[ti_arme][C_ID_Jack]
//	
//	// Met l'arme de hayes au bon endroit chez jack
//	if(@"univ" i_weapon_ID[C_ID_Jack] == ti_arme)
//		@"univ" i_weapon_ID[C_ID_Jack] = ti_mem_arme 
//	else if(@"univ" i_weapon_ID_second[C_ID_Jack] == ti_arme)
//		@"univ" i_weapon_ID_second[C_ID_Jack] = ti_mem_arme
//	else
//		@"univ" i_weapon_ID_Save[C_ID_Jack] = ti_mem_arme 
//		
//	// swap si le colt en main
////	if ( @"univ" i_weapon_ID[C_ID_Jack] == Ci_weapon_ID_colt )
////	{
////		@"univ" i_weapon_ID[C_ID_Jack] = ti_mem_arme
////		@"univ" i_weapon_ID_second[C_ID_Jack] = Ci_weapon_ID_colt
////	}
////	else if (@"univ" i_weapon_ID_Save[C_ID_Jack] == Ci_weapon_ID_colt )
////	{
////		@"univ" i_weapon_ID_Save[C_ID_Jack] = ti_mem_arme
////		@"univ" i_weapon_ID_second[C_ID_Jack] = Ci_weapon_ID_colt
////	}
//	
//	@"univ" i_weapon_ammunition[ti_arme][C_ID_Jack] = 0
//	@"univ" i_weapon_ammunition_reserve[ti_arme][C_ID_Jack] = 0
//	
//	@"univ" i_weapon_ammunition[ti_mem_arme][C_ID_Jack] = ti_mem_ammo
//	@"univ" i_weapon_ammunition_reserve[ti_mem_arme][C_ID_Jack] = ti_mem_reserve	
////	if(@"univ" i_weapon_ammunition[ti_mem_arme][C_ID_Jack] < @"univ" Weapon_ai_clipsize[ti_mem_arme]) @"univ" i_weapon_ammunition[ti_mem_arme][C_ID_Jack] = @"univ" Weapon_ai_clipsize[ti_mem_arme]
//	macro_STATS_Dump( 4, OBJ_Me() )
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
// Genere un evenement vision
procedure_local void MakeVision(  )
{
	float	tf_liferatio
	float	tf_visibility
	int 	ti_context
	int		ti_ground
	int		ti_capa
	int		ti_fantom
	
//	if(i_etat_courant == ETAT_IA_stunned)
//		ti_context  = C_EVENT_CONTEXT_STUNNED
//	else 
	if(i_flag_crouch)
		ti_context  = C_EVENT_CONTEXT_ACCROUPI
	else
		ti_context  = C_EVENT_CONTEXT_DEBOUT
		
	// Type de terrains spéciaux indiqués sur la deuxieme grille	
	ti_ground = i_ground_ID
	if(CaseBrulee(OBJ_PosGet())) ti_ground = 0
	tf_visibility = C_EVENT_Visibility_Full_Mvt
	ti_context += ti_ground * 10
	if(@"univ" LIFE_HumainEtat[ i_id_humain ] == Life_ETAT_Normal)
		tf_liferatio = 1.0
	else if(@"univ" LIFE_HumainEtat[ i_id_humain ] == Life_ETAT_Conval)	
		tf_liferatio = Cf_Life_Blesse
	else if(@"univ" LIFE_HumainEtat[ i_id_humain ] == Life_ETAT_Mort)	
		tf_liferatio = 0
//	else if(joueur)
//		tf_liferatio = Cf_Life_Blesse
	else
		tf_liferatio = Cf_Life_Agonisant
		
//	if (i_etat_courant == ETAT_IA_carried) 
//		tf_liferatio = 0
	if(!i_fantome_vision)
		EVENT_AddEventVision( i_id_humain, C_EVENT_FILTER_Marin, OBJ_Me(), 0.001, OBJ_PosGet(), tf_visibility, Cf_Rayon_De_Vision, f_interet, ti_context, 0, tf_liferatio)
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local int HasInteretOnMe(object to_ennemy)
{
	messageid		tmsg_id
	message		tmsg_filter
	int					ti_rank
	object			to_tmp
	
	MSG_SetNull( tmsg_filter )
	ti_rank = -1
	tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	while(MSG_GlobalIsValid(tmsg_id))
	{
		if ( MSG_GlobalGetGao(tmsg_id,GAO1) == OBJ_Me()) 
		{
			to_tmp = MSG_GlobalGetSender(tmsg_id)
			if(to_tmp == to_ennemy) return vrai
		}
		
		tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	}
	
	return faux
}

procedure_local int HasInteret( )
{
	messageid		tmsg_id
	message		tmsg_filter
	int					ti_rank
	object			to_tmp
	
	MSG_SetNull( tmsg_filter )
	ti_rank = -1
	tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	while(MSG_GlobalIsValid(tmsg_id))
	{
		if ( MSG_GlobalGetGao(tmsg_id,GAO1) == OBJ_Me()) 
			return vrai
		tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	}
	
	return faux
}

// Determine si l'objet passé en paramètre est l'intérêt d'un bestiaux
procedure_local int HasInteretOn(object to_param, byref object to_ennemy, byref float radius)
{
	messageid		tmsg_id
	message		tmsg_filter
	int					ti_rank
	int					type
	
	to_ennemy = nobody
	MSG_SetNull( tmsg_filter )
	ti_rank = -1
	tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	while(MSG_GlobalIsValid(tmsg_id))
	{
		if ( MSG_GlobalGetGao(tmsg_id,GAO1) == to_param) 
		{
			to_ennemy = MSG_GlobalGetSender(tmsg_id)
			type = EVENT_InteretVisionIDGet(tmsg_id)
			type_interet = type
			if(type == -1)
				radius = 10
			else
				radius = @"univ" Enemy_af_Radius[type]
			return vrai
		}
		
		tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	}
	
	return faux
}

procedure_local float HasInteretOnMinDist(object to_param, byref object to_ennemy, byref int type)
{
	messageid		tmsg_id
	message		tmsg_filter
	int					ti_rank
	float				tf_res
	object			to_temp
	
	tf_res = 10000.0
	to_ennemy = nobody
	MSG_SetNull( tmsg_filter )
	ti_rank = -1
	tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	while(MSG_GlobalIsValid(tmsg_id))
	{
		if ( MSG_GlobalGetGao(tmsg_id,GAO1) == to_param) 
		{
			to_temp = MSG_GlobalGetSender(tmsg_id)
			if(@to_param OBJ_SqrDist(to_temp) < tf_res)
			{
				to_ennemy = to_temp
				type = EVENT_InteretVisionIDGet(tmsg_id)
				tf_res = OBJ_SqrDist(to_temp)
			}
		}
		
		tmsg_id = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
	}
	
	return tf_res
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local float HL_PondCache(vector tv_pos, object to_cache)
{
	float			tf_pond
	vector		tv_temp, tv_temp1
	object		to_next
	int				ti_i, ti_terrain
	float			tf_dot, tf_temp
	messageid	tmid_info
	object		to_obj
	int				ti_type_cache
	
	tf_pond = 0
	
	if(!o_ref_cache_0D) o_ref_cache_0D = OBJ_Me()

	// Une cache de zone	
	ti_type_cache = 0
	if(@to_cache OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
		ti_type_cache = to_cache.des_int3
	if((ti_type_cache & 0xFF) != C_Cache_Surface) tf_pond += 1000

	// Distance a moi meme
	tf_pond += MATH_VecNorm(tv_pos - @o_ref_cache_0D OBJ_PosGet())

	// Si jack est dans la cache, et jack est safe, et j'en suis pas loin
//	to_obj = AI_MainActorGet(C_ID_Jack)
//	if(@to_obj COL_Pivot_BVCollide(to_cache))
//	{
//		if(OBJ_SqrDist(to_cache) < 10 * 10)
//		{
//			if(!EVENT_InfoCanGaoSeeGao(nobody, to_obj, tmid_info))
//			{
//				tf_pond /= 100
//			}
//		}
//	}
	
	// Si la cache est derriere moi, un petit malus
	tv_temp = tv_pos - OBJ_PosGet()
	tv_temp.z = 0
	if(!MATH_VecNullEpsilon(tv_temp))
	{
		if(MATH_VecNorm(tv_temp) > 5)
		{
			MATH_VecSetHorzNormalize(tv_temp)
			if(MATH_VecDotProduct(tv_temp, OBJ_SightGet()) < 0) tf_pond += 5
		}
	}
	
	// Si on cherche une cache visible, une cache non visible est moins bonne
	if(i_cherche_cache_visible)
	{
		tv_temp = tv_pos - @get_camera OBJ_PosGet()
		tf_temp = MATH_VecNorm(tv_temp)
		MATH_VecSetHorzNormalize(tv_temp)
		tf_dot = MATH_VecDotProduct(tv_temp, @get_camera OBJ_SightGet())
		if(tf_dot < 0) tf_pond += 10
	}
	
//	ti_terrain = GRID_CapaGet(tv_pos) & tag_grid_terrain
//	switch(ti_terrain)
//	{
//		case Ci_sol_herbe : 				tf_pond -= 4 	break
//		case Ci_sol_herbe_haute : 	tf_pond -= 5 	break
//		case Ci_sol_plafondbas : 		tf_pond -= 10 	break
//	}
	
	return tf_pond
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local int HL_PosAccessible(vector tv_pos)
{
	messageid		EVT_ID
	object			to_obj
	int					ie
	
	// Si un ennemi trop proche, danger
	for(ie = 0; ie < ai_AllEnemy; ie++)
	{
		EVT_ID = ao_AllEnemy[ie]
		if(!MSG_GlobalIsValid(EVT_ID)) continue
		to_obj = EVENT_PereGet(EVT_ID)		
		@get_global i_flag_pos_accessible = 1
		@get_global v_flag_pos_accessible = tv_pos
		@to_obj AI_CBExecute(CallBack_Info, 0)					
		if(@get_global i_flag_pos_accessible) return vrai
	}
	
	// Sinon c ok
	return faux
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local int HL_EnnDangereuxForPos(messageid EVT_ID, vector tv_pos)
{
	int			ti_state, ti_type
	object	to_obj
	float		tf_size
	vector	tv_temp
	
	ti_state = EVENT_EnemyStateGet( EVT_ID )
	if (ti_state  == C_EVENT_EnemyState_Fight || ti_state  == C_EVENT_EnemyState_Wait || ti_state  == C_EVENT_EnemyState_Neutral)
	{
		to_obj = EVENT_PereGet(EVT_ID)
		// Ennemi proche	(zone de panique)
		ti_type = EVENT_EnemyTypeGet( EVT_ID)
		tf_size = @"univ" Enemy_af_ReaDist[ ti_type] [ C_EnemyDist_Fear ]
		tv_temp = tv_pos - @to_obj OBJ_PosGet()
		if(MATH_VecDotProduct(tv_temp, tv_temp) < tf_size * tf_size)
		{
			// Peut venir jusqu'à la position ?
			if(ti_type == C_ID_BatCharognard || GRID_PosValid(tv_pos, @to_obj OBJ_PosGet()))
			{
				@get_global i_flag_pos_accessible = 1
				@get_global v_flag_pos_accessible = tv_pos
				@to_obj AI_CBExecute(CallBack_Info, 0)					
				if(@get_global i_flag_pos_accessible) return @"univ" Enemy_af_Danger[ti_type]
			}
		}
	}
	
	return 0
}

procedure_local int HL_PosDangereuse(vector tv_pos)
{
	int					ti_state
	vector			tv_temp, tv_temp1
	messageid		tmid_info
	messageid		EVT_ID
	object			to_obj
	float				tf_size
	int					ti_danger, ti_type
	int					ie
	
	// Si un ennemi trop proche, danger
	ti_danger = 0
	for(ie = 0; ie < ai_AllEnemy; ie++)
	{
		EVT_ID = ao_AllEnemy[ie]
		if(!MSG_GlobalIsValid(EVT_ID)) continue
		to_obj = EVENT_PereGet(EVT_ID)
		ti_danger += HL_EnnDangereuxForPos(EVT_ID, tv_pos)		
	}
	
	// Sinon c ok
	return ti_danger
}

procedure_local int HL_PosDangereuseMe( )
{
	messageid	tmid_info
	
	if(!EVENT_InfoCanGaoSeeGao(nobody, OBJ_Me(), tmid_info)) return faux
	return HL_PosDangereuse(OBJ_PosGet())
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local int HL_CheminDangereux(vector v_pos_cache)
//{
//	object		to_nearest_cible
//	object		to_nearest_me
//	int				ti_num, ti_i, ti_rank
//	object		ao_obj[100]
//	vector		av_pos[100]
//	messageid EVT_ID
//	object 		EVT_Pere
//	vector		tv_temp, tv_temp1
//	int				ti_state, ti_type
//	float			tf_temp
//	object		to_obj, to_obj1
//	object		to_cache
//	int				failed
//	int				ti_block
//	float			tf_radius, tf_dot
//	int				ie
//	
//	if(!move_network) move_network = @get_global move_network
//	to_nearest_cible = WAY_WPNearestOfPosGrid(v_pos_cache, move_network, -1, 0, 0, &failed)	
//	to_nearest_me = o_nearest_me
//	
//	// Test de la dangerosité du chemin courant
//	if(i_flag_test_danger_me)
//	{
//		i_flag_test_danger_me = faux
//		for(ti_i = 0; ti_i < way_num_objs; ti_i++) av_pos[ti_i + 1] = @way_objs[ti_i] OBJ_PosGet()
//		ti_num = way_num_objs
//	}
//	
//	// Calcul d'un chemin
//	else
//	{
//		ti_block = OBJ_Capa_7
//		if (i_id_humain != C_ID_Ann || i_etat_courant != ETAT_IA_use) ti_block |= OBJ_Capa_6
//		ti_num = WAY_ShortWay(move_network, &ao_obj[0], to_nearest_me, to_nearest_cible, -1, ti_block)
//		if(!ti_num) return -1
//		for(ti_i = 0; ti_i < ti_num; ti_i++) av_pos[ti_i + 1] = @ao_obj[ti_i] OBJ_PosGet()
//	}
//	
//	// Si je suis entre to_nearest_me et son suivant sur le chemin, je prend le suivant
//	if(ti_num && ti_num > 1)
//	{
//		tv_temp = av_pos[ti_num] - OBJ_PosGet()
//		tv_temp.z = 0
//		if(MATH_VecNullEpsilon(tv_temp))
//			ti_num--
//		else
//		{
//			tv_temp1 = av_pos[ti_num - 1] - OBJ_PosGet()
//			MATH_VecSetHorzNormalize(tv_temp)
//			MATH_VecSetHorzNormalize(tv_temp1)
//			if(MATH_VecDotProduct(tv_temp, tv_temp1) < 0)
//			{
//				ti_num--
//			}
//		}
//	}
//	
//	// Premiere pos = la mienne (rejoindre le reseau), Dernière pos = destination (sortit du reseau)
//	av_pos[0] = v_pos_cache
//	ti_num++
//	av_pos[ti_num] = OBJ_PosGet()
//	ti_num++
//	
//	for(ti_i = ti_num - 1; ti_i > 0; ti_i--)	
//	{
//		for(ie = 0; ie < ai_AllEnemy; ie++)
//		{
//			EVT_ID = ao_AllEnemy[ie]
//			if(!MSG_GlobalIsValid(EVT_ID)) continue
//			EVT_Pere = EVENT_PereGet(EVT_ID)
//			ti_state = EVENT_EnemyStateGet( EVT_ID )
//			
//			// Y'a-t-il un mechant sur la ligne droite entre les 2 wps ?
//			ti_type = EVENT_EnemyTypeGet( EVT_ID )
//			tf_radius = @"univ" Enemy_af_Radius[ ti_type ]
//				
//			tv_temp = av_pos[ti_i] - @EVT_Pere OBJ_PosGet()
//			tv_temp1 = av_pos[ti_i - 1] - @EVT_Pere OBJ_PosGet()
//			if(MATH_VecDotProduct(tv_temp, tv_temp1) < 0)
//			{
//				tv_temp = @EVT_Pere OBJ_PosGet()	 - av_pos[ti_i - 1]
//				tv_temp.z = 0
//				
//				tv_temp1 = av_pos[ti_i] - av_pos[ti_i - 1]
//				MATH_VecSetHorzNormalize(tv_temp1)
//				
//				tv_temp1 = MATH_VecCrossProduct(tv_temp1, Cv_VerticalVector)
//				tf_dot = MATH_VecDotProduct(tv_temp, tv_temp1)
//				if(MATH_AbsFloat(tf_dot) < tf_radius)
//				{
//					return vrai
//				}
//			}						
//	
//			// Aller de wp à wp + 1 m'éloigne de lui, donc on ignore cet ennemi car ca m'éloigne de lui
//			tv_temp = av_pos[ti_i] - @EVT_Pere OBJ_PosGet()
//			tv_temp1 = av_pos[ti_i - 1] - @EVT_Pere OBJ_PosGet()
//			if(MATH_VecNorm(tv_temp) > MATH_VecNorm(tv_temp1))
//			{
//				if(HL_EnnDangereuxForPos(EVT_ID, av_pos[ti_i - 1]))
//					return vrai
//			}
//		}		
//	}
//	
//	return faux
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local int HL_ObjDevantObj( object to_obj, object to_obj1 )
{
	object	to_next
	object	to_nearest_me, to_nearest_cible
	int			ti_num
	object	ao_obj[100]
	int			i, res, rank
	vector	tv_pos, tv_pos1
	
	tv_pos = GRID_PosGet(@to_obj OBJ_PosGet())
	tv_pos1 = GRID_PosGet(@to_obj1 OBJ_PosGet())
	
	// Deja calculé ?
	rank = -1
	for(i = 0; i < 30; i++)
	{
		if(!a_HL_ObjDevantObj1[i]) 
		{
			rank = i
			break
		}
		
		if(a_HL_ObjDevantObj1[i] == to_obj && a_HL_ObjDevantObj2[i] == to_obj1)
		{
			rank = i
			if(MATH_VecNullEpsilon(tv_pos - av_HL_ObjDevantObj1[i]))
			{
				if(MATH_VecNullEpsilon(tv_pos1 - av_HL_ObjDevantObj2[i]))
				{
					return a_HL_ObjDevantObjR[i]
				}
			}
			
			break
		}
	}
	
	res = faux
	to_nearest_me = WAY_WPNearestOfPos(@to_obj1 OBJ_PosGet(), move_network, -1, 0, 0)
	to_nearest_cible = WAY_WPNearestOfPos(@to_obj OBJ_PosGet(), move_network, -1, 0, 0)	
	ti_num = WAY_ShortWay(move_network, &ao_obj[0], to_nearest_me, to_nearest_cible, OBJ_Capa_0, 0)
	if(ti_num > 1) 
		res = vrai
	else if(ti_num == 1)
	{
		to_next = WAY_NetNextWP(move_network, to_nearest_me, 7, OBJ_Capa_0)
		if(to_next && @to_obj OBJ_SqrDist(to_next) < @to_obj1 OBJ_SqrDist(to_next)) 
			res = vrai
	}
	
	if(rank != -1)
	{
		a_HL_ObjDevantObj1[rank] = to_obj
		a_HL_ObjDevantObj2[rank] = to_obj1
		av_HL_ObjDevantObj1[rank] = tv_pos
		av_HL_ObjDevantObj2[rank] = tv_pos1
		a_HL_ObjDevantObjR[rank] = res
	}
	
	return res
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local object FollowQueueLL( )
//{
//	object	to_obj1
//	int			follow
//	int			i
//	vector	tv_temp
//	float		tf_bestdist, tf_dot
//	
//	if(i_id_humain == C_ID_Hayes)
//		return (AI_MainActorGet(C_ID_Jack))
//	
//	tf_bestdist = 100000
//	follow = -1
//	for(i = C_ID_Ann; i <= C_ID_Jimmy; i++)
//	{
//		if(@"univ" ai_HumainIsHere[i] && i != i_id_humain)
//		{
//			to_obj1 = @"univ" ao_AllHumains[i]
//			if(HL_ObjDevantObj(to_obj1, OBJ_Me()))
//			{
//				tv_temp = @to_obj1 OBJ_PosGet() - OBJ_PosGet()
//				MATH_VecSetNormalize(tv_temp)
//				tf_dot = MATH_VecDotProduct(OBJ_SightGet(), tv_temp)
//				if(tf_dot > 0)
//				{
//					tf_dot = 1 - tf_dot
//					if(OBJ_SqrDist(@"univ" ao_AllHumains[i]) * tf_dot < tf_bestdist)
//					{
//						tf_bestdist = OBJ_SqrDist(@"univ" ao_AllHumains[i]) * tf_dot
//						follow = i
//					}
//				}
//			}
//		}
//	} 
//	
//	if(follow == -1)
//	{
//		follow = C_ID_Hayes
//	}
//	
////	switch(i_id_humain)
////	{
////		case C_ID_Ann :			follow = C_ID_Hayes break
////		case C_ID_Denham :	follow = C_ID_Ann break
////		case C_ID_Jimmy :		follow = C_ID_Denham break
////		default:						return AI_MainActorGet(C_ID_Jack)
////	}
////	
////	if(!@"univ" ai_HumainIsHere[follow])
////	{
////		switch(follow)
////		{
////			case C_ID_Ann :				follow = C_ID_Hayes break
////			case C_ID_Denham :		follow = C_ID_Ann break
////			case C_ID_Jimmy :			follow = C_ID_Denham break		
////		}
////	}
////	
////	if(!@"univ" ai_HumainIsHere[follow])
////	{
////		follow = C_ID_Hayes
////	}
//	
//	to_obj1 = @"univ" ao_AllHumains[ follow ]
//	return to_obj1
//}
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local int HL_TestCover( )
//{
//	int			ti_capa, ti_capa1
//	int			ti_devant
//	object	to_obj
//	
//	if(!GRID_Has(1)) return faux
//	if(!o_nearest_me) return faux
//	if(!@o_nearest_me OBJ_CapaTest(OBJ_Capa_3)) return faux
//	
//	if(i_id_humain == C_ID_Hayes)
//		to_obj = AI_MainActorGet(C_ID_Jack)
//	else
//		to_obj = FollowQueueLL()
//	
//	if(to_obj && OBJ_SqrDist(to_obj) < 15 * 15)
//	{
//		GRID_CurrentSet(1)		
//		ti_capa1 = GRID_CapaGet(@to_obj OBJ_PosGet())
//		ti_capa1 &= tag_grid_terrain
//		ti_capa = GRID_CapaGet(OBJ_PosGet())
//		ti_capa &= tag_grid_terrain
//		GRID_CurrentSet(0)
//	
//		if (ti_capa1 == 2 && ti_capa == 2) 
//			return faux
//		if (ti_capa1 == 1 || ti_capa == 1)
//			return vrai
//		if (ti_capa1 == 2 || ti_capa == 2)
//			return vrai
//	}
//	
//	return faux
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local int PartialTir( )
//{
//	int		ti_weapon
//	
//	ti_weapon = @"univ" i_weapon_ID[i_id_humain]
//	if((ACT_PartialActionGet() == Action_Hayes_Tir_Mix + ti_weapon - 1) && !ACT_PartialActionFinished()) return 1
//	if((ACT_PartialActionGet() == Action_Jack_TirCible_Mix + ti_weapon - 1) && !ACT_PartialActionFinished()) return 1
//	return 0
//}
	
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void HL_MakeShoot(  byref function ret )
//{
//	float	tf_size
//	int		ti_weapon
//	int		ti_id	
//	
//	ret = nofunc
//	if(i_recharge_arme) 
//	{
//		i_interrupt_charge = vrai
//		return
//	}
//	
//	if(i_flag_frappe_jack)
//	{
//		return
//	}
//	
//	if(@"univ" i_weapon_ID[i_id_humain] == Ci_weapon_ID_levier)
//	{
//		return
//	}
//		
//	ti_weapon = @"univ" i_weapon_ID[i_id_humain]
//	if(!@"univ" i_weapon_ID[i_id_humain]) return
//
//	// Bidouille shotgun	
//	if(ACT_PartialActionGet() == 127)
//	{
//		ACT_PartialActionOnOff(faux)	
//	}
//	else if( ! i_flag_tir_secondaire && ! i_flag_tir_continu && ! ACT_PartialActionFinished() )
//	{
//		return
//	}
//	
//	if(o_target_stimulus_vis && (@o_target_stimulus_vis OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct) && o_target_stimulus_vis.des_int1 == Ci_DISPLAY_FIGHTBLOQUE) return
//	
//	f_rand_tir = MATH_RandFloat(0, 0.5)
//	
//	// Coup de cross si proche
//	tf_size = 0.0
//
////	if (i_flag_tir_secondaire)
////	{
////		ret  = "H_ETAT_IA_frappe"
////		return
////	}
//	
//	f_tir_dispertion = 0.0
//	i_flag_tir = vrai
//	ti_weapon = @"univ" i_weapon_ID[i_id_humain]
//	switch(ti_weapon)
//	{
//		case Ci_weapon_ID_bambou :
//		case Ci_weapon_ID_ossement :
////		case Ci_weapon_ID_bambou_moy :
////		case Ci_weapon_ID_bambou_petit :
//			ret = "H_ETAT_Lance"
//			break
//	
////		case Ci_weapon_ID_grenade :
//		case Ci_weapon_ID_crane :
//		case Ci_weapon_ID_levier :
//			ret = "H_ETAT_Lance"
//			break
//			
////		case Ci_weapon_ID_shotgun : 	
////			i_shotgun_target_nb = 0
////			i_tir_nb = 0
////			f_time_shoot_disable = 1.0
////			if (!i_flag_add_shoot)
////			{
////				i_flag_add_shoot = vrai
////				macro_add_callback_tir("H_callback_tir")
////			}
////			break
////	
////		case Ci_weapon_ID_sniper_rifle : 
////			f_time_shoot_disable = 0.5
////			if (!i_flag_add_shoot)
////			{
////				i_flag_add_shoot = vrai
////				macro_add_callback_tir("H_callback_tir")
////			}
////			break
////	
////		case Ci_weapon_ID_colt : 
////			f_time_shoot_disable = 0.25
////			if (!i_flag_add_shoot)
////			{
////				i_flag_add_shoot = vrai
////				macro_add_callback_tir("H_callback_tir")
////			}
////			break
////	
////		case Ci_weapon_ID_tommy_gun :
////			if (!i_flag_add_shoot)
////			{
////				i_flag_add_shoot = vrai
////				macro_add_callback_tir("H_callback_tir")
////			}					
////			break
//	}
//		
////	ti_weapon = @"univ" i_weapon_ID[i_id_humain]
////	switch(@"univ" i_weapon_ID[i_id_humain])
////	{
////	case Ci_weapon_ID_shotgun : 	
////	case Ci_weapon_ID_sniper_rifle : 
////	case Ci_weapon_ID_tommy_gun :
////	case Ci_weapon_ID_colt :
////		if(@"univ" i_weapon_ammunition[ti_weapon][i_id_humain])
////		{
////			if (i_flag_add_shoot && !PartialTir())
////			{
////				ACT_PartialActionOnOff(vrai)	
////				macro_action_new_mix
////				macro_action_mix_bras
////				ACT_PartialMaskSet(i_bone_nb, &ai_bones[0])
////				ACT_PartialBlendSet(0, 8)
////				i_interrupt_charge = faux
////				
////				if(i_flag_snipe)
////					ACT_PartialActionSet(Action_Jack_TirCible_Mix + ti_weapon - 1)
////				else
////					ACT_PartialActionSet(Action_Hayes_Tir_Mix + ti_weapon - 1)
////			}
////		}
////		break
////	}
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local void EnnemiLePlusProche()
{
	object			to_obj
	messageid		EVT_ID
	float				tf_bestdist_novis
	vector			tv_temp, tv_temp1
	int					ti_state
	float				tf_temp
	int					ie
	
	o_ennemi_proche = nobody
	v_ennemi_proche = Cv_NullVector
	
	tf_bestdist_novis = Cf_Infinit
	for(ie = 0; ie < ai_AllEnemy; ie++)
	{
		EVT_ID = ao_AllEnemy[ie]
		if(!MSG_GlobalIsValid(EVT_ID)) continue
		to_obj = EVENT_PereGet(EVT_ID)
		ti_state = EVENT_EnemyStateGet(EVT_ID)
		
		tf_temp = OBJ_SqrDist(to_obj)
		if(to_obj == o_last_ennemi_proche) tf_temp -= 9 // Petit hysteresis
		
		if(tf_temp < tf_bestdist_novis)
		{
			o_ennemi_proche = to_obj
			v_ennemi_proche = EVENT_PositionGet(EVT_ID)
			i_ennemi_proche_type = EVENT_EnemyTypeGet(EVT_ID)
			i_ennemi_proche_state = ti_state
			tf_bestdist_novis = tf_temp
		}
	}
	
	if(OBJ_HasBeenKilled(o_ennemi_proche))
		o_ennemi_proche = nobody
		
	o_last_ennemi_proche = o_ennemi_proche
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void OrienteVersToler(object obj, float toler, float speed)
//{
//	vector	tv_temp
//	vector	tv_res
//	float		tf_dot
//	float		tf_max
//
//	if(i_flag_oriente_vers) return
//	if(IsLoadingWeapon()) return
//	
//	i_flag_oriente_vers = vrai
//	tv_res = OBJ_SightGet()
//	tv_temp = @obj OBJ_PosGet() - OBJ_PosGet()
//	MATH_VecSetHorzNormalize(tv_temp)
//	tf_dot = MATH_VecDotProduct(OBJ_SightGet(), tv_temp)
//	if(f_oriente_proche || tf_dot < toler)
//	{
//		tf_max = 0.8
//		tf_max += 1.0 / i_id_humain
//		
////		switch(i_etat_courant)
////		{
////			case ETAT_IA_Ann_Heal :
////				f_time_derriere = 0
////				break
////		}
//		
//		// Temporise la rotation dans le dos
//		if(tf_dot < 0 && !f_joy_norm)
//			f_time_derriere += TIME_GetDt()
//		else if(f_time_derriere && f_time_derriere < tf_max)
//			f_time_derriere += TIME_GetDt()
//		else
//			f_time_derriere = 0
//		
//		if(f_time_derriere && f_time_derriere < tf_max && i_etat_courant != ETAT_IA_multicover)
//			tv_res = OBJ_SightGet()
//		else
//		{
//			tv_res = MATH_VecBlendRotate(OBJ_SightGet(), tv_temp, speed * TIME_GetDt())
//			if(!f_oriente_proche) f_oriente_proche = 0.5
//			f_oriente_proche -= TIME_GetDt()
//			if(f_oriente_proche < 0) f_oriente_proche = 0
//		}
//	}
//	
//	v_joy_dir = tv_res
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void OrienteVersTolerReal(object obj, float toler, float speed)
//{
//	OrienteVersToler(obj, toler, speed)
//	OBJ_BankingGeneralSet(v_joy_dir, Cv_VerticalVector)
//}
//
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void OrienteVers(object obj)
//{
//	OrienteVersToler(obj, 0.85, 8.0)
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void OrienteVersEnnemiProche( )
//{
//	vector	tv_res
//	vector	tv_temp
//	object	to_obj
//	float		tf_dist
//	
//	if(!o_ennemi_proche) return
//	
//	if(@get_global o_qqun_carry)
//	{
//		if(OBJ_SqrDist(@get_global o_qqun_carry) < OBJ_SqrDist(o_ennemi_proche))
//		{
//			OrienteVersToler(@get_global o_qqun_carry, 0.7, 4.0)
//			return
//		}
//	}
//	
//	if(@get_global o_qqun_walkstunned)
//	{
//		if(OBJ_SqrDist(@get_global o_qqun_walkstunned) < OBJ_SqrDist(o_ennemi_proche))
//		{
//			OrienteVersToler(@get_global o_qqun_walkstunned, 0.7, 4.0)
//			return
//		}
//	}
//	
//	// i_flag_danger ajouter pour qu'en cache safe, orientation tout le temps pour opportunité d'aide
////	tf_dist = @"univ" Enemy_af_ReaDist[i_ennemi_proche_type][C_EnemyDist_Fear]
////	if(!i_flag_danger || ((OBJ_SqrDist(o_ennemi_proche) < tf_dist * tf_dist) && !i_flag_crouch))
//		OrienteVersToler(o_ennemi_proche, 0.7, 4.0)
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//procedure_local void OrienteVersEnnemiProchePasDerriere( )
//{
//	int			ti_ok
//	float		tf_dist
//	vector	tv_temp
//	
//	// Je ne m'oriente vers un ennemi derriere moi que si je suis dans son radius
//	ti_ok = vrai
//	if(o_ennemi_proche && i_ennemi_proche_type != C_ID_Raptor && i_ennemi_proche_type != C_ID_Tyranosaure)
//	{
//		if(!HasInteretOnMe(o_ennemi_proche))
//		{
//			tf_dist = @"univ" Enemy_af_Radius[i_ennemi_proche_type]
//			if(OBJ_SqrDist(o_ennemi_proche) > tf_dist * tf_dist)
//			{
//				tv_temp = @o_ennemi_proche OBJ_PosGet() - OBJ_PosGet()
//				MATH_VecSetHorzNormalize(tv_temp)
//				if(MATH_VecDotProduct(OBJ_SightGet(), tv_temp) < 0.5)
//					ti_ok = faux
//			}
//		}
//	}
//
//	if(ti_ok) OrienteVersEnnemiProche()
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
// Determine si la position est une position valide de regard
procedure_local int PositionDeRegardValide(vector tv_pos)
{
	vector	tv_temp
	float		tf_dot
	
	tv_temp = tv_pos - OBJ_PosGet()
	MATH_VecSetNormalize(tv_temp)
	tf_dot = MATH_VecDotProduct(tv_temp, OBJ_SightGet())
	if(tf_dot > 0.1) return vrai
	return faux
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void ComputeCibleAShooter( float tf_maxdist)
//{
//	float				tf_cone_cos_angle 
//	float				tf_temp
//	object			to_obj
//	float				tf_dot
//	vector			tv_temp
//	vector			tv_temp1	
//	int					ti_rank
//	int					ti_id
//	int					ti_state
//	int					ti_index
//	int					ie	
//	object			EVT_Pere	
//	object			to_ennemy
//	messageid		EVT_ID	
//	float				tf_best_dist
//	object			to_who	
//	vector			tv_sommet
//	
//	if(i_interdit_tir)
//	{
//		o_target_stimulus_vis = nobody
//		return
//	}
//	
//	// Tir préférenciel
//	to_who  = o_pref_target_stimulus_vis
//	if(!to_who) to_who = OBJ_Me()
//	
//	f_dist_max_shoot = tf_maxdist
//	ti_rank = -1
//	o_target_stimulus_vis = nobody
//	tf_best_dist = Cf_Infinit
//	for(ie = 0; ie < ai_AllEnemy; ie++)
//	{
//		EVT_ID = ao_AllEnemy[ie]
//		if(!MSG_GlobalIsValid(EVT_ID)) continue
//		EVT_Pere = EVENT_PereGet(EVT_ID)
//		
//		ti_state = EVENT_EnemyStateGet( EVT_ID )
//		if (ti_state  == C_EVENT_EnemyState_Fight)
//		{
//			ti_id = EVENT_EnemyTypeGet(EVT_ID)
//					
//			// On ne tir que si on est suffisement proche
//			tf_temp = tf_maxdist
//			if(tf_temp == -1) tf_temp =  @"univ" Enemy_af_ReaDist[ti_id][C_EnemyDist_Fear]
//			
//			if(@to_who OBJ_SqrDist(EVT_Pere) < tf_temp * tf_temp)
//			{	
//				// Visible ?
//				tv_temp = @EVT_Pere OBJ_PosGet() - OBJ_PosGet()	
//				tf_cone_cos_angle = 0.0		// 180°
//				
//				// Si crouch, on test d'un peu au dessus (vu qu'on va se lever pour tirer)
//				to_obj = o_canal_maind
//				tv_sommet = @o_canal_maind OBJ_PosGet()
//				if(BambouEnMain() && ACT_ActionGet() == Action_Cache_Att) tv_sommet += cvector(0,0,1)
//				
//				if( EnemyIsInCone( EVT_ID, tv_sommet, OBJ_SightGet(), tf_cone_cos_angle, tf_temp, vrai))
//				{
//					tf_temp = @to_who OBJ_SqrDist(EVT_Pere)
//					
//					// Une petite prio a l'ancienne cible
//					if(EVT_Pere == o_last_target_stimulus_vis)
//						tf_temp -= 4
//						
////					if(tf_temp > 5 * 5)
////					{
////						tv_temp = EVENT_PositionGet(EVT_ID) - OBJ_PosGet()
////						if(!MATH_VecNullEpsilon(tv_temp))
////						{
////							MATH_VecSetNormalize(tv_temp)
////							tf_dot = MATH_VecDotProduct(OBJ_SightGet(), tv_temp)
////							if(BambouEnMain() && tf_dot < 0.5) 
////							{
////								tf_temp = tf_temp
////								continue
////							}
////							
////							tf_temp *= 1 - tf_dot
////						}
////					}
//					
//					if(tf_temp < tf_best_dist)
//					{
//						tf_best_dist = tf_temp
//						o_target_stimulus_vis = EVT_Pere
//						v_target_stimulus_vis = EVENT_PositionGet(EVT_ID)
//						type_target_stimulus_vis = EVENT_EnemyTypeGet(EVT_ID)
//						
//						// Correction
//						if(@get_global i_jack_grab && ti_id == C_ID_Raptor) 
//						{
//							v_target_stimulus_vis.z -= 0.5
//						}
//						
//						msgid_target_stimulus_vis = EVT_ID
//					}
//				}
//			}
//		}		
//	}	
//	
//	o_last_target_stimulus_vis = o_target_stimulus_vis
//}	

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local int TestReculPorte( int id, int dodo )
//{
//	object	to_obj
//	
//	if(i_etat_courant != ETAT_IA_suivi) return faux
//	if(f_time_recule && f_time_recule < 2.0) 
//	{
//		f_time_recule += TIME_GetDt()
//		i_flag_recul = vrai
//		f_joy_norm = 1
//		return vrai
//	}
//		
//	if(id == i_id_humain) return faux
//	if(!(@"univ" ai_HumainIsHere[id])) return faux
//	to_obj = @"univ" ao_AllHumains[id]
//	if(!to_obj) return faux
//	
//	if(dodo && OBJ_SqrDist(to_obj) > 3 * 3) return faux
//	if(!dodo && OBJ_SqrDist(to_obj) > 5 * 5) return faux
//	
//	if(!(@"KingKong/Humain" to_obj i_use_porte)) return faux
//	if(!dodo) return vrai
//	if(f_joy_norm) return faux
//	v_joy_dir = @to_obj OBJ_PosGet() - OBJ_PosGet()
//	MATH_VecSetNormalize(v_joy_dir)
//	i_flag_recul = vrai
//	f_joy_norm = 1
//	i_way_force_recompute = vrai
//	if(!f_time_recule) f_time_recule = TIME_GetDt()
//	return vrai
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void TestRecule( )
//{
//	float				tf_temp, tf_temp1
//	messageid		tmid_info
//	object			to_ennemy
//	int					ti_id
//	int					i
//	int					ti_force
//	vector			tv_temp, tv_temp1
//			
//	i_flag_recul = faux
//	
//	// HACK : si un perso est en use porte, et qu'on est proche, on recul
//	if(i_etat_courant == ETAT_IA_hide || i_etat_courant == ETAT_IA_suivi)
//	{
//		if
//		(
//			TestReculPorte(C_ID_Joueur, 1) 
////		||	TestReculPorte(C_ID_Denham, 1)
////		||	TestReculPorte(C_ID_Jimmy, 1)
////		||	TestReculPorte(C_ID_Hayes, 1)
////		||	TestReculPorte(C_ID_Ann, 1)
//		)
//		{
//			f_time_force_attend = 3
//			return
//		}
//	}
//	
//	// Pas en multicover
//	if(i_etat_courant == ETAT_IA_multicover)
//		return
//	
//	// Pas de recul si recharge arme
//	if(IsLoadingWeapon())
//	{
//		f_time_recule = 0
//		return
//	}
//	
//	if(i_flag_disable_recul)
//	{
//		i_flag_disable_recul = faux
//		f_time_recule = 0
//		return
//	}
//	
//	// Si on recul, on recul pendant un certain temps
//	ti_force = faux
//	if(f_time_recule && f_time_recule < 1.0) ti_force = vrai
//	
//	if(i_flag_nage)
//	{
//		f_time_recule = 0
//		return
//	}
//	
//	if(IsWater(i_ground_ID) && f_hauteur_eau >= Hauteur_Eau_Haute) 
//	{
//		f_time_recule = 0
//		return
//	}
//	
//	if(o_ennemi_proche)
//	{
//		// On recule dans le radius de l'ennemi
//		tf_temp = @"univ" Enemy_af_Radius[ i_ennemi_proche_type]
//		if(i_etat_courant == ETAT_IA_suivi) 
//			tf_temp = @"univ" Enemy_af_ReaDist[ i_ennemi_proche_type] [ C_EnemyDist_Fear ]
//		
//		// La cache me fait partir en arriere, alors on recule dans le fear de l'ennemi
////		if(o_hide_0D && @o_hide_0D OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Hierarchy) && COL_CollideType(COL_C_Wall))
//		if(COL_CollideType(COL_C_Wall))
//		{
//			f_time_recule = 0
//			return
//		}
//		
//		if(o_hide_0D)
//		{
//			tv_temp = v_pos_fuite - OBJ_PosGet()
//			tv_temp.z = 0
//			if(!MATH_VecNullEpsilon(tv_temp))
//			{
//				if(MATH_VecDotProduct(tv_temp, OBJ_SightGet()) < 0)
//				{
//					tf_temp = @"univ" Enemy_af_ReaDist[ i_ennemi_proche_type] [ C_EnemyDist_Fear ]
//				}
//			}
//		}
//	
//		// Pas de recul si derriere moi
//		if(!HasInteretOnMe(o_ennemi_proche))
//		{
//			// Si je suis dans une cache safe, pas de recul
//			if(o_hide_0D && (i_cache_surface & 0xFF) == C_Cache_Surface)
//			{
//				if(!CacheTientLaPos(o_hide_0D))
//				{
//					f_time_recule = 0
//					return
//				}
//			}
//		
//			// Si l'ennemi est derrière moi, pas de recul
//			tv_temp = @o_ennemi_proche OBJ_PosGet() - OBJ_PosGet()
//			MATH_VecSetHorzNormalize(tv_temp)
//			if(MATH_VecDotProduct(tv_temp, OBJ_SightGet()) < 0) 
//				tf_temp = 0
//				
//			// Si l'ennemi me tourne le dos, le recule à la moitier de la distance
//			if(MATH_VecDotProduct(@o_ennemi_proche OBJ_SightGet(), OBJ_SightGet()) > 0) 
//				tf_temp *= 0.5
//		}
//		
//		if((OBJ_SqrDist(o_ennemi_proche) < tf_temp * tf_temp) || ti_force)
//		{
//			if(EVENT_InfoCanGaoSeeGao(o_ennemi_proche, OBJ_Me(), tmid_info) || ti_force)
//			{
//				// Si ligne droite entre moi et lui
//				if(GRID_PosValid(OBJ_PosGet(), @o_ennemi_proche OBJ_PosGet()) || ti_force)
//				{					
//					// Si en plus la bestiolle m'en veut, je panique
////					if(!@"univ" i_weapon_ID [i_id_humain] && HasInteretOn(OBJ_Me(), to_ennemy, tf_temp)) 
////					{
////						tf_temp = @"univ" Enemy_af_Radius[ i_ennemi_proche_type]						
////						if(OBJ_SqrDist(to_ennemy) <= tf_temp * tf_temp)
////						{
////							if(to_ennemy == o_ennemi_proche)
////							{
////								if(!IsIndigene())
////									i_flag_panique = vrai
////							}
////						}
////					}
//					
//					tv_temp = @o_ennemi_proche OBJ_PosGet() - OBJ_PosGet()
//					MATH_VecSetHorzNormalize(tv_temp)
//					
////					if(GRID_Blocked(OBJ_PosGet() - tv_temp, vrai)) tv_temp += OBJ_HorizonGet()
////					if(GRID_Blocked(OBJ_PosGet() - tv_temp, vrai)) tv_temp -= 2 * OBJ_HorizonGet()
//					if(!GRID_Blocked(OBJ_PosGet() - tv_temp, vrai))
//					{
//						if(f_time_disable_recule <= 0)
//						{
//							v_joy_dir = tv_temp
//							f_time_disable_recule = -1
//							i_flag_recul = vrai
//							f_joy_norm = 1
//							i_way_force_recompute = vrai
//						}
//						else
//						{
//							f_time_disable_recule -= TIME_GetDt()
//							if(f_time_disable_recule < 0) f_time_disable_recule = 0
//						}
//					}
//					else
//					{
//						f_time_recule = 0
//						f_time_disable_recule = 1
//					}
//				}
//			}
//		}
//	}
//	
//	if(!i_flag_recul && f_time_disable_recule == -1) 
//		f_time_disable_recule = 1
//		
//	if(!i_flag_recul && !f_joy_norm && f_time_disable_recule > 0) 
//	{
//		f_time_disable_recule -= TIME_GetDt()
//		if(f_time_disable_recule < 0) f_time_disable_recule = 0
//	}
//	
//	if(i_flag_recul) 
//		f_time_recule += TIME_GetDt()
//	else 
//	{
////		if(f_time_recule) f_sight_blend_speed = 12
//		f_time_recule = 0
//	}
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
//procedure_local void CommonMove( )
//{
//	messageid	EVT_ID, tmid_info
//	int				ti_rank, ti_id
//	object		to_obj
//	int				ti_state
//	float			tf_temp
//	vector		tv_temp
//	float			tf_dist_todest
//	int				i
//	float			tf_arrivee
//	float			tf_dot
//	int				ti_force_arret
//	float			tf_dist_course
//	float			tf_dist_sprint
//	int				ti_crouch
//	
//	i_flag_arrived = faux
//	
//	// Forcer le crouch ?
//	ForceCrouch()
//	
//	// Hysteresis crouch
//	ti_crouch = i_flag_crouch
//	if(!ti_crouch) ti_crouch = H_RealCrouch()
//	
//	if(!ti_crouch && f_time_crouch && f_time_crouch < 1)
//	{
//		i_flag_crouch = vrai
//		f_time_crouch += TIME_GetDt()
//	}
//	else if(i_flag_crouch)
//	{
//		f_time_crouch += TIME_GetDt()
//	}
//	else
//		f_time_crouch = 0
//		
////	if(!ti_crouch)
////		f_disable_crouch += TIME_GetDt()
////	else if(f_disable_crouch && f_disable_crouch < 1)
////		i_flag_crouch = faux
////	else if(ti_crouch)
////		f_disable_crouch = 0
//		
//	// Recul
//	TestRecule()
//	if(i_flag_recul) return
//	
//	i_way_moving = vrai
//	ti_force_arret = faux
//	
//	// Priorite
//	// Si un humain en mouvement est trop proche de moi, j'attend en le regardant
//	for(i = C_ID_Jack; i < C_ID_Marin1; i++)
//	{
//		to_obj = @"univ" ao_AllHumains[i]
//		if(!to_obj) continue
//		if(to_obj == OBJ_Me()) continue
//		if(to_obj == ao_CL[Ci_LNK_CARRY]) continue
//		if(OBJ_SqrDist(to_obj) < 1.0 * 1.0)
//		{
//			tv_temp = @to_obj OBJ_PosGet() - OBJ_PosGet()
//			tv_temp.z = 0
//			if(!MATH_VecNullEpsilon(tv_temp))
//			{
//				MATH_VecSetHorzNormalize(tv_temp)
//				if(MATH_VecDotProduct(tv_temp, OBJ_SightGet()) > 0.3)
//				{
//					tv_temp = @to_obj DYN_SpeedGetVector()
//					tv_temp.z = 0
//					if(MATH_VecNorm(tv_temp) > 0.1)
//					{
//						if(@"KingKong/Humain" to_obj f_real_speed > 3)
//							i_flag_force_marche = vrai
//						else
//						{
//							if(!i_flag_danger) ForceRegardSur(to_obj, 1.0)
//							i_way_moving = faux
//							ti_force_arret = vrai
//						}
//						
//						break
//					}
//				}
//			}
//		}
//	}
//	
//	// Distance trot/course
//	if(i_etat_courant == ETAT_IA_suivi)
//	{
//		tf_dist_course = 8
//		tf_dist_sprint = 12
//	}
//	else
//	{
//		tf_dist_course = 6
//		tf_dist_sprint = 8
//	}
//	if(i_flag_danger) 
//	{
//		tf_dist_course = 3
//		tf_dist_sprint = 5
//	}
//
//	// Distance de déplacement pour calculer le mode de déplacement (course etc...)
//	tv_temp = v_way_destpos - OBJ_PosGet()
//	//tv_temp.z = 0
//	if(f_eval_dist_move > 0)
//		tf_dist_todest = f_eval_dist_move
//	else 
//		tf_dist_todest = MATH_VecNorm(tv_temp)	
//	f_eval_dist_move = 0
//		
//	if(i_etat_courant == ETAT_IA_suivi && f_joy_norm )
//	{
//		to_obj = AI_MainActorGet(C_ID_Jack)
//		f_blend_speed = MATH_FloatBlend(f_blend_speed, @"KingKong/Humain" to_obj f_dest_speed, TIME_GetDt())
//		tf_dist_todest += f_blend_speed
//	}
//	else
//	{
//		f_blend_speed = 0
//	}
//		
//	// Si on n'utilise pas la grille, on doit se rapprocher au max des WPs
//	if(i_etat_courant == ETAT_IA_stunnedwalk)
//	{
//		tf_arrivee = 0.5
//		f_min_dist_attend = 0.5
//	}
//	else
//		tf_arrivee = 1
//	if(!o_nearest_me)
//	{
//		DBG_Error("Les humains n'ont pas de reseau defini")
//		return
//	}
//	
////	if(@o_nearest_me OBJ_CapaTest(OBJ_Capa_2))
////	{
////		tf_arrivee = 0.5
////		f_min_dist_attend = 0.5
////	}
//	
//	// Arrivé ?
//	if(!f_time_attend && tf_dist_todest < tf_arrivee) 
//	{
//		i_flag_arrived = vrai
//		i_way_moving = faux
//	}
//	
//	// On doit quand meme vérifier qu'il n'y a pas un mur entre la destination et moi
//	if(f_time_attend && tf_dist_todest < f_min_dist_attend) 
//	{
//		tv_temp = v_way_destpos - OBJ_PosGet()
//		tv_temp.z = 0
//		tv_temp *= 0.5
//		if(f_min_dist_attend <= 1 || tf_dist_todest <= 1.0 || !GRID_Blocked(OBJ_PosGet() + tv_temp, faux))
//		{
//			i_flag_arrived = vrai
//			i_way_moving = faux
//		}
//	}
//	
//	f_min_dist_attend = 2
//	
//	if(i_flag_force_attente) 
//	{
//		i_way_moving = faux
//		ti_force_arret = vrai
//	}
//	
//	if(f_time_force_attend)
//	{
//		f_time_force_attend -= TIME_GetDt()
//		if(f_time_force_attend < 0) f_time_force_attend = 0
//		i_way_moving = faux
//		ti_force_arret = vrai
//	}
//
//	// Si on est a l'arret, on s'arrete un minimum
//	if(f_time_attend && f_time_attend < 0.5 && !i_flag_grosse_panique) 
//	{
//		i_way_moving = faux
//	}
//
////	if(i_way_moving && f_time_attend && f_time_attend < 2 && ACT_ActionIsTransition() && i_etat_courant != ETAT_IA_Ann_Heal) 
////	{
////		i_way_moving = faux
////	}
//
//	// Si jack me bute dedans
//	if(!i_bute_jack_mode && i_etat_courant == ETAT_IA_suivi)
//	{
//		if(!f_joy_norm && COL_CollideType(COL_C_Wall) && COL_ObjectGet(COL_C_Wall) == AI_MainActorGet(C_ID_Jack) )
//		{
//			f_time_bute_jack += TIME_GetDt()
//			if(f_time_bute_jack > 1)
//			{
//				i_bute_jack_mode = 1
//			}
//		}
//	}
//	
//	if(i_bute_jack_mode)
//	{
////		if(!i_in_fight) AskTextG(TEXTE_Psss, Gene_C_excuse, 20, nobody)
//		f_time_bute_jack += TIME_GetDt()
//		if(f_time_bute_jack < 3)
//		{
//			i_way_moving = vrai
//			if(i_bute_jack_mode == 1)
//				v_way_destpos = @get_camera OBJ_PosGet() - (2 * @get_camera  OBJ_SightGet())
//			else
//				v_way_destpos = @get_camera OBJ_PosGet() + (2 * @get_camera  OBJ_SightGet())
//		}
//		else
//		{
//			f_time_bute_jack = 0
//			i_bute_jack_mode = 0
//		}
//	}
//
//	// Si je suis a l'arret, et que je veut aller derriere moi, je jette un ptit coup d'oeil, puis
//	// je me retourne apres
////	if(i_way_moving)
////	{
////		tv_temp = v_way_destpos - OBJ_PosGet()
////		tv_temp.z = 0
////		tf_temp = MATH_VecDotProduct(tv_temp, tv_temp)
////		if(f_time_attend && !MATH_VecNullEpsilon(tv_temp))
////		{
////			MATH_VecSetHorzNormalize(tv_temp)
////			tf_dot = MATH_VecDotProduct(tv_temp, OBJ_SightGet()) 
////			if(tf_temp > 2 * 2 && ((!f_time_demitour && tf_dot < 0) || (f_time_demitour && tf_dot < 0.7)))
////			{
////				if(!i_flag_oriente_vers)
////				{
////					to_obj = ANI_CanalObjectGet(Anim_Canal_Tete)
////					tv_temp = v_way_destpos
////					tv_temp.z = @to_obj OBJ_PosGet().z
////					f_time_demitour += TIME_GetDt()
////					if(f_time_demitour < 1.0) 
////					{
////						ForceRegardSurPos(tv_temp, 0.5)
////						i_way_moving = faux
////						tv_temp = v_way_destpos - OBJ_PosGet()
////						tv_temp.z = 0
////						v_joy_dir = tv_temp
////						i_flag_oriente_vers = vrai
////						ti_force_arret = vrai
////					}
////				}
////			}
////		}
////	}
//	
//	// Deplacement
//	if(i_way_moving)
//	{
//		AI_Execute("H_exec_way_find")
//		if(i_way_moving)
//		{
//			v_joy_dir = v_way_sight
//			f_joy_norm = MATH_VecNorm(v_joy_dir)
//		}
//	}
//	
//	// Si je voulais me casse de jack, et que j'ai échouer, j''essaierai une autre pos
//	if(!i_way_moving && i_bute_jack_mode)
//	{
//		i_bute_jack_mode = i_bute_jack_mode + 1
//		if(i_bute_jack_mode == 3) i_bute_jack_mode = 1
//	}
//	
//	if (i_way_moving && f_joy_norm)
//	{
//		v_joy_dir /= f_joy_norm
//		f_joy_norm = MATH_FloatLimit(f_joy_norm, 0.0, 1.0)				
//	}
//	else
//	{
//		f_joy_norm = 0
//	}
//	
//	// o_nearest_me
//	if(o_nearest_me)
//	{
//		if(@o_nearest_me OBJ_CapaTest(OBJ_Capa_5)) i_flag_force_marche = vrai
//		if(@o_nearest_me OBJ_CapaTest(OBJ_Capa_6)) i_flag_force_course = vrai
//		if(@o_nearest_me OBJ_CapaTest(OBJ_Capa_7)) i_flag_force_sprint = vrai
//	}
//	
//	// Course ? 
//	if(f_joy_norm)
//	{	
//		i_flag_recul = faux
//		f_time_demitour = 0
//		
//		if(i_flag_grosse_panique)
//		{
//			i_flag_force_sprint = vrai
//			i_flag_force_marche = faux
//		}
//		
//		if(i_flag_force_sprint) tf_dist_sprint = 1
//		if(i_flag_disable_sprint)
//			i_flag_sprint = faux
//		else if(tf_dist_todest > tf_dist_sprint || (tf_dist_todest > 3 && i_flag_old_sprint)) 
//			i_flag_sprint = vrai
//		else
//			i_flag_sprint = faux
//		if(f_time_sprint && f_time_sprint < 0.5) i_flag_sprint = vrai
//		
//		if(i_flag_force_course) tf_dist_course = 1
//		if(!i_flag_sprint && (tf_dist_todest > tf_dist_course || (tf_dist_todest > 1 && (i_flag_old_run || i_flag_old_sprint))))
//			i_flag_run = vrai
//		else if(!i_flag_sprint && i_flag_disable_marche)
//			i_flag_run = vrai
//		else
//			i_flag_run = faux
//		if(f_time_run && f_time_run < 0.5) 
//		{
//			i_flag_sprint = faux
//			i_flag_run = vrai
//		}
//		
//		if(f_time_attend && !i_flag_grosse_panique && !i_in_fight)
//		{
//			i_flag_run = faux
//			i_flag_sprint = faux
//		}
//		
//		if(i_flag_force_marche) { i_flag_run = faux i_flag_sprint = faux }
//		
//		if(f_time_marche && f_time_marche < 1.0)
//		{
//			if(i_flag_run || i_flag_sprint)
//			{
//				i_flag_run = faux 
//				i_flag_sprint = faux
//			}
//		}
//		
//		f_time_attend = 0
//		if(i_flag_sprint) 
//		{
//			f_time_marche = 0
//			f_time_run = 0
//			f_time_sprint += TIME_GetDt()		
//		}
//		else if(i_flag_run) 
//		{
//			f_time_marche = 0
//			f_time_run += TIME_GetDt()
//			f_time_sprint = 0
//		}
//		else
//		{
//			if(tf_dist_todest > 3 && !@get_global i_progression_stress_lente) 
//				i_flag_force_rapide = vrai
//			else if(tf_dist_todest > 1.5 && i_flag_force_rapide)
//				i_flag_force_rapide = vrai
//			else
//				i_flag_force_rapide = faux
//			f_time_sprint = 0
//			f_time_run = 0
//			f_time_marche += TIME_GetDt()		
//		}
//	}
//	
//	if(!f_joy_norm)
//	{
////		if
////		(
////			!ti_force_arret
////		&&
////		(	
////				(f_time_marche && f_time_marche < 0.5)
////			||	(f_time_run && f_time_run < 0.5)
////			||	(f_time_sprint && f_time_sprint < 0.5)
////			)
////		)
////		{
////			f_time_marche += TIME_GetDt()
////			f_time_run = 0
////			f_time_sprint = 0
////			f_joy_norm = 1
////			v_joy_dir = OBJ_SightGet()
////			i_flag_run = faux
////			i_flag_sprint = faux
////		}
////		else
//		{
//			f_time_attend += TIME_GetDt()
//			f_time_marche = 0
//			f_time_run = 0
//			f_time_sprint = 0
//		}
//		
//		i_way_force_recompute = vrai
//		o_nearest_cible = nobody
//	}	
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Decale la position d'arrivee sur le cote en fonction de moi
//procedure_local vector ComputeDestPosDecalee(vector dest)
//{
//	vector	tv_temp, tv_temp1
//	float		tf_temp
//	vector 	axis
//	float		tf_norm
//	
//	if(i_etat_courant == ETAT_CINE_Vala) return dest
//	tf_temp = PRG_Suivi_TubeCote
////	if(tf_temp == 666)
////	{
////		switch(i_id_humain)
////		{
////			case C_ID_Ann :			tf_temp = 0 break
////			case C_ID_Jimmy :		tf_temp = 1 break
////			case C_ID_Denham :	tf_temp = -3 break
////			default:						tf_temp = 1.5 break
////		}
////	}
//	
//	// Pas en nage			
//	if(i_flag_nage) tf_temp = 0
//	
//	// Par rapport à mon chemin
//	if(way_num_objs > 1)
//	{
//		axis = @way_objs[way_num_objs - 2] OBJ_PosGet() - @way_objs[way_num_objs - 1] OBJ_PosGet()
//	}
//	
//	// Par rapport à moi
//	else
//	{
//		axis = dest - OBJ_PosGet()
//	}
//	
//	axis.z = 0
//	if(MATH_VecNullEpsilon(axis)) axis = dest - OBJ_PosGet()
//	MATH_VecSetHorzNormalize(axis)			
//	tv_temp1 = MATH_VecCrossProduct(axis, Cv_VerticalVector)
//	MATH_VecSetHorzNormalize(tv_temp1)			
//	tv_temp = dest + (tv_temp1 * tf_temp)
//	dest = GRID_LastPosValid(dest, tv_temp, faux)
//	return dest
//}

#define ISHERE(__id) \
{ \
	if(@"univ" ai_HumainIsHere[__id])  \
	{ \
		to_obj = @"univ" ao_AllHumains[__id] \
		if(@"KingKong/Humain" to_obj i_etat_courant == ETAT_IA_suivi) \
		{ \
			if(i_id_humain > __id) cptm++ \
			cpt++ \
		} \
	} \
} 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Decale la position d'arrivee sur le cote en fonction de moi
//procedure_local vector ComputeDestPosDecaleeFull(vector dest, object o1, object o2)
//{
//	vector	tv_temp, tv_temp1
//	float		tf_temp
//	vector 	axis
//	float		tf_norm
//	int			cpt, cptm
//	vector	dest1
//	object	to_obj
//	
//	if(i_etat_courant == ETAT_CINE_Vala) return dest
//	dest1 = dest
//	tf_temp = PRG_Suivi_TubeCote
//	if(tf_temp == 666)
//	{
//		cpt = 0
//		cptm = 0
//		
////		ISHERE(C_ID_Ann)
////		ISHERE(C_ID_Denham)
////		ISHERE(C_ID_Jimmy)
////		ISHERE(C_ID_Hayes)
//		
//		if(cpt == 1)
//			tf_temp = 0
//		else if(cpt == 2)
//		{
//			switch(cptm)
//			{
//				case 0 :	tf_temp = -1.5 break
//				case 1 :	tf_temp = 1.5 break
//			}
//		}
//		else if(cpt == 3)
//		{
//			switch(cptm)
//			{
//				case 0 :	tf_temp = -1.5 break
//				case 1 :	tf_temp = 1.5 break
//				case 2 :	tf_temp = 0 break
//			}
//		}
//		else
//		{
//			switch(cptm)
//			{
//				case 0 :	tf_temp = -1.5 break
//				case 1 :	tf_temp = 1.5 break
//				case 2 :	tf_temp = 0 break
//				case 3 :	tf_temp = 2.5 break
//			}
//		}
//	}
//	
//	// Pas en nage			
//	if(i_flag_nage) tf_temp = 0
//	
//	// Par rapport à mon chemin
//	axis = @o2 OBJ_PosGet() - @o1 OBJ_PosGet()
//	
//	axis.z = 0
//	if(MATH_VecNullEpsilon(axis)) axis = dest - OBJ_PosGet()
//	MATH_VecSetHorzNormalize(axis)			
//	tv_temp1 = MATH_VecCrossProduct(axis, Cv_VerticalVector)
//	MATH_VecSetHorzNormalize(tv_temp1)			
//	tv_temp = dest + (tv_temp1 * tf_temp)
//	dest = GRID_LastPosValid(dest, tv_temp, faux)
//	dest.z = dest1.z
//	return dest
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Choisi l'intention a l'arret, en cache
//procedure_local int IntentionEnCache( )
//{
//	vector	tv_temp, tv_ou
//	vector	tv_temp1, tv_temp2
//	float		tf_temp
//	object	to_obj
//	int			ti_forcemur
//	int			ti_sens
//	float		tf_dot
//	
//	if(i_flag_oriente_vers) return faux	// Deja orienté
//	
//	if(f_pilotage_bras_duration) 
//	{
//		i_mur_en_face = -1
//		OrienteVersEnnemiProche()	
//		return faux
//	}
//	
//	// C'est le marasme autour de moi, merde, je m'oriente vers l'ennemi
//	if(o_ennemi_proche && i_flag_danger && i_in_fight)
//	{
//		if(OBJ_SqrDist(o_ennemi_proche) < f_toler_cache * f_toler_cache)
//		{
//			tv_temp = @o_ennemi_proche OBJ_PosGet() - OBJ_PosGet()
//			tf_dot = MATH_VecDotProduct(tv_temp, OBJ_SightGet())
//			if(tf_dot >= 0 || !GRID_Blocked(OBJ_PosGet() - OBJ_SightGet(), faux))
//			{
//				f_toler_cache = 6
//				i_mur_en_face = -1
//				OrienteVersEnnemiProche()
//				i_flag_no_intention_dir = vrai	
//				return faux
//			}
//		}
//	}
//	
//	f_toler_cache = 4
//	
//	// Si une intention est active, on ne fait rien
//	ti_forcemur = faux
//	if(PRG_Intention && @"Progression/PRG_Intention" PRG_Intention des_i_attitude == 1) 
//		ti_forcemur = vrai
//	if(PRG_Intention && TIME_Elapsed(f_time_disable_intention, 2.0))
//	{
//		if(@"Progression/PRG_Intention" PRG_Intention des_i_attitude == 1) 
//			ti_forcemur = vrai
//		else 
//		{
//			if(!(@"Progression/PRG_Intention" PRG_Intention des_i_oriente) )
//			{
//				OrienteVersEnnemiProche()	
//				return faux
//			}
//		}
//	}
//	
//	// Si pas dans une cache
//	if(!o_hide_0D)
//	{
//		i_mur_en_face = -1
//		OrienteVersEnnemiProche()	
//		return faux
//	}
//	
//	to_obj = AI_MainActorGet(C_ID_Joueur)
//	
//	// Proche de la destination
//	tv_temp = GRID_PosGet(v_pos_fuite) - GRID_PosGet(OBJ_PosGet())
//	tv_temp.z = 0
//	tf_temp = MATH_VecNorm(tv_temp)
//	if(tf_temp > 3)
//	{
//		i_mur_en_face = -1
//		OrienteVersEnnemiProche()	
//		return faux
//	}
//	
//	if(ti_forcemur)
//	{
//		tv_temp = @PRG_Intention OBJ_PosGet()
//		tv_ou = -@PRG_Intention OBJ_SightGet()
//	}
//	else
//	{
//		tv_ou = Cv_NullVector
//		if(f_time_attend > 2)
//			tv_temp = GRID_PosGet(OBJ_PosGet())
//		else
//			tv_temp = GRID_PosGet(v_pos_fuite)
//		tv_temp1 = cvector(-1.0, 0, 0)
//		if(GRID_Blocked(tv_temp + tv_temp1, faux)) tv_ou = tv_temp1
//		tv_temp1 = cvector(1.0, 0, 0)
//		if(GRID_Blocked(tv_temp + tv_temp1, faux)) tv_ou = tv_temp1
//		tv_temp1 = cvector(0, -1.0, 0)
//		if(GRID_Blocked(tv_temp + tv_temp1, faux)) tv_ou = tv_temp1
//		tv_temp1 = cvector(0, 1.0, 0)
//		if(GRID_Blocked(tv_temp + tv_temp1, faux)) tv_ou = tv_temp1
//	}
//	
//	if(!MATH_VecNull(tv_ou))
//	{
//		tv_temp = GRID_PosGet(tv_temp + tv_ou)
//		
//		if(ti_forcemur) 
//			tv_temp1 = @PRG_Intention OBJ_PosGet()
//		else
//			tv_temp1 = tv_temp - tv_ou
//		tv_temp1.z = 0
//		
//		// Distance au point d'accroche
//		tv_temp2 = OBJ_PosGet() - tv_temp1
//		tv_temp2.z = 0
//		tf_temp = MATH_VecNorm(tv_temp2)
//		
//		tv_temp1.z = OBJ_PosGet().z
////		DBG_RenderVector(tv_temp1,cvector(0,0,4),0xFF00FF)
//		
//		// Sinon je regarde si je peux m'en rapprocher
//		if(tf_temp > 0.5 && (!GRID_Blocked(tv_temp1, vrai) || ti_forcemur))
//		{
//			i_mur_en_face = -1
//			
//			if(tf_temp < 2)
//			{
//				if(i_flag_crouch)
//					H_ActionCacheAtt()	
//				else if(f_hauteur_eau >= Hauteur_Eau_Basse)
//				{
//					if(AnimWeapon())
//						ACT_ActionSet1(Action_Marche_Eau_Taille_Flingue)
//					else
//						ACT_ActionSet1(Action_Marche_Eau_Taille)
//				}
//				else if(f_hauteur_eau >= Hauteur_Eau_Haute)
//				{
//					if(AnimWeapon())
//						ACT_ActionSet1(Action_Marche_Eau_cou_Flingue)
//					else
//						ACT_ActionSet1(Action_Marche_Eau_cou)
//				}
//				else if(AnimWeapon())
//					ACT_ActionSet1(Action_Hayes_Arme_Marche)
//				else
//					ACT_ActionSet1(Action_Stress_Marche)
//				v_joy_dir = H_BlendRotate(OBJ_SightGet(), tv_temp1 - OBJ_PosGet(), 5.0, 0.0)
//				OBJ_BankingGeneralSet(v_joy_dir, Cv_VerticalVector)
//				return vrai
//			}
//			else
//			{
//				tv_temp1 = OBJ_PosGet()
//			}
//		}
//		
//		// Arrivée : detection de l'environnement
//		if(ti_forcemur)
//		{
//			v_pos_mur_en_face = @PRG_Intention OBJ_PosGet()
//			v_pos_mur_en_face.z = OBJ_PosGet().z
//			i_mur_en_face = 1
//		}
//		
//		// Est ce que je peux me coller a un mur ?
////		else if(i_mur_en_face == -1 && i_ground_ID != Ci_sol_herbe)
////		{
////			i_mur_en_face = 0
////			OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, 0)
////			tv_temp2 = MATH_VecNormalize(tv_ou)
////			to_obj = COL_RayObject_Dist(tv_temp1 + cvector(0,0,1.6), tv_temp2, 1.5, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
////			OBJ_FlagsControlSet(0, OBJ_C_ControlFlag_RayInsensitive)
////			if(to_obj && !@to_obj OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims)) 
////			{
////				 i_mur_en_face = 2
////				v_pos_mur_en_face = COL_RayObject_PosGet()
////				v_pos_mur_en_face.z = OBJ_PosGet().z
////				
////				if(!GRID_Blocked(v_pos_mur_en_face, vrai))
////				{
////					i_mur_en_face = 1
////					tv_temp = tv_ou
////					MATH_VecSetNorm(tv_temp, -0.6)
////					v_pos_mur_en_face += tv_temp
////				}
////			}
////		}
//		
//		// Ennemi dans le dos, qqpart
//		ti_sens = 0
//		if(o_ennemi_proche)
//		{
//			tv_temp = @o_ennemi_proche OBJ_PosGet() - OBJ_PosGet()
//			MATH_VecSetHorzNormalize(tv_temp)
//			if(MATH_VecDotProduct(OBJ_SightGet(), tv_temp) < 0)
//			{
//				tv_temp = MATH_VecCrossProduct(OBJ_SightGet(), tv_temp)
//				ti_sens = MATH_FloatSign(tv_temp.z)
//			}
//		}
//		
//		// Débout dos au mur
//		if(i_mur_en_face == 1)
//		{	
//			i_flag_oriente_vers = vrai
//			OBJ_PosSet(MATH_VecBlend(OBJ_PosGet(), v_pos_mur_en_face, 5 * TIME_GetDt()))
//			OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), -tv_ou, 5 * TIME_GetDt()), Cv_VerticalVector)
//			
//			COL_ColSetActivationSet(0, C_bit_zdm_pied)
//			DYN_GravitySet(Cv_NullVector)
////			if(f_hauteur_eau >= Hauteur_Eau_Basse && i_id_humain == C_ID_Denham)
////				ACT_ActionSet1(Action_Att_Eau_Taille)
////			else 
//			if(AnimWeapon())
//				ACT_ActionSet1(Action_Contre_Mur_Flingue)
//			else
//			{
//				if(ACT_ActionGet() == Action_CacheMur_Gauche || ACT_ActionGet() == Action_CacheMur_Droite)
//				{
//					if(ACT_ActionFinished() )
//					{
//						f_time_intention_att = TIME_Get()
//						ti_sens = 0
//					}
//				}
//				else if(ti_sens && !TIME_Elapsed(f_time_intention_att, 8))
//					ti_sens = 0
//				
//				if(ti_sens > 0)
//					ACT_ActionSet1(Action_CacheMur_Gauche)
//				else if(ti_sens < 0)
//					ACT_ActionSet1(Action_CacheMur_Droite)
//				else
//					ACT_ActionSet1(Action_Contre_Mur)
//			}
//			return vrai
//		}
//		
//		// Accroupi dos au mur
//		if(i_mur_en_face == 2)
//		{
//			if(!GRID_Blocked(OBJ_PosGet(), faux))
//			{
////				i_flag_oriente_vers = vrai
////				v_joy_dir = -MATH_VecNormalize(tv_ou)
//				return faux
//			}
//		}
//	}
//	
//	i_mur_en_face = -1
//	if(!PRG_Intention || !(@"Progression/PRG_Intention" PRG_Intention des_i_oriente) )
//		OrienteVersEnnemiProche()	
//	return faux
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//procedure_local int ComputeIntention( )
//{
//	int	attitude, res
//		
//	// Orientation
//	if((i_etat_courant == ETAT_IA_suivi || i_etat_courant == ETAT_IA_hide || i_etat_courant == ETAT_CINE_WaitDefault) && !f_pilotage_bras_duration)
//	{
//		if(!TIME_Elapsed(f_time_disable_intention, 2.0))
//		{
//			return faux
//		}
//		
//		if(@"Progression/PRG_Intention" PRG_Intention des_i_oriente && !i_flag_no_intention_dir) 
//			v_joy_dir = @PRG_Intention OBJ_SightGet()
//	}
//	else
//	{
//		f_time_disable_intention = TIME_Get()
//		return faux
//	}
//		
//	attitude = @"Progression/PRG_Intention" PRG_Intention des_i_attitude
//	switch(attitude)
//	{
//		case 0:
//			H_ActionCacheAtt()	
//			return vrai
//		case 1:
//			if(i_etat_courant == ETAT_IA_suivi)
//			{
//				v_pos_fuite = OBJ_PosGet()
//				i_flag_oriente_vers = faux
//				o_hide_0D = PRG_Intention
//				res = IntentionEnCache()
//				o_hide_0D = nobody
//				v_pos_fuite = Cv_NullVector
//				return res
//			}
//			return vrai
//		case 2:
//			ACT_ActionSet1(Action_Stress_Attente)
//			return vrai
//		case 3:
//			ACT_ActionSet1(Action_Den_Camera)
//			return vrai	
//		default:
//			return faux
//	}
//	
//	return vrai
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//procedure_local int ComportementPeutShooter( )
//{
//	switch(i_etat_courant)
//	{
//		case ETAT_IA_suivi :
//		case ETAT_IA_hide :
//		case ETAT_IA_multicover :
//		case ETAT_IA_cover :
//			return vrai
//	}
//	
//	return faux
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Doit trouver une cache, meme si dangereuse
//procedure_local void ForceChercheCache( )
//{
//	i_cherche_cache_dangereux = faux
//	f_time_search_hide = TIME_Get()
//	AI_Execute("H_exec_ch_hide_0D")
//	if(!o_hide_0D)
//	{
//		if(o_memo_wp_dangereux)
//		{
//			if(!@"univ" i_weapon_ID[i_id_humain] || !HL_PosAccessible(v_memo_pos_dangereux))
//			{
//				o_hide_0D = o_memo_wp_dangereux
//				v_pos_fuite = v_memo_pos_dangereux
//				i_cache_surface = i_memo_type_cache_dangereux
//				if( @o_hide_0D OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
//					o_hide_0D.des_int2 = o_hide_0D.des_int2 + 1		
//			}
//		}
//		
//		o_hide_0D_dangereux = o_hide_0D
//	}		
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Detag les humains qui a priori vont pas me faire chier pour le deplacement
procedure_local void GRID_EliminateHumains( )
{
	int			i
	int			elim
	object	to_obj
	float		tf_my_speed
	float		tf_his_speed
	float		tf_dist
	vector	tv_temp
	
	tf_my_speed = f_real_speed
	
	i_eliminate_hum = 0
//	for(i = C_ID_Jack; i < C_ID_Marin_dernier; i++)
	for(i = C_ID_Joueur; i < C_ID_Last_Compagnon; i++)
	{
		to_obj = @"univ" ao_AllHumains[i]
		if(!to_obj) continue
		if(to_obj == OBJ_Me()) continue
		if(!GRID_IsIn(@"KingKong/Humain" to_obj tag_vectorpos)) continue
		if(!@"KingKong/Humain" to_obj i_can_tag) continue
		if(!@"KingKong/Humain" to_obj tag_flag) continue
		
		// Si je bute sur jack, alors jack continue de tagguer
		if(i_bute_jack_mode && to_obj == AI_MainActorGet(C_ID_Joueur)) continue
		
		elim = faux
//		if(!@to_obj COL_CollideType(COL_C_Ground)) elim  = vrai	// Si saute, tombe
		tf_dist = OBJ_SqrDist(to_obj)
		if(tf_dist > 4 * 4) elim = vrai	// Si loin
		
		tf_his_speed = @"KingKong/Humain" to_obj f_real_speed
				
		if(tf_his_speed > tf_my_speed * 0.5) elim = vrai	// S'il va plus vite que moi
		if(tf_dist > 2 * 2 && tf_his_speed > (tf_my_speed * 0.5))  elim = vrai
		if(f_time_fail_move > 0.01) elim = vrai
		
//		if(!elim && to_obj != AI_MainActorGet(C_ID_Jack))
//		{
//			tv_temp = @to_obj OBJ_PosGet() - OBJ_PosGet()
//			MATH_VecSetHorzNormalize(tv_temp)
//			if(MATH_VecDotProduct(tv_temp, OBJ_SightGet()) < 0.9)
//				elim = vrai
//		}
		
		if(elim)
		{
			ao_eliminate_hum[i_eliminate_hum] = to_obj
			i_eliminate_hum++
			GRID_TagBox(@"KingKong/Humain" to_obj tag_vectorpos, @"KingKong/Humain" to_obj tag_vectorsight, cvector(-0.1,-0.1,0), cvector(0.1,0.1,0), -64)
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void GRID_RestoreHumains( )
{
	int			i
	object	to_obj
		
	for(i = 0; i < i_eliminate_hum; i++)
	{
		to_obj = ao_eliminate_hum[i]
		GRID_TagBox(@"KingKong/Humain" to_obj tag_vectorpos, @"KingKong/Humain" to_obj tag_vectorsight, cvector(-0.1,-0.1,0), cvector(0.1,0.1,0), 64)
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//procedure_local vector WAY_Compute(vector v_dest, byref int ti_direct, byref int ti_exact_way)
//{
//	int			ti_directway
//	vector	tv_target
//	object	to_nearest_me, to_nearest_cible
//	vector	tv_temp, tv_temp1
//	object	to_obj, to_obj1
//	int			ti_block
//	int			failed
//	int			ti_capa
//	int			ti_i, ti_m, ti_c
//	int			ti_way
//	int			ti_force
//	
//	GRID_EliminateHumains()
//	
//	// Aide reseau (longues distances) ??
//	tv_target = v_dest
//	v_way_destpos = tv_target
//	ti_exact_way = faux
//	ti_direct = faux
//	if(move_network)
//	{
//		@get_global move_network = move_network
//		
//		// Suivre exactement le réseau ?
//		if(@o_nearest_me OBJ_CapaTest(OBJ_Capa_2)) ti_exact_way = vrai
//		
//		to_nearest_me = o_nearest_me
//		tv_temp = v_way_destpos - OBJ_PosGet()
//		ti_way = vrai
//		if(ti_exact_way)
//		{
//			ti_way = faux
//			to_nearest_cible = WAY_WPNearestOfPos(v_way_destpos, move_network, -1, 0, 0)
//			
//			if(o_nearest_cible != to_nearest_cible || !way_num_objs)
//			{
//				o_nearest_cible = to_nearest_cible
//				way_num_objs = WAY_ShortWay(move_network, &way_objs[0], to_nearest_me, to_nearest_cible, -1, OBJ_Capa_7)
//			}
//			else if(o_nearest_cible == o_nearest_me)
//			{
//				tv_target = @o_nearest_cible OBJ_PosGet()
//				way_num_objs = 666
//			}
//						
//			if(way_num_objs == 666)
//			{
//				way_num_objs = 0
//			}
//			else if(way_num_objs >= 2)
//			{	
//				to_obj = way_objs[way_num_objs-1]
//				if(way_num_objs > 1 && OBJ_SqrDist(to_obj) < 1.0 * 1.0)
//				{
//					way_num_objs--
//					to_obj = way_objs[way_num_objs-1]
//				}
//				
//				tv_target = @to_obj OBJ_PosGet()
//			}
//			else if(way_num_objs == 1)
//			{
//				to_obj = way_objs[0]
//				tv_target = @to_obj OBJ_PosGet()
//			}
//			else
//			{
//				tv_target = OBJ_PosGet()
//			}
//		}
//		
//		// Peut se passer du réseau (si proche et si ligne droite possible) ?
//		if(ti_way && MATH_VecDotProduct(tv_temp, tv_temp) < 10 * 10)
//		{
//			// Si y' une capa_7 dans le coin, on force à utiliser le reseau
//			ti_force = faux
//			for(ti_i = 0; ti_i < WAY_GetNumLinks(move_network, o_nearest_me); ti_i++)
//			{
//				to_obj = WAY_NetNextWP(move_network, o_nearest_me, NetNextWP_Mode_choix_de_lindice, ti_i)
//				if(WAY_LinkCapaGet(move_network, o_nearest_me, to_obj) & OBJ_Capa_7)
//				{
//					ti_force = vrai
//					ti_way = vrai
//					break
//				}
//			}
//			
//			if(!ti_force)
//			{
//				// Est ce que j'ai un chemin grille qui m'ammene deja à ma destination ?
//				if(i_way_case_nbr > 0)
//				{
//					tv_temp1 = v_way_case[0] - GRID_PosGet(v_way_destpos)
//					if(MATH_VecNullEpsilon(tv_temp1)) 
//						ti_way = faux
//				}
//				
//				// Sinon je suis proche, mais est ce que je peux y aller en ligne droite ?
//				if(ti_way && GRID_PosValid(OBJ_PosGet(), v_way_destpos)) ti_way = faux
//			}
//		}
//		
//		if(ti_way)
//		{
//			to_nearest_cible = WAY_WPNearestOfPosGrid(tv_target, move_network, -1, 0, 0, &failed)	
//			to_nearest_me = o_nearest_me
//			
//			// tous les persos hormis ann sont bloqués par les liens capa_6 = lien de grimpette
//			ti_force = -1
//			ti_block = OBJ_Capa_7
//			if(i_etat_courant == ETAT_IA_suivi && PRG_Suivi_DistMin != 0) ti_force = @get_global i_capa_progession
////			if (i_id_humain != C_ID_Ann || i_etat_courant != ETAT_IA_use) 
//			ti_block |= OBJ_Capa_6
//		
//			// On ne calcul le chemin que si on a changé de cible, ou si on n'a pas de chemin en stock
//			if(o_nearest_cible != to_nearest_cible || !way_num_objs)
//			{
//				way_v_pos = Cv_NullVector				
//				way_num_objs = WAY_ShortWay(move_network, &way_objs[0], to_nearest_me, to_nearest_cible, ti_force, ti_block)
//			}
//			
//			o_nearest_cible = to_nearest_cible
//	
//			// Aucune solution trouvée
//			// Faut quand meme essayer d'aller le plus pres possible du bloquage		
//			if(!way_num_objs)
//			{
//				if(!i_autorise_capa7)
//				{
//					i_autorise_capa7 = vrai
//				}
//				else
//				{
//					ti_block = OBJ_Capa_7
////					if (i_id_humain != C_ID_Ann || i_etat_courant != ETAT_IA_use)
//					ti_block |= OBJ_Capa_6
//					way_num_objs = WAY_ShortWay(move_network, &way_objs[0], to_nearest_me, to_nearest_cible, -1, 0)
//					if(way_num_objs)
//					{
//						to_obj = way_objs[way_num_objs - 1]
//						to_obj1 = way_objs[way_num_objs - 2]
//						ti_capa = WAY_LinkCapaGet(move_network, to_obj, to_obj1)
//						if(ti_capa & ti_block)
//						{
//							if(ti_capa & OBJ_Capa_7)
//							{
//								tv_target = @to_obj OBJ_PosGet()
//								if(OBJ_SqrDist(to_obj) < 1)
//								{
//									i_flag_arrived = vrai
//									i_way_moving = faux
//								}
//							}
//							
//							way_num_objs = 0
//						}
//						else
//						{
//							way_num_objs = 0
//							tv_target = @to_obj1 OBJ_PosGet()
//						}
//					}
//					else
//					{
//						tv_target = OBJ_PosGet()
//					}
//				}
//			}
//		
//			if(way_num_objs >= 2) 
//			{
//				ti_directway = faux
//				
//				// Si je suis entre to_nearest_me et son suivant sur le chemin, je prend le suivant
//				tv_temp = @way_objs[way_num_objs - 1] OBJ_PosGet() - OBJ_PosGet()
//				tv_temp1 = @way_objs[way_num_objs - 2] OBJ_PosGet() - OBJ_PosGet()
//				if(MATH_VecNullEpsilon(tv_temp))
//					way_num_objs--
//				else
//				{
//					tv_temp.z = 0
//					tv_temp1.z = 0
//					if(!MATH_VecNullEpsilon(tv_temp) && !MATH_VecNullEpsilon(tv_temp1))
//					{
//						MATH_VecSetHorzNormalize(tv_temp)
//						MATH_VecSetHorzNormalize(tv_temp1)
//						if(MATH_VecDotProduct(tv_temp, tv_temp1) < 0)
//							way_num_objs--
//					}
//				}
//					
//				// Si je suis proche du courant, je prend le suivant
//				if(way_num_objs)
//				{
//					if(OBJ_SqrDist(way_objs[way_num_objs-1]) <= 2 * 2)
//					{
//						way_num_objs--
//					}
//				}
//				
//				// Si je peux aller directement à un suivant (à condition que je n'ai pas deja
//				// testé le raccourci pour la case courante)
//				if(PeutSimplifierLeReseau())
//				{
//					if(way_num_objs >= 2)
//					{
//						tv_temp = GRID_PosGet(OBJ_PosGet())
//						if(!MATH_VecNullEpsilon(tv_temp - way_v_pos))
//						{
//							way_v_pos = GRID_PosGet(OBJ_PosGet())
//							ti_m = way_num_objs
//							ti_c = 0
//							for(ti_i = way_num_objs - 2; ti_i >= 0; ti_i--)
//							{
//								tv_temp = GRID_PosValidSimplifie(OBJ_PosGet(), @way_objs[ti_i] OBJ_PosGet(), vrai)
//								if(!MATH_VecNull(tv_temp))
//								{
//									ti_m = ti_i + 1
//								}
//								
////								ti_c++
////								if(ti_c >= 3) break
//								break
//							}
//							
//							way_num_objs = ti_m
//						}
//					}
//				}
//				
//				if(!way_num_objs)
//				{
//					tv_target = v_way_destpos
//					ti_directway = vrai
//				}
//				
//				// Position wp a atteindre
//				if(!ti_directway)
//				{
//					to_obj = way_objs[way_num_objs-1]
//					tv_target = @to_obj OBJ_PosGet()
////					tv_target = ComputeDestPosDecalee(tv_target)
//					
//					// Si je suis proche de cette pos, alors je choisi le wp suivant
//					if(way_num_objs > 1)
//					{
//						tv_temp = tv_target - OBJ_PosGet()
//						tv_temp.z = 0
//						if(!@to_obj OBJ_CapaTest(OBJ_Capa_0) && MATH_VecNorm(tv_temp) < 2)
//						{
//							way_num_objs--
//						 	to_obj = way_objs[way_num_objs-1]
//							tv_target = @to_obj OBJ_PosGet()
////							tv_target = ComputeDestPosDecalee(tv_target)
//						}
//					}
//				}
//			}
//		}
//	}
//	
//	GRID_RestoreHumains()
//	return tv_target
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void ChercheCacheSafe()
{
	int			ti_i
	object	to_wp
	
	i_num_cache_safe = 0	
	for (ti_i = 0; ti_i < @get_list_manager i_hide_0D_wp_nb; ti_i++)
	{
		to_wp = @get_list_manager ao_hide_0D_wp[ti_i]
		
		// Sectorisé
		if(!@to_wp SCT_ObjVisible()) continue
		
		// Annulée
		if(@to_wp OBJ_CapaTest(OBJ_Capa_0)) continue
		
		// Pleine
		if(@to_wp OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
		{
			if(to_wp.des_int1 && to_wp.des_int1 == to_wp.des_int2) continue
			if((to_wp.des_int3 & 0xFF) != C_Cache_Surface) continue	
		}
				
		// Stock
		ao_cache_safe[i_num_cache_safe] = to_wp
		i_num_cache_safe++
	}	
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int Weapon_damage( int i_weapon, float f_dist )
{
	float  tf_range
	
	tf_range = @"univ" Weapon_af_pointblankrange[ i_weapon  ]
	if ( f_dist < (tf_range * tf_range) ) 
		return  @"univ" Weapon_af_Damage[ i_weapon ][ 0 ]
			
	tf_range = @"univ" Weapon_af_middlerange[ i_weapon ]
	if ( f_dist < (tf_range * tf_range) ) 
		return @"univ" Weapon_af_Damage[ i_weapon ][ 1 ]

	return @"univ" Weapon_af_Damage[ i_weapon][ 2 ]
}





//procedure_local void H_Joueur_GrabbedObject_Ramasse_Action(byref int ti_req_action)
//{
//	object		to_grabbed_object
//	messageid	tmid_grabbed_object
//	int				ti_index
//
//	if(ACT_ActionGet() == Action_Jack_Ramasse && ! ACT_ActionFinished())
//		ti_req_action = Action_Jack_Ramasse
//	else if(ACT_ActionGet() == Action_Jack_RamasseF && ! ACT_ActionFinished())
//		ti_req_action = Action_Jack_RamasseF
//	else if(@"univ" o_ramasse_objet_who == OBJ_Me() && @"univ" i_ramasse_objet !=-1)
//	{
//		switch(@"univ" i_ramasse_objet)
//		{
//			case Ci_weapon_ID_colt :
//			case Ci_weapon_ID_shotgun :
//			case Ci_weapon_ID_tommy_gun :
//			case Ci_weapon_ID_sniper_rifle :
//				ti_req_action = Action_Jack_RamasseF
//				break
//			default:
//				ti_req_action = Action_Jack_Ramasse	
//				break
//		}
//	}
//	else if(i_flag_declenche)
//		ti_req_action = Action_Jack_Declenche
//	else if( IO_ButtonJustPressed(Jack_Joy_Tirer) )
//	{
//		if( TIME_Elapsed(f_grabbed_object_ramasse_time, 0.5) )
//		{
//			if( H_Joueur_GrabbedObject_Count() < Ci_Joueur_GrabObject_max_nb )
//			{
//				if( i_etat_courant != ETAT_IA_lance )
//				{
//					to_grabbed_object = LNK_ClientGet(Ci_LNK_GRAB_OBJECT, tmid_grabbed_object, vrai, "H_exec_grab_object_add_data", "H_exec_grab_object_select", nofunc)
//					if( to_grabbed_object )
//					{
//						ti_req_action = Action_Jack_Ramasse
//						f_grabbed_object_ramasse_time = TIME_Get()
//						i_flag_tape_bambou = faux
//						i_flag_frappe_jack = faux
//						i_flag_tir = faux
//						// stocker
//						ti_index = H_Joueur_GrabbedObject_GetIndex_Free()
//						ao_grabbed_object[ti_index] = to_grabbed_object
//						amid_grabbed_object[ti_index] = tmid_grabbed_object
//						ai_grabbed_object_ID[ti_index] = LNK_GrabObjectIdGet(tmid_grabbed_object)
//						@"univ" i_ramasse_objet = LNK_GrabObjectIdGet(tmid_grabbed_object)
//						@"univ" o_ramasse_objet_who = OBJ_Me()
//					}
//				}
//			}
//		}
//	}
//}



