#include "H_defines.var"

vector	tv_new_speed
float		tf_speed

// CHEAT MOVE
if( i_flag_cheat_move )	return

// JUMP FROM KK
if( i_jump_from_KK_flag )	return			// ne pas changer la dyna pour conserver l'impulsion


// SPEED ======================================
if( i_etat_courant == ETAT_Reward )
{
	f_speed_jack = 0
	tv_new_speed	= Cv_NullVector
	tv_new_speed.z = DYN_SpeedGetVector().z
	DYN_SpeedSetVector(tv_new_speed)
}
else if( i_flag_nage || f_nage_wall_contact_Z_offset )
{
	// NAGE (ou sort de l'eau)
	if( i_flag_nage && ! f_joy_norm )
	{
		// NAGE ARRÊT
		tv_new_speed = Cv_NullVector
		f_speed_jack = 0.0
	}
	else
	{
		// NAGE DEPLACEMENT
		tv_new_speed	= v_joy_dir * f_joy_norm
		f_speed_jack = f_joy_norm
	}
	DYN_SpeedSetVector(tv_new_speed)
}
else if( i_echelle_flag && ! i_jump_from_echelle_flag )
{
	// ECHELLE
	if( COL_CollideType(COL_C_Ground) && f_joy_norm )
	{
		goto AU_SOL_DEPL
	}
	else
	{
		tv_new_speed = Cv_NullVector
		f_speed_jack = 0.0
		DYN_SpeedSetVector(tv_new_speed)
	}
}
else if( f_joy_norm )
{
	// DEPLACEMENT
	AU_SOL_DEPL:
	tf_speed = MATH_VecNorm(IO_JoyGetMove())
	if( i_flag_crouch )
		tf_speed *= 1.5
	else if( H_IsWater() )
	{
		if(f_hauteur_eau >= Hauteur_Eau_Haute)
			tf_speed *= 1.0
		else
			tf_speed *= 1.5
	}
	else
		tf_speed *= 4.5
	f_speed_jack = MATH_FloatBlend(f_speed_jack, tf_speed, 4 * TIME_GetDt())
	tv_new_speed	= v_joy_dir * f_speed_jack
	tv_new_speed.z = DYN_SpeedGetVector().z
	DYN_SpeedSetVector(tv_new_speed)
}
else
{
	// ARRÊT
	f_speed_jack = 0
	tv_new_speed	= Cv_NullVector
	tv_new_speed.z = DYN_SpeedGetVector().z
	DYN_SpeedSetVector(tv_new_speed)	
}
