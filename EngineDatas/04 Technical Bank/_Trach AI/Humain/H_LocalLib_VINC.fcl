Include_UltraProcedure_Header
#include "H_defines.var"
#include "H_action.var"

//=============================================================
// WEAPON ID ACCESSORS
//=============================================================
procedure_ultra int H_Weapon_ID_Get()
{
	return @"univ" i_weapon_ID[i_id_humain]
}

procedure_ultra object H_Weapon_Gao_Get()
{
	return o_grabbed_object_en_main
}

procedure_local void H_Weapon_ID_Set(int ti_ID)
{
	@"univ" i_weapon_ID[i_id_humain] = ti_ID
}

procedure_local int H_WeaponSave_ID_Get()
{
	return @"univ" i_weapon_ID_Save[i_id_humain]
}

procedure_local void H_WeaponSave_ID_Set(int ti_ID)
{
	@"univ" i_weapon_ID_Save[i_id_humain] = ti_ID
}

procedure_local int H_WeaponSecond_ID_Get()
{
	return @"univ" i_weapon_ID_second[i_id_humain]
}

procedure_local void H_WeaponSecond_ID_Set(int ti_ID)
{
	@"univ" i_weapon_ID_second[i_id_humain] = ti_ID
}



//============================================================================
// GRABBED OBJECTS
//============================================================================
procedure_local int H_Joueur_GrabbedObject_Count()
{
	int		ti_i
	int		ti_cpt
	ti_cpt = 0
	for( ti_i = 0; ti_i < Ci_Joueur_GrabObject_max_nb; ti_i++ )
	{
		if( ao_grabbed_object[ti_i] )
			ti_cpt++
	}
	return ti_cpt
}

procedure_local int H_Joueur_GrabbedObject_GetIndex_Free()
{
	int		ti_i
	for( ti_i = 0; ti_i < Ci_Joueur_GrabObject_max_nb; ti_i++ )
	{
		if( ! ao_grabbed_object[ti_i] )
			return ti_i
	}
	return -1
}

procedure_local int H_Joueur_GrabbedObject_GetIndex_ByID(int ti_id)
{
	int		ti_i
	for( ti_i = 0; ti_i < Ci_Joueur_GrabObject_max_nb; ti_i++ )
	{
		if( ai_grabbed_object_ID[ti_i] == ti_id )
			return ti_i
	}
	return -1
}

procedure_local void H_Joueur_GrabbedObject_Delete_ByIndex(int ti_index)
{
	if( ti_index >= 0 && ti_index < Ci_Joueur_GrabObject_max_nb )
	{
//		ao_grabbed_object[ti_index] = LNK_ClientGet(Ci_LNK_GRAB_OBJECT, amid_grabbed_object[ti_index], faux, nofunc, nofunc, nofunc)
		ao_grabbed_object[ti_index] = nobody
		ai_grabbed_object_ID[ti_index] = -1
	}
}

procedure_local void H_Joueur_GrabbedObject_Delete_ByID(int ti_id)
{
	int		ti_index
	ti_index = H_Joueur_GrabbedObject_GetIndex_ByID(ti_id)
	if( ti_index != -1 )
		H_Joueur_GrabbedObject_Delete_ByIndex(ti_index)
}

// Resete les infos de l'arme en main
procedure_ultra void H_Weapon_Current_Reset()
{
	i_grabbed_object_index = -1
	o_grabbed_object_en_main = nobody
	H_Weapon_ID_Set(0)
}

// Force l'arme en main (doit d'abord avoir été ajoutée)
procedure_ultra void H_Weapon_Current_Set(int ti_index, int ti_id, object to_obj)
{
	i_grabbed_object_index = ti_index
	o_grabbed_object_en_main = to_obj
	H_WeaponSecond_ID_Set(H_Weapon_ID_Get())		// l'arme principale passe en 2ndaire
	H_Weapon_ID_Set(ti_id)
}

// Retire l'objet spécifié de l'inventaire.
procedure_local void H_Weapon_Delete(object to_gao)
{
	int		ti_i
	object	to_cur_weapon
	if( to_gao )
	{
		if( to_gao == o_grabbed_object_en_main )
		{
			if( i_weapon_delete_n_destroy )
				to_cur_weapon = o_grabbed_object_en_main
			H_Weapon_Current_Reset()		// plus rien en main
			if( i_weapon_delete_n_destroy )
				@to_cur_weapon OBJ_Destroy()
		}
		for( ti_i = 0; ti_i < Ci_Joueur_GrabObject_max_nb; ti_i++ )
		{
			if( ao_grabbed_object[ti_i] == to_gao )
				H_Joueur_GrabbedObject_Delete_ByIndex(ti_i)
		}
	}
	i_weapon_delete_n_destroy = faux
}

procedure_ultra int H_Joueur_GrabbedObject_Add(int ti_id, object to_object)
{
	int		ti_index
	ti_index = H_Joueur_GrabbedObject_GetIndex_Free()
	if( ti_index != -1 )
	{
		ao_grabbed_object[ti_index] = to_object
		ai_grabbed_object_ID[ti_index] = ti_id
//		if( ! @"univ" i_weapon_ID[i_id_humain] )
//		{
//			@"univ" i_weapon_ID[i_id_humain] = ti_id
//			o_grabbed_object_en_main = to_object
//		}
	}
	return ti_index
}


//============================================================================
// WEAPON TYPE
//============================================================================
//procedure_local void H_Weapon_Swap()
//{
//	int		ti_new_id
//	int		ti_old_id
//	object	to_new_obj
//	int		ti_new_index
//	ti_new_id = 0
//	if( H_WeaponSecond_ID_Get() )
//		ti_new_id = H_WeaponSecond_ID_Get()
//	else if( H_WeaponSave_ID_Get() )
//		ti_new_id = H_WeaponSave_ID_Get()
//	if( ti_new_id )
//	{
//		// j'ai une weapon pour swapper
//		ti_new_index = H_Joueur_GrabbedObject_GetIndex_ByID(ti_new_id)
//		H_Weapon_Current_Set(ti_new_index, ti_new_id, ao_grabbed_object[ti_new_index])
//	}
//}

procedure_local void H_Weapon_Swap()
{
	int		ti_cpt
	int		ti_index
	// next index ?
	ti_index = i_grabbed_object_index
	for( ti_cpt = 0; ti_cpt < (Ci_Joueur_GrabObject_max_nb - 1); ti_cpt++ )
	{
		ti_index = MATH_Modulo(ti_index + 1, Ci_Joueur_GrabObject_max_nb)
		if( ao_grabbed_object[ti_index] )
		{
			H_Weapon_Current_Set(ti_index, ai_grabbed_object_ID[ti_index], ao_grabbed_object[ti_index])
		}
	}
}


procedure int IsBambou(int weapon)
{
	if(weapon == Ci_weapon_ID_bambou) return vrai
	if(weapon == Ci_weapon_ID_ossement) return vrai
	return faux
}

procedure_local int BambouEnMain()
{
	if( IsBambou(@"univ" i_weapon_ID[i_id_humain]) )
		return vrai
	return faux
}

procedure int IsJetable(int weapon)
{
//	if(weapon == Ci_weapon_ID_levier) return vrai
	if(weapon == Ci_weapon_ID_bambou) return vrai
	if(weapon == Ci_weapon_ID_ossement) return vrai
	if(weapon == Ci_weapon_ID_crane) return vrai
	if(weapon == Ci_weapon_ID_hachette) return vrai
	return faux
}

procedure_local int JetableEnMain()
{
	if( IsJetable(@"univ" i_weapon_ID[i_id_humain]) )
		return vrai
	return faux
}

procedure int IsLevier(int weapon)
{
	if(weapon == Ci_weapon_ID_levier) return vrai
	return faux
}

procedure_local int LevierEnMain()
{
	if( IsLevier(@"univ" i_weapon_ID[i_id_humain]) )
		return vrai
	return faux
}


//--------------------------------------------------------------------------
// procédure pour lâcher l'objet que l'on a en main
//--------------------------------------------------------------------------
procedure_local void H_Weapon_Drop()
{
	object		to_obj
	object		to_bidoche
	int				i
	message	tm_msg
	vector		tv_temp
	float			tf_temp
	int				ti_index
	
	to_obj = o_grabbed_object_en_main
	if( ! to_obj )
		return		// rien en main

	switch( H_Weapon_ID_Get())
	{
		case Ci_weapon_ID_bambou :
		case Ci_weapon_ID_ossement :
			@to_obj OBJ_SightGeneralSet(v_sight_annexe1, v_bank_annexe1)
 			@to_obj OBJ_PosSet(v_pos_annexe1)
 			break
 			
 		default:
			@to_obj OBJ_SightGeneralSet(v_sight_annexe1, v_bank_annexe1)
			@to_obj OBJ_PosSet(v_pos_annexe1)
			break
	}
	MSG_SetNull(tm_msg)
	
	@to_obj OBJ_FlagsIdentitySet(OBJ_C_IdentityFlag_Msg, 0)		// get msg !!!!

	// On rajoute une vitesse de sight qui depend de la vitesse du joueur
	tf_temp = 1
	tv_temp = DYN_SpeedGetVector()
	tv_temp.z = 0
	if( ! MATH_VecNullEpsilon(tv_temp) )
	{
		MATH_VecSetHorzNormalize(tv_temp)
		tf_temp = MATH_AbsFloat(MATH_VecDotProduct(tv_temp, @get_camera OBJ_SightGet()))
	}
	
	tm_msg.msg_id = msg_id_grenadefall
	tm_msg.msg_sender = OBJ_Me()
	
	tv_temp = DYN_SpeedGetVector() * 2 * tf_temp
	tv_temp.z += 3
	tv_temp = MATH_VecGlobalToLocal(tv_temp)
	if( tv_temp.y > 0 )
		tv_temp.y = 0
	tv_temp = MATH_VecLocalToGlobal(tv_temp)		
	tm_msg.msg_vec1 = (OBJ_SightGet() * 2) + tv_temp

	tm_msg.msg_vec2 = Cv_NormalGravity
	tm_msg.msg_vec3 = cvector(1.0, 1.0, 0.0)
	tm_msg.msg_vec4 = cvector( f_time_dynamite, 0, 0 )
	
	@to_obj MSG_Send( tm_msg )
	
	// Bidoche plugée

// FRED
//	if( BambouEnMain() && H_Joueur_Gets_Bidoche() )
//	{
//		to_bidoche = @get_global o_bidoche_gao
//		@get_PNJ_Bidoche_path to_bidoche o_javelin = to_obj
//
//		@get_Arme_Lance_path to_obj o_bidoche = @get_global o_bidoche_gao
//
//		@get_global o_bidoche_gao = nobody
//		@get_global o_bidoche_plug_jack = nobody
//	}

	f_time_tir_grenade = TIME_Get()	
	H_Weapon_Delete(o_grabbed_object_en_main)
}


//=============================================================
// JUMP
//=============================================================
procedure_local void H_JumpReset()
{
	i_jump_flag = faux
	i_jump_from_KK_flag = faux
	i_jump_from_echelle_flag = faux
	f_jump_from_echelle_timer = 0.0
	v_jump_destination = Cv_NullVector
}



//=============================================================
//		FLAMME FUNCTION
//=============================================================

#define DBG_GFXFire

//---------------------------------------------------------------------------
// Get type of fire
//		0 : none
//		1 : bambou
//		2 : crane enflammé
//---------------------------------------------------------------------------
procedure_local int GFX_Fire_GetType()
{
	if (BambouEnMain())
		return 1
	if (@"univ" i_weapon_ID[i_id_humain] == Ci_weapon_ID_crane )
		return 2
	return 0
}

//---------------------------------------------------------------------------
// Compute pos of fire
//		0 : none
//		1 : bambou
//		2 : crane enflammé
//---------------------------------------------------------------------------
procedure_local void GFX_Fire_ComputePos()
{
	int			ti_type
		
	ti_type = GFX_Fire_GetType()
	if ( ! ti_type || ! o_canal_annexe1 )
		return
		
	switch( ti_type )
	{
		//----( bambou )----
		case 1 :
			GFX_FlammeAxe = @o_canal_annexe1 OBJ_SightGet()
			MATH_VecSetNorm( GFX_FlammeAxe, 0.1 )
			GFX_FlammePos = @o_canal_annexe1 OBJ_PosGet() + (15 * GFX_FlammeAxe)
			GFX_FlammeFXPos = @o_canal_annexe1 OBJ_PosGet() + (8 * GFX_FlammeAxe)
			break
			
		//----( crane enflammé )----
		case 2 : 
			GFX_FlammeAxe = @o_canal_annexe1 OBJ_BankingGet()
			GFX_FlammeAxe *= 0.03
			GFX_FlammePos = @o_canal_annexe1 OBJ_PosGet()
			GFX_FlammePos += 6 * GFX_FlammeAxe
			GFX_FlammePos += 0.05 * @o_canal_annexe1 OBJ_SightGet()
			GFX_FlammeFXPos = GFX_FlammePos
			break
	}
	
	//---( Debug )----
	#ifdef DBG_GFXFire
	DBG_RenderSphere( GFX_FlammePos, 0.03, color_rouge )
	DBG_RenderSphere( GFX_FlammeFXPos, 0.03, color_rouge )
	DBG_RenderVector( GFX_FlammeFXPos, GFX_FlammeAxe, color_rose )
	DBG_RenderVector( GFX_FlammeFXPos, -GFX_FlammeAxe, color_rose )
	#endif
}

//---------------------------------------------------------------------------
// éteint le feu
//---------------------------------------------------------------------------
procedure_local void GFX_Fire_Stop()
{
	//----( stop visual effect )----
	if ( GFX_Flamme != -1)
	{
		GFX_Seti( GFX_Flamme, 13106, 0)	
		GFX_Flamme = -1
	}
	if (GFX_Spark != -1 )
	{
		GFX_Seti( GFX_Spark, 9102, GFX_Geti( GFX_Spark, 9102) | 4 )
		GFX_Spark = -1
	}
	if (GFX_Flamme2_Halo != -1)
		LIBGFX_JavelinFire2( GFX_FlammeFXPos, GFX_FlammeAxe, 1.0, 0, &GFX_Flamme2[0], GFX_Flamme2_Halo, GFX_Flamme2_lastlastpos, GFX_Flamme2_lastpos)

	//----( stop sound effect )----
	if(i_snd_fire != -1) 
	{
		SND_Stop(i_snd_fire)
		i_snd_fire = -1
	}
	
	//----( set vars )----
	f_time_no_fire = Cf_EVENT_Duree_1Trame

	LIGGFX_Fumee(i_gfx_fumee1, i_gfx_fumee2, GFX_FlammePos, 2)

//	if(TIME_Elapsed(time_pshhhh, 1))
//	{
//		time_pshhhh = TIME_Get()
//		SND_RequestPlay(37)
//	}
}


//---------------------------------------------------------------------------
// allume le feu
//---------------------------------------------------------------------------
procedure_local void GFX_Fire_Start()
{
	if(i_snd_fire == -1) 
		i_snd_fire = SND_RequestPlayLoop(SND_Jack_BambooFire)	
	if(TIME_Elapsed(time_pshhhh1, 1))
	{
		time_pshhhh1 = TIME_Get()
		SND_RequestPlay(34)
	}
}


//============================================================================
// FIRE / POISON / BIDOCHE
//============================================================================
procedure_ultra object H_Joueur_Gets_Bidoche()
{
	if( @get_global o_bidoche_plug_jack )
		return @get_global o_bidoche_gao
	else
		return nobody
}

procedure_ultra int H_Weapon_IsOnFire()
{
	if( o_grabbed_object_en_main )
	{
// FRED
//		if( @o_grabbed_object_en_main AI_IsModel(get_Arme_Lance_path) )
//		{
//			if( @o_grabbed_object_en_main Lance_IsOnFire() )
//				return vrai
//		}
	}
	return faux
}

procedure_ultra void H_Weapon_SetOnFire(int ti_on)
{
	object	to_bidoche
	// gfx
	if( ti_on )
	{
		GFX_Fire_Start()
		// bidoche
		if( H_Joueur_Gets_Bidoche() )
		{
			to_bidoche = @get_global o_bidoche_gao
			@to_bidoche OBJ_CapaSet(CAPA_Bidoche_Snapped_SeDetacher, none)
			@get_global o_bidoche_gao = nobody
			@get_global o_bidoche_plug_jack = nobody
		}
	}
	else
		GFX_Fire_Stop()
	// weapon
	if( o_grabbed_object_en_main )
	{
// FRED
//		if( @o_grabbed_object_en_main AI_IsModel(get_Arme_Lance_path) )
//		{
//			 @o_grabbed_object_en_main Lance_SetOnFire(ti_on)
//		}
	}
}

procedure_ultra int H_Weapon_IsPoisonned()
{
	if( o_grabbed_object_en_main )
	{
		if( @o_grabbed_object_en_main AI_IsModel(get_Arme_Lance_path) )
		{
			return @o_grabbed_object_en_main Lance_IsPoisonned()
		}
	}
	return faux
}

procedure_ultra void H_Weapon_SetPoisonned(int ti_on)
{
	object	to_bidoche
	// bidoche
	if( ti_on )
	{
		if( H_Joueur_Gets_Bidoche() )
		{
			to_bidoche = @get_global o_bidoche_gao
			@to_bidoche PNJ_EatMe_SetPoisonned(ti_on)
		}
	}
	// weapon
	if( o_grabbed_object_en_main )
	{
		if( @o_grabbed_object_en_main AI_IsModel(get_Arme_Lance_path) )
		{
			@o_grabbed_object_en_main Lance_SetPoisonned(ti_on)
		}
	}
}



//============================================================================
// WATER
//============================================================================
procedure_local int H_IsWater()
{
	float	tf_water_Z
	int		ti_under
	ti_under = IsInWater(OBJ_PosGet(), tf_water_Z)
	if( tf_water_Z != Cf_water_Z_unknown )
		f_water_Z_world = tf_water_Z		// update, même si pas sous l'eau 
	return ti_under
}

//procedure_local int IsWater(int ground)		// OLD !!!!
//{
//	return H_IsWater()
//}




procedure void Dupl_Fleche(byref object to_obj, int ti_force_new)
{
	if( ! to_obj || ti_force_new )
	{
		to_obj = @get_Arme_Fleche OBJ_Duplicate(OBJ_PosGet())
		@to_obj OBJ_FlagInvisibleSet(vrai)
	}
}



procedure_local int H_ActionArc(int ti_action)
{
	if( ti_action >= Inf_Action_Arc_Arme_Horiz_Deb
		&& ti_action <= Inf_Action_Arc_Arme_Vert_tr_Horiz )
		return vrai
	if( ti_action >= Inf_Action_Arc_Incline_Deb
		&& ti_action <= Inf_Action_Arc_Incline_Tir )
		return vrai
	return faux
}




procedure void DBG_Gao_All_Capas(string str_text, object to_gao, vector tv_debug)
{
	Str_DisplayTextOnce(str_text, tv_debug)
	if( to_gao )
	{
		tv_debug += cvector(0,0.05,0)
		Str_DisplayGaoOnce(to_gao, tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_0) )	Str_DisplayTextOnce("capa 0", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_1) )	Str_DisplayTextOnce("capa 1", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_2) )	Str_DisplayTextOnce("capa 2", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_3) )	Str_DisplayTextOnce("capa 3", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_4) )	Str_DisplayTextOnce("capa 4", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_5) )	Str_DisplayTextOnce("capa 5", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_6) )	Str_DisplayTextOnce("capa 6", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_7) )	Str_DisplayTextOnce("capa 7", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_8) )	Str_DisplayTextOnce("capa 8", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_9) )	Str_DisplayTextOnce("capa 9", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_10) )	Str_DisplayTextOnce("capa 10", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_11) )	Str_DisplayTextOnce("capa 11", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_12) )	Str_DisplayTextOnce("capa 12", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_13) )	Str_DisplayTextOnce("capa 13", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_14) )	Str_DisplayTextOnce("capa 14", tv_debug)
		tv_debug += cvector(0,0.05,0)
		if( @to_gao OBJ_CapaTest(OBJ_Capa_15) )	Str_DisplayTextOnce("capa 15", tv_debug)
	}
}



//=============================================================
//		POUSSE PORTE FUNCTION
//=============================================================
procedure_local void	Joueur_TournePilier()
{
	object	to_main
	vector	tv_temp, tv_temp1
	vector	tv_pilier_sight
	vector	tv_pilier_horizon
	float		tf_val
	int			ti_rotinverse
	
	if (!o_obj_porte) return
	to_main = ANI_CanalObjectGet(Anim_Canal_MainDroite)
	if (!to_main) return
	
	// ----( rotation inversée )----
	ti_rotinverse = 0
	if (@o_obj_porte OBJ_CapaTest(OBJ_Capa_5) )
		ti_rotinverse = 1
	
	// ----( get axis )----
	tv_pilier_sight = o_obj_porte.des_vec1
	tv_pilier_horizon =o_obj_porte.des_vec2
	
	if (ti_rotinverse)
		tv_pilier_horizon = -tv_pilier_horizon
	
	tv_temp = @to_main OBJ_PosGet() - OBJ_PosGet()
	tf_val = MATH_VecDotProduct( tv_temp, OBJ_SightGet() ) - 0.385
	
	if ( ACT_ActionGet() == Inf_Action_Levier_Pousse_Bloque )
	{
		if (o_obj_levier && ! @o_obj_levier OBJ_CapaTest( OBJ_Capa_11 ) )
			@o_obj_levier OBJ_CapaSet( OBJ_Capa_10 | OBJ_Capa_11, 0 )

		tv_temp = @to_main OBJ_PosGet() 
		if (i_etat_state == 1)
			tv_temp += OBJ_SightGet() * 0.135
		else
			tv_temp += OBJ_SightGet() * 0.1
		tv_temp -= @o_obj_porte OBJ_PosGet()
		tv_temp.z = 0
		tv_temp1 = -tv_pilier_sight
		tv_temp1.z = 0
		tf_val = MATH_VecAngle(tv_temp1, tv_temp, @o_obj_porte OBJ_BankingGet()) 
		o_obj_porte.des_float1 = tf_val
	}
	else if ( ACT_ActionGet() == Inf_Action_Levier_Tire_Bloque )
	{
		if (o_obj_levier && ! @o_obj_levier OBJ_CapaTest( OBJ_Capa_11 ) )
			@o_obj_levier OBJ_CapaSet( OBJ_Capa_10 | OBJ_Capa_11, 0 )

		tv_temp = @to_main OBJ_PosGet() 
		if (i_etat_state == 1)
			tv_temp += OBJ_SightGet() * 0.08
		else
			tv_temp += OBJ_SightGet() * 0.04
		tv_temp -= @o_obj_porte OBJ_PosGet()
		tv_temp.z = 0
		tv_temp1 = -tv_pilier_sight
		tv_temp1.z = 0
		tf_val = MATH_VecAngle(tv_temp1, tv_temp, @o_obj_porte OBJ_BankingGet()) 
		o_obj_porte.des_float1 = tf_val
	}
	else if (o_obj_porte.des_float1 != 0 )
	{
		if (o_obj_levier)
			@o_obj_levier OBJ_CapaSet( 0, OBJ_Capa_10 | OBJ_Capa_11 )

		if ( o_obj_porte.des_float1 > 0)
		{
			o_obj_porte.des_float1 -= TIME_GetDt()
			if ( o_obj_porte.des_float1 < 0)
				o_obj_porte.des_float1 = 0
		}
		else
		{
			o_obj_porte.des_float1 += TIME_GetDt()
			if ( o_obj_porte.des_float1 > 0)
				o_obj_porte.des_float1 = 0
		}
	}

	// POS/ORIENT	
	tv_temp = @o_obj_porte OBJ_PosGet()
	if ( o_obj_levier)
	{
		tv_temp1 = @o_obj_levier OBJ_PosGet()
		tv_temp.z = tv_temp1.z - 1.2
	}
	tv_temp -= (tv_pilier_sight * 0.7)
	
	tf_val = MATH_VecDotProduct(OBJ_SightGet(), tv_pilier_horizon )
	if(tf_val < 0)
	{
		tv_temp += (tv_pilier_horizon * 0.48)
		v_sight_pousse = -tv_pilier_horizon
	}
	else // Inversé
	{
		tv_temp -= (tv_pilier_horizon * 0.5)
		v_sight_pousse = tv_pilier_horizon
	}

	if (i_etat_state == 0)		// prise en main
		OBJ_PosSet( MATH_VecBlend( OBJ_PosGet(), tv_temp, 3 * TIME_GetDt() ) )
	else
		OBJ_PosSet( MATH_VecBlend( OBJ_PosGet(), tv_temp, 10 * TIME_GetDt() ) )

	tv_temp1 = Cv_VerticalVector	
	if(f_joy_norm)
		tv_temp1 += @get_Kamera OBJ_HorizonGet() * 0.03 * MATH_Sin(TIME_Get() * 2)
	
	if (i_etat_state == 0)		// prise en main
	{
		v_sight_pousse.z -= 0.1
		tv_temp = MATH_VecBlendRotate(@get_Kamera OBJ_SightGet(), v_sight_pousse, 10 * TIME_GetDt())
		@get_Kamera OBJ_SightGeneralSet(tv_temp, tv_temp1)
	}
	else
	{
		tv_temp = MATH_VecInCone(v_sight_pousse, @get_Kamera OBJ_SightGet(), 0.6, 0)
		tv_temp = MATH_VecBlendRotate(@get_Kamera OBJ_SightGet(), tv_temp, 10 * TIME_GetDt())
		@get_Kamera OBJ_SightGeneralSet(tv_temp, tv_temp1)
	}
	// BRIDER L'ORIENTATION DE LA KAMERA !!!!! ----------------
	@get_Kamera v_sfx_sight = tv_temp
	@get_Kamera v_sfx_bank = tv_temp1
	// BRIDER L'ORIENTATION DE LA KAMERA !!!!! ----------------
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
procedure_local void MakeTirCommon
( 
	byref vector 	tv_tir_depart, 
	byref vector 	tv_tir_arrivee, 
	byref vector 	tv_sight,
	byref object		to_gao,
	byref int			ti_canal,
	byref int			ti_playsound
)
{
	vector	tv_impact
	object	to_jack, to_gao1
	vector	tv_normal
	vector	tv_temp
	int			tc_color
	int			ti_id
	int			ti_sound
	float		tf_range
	int			ti_sndinst
	
	ti_id = @"univ" i_weapon_ID[i_id_humain]	
	tf_range = @"univ" Weapon_af_range[ti_id]
	to_jack = AI_MainActorGet(C_ID_Joueur)
	@to_jack OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, 0)
	
//	STATS_IncBullet()
	tv_tir_depart = @get_camera OBJ_PosGet()
	tv_sight = @get_camera OBJ_SightGet()
	
	to_gao = @"KingKong/Humain" to_jack o_tir_prefered
	ti_canal = @"KingKong/Humain" to_jack i_tir_prefered_canal
	tv_impact = @"KingKong/Humain" to_jack v_tir_prefered_impact
	tv_normal = @"KingKong/Humain" to_jack v_tir_prefered_normal
	ti_sound = @"KingKong/Humain" to_jack i_tir_prefered_sound
	
	if ( to_gao && (ti_canal != -1) )	
		ti_sound = COL_C_Snd_Flesh

	// Impact eau
	if(to_gao && ti_sound == COL_C_Snd_Water)
	{
		ti_sndinst = SND_RequestPlay( SND_Jack_BulletNone + ti_sound )
		SND_InstPosUpdate( ti_sndinst, tv_impact )

		//FRED ------------------------------------------------------------
		LIBGFX_GunsImpact( tv_impact, tv_normal, to_gao, -1, Ci_Color_Impact_Eau , ti_sound )
//		push(tv_normal)														// Fr
//		push(tv_impact)														// Fr
//		AI_Execute("H_exec_GFX_TirEau")							// Fr
		//FRED ------------------------------------------------------------		
		
		tf_range -= MATH_VecNorm(tv_impact - tv_tir_depart)
		if(tf_range > 0)
		{
			@to_gao OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, 0)
			to_gao1 = COL_RayObject_Dist(tv_impact, tv_sight, tf_range, all, none, 0, COL_C_Ray_on_visuel_and_bone_volumes)
			@to_gao OBJ_FlagsControlSet(0, OBJ_C_ControlFlag_RayInsensitive)
			to_gao = to_gao1

			// Un humain ? (et on n'a pas le droit de les shooter)
			if(to_gao && @to_gao AI_IsModel("KingKong/Humain") && !OBJ_CapaTest(OBJ_Capa_1)) to_gao = nobody

			ti_canal = COL_RayObject_CanalGet()
			if (ti_canal != -1) to_gao = COL_RayObject_ActorGet()
			tv_impact = COL_RayObject_PosGet()
			tv_normal = COL_RayObject_NormalGet()
			ti_sound = COL_RayObject_SoundGet()

			// Son a travers l'Eau = Uniquement la Chair !
			if ( to_gao && (ti_canal != -1) )
				ti_sound = COL_C_Snd_Flesh 
			else if ( ti_sound != COL_C_Snd_Flesh )
				 ti_playsound = faux
		}
	}

	//FRED ------------------------------------------------------------
	if(to_gao )
	{
		// On a touché quelque chose
		tv_tir_arrivee = tv_impact

		// Impact
		LIBGFX_GunsImpact( tv_impact, tv_normal, to_gao, ti_canal, 0 , ti_sound )

//		tc_color = Ci_sang											// Fr
//		if(ti_canal == -1) tc_color = Ci_etincelle				// Fr
//		push(tc_color)													// Fr
//		push(tv_normal)												// Fr
//		push(tv_impact)												// Fr
//		AI_Execute("H_exec_GFX_Impact")					// Fr
	}
	else
	{
		// On a rien touché (on va au bout du range)
		tv_tir_arrivee = tv_tir_depart + (tv_sight *  tf_range)
	}
	//FRED ------------------------------------------------------------
	
	EVENT_AddEventShoot(OBJ_Me(), ti_id, tv_tir_depart, tv_tir_arrivee, to_gao, ti_canal)
	
	if (ti_playsound)
	{
		ti_sndinst = SND_RequestPlay( SND_Jack_BulletNone + ti_sound )
		SND_InstPosUpdate( ti_sndinst, tv_impact )
		ti_playsound = ti_sound
	}

	tv_sight = tv_tir_arrivee - tv_tir_depart
	if ( MATH_VecNullEpsilon( tv_sight)) tv_sight = OBJ_SightGet()
	MATH_VecSetNormalize( tv_sight)	
	@to_jack OBJ_FlagsControlSet(0, OBJ_C_ControlFlag_RayInsensitive)
}

procedure_local object H_COL_RayObject_Dist(int what, vector sight, float dist)
{
	object	to_obj1
	vector	tv_temp
	float		tf_temp
	
	to_obj1 = nobody
	if(!af_tir_idle_dist[what] || af_tir_idle_dist[what] >= dist)
	{
		to_obj1 = COL_RayObject_Dist(@get_camera OBJ_PosGet(), sight, dist, all, none, 0, COL_C_Ray_on_visuel_and_bone_volumes)
//		DBG_RenderVector(@get_camera OBJ_PosGet(), sight * dist, 0xFF)
	}
	else
	{
		to_obj1 = COL_RayObject_Dist(@get_camera OBJ_PosGet(), sight, af_tir_idle_dist[what], all, none, 0, COL_C_Ray_on_visuel_and_bone_volumes)
//		DBG_RenderVector(@get_camera OBJ_PosGet(), sight * af_tir_idle_dist[what], 0xFF)
		if(!to_obj1)
		{
			tv_temp = MATH_VecNormalize(sight)
			tv_temp *= af_tir_idle_dist[what]
			tv_temp += @get_camera OBJ_PosGet()
			to_obj1 = COL_RayObject_Dist(tv_temp, sight, dist - af_tir_idle_dist[what], all, none, 0, COL_C_Ray_on_visuel_and_bone_volumes)
//			DBG_RenderVector(tv_temp, sight * (dist - af_tir_idle_dist[what]), 0xFF)
		}
	}
	
	if(to_obj1)
	{
		tv_temp = COL_RayObject_PosGet() - @get_camera OBJ_PosGet()
		tf_temp = MATH_VecNorm(tv_temp) + 1
		if(tf_temp > dist) tf_temp = dist
		af_tir_idle_dist[what] = tf_temp
	}
	else
	{
		af_tir_idle_dist[what] = 0
	}
	
	return to_obj1
}



////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////:
// Determine la cible si on shoot
procedure_local void H_PreferedTarget()
{
	int			i, j
	float		tf_temp
	object	to_obj, to_obj1
	vector	tv_temp, tv_temp1
	int			ti_rem
	int			ti_canal
	float		tf_precision
	
	OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, 0)
	
	i = @"univ" i_weapon_ID[C_ID_Joueur]
	if(!i)
		tf_temp = 50
	else
		tf_temp = @"univ" Weapon_af_range[i]
		
	// Si je touche quelquechose au centre, et que ce qqchose est touchable, c'est lui qui a la prio
	o_water = nobody
	if( ! i_joy_flag_viser )
//	if(i_flag_arme_basse && !i_flag_tape_bambou)
	{
//		if ( BambouEnMain() && (H_OBJENMAIN_PARAM == 1) )	
		if ( BambouEnMain() && H_Weapon_IsOnFire() )
		{
			to_obj1 = COL_RayObject_Dist(@get_camera OBJ_PosGet(), @get_camera OBJ_SightGet(), tf_temp, all, none, 0, COL_C_Ray_on_visuel_and_bone_volumes)
			if (COL_RayObject_SoundGet() == COL_C_Snd_Water)
			{
				o_water = to_obj1
				v_water_impact = COL_RayObject_PosGet()
			}
		}
		to_obj1 = nobody
	}
	else
		to_obj1 = H_COL_RayObject_Dist(4, @get_camera OBJ_SightGet(), tf_temp)
	if(to_obj1)
	{
		// On vire les humains si trop petit à l'écran
		ti_canal = COL_RayObject_CanalGet()
		if(ti_canal != -1) to_obj1 = COL_RayObject_ActorGet()
		v_tir_centre_impact = COL_RayObject_PosGet()
		
		if(ao_tir_idle[4]) OBJ_UnRegisterKill(ao_tir_idle[4], &ao_tir_idle[4])
		ao_tir_idle[4] = to_obj1
		av_tir_idle_impact[4] = v_tir_centre_impact
		av_tir_idle_normal[4] = COL_RayObject_NormalGet()
		ai_tir_idle_canal[4] = ti_canal
		ai_tir_idle_sound[4] = COL_RayObject_SoundGet()
		
		if (ai_tir_idle_sound[4] == COL_C_Snd_Water)
		{
			o_water = to_obj1
			v_water_impact = v_tir_centre_impact
		}
	}
	else
	{
		if(ao_tir_idle[4]) OBJ_UnRegisterKill(ao_tir_idle[4], &ao_tir_idle[4])
		ao_tir_idle[4] = nobody
		ti_canal = -1
		v_tir_centre_impact = Cv_NullVector
	}
	
	if((to_obj1 && @to_obj1 OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct) && to_obj1.des_int1)
	{
		v_tir_prefered_impact = COL_RayObject_PosGet()
		v_tir_prefered_normal = COL_RayObject_NormalGet()
		i_tir_prefered_sound = COL_RayObject_SoundGet()
		i_tir_prefered_canal = ti_canal
	}
	else if( i_joy_flag_viser )	// if(!i_flag_arme_basse)
	{
		v_tir_prefered_impact = Cv_NullVector
		to_obj1 = nobody
		tv_temp = @get_camera OBJ_SightGet()
//		if(@"univ" i_weapon_ID[i_id_humain] == Ci_weapon_ID_sniper_rifle)
//			tf_precision = 0.01
//		else
			tf_precision = 0.05
			
		if(i_tir_idle1 == 0)
			tv_temp = MATH_VecRotate(tv_temp, @get_camera OBJ_BankingGet(), -tf_precision)
		else if(i_tir_idle1 == 1)
			tv_temp = tv_temp
		else
			tv_temp = MATH_VecRotate(tv_temp, @get_camera OBJ_BankingGet(), tf_precision)
		MATH_VecSetNormalize(tv_temp)
		tv_temp = MATH_VecRotate(tv_temp, @get_camera OBJ_HorizonGet(), i_tir_idle * tf_precision)
		
//		for(i = 0; i < 3; i++)
		i = i_tir_idle1
		
		{
			j = ((i_tir_idle + 1) * 3) + i
			if(j != 4)
			{			
//	 			if(@"univ" i_weapon_ID[i_id_humain] == Ci_weapon_ID_sniper_rifle && i_flag_snipe )
//	 				to_obj = nobody
//	 			else
					to_obj = H_COL_RayObject_Dist(j, tv_temp, tf_temp)
				DBG_RenderVector(@get_camera OBJ_PosGet(),tv_temp*tf_temp,0xFFFF00)
				if(to_obj)
				{
					ti_canal = COL_RayObject_CanalGet()
					if(ti_canal != -1) to_obj = COL_RayObject_ActorGet()
				}
				else
				{
					ti_canal = -1
				}
				
	
				if(ao_tir_idle[j]) OBJ_UnRegisterKill(ao_tir_idle[j], &ao_tir_idle[j])
				ao_tir_idle[j] = to_obj
				av_tir_idle_impact[j] = COL_RayObject_PosGet()
				av_tir_idle_normal[j] = COL_RayObject_NormalGet()
				ai_tir_idle_canal[j] = ti_canal
				ai_tir_idle_sound[j] = COL_RayObject_SoundGet()
				
				tv_temp = MATH_VecRotate(tv_temp, @get_camera OBJ_BankingGet(), tf_precision)
			}
		}
		
		i_tir_idle1++
		if(i_tir_idle1 == 3) 
		{
			i_tir_idle1 = 0		
			i_tir_idle++
			if(i_tir_idle == 2) i_tir_idle = -1		
		}
	}
	else
	{
			for(i = 0; i < 9; i++)
			{
				if(ao_tir_idle[i]) OBJ_UnRegisterKill(ao_tir_idle[i], &ao_tir_idle[i])
				ao_tir_idle[i] = nobody
			}
	}
	
	// Je choisi parmi la liste le meilleur (sauf si ligne directe)
	if(!to_obj1)
	{
		// Prio horizontale
		for(i = 0; i < 9; i++)	
		{
			to_obj = ao_tir_idle[i]
			if(!to_obj) continue
			
			if((@to_obj OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct) && to_obj.des_int1) 
			{
				if(!@to_obj AI_IsModel("KingKong/Humain") || @to_obj OBJ_CapaTest(OBJ_Capa_1))
				{
					to_obj1 = to_obj
					v_tir_prefered_impact = av_tir_idle_impact[i]
					v_tir_prefered_normal = av_tir_idle_normal[i]
					i_tir_prefered_canal = ai_tir_idle_canal[i]
					i_tir_prefered_sound = ai_tir_idle_sound[i]
					break
				}
			}
		}		

		// N'importe qui
		if(!to_obj1)
		{
			if(ao_tir_idle[4])
			{
				to_obj1 = ao_tir_idle[4]
				v_tir_prefered_impact = av_tir_idle_impact[4]
				v_tir_prefered_normal = av_tir_idle_normal[4]
				i_tir_prefered_canal = ai_tir_idle_canal[4]
				i_tir_prefered_sound = ai_tir_idle_sound[4]
			}
			else for(i = 0; i < 9; i++)	
			{
				to_obj = ao_tir_idle[i]
				if(!to_obj) continue
				to_obj1 = to_obj
				v_tir_prefered_impact = av_tir_idle_impact[i]
				v_tir_prefered_normal = av_tir_idle_normal[i]
				i_tir_prefered_canal = ai_tir_idle_canal[i]
				i_tir_prefered_sound = ai_tir_idle_sound[i]
				break
			}		
		}
	}
	
	o_tir_prefered = to_obj1	
	OBJ_FlagsControlSet(0, OBJ_C_ControlFlag_RayInsensitive)
	
	// Register kill
	for(i = 0; i < 9; i++)
	{
		if(ao_tir_idle[i]) OBJ_RegisterKill(ao_tir_idle[i], &ao_tir_idle[i])
	}
	
	if(o_tir_prefered) OBJ_RegisterKill(o_tir_prefered, &o_tir_prefered)
	
	///////////////////////////////////////////
	// PUTAINS DE CATHOS !!!!!!
	///////////////////////////////////////////
	if(1)
	{
		if(o_tir_prefered && @o_tir_prefered AI_IsModel("PNJ_Predators/PNJ_Native") && i_flag_snipe) 
			o_tir_prefered = nobody
	}
}

