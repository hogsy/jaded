// PARAMETRES D'ENTREE:
//    La position courante: v_way_currentpos
//    La position finale (destination): v_way_destpos
//    La vitesse du blend lors de la rotation: f_way_blendrotate (Valeur par defaut: 0.2)
//    La distance limite de l'alogo a partir de laquel il s'arrete i_way_algo_limitdestpos    (Laisser si possible la valeur par defaut: 6)
//    L'information de hauteur courante: (Le CBits_Hauteur_Grille_Courante du perso) il est mis a jour automatiquement dans les fonctions de TAG sur la grille (information recupéré dans le GMAT du sol)
//    L'information de hauteur de destination: i_way_etage_dest ( 0 = etage 0 ou != 0 pour l'etage 1)
//    Eventuellement i_way_fore_recompute lorsque l'on passe de l'etat j'etais arreté et je veux me deplacer (Ne pas mettre a vrai en permanance !!!!)
//
// PARAMETRES DE SORTIE:
//    L'indication que le perso peut se deplacer : i_way_moving
//    La visée pour le perso: v_way_sight (elle s'oriente progressivement de la visée courante vers la case dest)
//    La prochaine case vers laquel le perso se dirige: v_way_case_dest    Attention ce n'est pas forcement une case a proximité car la fonction de recherche de chemin smooth les deplacements  pour que l'on ne voit pas les escaliers... Donc il est possible si rien ne l'en empeche que l'on se dirige vers une case qui est a 5 ou 6 cases de la case courante...


vector		tv_way_temp 					// Vecteur Temporaire.
int				ti_way_case_nbr_smooth	// Nbr de case dans la grille
vector		tv_way_normal					// normal de collision
int				ti_way_case_next_value 	// Valeur de la case next
int				ti_way_dif_level 				// Indique si on va sur le meme level que le courant ou pas...
vector		tv_dest_pos_temp			// Vecteur temporraire pour l'erreur grille
float			tf_lenbig
float			tf_born
int				ti_etage
int				ti_isin
int				ti_exit
int				ti_i, ti_capa, ti_cpt
int				ti_flag_next_case_reached
vector		tv_temp, tv_temp1
int				ti_temp
float			tf_temp

if(!f_way_test_born) tf_born = 4
else tf_born = f_way_test_born
f_way_test_born = 0

// Permet de travailler sur le meme Z (cause distance)
v_way_destpos.z = v_way_currentpos.z

// Test des isin sur les etages respectifs
ti_isin = vrai
ti_exit = faux
if(!GRID_IsIn(v_way_destpos)) ti_isin = faux
if(!GRID_IsIn(v_way_currentpos)) ti_isin = faux

if (ti_isin)		// Test Source & Destination
{
	// ############
	// AVEC GRILLE
	// ############

	// Si on a changé de case, on vérifie le chemin stocké
	if(!i_way_force_recompute)
	{
		// Case suivante occupée
		ti_capa = GRID_CapaGet(v_way_case_dest)
		if(GRID_Blocked(v_way_case_dest, vrai))
			i_way_force_recompute = vrai
//		if(ti_capa & tag_grid_occupe_msk) i_way_force_recompute = vrai
		
		tv_way_temp = GRID_PosGet(v_way_case_dest) 

		// Si une ligne bloquée entre moi et case_dest, je recalcul le chemin
		if(!i_way_force_recompute)
		{
			tv_temp = tv_way_temp - OBJ_PosGet()
			tv_temp.z = 0
			if(MATH_VecNorm(tv_temp) > 4) MATH_VecSetNorm(tv_temp, 4)
			tv_temp += OBJ_PosGet()
			if(!GRID_PosValidDyn(OBJ_PosGet(), tv_temp))
				i_way_force_recompute = vrai
				
			// La ligne droite peut rater des persos à l'arret : donc on regarde un peu sur le cote si on collisionne un mur
			tv_temp1 = OBJ_HorizonGet() * 0.4
			if(!i_way_force_recompute && COL_CollideType(COL_C_Wall) && !GRID_PosValidDyn(OBJ_PosGet() + tv_temp1, tv_temp + tv_temp1))
				i_way_force_recompute = vrai
			if(!i_way_force_recompute && COL_CollideType(COL_C_Wall) && !GRID_PosValidDyn(OBJ_PosGet() - tv_temp1, tv_temp - tv_temp1))
				i_way_force_recompute = vrai
		}
		
		// Si une des cases de notre chemin est occupé, on recalcul le chemin
		if(!i_way_force_recompute)
		{
			ti_cpt = 0
			for(ti_i = i_way_case_nbr - 2; ti_i >= 0; ti_i--)
			{
				ti_cpt++
				if(ti_cpt == 4) break	// Pas la peine de tester tout le chemin, juste le debut
				tv_temp = v_way_case[ti_i] - OBJ_PosGet()
				tv_temp.z = 0
				if(MATH_VecDotProduct(tv_temp, tv_temp) > 4 * 4) break	// Trop loin, on laisse pisser
				ti_capa = GRID_CapaGet(v_way_case[ti_i])
				if(ti_capa & tag_grid_occupe_msk) i_way_force_recompute = vrai
				if(GRID_GetPond(ti_capa & tag_grid_terrain) == 0) i_way_force_recompute = vrai
			}
		}
			
		// On est sur la case désirée
		if (MATH_VecNullEpsilon(tv_way_temp - GRID_PosGet(v_way_currentpos)))
		{
			if(!i_way_force_recompute) 
			{
				i_way_case_nbr--
				v_way_case_dest = v_way_case[i_way_case_nbr - 1]
			}
		}
	}
	
	if(i_way_force_recompute)
	{
		// Gestion d'erreur sur le point de dest (il doit etre libre d'acces)
		tv_dest_pos_temp = GRID_ComputeDest(v_way_destpos, i_way_algo_limitdestpos)
		if (MATH_VecNull(tv_dest_pos_temp))
		{
			i_way_destpos_error = vrai															// Pas de solutions (je peux pas m'en sortir)
			i_way_moving = faux																	// Donc je m'arrete
			ti_exit = vrai																				// J'arrete l'exec de cette fonction
		}
		else
			i_way_destpos_error = faux															// Cool j'ai une solution j'y go !
			
		if (!ti_exit)
		{
			tv_temp = tv_dest_pos_temp - v_way_currentpos
			tf_temp = MATH_VecNorm(tv_temp)
			ti_temp = (tf_temp + (tf_temp * 0.5))
			if(ti_temp < 15) ti_temp = 15
			if(ti_temp < 10) ti_temp = 10
			if(ti_temp > 99) ti_temp = 99
			f_way_len_big = ti_temp

			// Taille carré de recherche
			if(!f_way_len_big) tf_lenbig = 20
			else tf_lenbig = f_way_len_big
			f_way_len_big = 0

			// Tableau des cases
			// Pos depart
			// Pos arrivé
			// ??? Nib !
			// Distance a partir de laquelle le destpos est testé occupé
			// Nbr de case max a partir dequelle la fonction de recherche de chemin abort
			// Taille de la demi longueur de la zone a ne jamais depassé (carré)
			// Nbr d'éléments max a retourner
			tf_born = 4
			tv_temp = v_way_currentpos
			if(GRID_Blocked(tv_temp, vrai)) 
				tv_temp = GRID_FreeCurPos(v_way_currentpos, tv_dest_pos_temp)
				
			if(MATH_VecNullEpsilon(GRID_PosGet(tv_temp) - GRID_PosGet(tv_dest_pos_temp)))
			{
				v_way_case[0] = GRID_PosGet(tv_temp)
				v_way_case[1] = GRID_PosGet(tv_dest_pos_temp)
				i_way_case_nbr = 2
			}
			else
			{
				i_way_case_nbr = GRID_ShortWay(v_way_case[0],tv_temp, tv_dest_pos_temp, tf_born, i_way_algo_limitdestpos, tf_lenbig, 99)	// Chemin
			}
			
			// Nbre de cases max autorisées (si trop élevée par rapport au déplacement réel, on annule
			if(i_way_case_nbr > ti_temp) i_way_case_nbr = 0
					
//			if(1)
//			{
//				int i
//				for(i = 0; i < i_way_case_nbr; i++) 
//				{
//					v_way_case[i].z = OBJ_PosGet().z
//					DBG_RenderVector(v_way_case[i], Cv_VerticalVector, 255)
//				}
//			}
			
			// ######################################################################
	
			if (i_way_case_nbr >= 2)
			{
				// On ne recalcul pas le chemin
				i_way_force_recompute = faux
				
				// Calcule de la case dest.
				v_way_case_dest = v_way_case[i_way_case_nbr -2]
	
				// Ok on se deplace sur le chemin grille
				tv_way_temp = v_way_case_dest - v_way_currentpos
				tv_way_temp.z = 0
				v_way_sight = MATH_VecBlendRotate(OBJ_SightGet(), MATH_VecNormalize(tv_way_temp), f_way_blendrotate* DT_30 )
			}
			else
			{
				// ERREUR: Pas de deplacements possibles (pas assez de case pour le déplacement)
				i_way_case_nbr = 0
	
				// On n'altere pas la visée car on n'a pas mieux.
				v_way_sight = OBJ_SightGet()
	
				// Il faut recalculer un chemin...
				i_way_force_recompute = vrai
	
				// On arrete le deplacement si on est arrivé
				i_way_moving = faux
			}
		}
	}
	else
	{
		// Orientation
		tv_way_temp = v_way_case_dest - v_way_currentpos
		tv_way_temp.z = 0
		v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_way_temp), f_way_blendrotate * DT_30)
//			if(1)
//			{
//				int i
//				for(i = 0; i < i_way_case_nbr; i++) 
//				{
//					v_way_case[i].z = OBJ_PosGet().z
//					DBG_RenderVector(v_way_case[i], Cv_VerticalVector, 255)
//				}
//			}
	}
}
else
{
	// ############
	// SANS GRILLE
	// ############

	tv_way_temp = v_way_destpos - v_way_currentpos
	tv_way_temp.z = 0
	if (!MATH_VecNullToler(tv_way_temp, 0.5))
	{
		// Je me deplace...
		v_way_sight = MATH_VecBlendRotate(OBJ_SightGet(), MATH_VecNormalize(tv_way_temp) , f_way_blendrotate * DT_30)
	}
	else
	{
		// Je suis a moins de 0.5m de ma destination... donc je m'arrete !
		i_way_force_recompute = vrai
		i_way_moving = faux
	}
}