#include "H_defines.var"

int				ti_i, ti_j, ti_danger
int				ti_rank
float			tf_dist
float			tf_best_dist, tf_best_dist_dangereux
float			tf_a, tf_b, tf_dot
vector		tv_temp, tv_temp1, tv_temp2, tv_temp3, tv_temp4, tv_temp5
object		to_wp
messageid EVT_ID
object		EVT_Pere
object		to_last_hide
vector		tv_new_pos
float			tf_temp
int				ti_cache_ok
int				ti_type_cache
int				ti_state
object		to_obj
object		to_wp_dangereux
int				ti_type_cache_dangereux
vector		tv_new_pos_dangereux
vector		tv_pos_cache_occ, tv_A, tv_B
vector		tv_pos_cache
vector		tv_atmp[10]
float			tf_atmp[10]
object		to_temp
int				ti_type
float			tf_size
float			af_dist[50]
int				ti_cpt_ao
int				ti_fonce
int				ie, ti_numero
int				ti_temp

o_hide_0D_dangereux = nobody
i_found_cache = 0

// Objet par rapport à qui on cherche une cache
if(!o_ref_cache_0D) o_ref_cache_0D = OBJ_Me()

// Reset occupation de la cache courante
if(o_hide_0D && @o_hide_0D OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
	o_hide_0D.des_int2 = o_hide_0D.des_int2 - 1
to_last_hide = o_hide_0D 
o_hide_0D = nobody

tf_best_dist_dangereux = Cf_Infinit
tf_best_dist = Cf_Infinit
tv_new_pos = Cv_NullVector
tv_new_pos_dangereux = Cv_NullVector
to_wp_dangereux = nobody


/// TRI en fonction de la distance ///////////////////////////
for (ti_i = 0; ti_i < @get_list_manager i_hide_0D_wp_nb; ti_i++)
{
	to_wp = @get_list_manager ao_hide_0D_wp[ti_i]
	af_dist[ti_i] = OBJ_SqrDistHorz(to_wp)
}

to_wp_dangereux = nobody
ARR_LIB_Gao_QuickSort_Order(&@get_list_manager ao_hide_0D_wp[0], &af_dist[0], @get_list_manager i_hide_0D_wp_nb)
to_wp_dangereux = nobody
ti_cpt_ao = 0
///////////////////////////////////////////////

for (ti_i = 0; ti_i < @get_list_manager i_hide_0D_wp_nb; ti_i++)
{
	ti_cache_ok = vrai
	
	// Une itération, et cache privilégiée : on sort
	if(ti_i && o_in_cache_0D)
	{
		o_in_cache_0D = nobody
		break
	}
	
	// Cache particulière a checker ?
	if(o_in_cache_0D)
		to_wp = o_in_cache_0D
	else
	{
		to_wp = @get_list_manager ao_hide_0D_wp[ti_i]
		if(to_wp == to_last_hide) continue
	}
	
	// Cache sectorisée
	if(!@to_wp SCT_ObjVisible()) continue
	
	// Cache interdite
	if(@to_wp OBJ_CapaTest(OBJ_Capa_0)) continue
	
	// Cache qui crame
	if(CaseEnFeu(@to_wp OBJ_PosGet())) continue
	
	// Cache complete ?
	if(@to_wp OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
	{
		if(to_wp.des_int1 && to_wp.des_int1 == to_wp.des_int2) continue
	}
	
	// Cache trop loingue de moi meme
	tv_temp = @to_wp OBJ_PosGet() - @o_ref_cache_0D OBJ_PosGet()
	tv_temp.z = 0
//	if(MATH_VecDotProduct(tv_temp, tv_temp) > 40 * 40) continue	
	if(f_cherche_cache_max_dist && MATH_VecDotProduct(tv_temp, tv_temp) > f_cherche_cache_max_dist * f_cherche_cache_max_dist) continue
	
	// Une cache eventuelle en plus
	i_found_cache++
	
	// Calcul d'une position liée a cette cache, en fonction du type de cache
	ti_type_cache = 0
	if(@to_wp OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
		ti_type_cache = to_wp.des_int3
	
	if(@to_wp AI_IsModel("Progression/PRG_CacheSafe"))
	{
		switch(i_id_humain)
		{
			case C_ID_Ann : 			
				if(!@"Progression/PRG_CacheSafe" to_wp des_i_accept_ann) continue
				break
			case C_ID_Hayes : 		
				if(!@"Progression/PRG_CacheSafe" to_wp des_i_accept_hayes) continue
				break
			case C_ID_Jimmy : 		
				if(!@"Progression/PRG_CacheSafe" to_wp des_i_accept_jimmy) continue
				break
			case C_ID_Denham : 	
				if(!@"Progression/PRG_CacheSafe" to_wp des_i_accept_denham) continue
				break
			case C_ID_Indigene1 :
			case C_ID_Indigene2 :
			case C_ID_Indigene3 :
			case C_ID_Indigene4 :
			case C_ID_Indigene5 :
				if(!@"Progression/PRG_CacheSafe" to_wp des_i_accept_indigene) continue
				break
		}		
	}
		
	ao_all_caches[ti_cpt_ao] = to_wp
	ti_cpt_ao++
	
	// Cache de destination. La position se trouve dans la BV
	//////////////////////////////////////////////////////////////////////////////////
	if((ti_type_cache & 0xFF) == C_Cache_Surface)
	{
		tv_temp1 = Cv_NullVector
		ti_fonce = faux
		if(@to_wp AI_IsModel("Progression/PRG_CacheSafe"))
		{
			if(@"Progression/PRG_CacheSafe" to_wp des_i_fonce_vers_moi) ti_fonce = vrai
			
			if(f_time_hide_0D > TIME_MODE_HIDE + i_rand_move_cache)
			{
				i_rand_move_cache = MATH_RandInt(0, 6)
				f_time_hide_0D = 0
				ti_temp = MATH_RandInt(0, 3)
				if(ti_temp == mi_numero_hide)
				{
					mi_numero_hide++
					if(mi_numero_hide == 3) mi_numero_hide = 0
				}
				else
				{
					mi_numero_hide = ti_temp
				}
			}
		
			to_temp = nobody
			switch(i_id_humain)
			{
				case C_ID_Ann : 
					switch(mi_numero_hide)
					{
						case 0:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_ann break
						case 1:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_ann1 break
						case 2:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_ann2 break
					}
					
					if(!to_temp) to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_ann
					break
				case C_ID_Hayes : 		
					switch(mi_numero_hide)
					{
						case 0:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_hayes break
						case 1:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_hayes1 break
						case 2:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_hayes2 break
					}
					
					if(!to_temp) to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_hayes
					break
				case C_ID_Jimmy : 		
					switch(mi_numero_hide)
					{
						case 0:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_jimmy break
						case 1:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_jimmy1 break
						case 2:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_jimmy2 break
					}
					
					if(!to_temp) to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_jimmy
					break
				case C_ID_Denham : 	
					switch(mi_numero_hide)
					{
						case 0:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_denham break
						case 1:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_denham1 break
						case 2:	to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_denham2 break
					}
					
					if(!to_temp) to_temp = @"Progression/PRG_CacheSafe" to_wp des_pos_denham
					break
			}
			
			if(to_temp) tv_temp1 = @to_temp OBJ_PosGet()
		}
		
		// Répartition automatique
		if(MATH_VecNull(tv_temp1))
		{
			tv_A = @to_wp BV_MaxGet()
			tv_B = @to_wp BV_MinGet()
			tv_A -= tv_B
			tv_A.z = 0
			switch(i_id_humain)
			{
				case C_ID_Hayes :		tv_A *= 0.3 break
				case C_ID_Ann :			tv_A *= 0.75 break
				case C_ID_Denham :	tv_A *= 0.1 break
				default:						tv_A *= 0.5 break
			}
			
			tv_A += @to_wp BV_MinGet()
			tv_A += @to_wp OBJ_PosGet()
			tv_temp1 = tv_A
			tv_temp1.z = @to_wp OBJ_PosGet().z
		}
	
		// Ponderation
		tf_dist = HL_PondCache(tv_temp1, to_wp)		
		if(!ti_fonce)
		{
			if(tf_dist < tf_best_dist_dangereux)
			{
				if(HL_PosDangereuse(tv_temp1)) continue
				to_wp_dangereux = to_wp
				ti_type_cache_dangereux = ti_type_cache
				tv_new_pos_dangereux = tv_temp1
				tf_best_dist_dangereux = tf_dist
			}
		}
		
		if(!i_cherche_cache_dangereux && tf_dist < tf_best_dist)
		{		
			// Cache dangereuse ?
			// On ne fait le test que ici, car si toutes les caches sont dangereuses, il va bien
			// falloir quand meme essayer de bouger (a condition que i_ch_cache_dangereux soit vrai)
			if(!ti_fonce)
			{
				ti_danger = HL_CheminDangereux(tv_temp1)
				if(ti_danger) continue	
			}
			
			tv_new_pos = tv_temp1
			tf_best_dist = tf_dist 
			o_hide_0D = to_wp				
			i_cache_surface = ti_type_cache
		}
	}
	
	// Calcul d'une position libre dans la direction en question (cache d'occlusion)	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	else
	{
		// La position de demarrage de l'occlusion depend de la BV, et de l'id de l'humain
		tv_pos_cache_occ = @to_wp OBJ_PosGet()
		tv_A = @to_wp BV_MaxGet()
		tv_B = @to_wp BV_MinGet()
		tv_A -= tv_B
		tv_A.z = 0
		
		tv_temp4 = tv_A	// Memo diagonale BV

		if(i_id_humain == C_ID_Hayes)
		{
			tv_atmp[0] = (tv_A * 0) + @to_wp BV_MinGet() + @to_wp OBJ_PosGet()
			tv_atmp[1] = (tv_A * 0.5) + @to_wp BV_MinGet() + @to_wp OBJ_PosGet()
			tv_atmp[2] = (tv_A * 1) + @to_wp BV_MinGet() + @to_wp OBJ_PosGet()
			tv_atmp[0] = MATH_VecNormalize(tv_atmp[0] - @get_camera OBJ_PosGet())
			tv_atmp[1] = MATH_VecNormalize(tv_atmp[1] - @get_camera OBJ_PosGet())
			tv_atmp[2] = MATH_VecNormalize(tv_atmp[2] - @get_camera OBJ_PosGet())
			tf_atmp[0] = MATH_VecDotProduct(@get_camera OBJ_SightGet(), tv_atmp[0])
			tf_atmp[1] = MATH_VecDotProduct(@get_camera OBJ_SightGet(), tv_atmp[1])
			tf_atmp[2] = MATH_VecDotProduct(@get_camera OBJ_SightGet(), tv_atmp[2])
			if(tf_atmp[0] > tf_atmp[1] && tf_atmp[0] > tf_atmp[2])
				tv_A *= 0
			else if(tf_atmp[1] > tf_atmp[0] && tf_atmp[1] > tf_atmp[2])
				tv_A *= 0.5
			else
				tv_A *= 1
		}
		else switch(to_wp.des_int2)
		{
			case 0 :		tv_A *= 0.25 break
			case 1 :		tv_A *= 0.75 break
			case 2 :		tv_A *= 0.5 break
			case 3 :		tv_A *= 0 break
		}
		
		tv_A += @to_wp BV_MinGet()
		tv_A += @to_wp OBJ_PosGet()
		tv_pos_cache_occ = tv_A
		// Calcul d'une direction de cache par rapport à tous les ennemis
		tv_temp = Cv_NullVector
		tv_temp2 = Cv_NullVector
		ti_rank = -1
		EVT_Pere = nobody
		for(ie = 0; ie < ai_AllEnemy; ie++)
		{
			EVT_ID = ao_AllEnemy[ie]
			if(!MSG_GlobalIsValid(EVT_ID)) continue
			EVT_Pere = EVENT_PereGet(EVT_ID)
			ti_state = EVENT_EnemyStateGet( EVT_ID )
			ti_type = EVENT_EnemyTypeGet( EVT_ID )
			if (ti_state == C_EVENT_EnemyState_Fight || ti_state == C_EVENT_EnemyState_Wait || ti_state == C_EVENT_EnemyState_Neutral)
			{
				EVT_Pere = EVENT_PereGet(EVT_ID)
				tv_temp1 = tv_pos_cache_occ - @EVT_Pere OBJ_PosGet()
				tf_dist = MATH_VecNorm(tv_temp1)
				MATH_VecSetNormalize(tv_temp1)
				tv_temp2 += tv_temp1				
						
				if(tf_dist > @"univ" Enemy_af_ReaDist[ ti_type] [ C_EnemyDist_Stress ]) 
					tv_temp1 *= 0
				else if(tf_dist > @"univ" Enemy_af_ReaDist[ ti_type] [ C_EnemyDist_Fight ]) 
					tv_temp1 *= 0.3
				else if(tf_dist > @"univ" Enemy_af_ReaDist[ ti_type] [ C_EnemyDist_Fear ]) 
					tv_temp1 *= 0.6
				tv_temp1 *= @"univ" Enemy_af_Danger[ti_type]
				tv_temp += tv_temp1
			}		
		}
		
		if(!ti_cache_ok) continue
		if(MATH_VecNullEpsilon(tv_temp)) tv_temp = tv_temp2
		
		if(MATH_VecNullEpsilon(tv_temp)) continue
		MATH_VecSetHorzNormalize(tv_temp)
		
		// On annule la cache si on est sur la tranche la plus petite de la BV
		tv_temp5 = tv_temp
//		MATH_VecSetHorzNormalize(tv_temp4)	
//		MATH_VecSetHorzNormalize(tv_temp5)	
//		tf_dot = MATH_AbsFloat(MATH_VecDotProduct(tv_temp4, tv_temp5))
//		if(tf_dot > 0.8) 	continue
		
		// Calcul d'une position libre dans cette direction
		tv_temp2 = tv_temp
		tv_temp1 = GRID_ScaleVectorToFitWithRectBorder( to_wp, tv_pos_cache_occ, tv_temp )
		tv_pos_cache_occ += tv_temp1
		tv_pos_cache_occ += (tv_temp * 0.2)
		DBG_RenderVector(tv_pos_cache_occ + cvector(0,0,2), tv_temp * 10, 0xFFFF0000)
					
		// Recherche une pos libre
		tf_dist = HL_PondCache(tv_pos_cache_occ, to_wp)
		if
		(
			(tf_dist < tf_best_dist_dangereux)
		|| 	((tf_dist < tf_best_dist) && !i_cherche_cache_dangereux)
		)
		{
			for(ti_j = 0; ti_j < 4; ti_j++)
			{
				DBG_RenderVector(tv_pos_cache_occ, cvector(0,0,10), 0xFFFF00FF)
				
				if(GRID_Blocked(tv_pos_cache_occ, faux)) break	// Si mur, alors (coin ?), on zap cette cache				
				if(!GRID_Blocked(tv_pos_cache_occ, vrai))
				{	
					// Ponderation
					tf_dist = HL_PondCache(tv_pos_cache_occ, to_wp)				
									
					if(tf_dist < tf_best_dist_dangereux)
					{
						if(!HL_PosDangereuse(tv_pos_cache_occ))
						{
							to_wp_dangereux = to_wp
							ti_type_cache_dangereux = ti_type_cache
							tv_new_pos_dangereux = tv_pos_cache_occ
							tf_best_dist_dangereux = tf_dist
						}
					}
					
					if(!i_cherche_cache_dangereux && tf_dist < tf_best_dist)
					{			
						// Cache dangereuse ?
						// On ne fait le test que ici, car si toutes les caches sont dangereuses, il va bien
						// falloir quand meme essayer de bouger (a condition que i_cherche_cache_dangereux soit vrai)
						if(!HL_PosDangereuse(tv_pos_cache_occ))
						{
							ti_danger = HL_CheminDangereux(tv_pos_cache_occ)						
							if(!ti_danger)	
							{
								tv_new_pos = tv_pos_cache_occ
								tf_best_dist = tf_dist 
								o_hide_0D = to_wp				
								i_cache_surface = ti_type_cache
							}
						}
					}
					
					break
				}
				
				tv_pos_cache_occ += tv_temp2
			}	
		}
	}
}

// Ajout occupation de la cache courante
v_pos_fuite = tv_new_pos
if(o_hide_0D && @o_hide_0D OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
	o_hide_0D.des_int2 = o_hide_0D.des_int2 + 1
	
// Je n'ai trouvé aucune cache, mais j'ai le droit de trouver une cache dangereux, 
// alors je prend la cache dangereuse trouvée
if((!o_hide_0D && i_cherche_cache_dangereux) && to_wp_dangereux)
{
	o_hide_0D = to_wp_dangereux
	v_pos_fuite = tv_new_pos_dangereux
	i_cache_surface = ti_type_cache_dangereux
	if( @o_hide_0D OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
		o_hide_0D.des_int2 = o_hide_0D.des_int2 + 1
}

i_cherche_cache_dangereux = faux
i_cherche_cache_visible = faux
o_ref_cache_0D = nobody

o_memo_wp_dangereux = to_wp_dangereux
i_memo_type_cache_dangereux = ti_type_cache_dangereux
v_memo_pos_dangereux = tv_new_pos_dangereux

