#include "H_defines.var"

vector		tv_dest_pos
vector		tv_target, tv_temp, tv_temp1, tv_temp2
object		to_nearest_cible
object		to_nearest_me
int				ti_num
object		to_obj, to_obj1
object		ao_obj[100]
float			tf_dot, tf_temp
int				ti_i, ti_capa, ti_smooth, ti_cpt, ti_block
int				failed, ti_direct, ti_directway
int				ti_exact_way

f_way_blendrotate = 1000

//--------( init )----------------------------------------------------------------------------------
way_i_climb = 0
way_real_pos = v_way_destpos

// Hack : si on veut aller sur une case jaune, on y va direct sans grille (si deja proche)
if(GRID_Blocked(v_way_destpos, vrai) || GRID_Blocked(OBJ_PosGet(), faux))
{
	if(!COL_CollideType(COL_C_Wall))
	{
		tv_temp = v_way_destpos - OBJ_PosGet()
		if(MATH_VecNorm(tv_temp) < 2.0)
		{
			if(GRID_PosGet(v_way_destpos) != GRID_PosGet(OBJ_PosGet()))
			{
				v_way_case_dest = v_way_destpos 
				tv_temp = v_way_case_dest - OBJ_PosGet()
				tv_temp.z = 0
				v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_temp), f_way_blendrotate * DT_30)
				i_way_moving = vrai
				return
			}
		}
	}
}
		
i_way_algo_limitdestpos = 60
f_way_len_big = 60

v_way_currentpos = OBJ_PosGet()
tv_dest_pos = GRID_PosGet(v_way_destpos)
i_way_moving = vrai

// Aide reseau (longues distances) ??
//DBG_StartRaster(6, "WAY")
tv_target = WAY_Compute(v_way_destpos, ti_direct, ti_exact_way)
//DBG_StopRaster(6)

// Force calcul grille ?
if(MATH_VecNullEpsilon(GRID_PosGet(v_way_case_dest) - GRID_PosGet(OBJ_PosGet())))
{
	if(i_way_case_nbr < 2)
		i_way_force_recompute = vrai
}

if (!MATH_VecNullEpsilon(GRID_PosGet(tv_target) - GRID_PosGet(v_way_last_destpos)))
{
	i_way_force_recompute = vrai
}

v_way_last_destpos = tv_target
v_way_destpos = tv_target
if(MATH_VecNullEpsilon(v_way_destpos - OBJ_PosGet()))
{
	i_way_moving = faux
	return
}

if(ti_exact_way)
{
	v_way_case_dest = tv_target
	tv_temp = v_way_case_dest - OBJ_PosGet()
	if(!MATH_VecNull(tv_temp))
		v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_temp), f_way_blendrotate * DT_30)
	return
}

// Si on peut y aller en ligne droite, on ne test meme pas la grille
if(!ti_direct)
{
	tv_temp = Cv_NullVector
	if(PeutSimplifierLeReseau())
	{
		GRID_EliminateHumains()
		tv_temp = v_way_destpos - OBJ_PosGet()
		MATH_VecSetNorm(tv_temp, MATH_FloatMin(MATH_VecNorm(tv_temp), 6))
		tv_temp += OBJ_PosGet()
		tv_temp = GRID_PosValidSimplifie(OBJ_PosGet(), tv_temp, vrai)
		GRID_RestoreHumains()
	}
}
else
	tv_temp = tv_target
if(!MATH_VecNull(tv_temp))
{
	v_way_case_dest = v_way_destpos
	tv_temp = v_way_case_dest - OBJ_PosGet()
	tv_temp.z = 0
	if(MATH_VecNullEpsilon(tv_temp))
		v_way_sight = OBJ_SightGet()
	else
		v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_temp), f_way_blendrotate * DT_30)
}
else
{
	tv_temp = GRID_ComputeDest(v_way_destpos, i_way_algo_limitdestpos)
	if(!MATH_VecNull(tv_temp)) v_way_destpos = tv_temp
	GRID_EliminateHumains()
	AI_Execute("H_exec_way_compute")
	GRID_RestoreHumains()
	
	// Echec ?
	if(!i_way_case_nbr && MATH_VecNorm(v_way_destpos - OBJ_PosGet()) > 1)
	{
		f_time_fail_move = 2.0
	}
}

// Simplification du chemin grille
ti_smooth = faux
ti_cpt = 0
GRID_EliminateHumains()
for(ti_i = i_way_case_nbr - 2; ti_i >= 0; ti_i--)
{
	if(ti_cpt >= 6) break
	ti_cpt++
	tv_temp1 = v_way_case[ti_i]
	tv_temp = OBJ_PosGet() + cvector(0, 0, 1.0)
	tv_temp1.z = tv_temp.z

	tv_temp = GRID_PosValidSimplifie(OBJ_PosGet(), tv_temp1, vrai)
	if(!MATH_VecNull(tv_temp))
	{
		ti_smooth = vrai
		i_way_case_nbr--
		v_way_case_dest = v_way_case[ti_i] //+ v_pos_decalage
		if(GRID_Blocked(v_way_case_dest, vrai)) v_way_case_dest = v_way_case[ti_i]	
	}
	else
		break
}	

GRID_RestoreHumains()

// Orientation
if(ti_smooth)
{
	tv_temp = v_way_case_dest - OBJ_PosGet()
	tv_temp.z = 0
	v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_temp), f_way_blendrotate * DT_30)
}


// Glissing sur mur
//if(COL_CollideType(COL_C_Wall))
//{
//	tv_temp = v_way_case_dest - OBJ_PosGet()
//	tv_temp.z = 0
//	if(!MATH_VecNullEpsilon(tv_temp))
//	{
//		tv_temp1 = COL_NormalGet(COL_C_Wall)
//		if(MATH_VecDotProduct(tv_temp, tv_temp1) < 0)
//		{
//			MATH_VecSetHorzNormalize(tv_temp)
//			tv_temp1 = COL_NormalGet(COL_C_Wall)
//			MATH_VecSetHorzNormalize(tv_temp1)
//			
//			tv_temp = MATH_VecCrossProduct(tv_temp, tv_temp1)
//			tv_temp = -MATH_VecCrossProduct(tv_temp, tv_temp1)
//			DBG_RenderVector(OBJ_PosGet() + cvector(0,0,2),tv_temp,0xFF00FF)
//			v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_temp), f_way_blendrotate * DT_30)	
//		}
//	}
//}