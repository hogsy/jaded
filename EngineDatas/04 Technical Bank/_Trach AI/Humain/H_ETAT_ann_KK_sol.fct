#include "H_defines.var"

#define			Cf_dist_min_detect_fight_actor					400.0
#define			Cf_dist_min_detect_enemy						100.0
#define			Cf_dist_min_action_fight							100.0

#define			Action_Accroupi										Action_Blesse_Marche1	// pas le même nom Humains/ANN

#define			Cf_toler_arrivee_sur_le_wp							0.3

int					ti_i
int					ti_indice_text
int					ti_context
int					ti_rank
int					ti_flag_gotowp
int					ti_action
int					ti_suivi_regard
int					ti_type_wp

float				tf_dist_max
float				tf_dist
float				tf_dot

object			to_actor
object			to_sight_object
object			to_WP
object			to_tmp
object			to_head

vector			tv_sight
vector			tv_temp

message		tm_msg
message		tm_msg_filter
messageid		EVT_ID

// Résolution locale ==============
int				ti_coll
vector		tav_coll[Ci_max_wall]
vector		tv_sight_perfect
vector		tv_new_sight_init
vector		tv_new_sight_res_loc
float			tf_wp_best_dist
vector		tv_trace_res_loc_screen_pos
int				tai_gmat_flags[Ci_max_wall]

#define macro_init_resolution_locale	\
{\
	tv_temp = @to_WP OBJ_PosGet() - OBJ_PosGet()\
	MATH_VecSetHorzNormalize(tv_temp)\
	to_tmp = @get_global o_ANN_KK_move_dir_wp \
	tf_dot = MATH_VecDotProduct(@to_tmp OBJ_SightGet(), tv_temp)\
	if( i_ANN_KK_moving_collide || OBJ_SqrDist(to_WP) < 9.0 )\
		tv_sight_perfect = @to_WP OBJ_PosGet() - OBJ_PosGet()\
	else\
		tv_sight_perfect = @to_tmp OBJ_SightGet()\
	tv_new_sight_init = MATH_VecBlendRotate(OBJ_SightGet(), tv_sight_perfect, 3 * TIME_GetDt())\
	tv_sight = tv_new_sight_init \
//	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_new_sight_init, color_jaune)\
//	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_sight_perfect, color_vert)\
}


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	
	o_ANN_KK_safe_wp = nobody
	
	MSG_SetNull(msg_pose_ANN)
	@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN	
	DYN_FrictionVectorSet(cvector(1.0, 1.0, 0.0))
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_IA_Ann_au_sol)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_IA_Ann_au_sol

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	fct_main_etat = AI_TrackCurGet()
	
	for (ti_i = 0; ti_i < Ci_LNK_TYPE_NB; ti_i++)
		ai_SRV_ENABLE[ti_i] = faux

	// AUTORISATIONS DES GRABS
	ai_SRV_ENABLE[Ci_LNK_GRAB_RAPTOR]		= vrai
	ai_SRV_ENABLE[Ci_LNK_KKGRAB_OBJECT]	= vrai

	// AUTORISATIONS DES BLOCKS
	ai_SRV_ENABLE[Ci_LNK_BLOCK_RAPTOR]	= vrai

	f_time_start_etat = 0.0
	
	// Si j'étais planqué sur un WP, je libère le WP
	if(o_in_cache_0D) 
	{
		@o_in_cache_0D OBJ_CapaSet(0, Capa_Cache_taken)
		o_in_cache_0D = nobody
	}
	
	@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
	o_fight_actor = nobody
	DYN_FrictionVectorSet(cvector(5.0, 5.0, 5.0))
	
	// Choix du WP -----------------------------------------------------------------------------------------------------------------------
	i_ANN_au_sol_mode = Ci_ANN_au_sol_pas_de_wp		// par défaut, ANN n'a pas d'endroit ou aller
	
	o_ANN_KK_safe_wp = ANN_KK_Choix_du_WP_Safe()		// Choix d'un wp si ANN n'en a pas déjà choisi un
	
	if( o_ANN_KK_safe_wp )
		i_ANN_au_sol_mode = Ci_ANN_au_sol_va_au_wp			// ANN a un WP de destination
	
	i_ANN_KK_moving_collide = faux			// n'a pas encore collisionné de mur en allant au wp (une fois vrai, ANN se dirige vers le wp et plu sselon l'axe de déplacement)
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE =======================================================================================================

AI_Execute("H_exec_read_world")
AI_Execute("H_exec_serveur_get")
AI_Execute("H_exec_change_etat")

if ( MATH_FloatNullEpsilon( @get_global f_time_KK_ANN_avant_la_mort))
{
	AI_Execute("H_exec_ch_Stimulus_Paf")
	if (o_paf_sender) 
		macro_change_etat("H_ETAT_IA_paf")
}

// COMPORTEMENT =======================================================================================================

if( COL_CollideType(COL_C_Ground) )
	i_flag_ANN_au_sol = vrai
else
	i_flag_ANN_au_sol = faux



// Résolution Locale
if( i_res_loc_flag && i_ANN_au_sol_mode != Ci_ANN_au_sol_va_au_wp )
	i_res_loc_flag = faux			// fin de la résolution locale


// TEST : KONG a-t-il déposé ANN au sol ? ==========================================================
//if( msg_pose_ANN.msg_id != 0 )
//	to_WP = msg_pose_ANN.msg_gao1
//else
//	to_WP = nobody
to_WP = o_ANN_KK_safe_wp

// CHECK ENNEMI DIRECT ==========================================================================
switch ( i_ANN_au_sol_mode )
{
	case Ci_ANN_au_sol_sur_le_wp :
	case Ci_ANN_au_sol_pas_de_wp :
	case Ci_ANN_au_sol_fight :
		// ANN fuit jusqu'à ce qu'elle soit à son wp. Une fois au wp elle se retourne pour se défendre
		MSG_SetNull(tm_msg_filter)
		tm_msg_filter.msg_gao1 = OBJ_Me()
		if( ( ! o_fight_actor ) || ( o_fight_actor && (f_fight_ann_target_maj > 0.25) ) )
		{
			// Pas d'ennemi ou ennemi updaté il y a plus de 1.5 sec
			o_fight_actor = nobody
			f_fight_ann_target_maj = 0.0
			
			tf_dist_max = Cf_Infinit
			tf_dist = Cf_Infinit
			ti_rank = -1
			for( 	EVT_ID = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Interet, &ti_rank, tm_msg_filter);
					MSG_GlobalIsValid(EVT_ID);
					EVT_ID = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Interet, &ti_rank, tm_msg_filter) )
			{
				to_actor = MSG_GlobalGetSender(EVT_ID)
				tf_dist = OBJ_SqrDist(to_actor)
				if( (tf_dist < tf_dist_max) && (tf_dist <= Cf_dist_min_detect_fight_actor) )
				{
					// plus proche que l'ancien mais suffisamment proche tout de même
//					if( i_ANN_au_sol_mode != Ci_ANN_au_sol_fight )
//						i_request_txt = Gene_C_caught			// 1er ennemi -> aaaaaahh !!!
					o_fight_actor = to_actor
					tf_dist_max = tf_dist
					i_ANN_au_sol_mode = Ci_ANN_au_sol_fight
				}
			}
		}
		else
			f_fight_ann_target_maj += TIME_GetDt()
	break
	default:
		o_fight_actor = nobody
	break
}


// CHECK ENNEMI PROCHE ==========================================================================
// NOTE : la différence est que ANN ne passe pas en mode Ci_ANN_au_sol_fight, 
// ce test sert à jouer l'anim terrorisé sans être en combat (et donc le timer est stoppé)
if( i_ANN_au_sol_mode != Ci_ANN_au_sol_fight )
{
	o_fight_actor = nobody
	tf_dist_max = Cf_Infinit
	tf_dist = Cf_Infinit
	ti_rank = -1
	for( 	EVT_ID = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank);
			MSG_GlobalIsValid(EVT_ID);
			EVT_ID = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank) )
	{
		to_actor = MSG_GlobalGetSender(EVT_ID)
		tf_dist = OBJ_SqrDist(to_actor)
		if( (tf_dist < tf_dist_max) && (tf_dist <= Cf_dist_min_detect_enemy) )
		{
			// plus proche que l'ancien mais suffisamment proche tout de même
			o_fight_actor = to_actor
			tf_dist_max = tf_dist
		}
	}
}

// COMPORTEMENT ==========================================================================
to_sight_object = nobody

switch ( i_ANN_au_sol_mode )
{
	case Ci_ANN_au_sol_fight :
		if( ! o_fight_actor )
		{
			// orientation
//			tv_sight = OBJ_SightGet()
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KK_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_KK_actor
			
			// action
//			if( tf_life_ratio > Cf_Life_Blesse )
////				ti_action = Action_Normal_Attente
//				ti_action = Action_Accroupi		// assis
//			else
//				ti_action = Action_Blesse_Attente
			ti_action = Action_Accroupi
			
			// Combat terminé
			i_cine_ANN_attack_played = faux		// autorise un nouveau cut scene
			
			if( to_WP )
			{
				// KONG a déposé ANN près d'un WP
				tv_temp = @to_WP OBJ_PosGet() - OBJ_PosGet()
				tv_temp.z = 0.0
				tf_dist = MATH_VecNorm(tv_temp)
				if( MATH_FloatNullToler(tf_dist, Cf_toler_arrivee_sur_le_wp) )
					i_ANN_au_sol_mode = Ci_ANN_au_sol_sur_le_wp
				else
					i_ANN_au_sol_mode = Ci_ANN_au_sol_va_au_wp
			}
			else
				i_ANN_au_sol_mode = Ci_ANN_au_sol_pas_de_wp
		}
		else
		{
			// Combat en cours
			
			// orientation
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_fight_actor
			
			// action
			if (  OBJ_SqrDist( o_fight_actor) < 100.0)
			{
				// Timer avant la mort
				@get_global f_time_KK_ANN_avant_la_mort -= MATH_FloatMin( @get_global f_time_KK_ANN_avant_la_mort, TIME_GetDt())
			 	if ( @get_global f_time_KK_ANN_avant_la_mort  <= 0)
			 	{
				 	@get_global f_time_KK_ANN_avant_la_mort = 0.0
					tm_msg.msg_id = msg_id_KK_Tue_ANN
					tm_msg.msg_sender = OBJ_Me()
					@o_fight_actor MSG_Send( tm_msg)
					ti_indice_text = STR_CreateText("\h0.1\",cvector( 0.5, 0.1, 0.0), 0)	
					STR_AppendText( ti_indice_text, "TOO LATE")
				}
				else
				{
					ti_indice_text = STR_CreateText("\jxy\ \h",cvector( 0.5, 0.1, 0.0), 0)	
					STR_AppendFloat( ti_indice_text, 0.04 + ( ( 1.0 - (@get_global f_time_KK_ANN_avant_la_mort / 15.0)) * 0.06),3)
					STR_AppendText( ti_indice_text, "\")
					STR_AppendFloat( ti_indice_text, @get_global f_time_KK_ANN_avant_la_mort, 1)
				}
			}
			if ( OBJ_SqrDist( o_fight_actor) < Cf_dist_min_action_fight )
				ti_action = Action_Terrorise_Attente 	//Action_Ann_Attaque_defense
			else 
				ti_action = Action_Accroupi
//			if( tf_life_ratio > Cf_Life_Blesse )
////				ti_action = Action_Normal_Attente
//			ti_action = Action_Accroupi		// assis
//			else
//				ti_action = Action_Blesse_Attente
			
			if( ( ! i_cine_ANN_attack_played ) && ( f_time_start_etat > 2.0 ) )
			{
				// Cut scene pas encore jouée
				i_cine_ANN_attack_played = vrai
				
				// ANN CRIE
				i_request_txt = Gene_C_help
//				Str_DisplayTextOnce("\c000000FF\KOOOOONG A L'AIIIIIIIIDE !!!", cvector(0, 0.5, 0))
				f_time_start_etat = 0.0
				
				// CUT SCENE
				// Kcamera_Insert_Plan( float Kcamera_duration, vector Kcamera_axis, float Kcamera_dist, object Kcamera_target, int Kcamera_module , vector Kcamera_offset, float Kcamera_transpeed, int Kcamera_flags)
				tv_temp = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
				tv_temp.z = 0.0
				tv_temp = MATH_VecBlendRotate(tv_temp, Cv_VerticalVector, 0.2)
//				Kcamera_Insert_Plan(4.0, tv_temp, 2.0, OBJ_Me(), -1, cvector(0.5, 0.0, 1.5), 0.0, 0b0)
			}
//			else
//			{
//				// Cut scene déjà jouée
//				if( f_time_start_etat <= 2.0 )
//					Str_DisplayTextOnce("\c000000FF\KOOOOONG A L'AIIIIIIIIDE !!!", cvector(0, 0.5, 0))
//			}
		}
		break
		
	case Ci_ANN_au_sol_va_au_wp :
		// orientation
		macro_init_resolution_locale
		RES_LOC_LIB_Collision(tv_sight_perfect, ti_coll, &tav_coll[0], &tai_gmat_flags[0] )
		if( ( ! i_res_loc_flag && ti_coll )
			|| ( i_res_loc_flag && ! ti_coll ) )
		{
			// on n'est pas encore en résolution locale et une collision est détectée
			// OU on est en résolution locale et aucune collision n'est détectée
			// => début ou fin de la résolution locale => on checke si le meilleur wp safe n'a pas changé
			i_ANN_KK_moving_collide = vrai
			o_ANN_KK_safe_wp = ANN_KK_Choix_du_WP_Safe()
			to_WP = o_ANN_KK_safe_wp
			macro_init_resolution_locale
		}
		i_res_loc_flag = RES_LOC_LIB_Proceed_Resolution_Locale(vrai, faux, 0.0, 0.0, tv_sight_perfect, tv_new_sight_init, tv_new_sight_res_loc, i_res_loc_force_on, f_res_loc_force_sens)
		if( i_res_loc_flag )
		{
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight_res_loc, 3 * TIME_GetDt())
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_new_sight_res_loc, color_cyan)
		}
		
		// Timer avant la mort
		@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
		
		// action
//		if( tf_life_ratio > Cf_Life_Blesse )
//		{
//			if( OBJ_SqrDist(to_WP) > 9 )
//				ti_action = Action_Normal_Trot
//			else
//				ti_action = Action_Normal_Marche
//		}
//		else
//			ti_action = Action_Blesse_Marche
		
		if( OBJ_SqrDist(to_WP) > 9 )
			ti_action = Action_Normal_Trot
		else
		{
//			if( tf_life_ratio > Cf_Life_Blesse )
				ti_action = Action_Normal_Marche
//			else
//				ti_action = Action_Blesse_Marche
		}
		
		// test wp atteint
		tv_temp = @to_WP OBJ_PosGet() - OBJ_PosGet()
		tv_temp.z = 0.0
		tf_dist = MATH_VecNorm(tv_temp)
//		if( MATH_FloatNullToler(tf_dist, 0.1) && (MATH_VecDotProduct(OBJ_SightGet(), @to_WP OBJ_PosGet() - OBJ_PosGet()) < 0) )
		if( MATH_FloatNullToler(tf_dist, Cf_toler_arrivee_sur_le_wp) )
			i_ANN_au_sol_mode = Ci_ANN_au_sol_sur_le_wp					// WP atteint
		
		// regard
		to_sight_object = to_WP
		
		break
		
	case Ci_ANN_au_sol_sur_le_wp :
		// Timer avant la mort
		@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
		
		if( o_fight_actor )
		{
			// ennemi menaçant (proche de ANN mais ce n'est pas ANN sa cible)
			ti_action = Action_Terrorise_Attente
//			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), - @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
			to_sight_object = o_fight_actor
		}
		else
		{
//			switch( msg_pose_ANN.msg_int1 )
			ti_type_wp = @"Interactive/Interactive_Kong_Pose_Ann" o_ANN_KK_safe_wp i_action_type
			switch( ti_type_wp )
			{
				case Ci_PoseAnn_CacheToi :
					// orientation
					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), - @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
					to_sight_object = o_KK_actor
					
					// action
//					if( tf_life_ratio > Cf_Life_Blesse )
////						ti_action = Action_Normal_Attente
//						ti_action = Action_Accroupi		// assis
//					else
//						ti_action = Action_Blesse_Attente
					ti_action = Action_Accroupi
					break
					
		 		case Ci_PoseAnn_VaBoire :
					if(@"univ" LIFE_HumainEtat[i_id_humain] == Life_ETAT_Agonisant)
			 		{
				 		// ANN blessée
			 			
			 			// orientation
						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
						to_sight_object = to_WP
						
						// action
						ti_action = Action_Ann_SeSoigne
				 		
				 		f_time_start_etat += TIME_GetDt()
						if( f_time_start_etat > 5)
						{
							f_time_start_etat = 0.0
							@"univ" LIFE_HumainEtat[i_id_humain] = Life_ETAT_Conval
						}
					}
					else
					{
						// ANN pas blessée
						
						// orientation
//						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KK_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), - @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
						to_sight_object = o_KK_actor
						
						// action
//						if( tf_life_ratio > Cf_Life_Blesse )
////							ti_action = Action_Normal_Attente
//							ti_action = Action_Accroupi		// assis
//						else
//							ti_action = Action_Blesse_Attente
						ti_action = Action_Accroupi
					}
			 		break
			 		
				case Ci_PoseAnn_VaAgir :
					// orientation
					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
					to_sight_object = to_WP
					
					// action
//					if( tf_life_ratio > Cf_Life_Blesse )
////						ti_action = Action_Normal_Attente
//						ti_action = Action_Accroupi		// assis
//					else
//						ti_action = Action_Blesse_Attente
					ti_action = Action_Accroupi
					break
					
				default:
					DBG_Error("Pose ANN : Type de message inconnu")
					
					// orientation
					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
					to_sight_object = o_KK_actor
					
					// action
//					if( tf_life_ratio > Cf_Life_Blesse )
////						ti_action = Action_Normal_Attente
//						ti_action = Action_Accroupi		// assis
//					else
//						ti_action = Action_Blesse_Attente
					ti_action = Action_Accroupi
					break
			}
		}
		break
		
	case Ci_ANN_au_sol_pas_de_wp :
		if( o_fight_actor )
		{
			// ennemi menaçant (proche de ANN mais ce n'est pas ANN sa cible)
			ti_action = Action_Terrorise_Attente
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_fight_actor
		}
		else
		{
			// orientation	
//			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KK_actor OBJ_PosGet() - OBJ_PosGet(), 1 * TIME_GetDt())
			tv_sight = OBJ_SightGet()
			to_sight_object = o_KK_actor
			
			// Timer avant la mort
			@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
			
			// action
//			if( tf_life_ratio > Cf_Life_Blesse )
////				ti_action = Action_Normal_Attente
//				ti_action = Action_Accroupi		// assis
//			else
//				ti_action = Action_Blesse_Attente
			ti_action = Action_Accroupi
		}
		break
		
	default:
		DBG_Error("ANN KK au sol : sous-mode inconnu")
		break
}

OBJ_BankingGeneralSet(tv_sight, Cv_VerticalVector)
ACT_ActionSet(ti_action)


// SUIVI DU REGARD ==================================================================================

i_flag_suivi_regard = vrai
o_force_regard_time = to_sight_object
v_force_regard_time = Cv_NullVector		// pour que ANN regarde bien la tête
f_force_regard_time = 1.0		// pour cette trame


if( 0 )
{
	if( i_res_loc_flag )
	{
		tv_trace_res_loc_screen_pos = cvector(0,0.85,0)
		Str_DisplayTextOnce("ANN RES LOC", tv_trace_res_loc_screen_pos)
		if( i_res_loc_force_on )
		{
			Str_DisplayTextOnce("Sens Force", tv_trace_res_loc_screen_pos + cvector(0,0.05,0))
			if( f_res_loc_force_sens == 1.0 )
				Str_DisplayTextOnce("Gauche", tv_trace_res_loc_screen_pos + cvector(0,0.1,0))
			else
				Str_DisplayTextOnce("Droite", tv_trace_res_loc_screen_pos + cvector(0,0.1,0))
		}
	}
}

//Str_DisplayGaoOnce(to_sight_object, Cv_NullVector)

// CHECK FORCE CONTOURNE DROITE OU GAUCHE
//if(COL_CollideType(COL_C_Wall) )
//{
//	if( COL_GMAT_FlagsGet(COL_C_Wall) & Gmat_KK_Force_Left )
//		Str_DisplayTextOnce("Force Gauche", cvector(0,0,0))
//	if( COL_GMAT_FlagsGet(COL_C_Wall) & Gmat_KK_Force_Right )
//		Str_DisplayTextOnce("Force Droite", cvector(0,0,0.05))
//}
