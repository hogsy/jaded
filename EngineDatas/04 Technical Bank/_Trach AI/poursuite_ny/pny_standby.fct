object			to_close
vector			tv_temp
float				f_dist
int					i, ti_mode  

//////////////////////////////////////////////////////////////////////////////////////////////////////
////////// POSITIONNEMENT DE LA TARGET EN STANDBY////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////

f_time_alert = 0			// A pu d'alerte ... donc reset de la durée depuis laquelle je suis en alerte
f_time_last_tir = 0		// J'annule la date de mon dernier shoot
f_time_tir = 0				// J'arrete de tirer comme un con .. je suis en stand-by

// Mode Stand-by .. je change la couleur de mon halo et de mon spot
GFX_Seti(i_idhalo, 21101, color_standby) 
//if(o_occluder)
//	@o_occluder OBJ_ShadowColorSet(color_standby)	
	
// Si un de mes potes est en alerte, mon spot reste rouge ... même si je suis en standby
i = 0
while(o_close_spots[i])
{
	to_close = o_close_spots[i]
	ti_mode  = @"little_actors/poursuite_ny" to_close i_mode
	
	if(ti_mode == 1)
	{
		GFX_Seti(i_idhalo, 21101, color_alerte) 
//		if(o_occluder)
//			@o_occluder OBJ_ShadowColorSet(color_alerte)	
		
		break
	}
	
	i++
}



v_speed_follow = @o_follow DYN_SpeedGetVector()

// Si j'ai un réseau, je l'utilise ...
if(n_parcours)
{	
	// Je sais pas ou aller ... => goto root
	if(o_next_wp == nobody)
	{
		o_next_wp = WAY_RootGet(n_parcours)
		v_pos_target = @o_next_wp BV_RandomPosGet(0)						
		f_follow_blend = 1
		
	}
	
	// On a atteint notre BV destination
	if(@o_next_wp COL_BV_PivotCollide(o_follow))
	{
		o_next_wp = WAY_NetNextWP(n_parcours,o_next_wp,1,0)
		v_pos_target = @o_next_wp BV_RandomPosGet(0)		
		f_follow_blend = 0.1
	}
}
// A pas de réseau ... si j'ai une BV de délimitation, je l'utilise
else
{	
	if(o_bv_limite_alerte)
	{	
		tv_temp = v_pos_target - @o_follow OBJ_PosGet()
		f_dist = MATH_VecNorm(tv_temp)
		if(f_dist < 5.0)
		{
			v_pos_target = @o_bv_limite_alerte BV_RandomPosGet(1)
			f_follow_blend = 0.1
		}
	}
}

// Voila le vecteur qui sépare mon o_follow de sa destination
tv_temp = v_pos_target - @o_follow OBJ_PosGet()
	
// Blend ?
if(f_follow_blend < 1)
{
	tv_temp = MATH_VecBlend(v_speed_follow, tv_temp, f_follow_blend)
	f_follow_blend += TIME_GetDt()		
}
	
// Set de la vitesse
if (@o_follow OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna))
{
	@o_follow DYN_SpeedSetVector(tv_temp)
//	@o_follow DYN_SpeedSet(f_max_speed)
}

