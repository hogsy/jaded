
#include "IOB_Defines.var"

procedure_local vector IOB_CheckPaf( byref int ti_step )
{

	message		tm_filter
	int					ti_rank	
	messageid		tmid_paf
	int					ti_paf_type
	vector			tv_paf_dir
	int					ti_puissance 

	tv_paf_dir	= Cv_NullVector
	ti_step = 0
	
	MSG_SetNull( tm_filter )
	tm_filter.msg_gao1 = OBJ_Me()
	
	ti_rank = -1
	for(	tmid_paf = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Paf, &ti_rank, tm_filter);
			MSG_GlobalIsValid(tmid_paf);
			tmid_paf = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Paf, &ti_rank, tm_filter))
	{
		// Loop in the messages...
	
		ti_paf_type = EVENT_PafTypeGet(tmid_paf)
		tv_paf_dir = EVENT_PafDirGet( tmid_paf)
	
		if ( i_poing_Inoperant && ( ti_paf_type & C_PAF_KK_Jacks_Punch) )
			SND_RequestPlay(0)		// Impact du Choc
		else
		{		
			if (ti_paf_type & C_PAF_KK_Repousse )
			{
				ti_step = 1
				break
			}
		
			ti_puissance = EVENT_PafPuisGet(tmid_paf)
			if (ti_puissance > f_destroyall_paf_force)
			{
				// ShootGun
				ti_step = 100
				break
			}
	
			if (ti_paf_type & C_PAF_KK_Repousse )
			{
				// Coup de Poing, Cross, Lance...
				ti_step = 1
				break
			}
	
			f_jauge += 1
		}

		if (f_jauge > 5)
		{
			f_jauge = 0
			ti_step = 1
			break
		}
		else
		{
			int		ti_ind
			for( ti_ind = 0; ti_ind <  Ci_IOB_NbrOfObjectMax; ti_ind++)
			{
				// activate the ode for the item that corresponds to the paf number
				if ( ODE_Objects[ti_ind] && ODE_Steps[ti_ind] > (i_step_current + ti_step ) )
					af_vibrating[ti_ind] = MATH_RandFloat( 0.005, 0.02)
			}
		}
	}
	return ( tv_paf_dir )
}
	

procedure_local void IOB_ApplyForces(object to_brique, vector tv_axis, int ti_step)
{
	MATH_VecSetHorzNormalize(tv_axis)

	if (ti_step > 2)
		tv_axis *= f_puissance_ejection_destroy
	else
		tv_axis *= f_puissance_ejection_normale

	tv_axis = MATH_VecRotate(tv_axis, Cv_VerticalVector, MATH_RandFloat(-0.5,0.5))

	DBG_RenderVector(@to_brique OBJ_PosGet(),tv_axis, color_rouge)
	@to_brique ODE_Setv(0, tv_axis  )
	@to_brique ODE_Setf(2, 100.0)
}

procedure_local int IOB_Module_lifetime()
{
	float		tf_old_ODE_LifeTime
	float		f_diffL, f_diffA
	int			tai_Prio[16], ti_NumPrio 
	int			ti_ind, instance, sound
	object	to_gao 
	int			ti_count
		
	ti_count = 0
	
	for( ti_ind = 0; ti_ind <  Ci_IOB_NbrOfObjectMax; ti_ind++)
	{
		tf_old_ODE_LifeTime = ODE_LifeTime[ti_ind]
		to_gao = ODE_Objects[ti_ind]
			
		if (ODE_LifeTime[ti_ind] > 0.0)
		{
			ODE_LifeTime[ti_ind] -= MATH_FloatMin(ODE_LifeTime[ti_ind], TIME_GetDt())
			
			// Dérivées  de vitesses linéraires et angulaires ont le même signe ... pas de choc
			if
			(
				( MATH_FloatSign(af_ode_deriveeL_frame[ti_ind]) != MATH_FloatSign(af_ode_deriveeL_old_frame[ti_ind]))
			||	( MATH_FloatSign(af_ode_deriveeA_frame[ti_ind]) != MATH_FloatSign(af_ode_deriveeA_old_frame[ti_ind]))
			)
			{
				// PRIORITE DES SONS LOCAUX ...	
				tai_Prio[0] = 4		// Water
				tai_Prio[1] = 3		// Pierre
				tai_Prio[2] = 2		// Veget
				tai_Prio[3] = 1		// Terre	
					
				ti_NumPrio = 4
				
				
				// On veut une valeur positive à tester
				f_diffL = af_ode_deriveeL_frame[ti_ind]
				f_diffA = af_ode_deriveeA_frame[ti_ind]		
				
				f_diffL = MATH_AbsFloat(f_diffL)
				f_diffA = MATH_AbsFloat(f_diffA)
									
				if( ((f_linear_threshold != 0.0) && (f_diffL > f_linear_threshold)) || ((f_angular_threshold != 0.0) && (f_diffA > f_angular_threshold)))
				{
					sound = @to_gao COL_ODE_PrioSoundGet(&tai_Prio[0], ti_NumPrio)
						
					instance = SND_Request(10 + sound, C_SND_Request_DestroyWhenFinished)								
					if(instance != -1)
						@to_gao SND_Play(instance)
					
				}		
			}
		}
		else if (!ODE_LifeTime[ti_ind])
		{
			if ( (to_gao && (@to_gao OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Active) ) && to_gao != OBJ_Me())
			{
				@to_gao ODE_Enable(faux)
				@to_gao OBJ_Destroy()
			}
			ti_count ++
		}
			
		if (ODE_LifeTime[ti_ind] < 2.0 && tf_old_ODE_LifeTime >= 2.0)
		{
			@to_gao DYN_On()
			@to_gao DYN_FlagsSet(DYN_C_BasicForces,none)
			@to_gao DYN_GravitySet(cvector(0,0,-5))
		}
	}

	if (ti_count == Ci_IOB_NbrOfObjectMax)
		return ( vrai )
	else
		return ( faux )
}	


procedure_local	void	IOB_Check_Vibrating()
{
	int			pi_int
	float		pf_x, pf_y
	vector	pv_decal
	for ( pi_int = 0; pi_int < Ci_IOB_NbrOfObjectMax; pi_int++)
	{
		if ( ODE_Objects[pi_int] && !MATH_FloatNullEpsilon( af_vibrating[pi_int]))
		{
			pf_x = MATH_RandFloat( -1,1)
			pf_y = MATH_RandFloat( -1,1)
			pv_decal = cvector( pf_x, pf_y, MATH_FloatSign( MATH_RandFloat( -1,1)) * MATH_FloatSqrt( (pf_x * pf_x) + (pf_y * pf_y))) * af_vibrating[pi_int]
			@ODE_Objects[pi_int] OBJ_PosSet( @ODE_Objects[pi_int] OBJ_PosInitGet() + pv_decal)
		}
		af_vibrating[pi_int] = MATH_FloatBlend( af_vibrating[pi_int], 0.0, 10.0 * TIME_GetDt())
	}
}