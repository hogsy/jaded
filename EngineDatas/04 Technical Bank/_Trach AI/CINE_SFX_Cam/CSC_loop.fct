vector	tv_newpos, tv_temp
float		tf_temp, tf_dist

VIEW_FocaleSet(0, des_focale)
VIEW_AssignObject(0)
if	( (TIME_Elapsed(f_temps, 0.1)) && (des_parkinson) )
{
	tv_newpos.x = MATH_RandFloat(-des_parkinson, des_parkinson)
	tv_newpos.y = MATH_RandFloat(-des_parkinson, des_parkinson)
	tv_newpos.z = MATH_RandFloat(-des_parkinson, des_parkinson)
	tv_newpos = MATH_VecLocalToGlobal(tv_newpos)
	OBJ_PosSet(v_startpos+tv_newpos)
//	@get_camera OBJ_PosSet(v_startpos+tv_newpos)
	f_temps = TIME_Get()
}

if	(OBJ_CapaTest(OBJ_Capa_8))// && (i_sfx_shake) )
{
	tf_temp = MATH_Sin(f_sfx_time * f_sfx_shake_freq)
	f_sfx_time += TIME_GetDt()
	if	(des_o_shake)
	{
//		tf_dist = MATH_VecDistance(OBJ_PosGet(), @des_o_shake OBJ_PosGet())
		tf_dist = MATH_FloatLimit(MATH_VecDistance(OBJ_PosGet(), @des_o_shake OBJ_PosGet()), 1, 10) * 1
		tf_temp *= (f_sfx_shake_amplitude / tf_dist)
	}
	else
	{	tf_temp *= f_sfx_shake_amplitude	}
	OBJ_PosSet(OBJ_PosGet() + cvector(0, 0, tf_temp))

//	tv_temp = OBJ_BankingGet()
//	tv_temp += OBJ_HorizonGet() * (tf_temp * 0.1)
//	OBJ_BankingGeneralSet(OBJ_SightGet(), tv_temp)

	f_sfx_shake_amplitude -= (f_sfx_shake_speed * TIME_GetDt())
	if	(f_sfx_shake_amplitude <= 0) 
	{
		f_sfx_shake_amplitude = 0.5
		i_sfx_shake = 0
		OBJ_CapaSet(0, OBJ_Capa_8)
	}
}
