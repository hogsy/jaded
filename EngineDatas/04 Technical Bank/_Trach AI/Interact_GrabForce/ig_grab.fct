
#include "ig_defines.var"

vector 	tv_banking, tv_force, tv_sens_actuel, tv_orth
vector 	tv_grav 
vector 	tv_new_grav
vector 	tv_bank
vector 	tv_speed_Y
vector	v_local_X
vector	v_local_Y
vector	v_KK_X
vector	v_KK_Y
float		tf_local_joy_X
float		tf_local_joy_Y

float		tf_norm
float		tf_alfa, tf_dot
int			ti_str 


float		tf_L
float		tf_Kx, tf_Ky, tf_Kz
vector	tv_pos_cercle

if ( i_fin_mode)
{
	// PURGE DU COMPORTEMENT
	// EXEC
//	 LNK_ServeurGet(Ci_LNK_KKGRAB_FORCE, mid_grabbed_LIAISON_ID, faux, nofunc)
	i_fin_mode = faux
	return
}

// INIT
if ( i_mode != Ci_mode_grab)
{
	i_mode = Ci_mode_grab
	if ( f_last_func)
	{
		i_fin_mode = vrai
		AI_Execute( f_last_func)
	}
//	v_last_sens = @o_grab_actor OBJ_SightGet()
	f_bonus_force = 1.0
}

// ANALYSE
o_grab_actor = LNK_ServeurGet(Ci_LNK_KKGRAB_FORCE, mid_grabbed_LIAISON_ID, vrai, nofunc, nofunc)
if (!o_grab_actor)
	ChangeEtat("ig_propose")


// COMPORTEMENT

//	REPERE LOCAL
if ( !MATH_FloatNullEpsilon(MATH_VecDotProduct(-Cv_VerticalVector, OBJ_BankingGet()) + 1.0))
{
	v_local_X = MATH_VecCrossProduct( -Cv_VerticalVector, OBJ_BankingGet())
	MATH_VecSetHorzNormalize( v_local_X)
}
else
	v_local_X = OBJ_HorizonGet()
v_local_Y = MATH_VecCrossProduct( OBJ_BankingGet(), v_local_X)

// Repère Kong
v_KK_X	= @o_grab_actor OBJ_HorizonGet()
v_KK_Y	= @o_grab_actor OBJ_SightGet()

// Force de Kong
tv_force = LNK_GrabVectorGet(mid_grabbed_LIAISON_ID)								// Action de KONG
tv_force = MATH_VecBlend( v_force, tv_force, Cf_ForceKong * TIME_GetDt())	// Blend du Joy
tf_norm = MATH_VecNorm( tv_force)															// Norm du joy
DBG_RenderVector( v_grav_pos, v_KK_X * 5.0, 0xFF00)
DBG_RenderVector( v_grav_pos, v_KK_Y * 5.0, 0xFF00)
DBG_RenderVector( OBJ_PosGet(), OBJ_BankingGet() * 15.0, 0xFF00)

tf_local_joy_Y = MATH_VecDotProduct( v_KK_Y, tv_force)							// Coordonnée Y sur le repere KK
tf_local_joy_X = MATH_VecDotProduct( v_KK_X, tv_force)							// Coordonnée X sur le repere KK

DBG_RenderCone( OBJ_PosGet(), cvector( 0.0, 0.0, 10.0), f_angle, 0x0BFFFFFF)
ti_str = STR_CreateText( "", cvector( 0.1,0.1,0.0), 0.0)
STR_AppendFloat( ti_str, MATH_VecDotProduct( Cv_VerticalVector, OBJ_BankingGet()), 3)
if ( MATH_VecAbsAngle( Cv_VerticalVector, OBJ_BankingGet()) < f_angle * 0.5 ) //Cf_Cos10)
{
	// Quand l arbre est plutot vertical on peux choisir entre les 4 directions de déplacement
//	if ( MATH_AbsFloat( tf_local_joy_X) > MATH_AbsFloat(tf_local_joy_Y))
//		tv_force = v_KK_X * tf_local_joy_X 
//	else
//		tv_force = v_KK_Y * tf_local_joy_Y
}
else
{
	// Sinon on est contraint dans le mouvement linéraire
	tf_local_joy_Y = MATH_VecDotProduct( v_local_Y, tv_force)							// Coordonnée Y sur le repere local
	tv_force = v_local_Y * tf_local_joy_Y	
}

if ( !MATH_FloatNullEpsilon( tf_norm))
	MATH_VecSetNorm( tv_force, tf_norm)

DBG_RenderVector( v_grav_pos, tv_force * 5.0, 0xFF)
tf_local_joy_Y = MATH_VecDotProduct( v_local_Y, tv_force)							// Coordonnée Y sur le repere local
tf_local_joy_X = MATH_VecDotProduct( v_local_X, tv_force)							// Coordonnée X sur le repere local
v_force = v_local_Y * tf_local_joy_Y															// La direction principale du mouvement est totale
v_force += v_local_X * ( tf_local_joy_X	* Cf_X_atenuation)								// La direction latérale sans contact full move
v_grav_pos = OBJ_PosGet() + ( OBJ_BankingGet() * Cf_G )							// Centre de gravité

if ( !MATH_FloatNullEpsilon(tf_norm))
	MATH_VecSetNorm( v_force, tf_norm)
v_grav_pos -= cvector( 0.0, 0.0, Cf_ForceGravite * TIME_GetDt())						// Action de la Gravité
v_grav_pos += v_force * ( Cf_ForceKong * TIME_GetDt() )								// Action de la Force

tv_grav = MATH_VecNormalize( v_grav_pos - OBJ_PosGet())
if( MATH_VecAbsAngle( Cv_VerticalVector, tv_grav ) > f_angle)
{
	// On est dans le dur : resistance
	if ( f_angle > 0.36)
		ChangeEtat("ig_casse")
	tv_speed_Y = v_local_Y * MATH_VecDotProduct( v_local_Y, v_grav_speed)
	if ( ( MATH_AbsFloat(tf_local_joy_X) > 0.5 * MATH_AbsFloat( tf_local_joy_Y) || (tf_local_joy_Y < 0 || MATH_FloatNullEpsilon(tf_local_joy_Y )))   //
	|| ( MATH_VecNorm( tv_speed_Y) < 0.2 && i_collision_bord))
	{
		// Glisser lateralement sur le dur
		// Multi mega test pas reussi a trouvre un truc simple grrr
		i_collision_bord = vrai
		tv_grav = MATH_VecInCone( tv_grav, Cv_VerticalVector, f_angle, 0)
		tv_speed_Y = v_local_Y * MATH_VecDotProduct( v_local_Y, v_grav_speed)
	}
	else
	{
		// S enfoncer ds le dur
		i_collision_bord = faux
		v_grav_pos=  OBJ_PosGet() + ( OBJ_BankingGet() * Cf_G )
		// Application de la l'amorti dans le dur
		v_grav_pos += tv_speed_Y * ( TIME_GetDt() * Cf_Amortie)									// Action de la Vitesse amortie
		tv_grav = MATH_VecNormalize( v_grav_pos - OBJ_PosGet())
	}
}

// CALCUL intersection avec un cercle ..

//tv_grav *= Cf_G
//tf_L = Cf_G * MATH_Sin( f_angle)
//vector	tv_proj
//tv_proj.x = tv_grav.x
//tv_proj.y = tv_grav.y
//tv_proj.z = 0
//tf_local_joy_X = MATH_VecDotProduct( v_KK_X, tv_proj)							// Coordonnée X sur le repere KK
//tf_local_joy_Y = MATH_VecDotProduct( v_KK_Y, tv_proj)							// Coordonnée Y sur le repere KK
//v_KK_X *= MATH_FloatSign( tf_local_joy_X)
//v_KK_Y *= MATH_FloatSign( tf_local_joy_Y)
//tf_local_joy_X = MATH_AbsFloat( tf_local_joy_X)
//tf_local_joy_Y = MATH_AbsFloat( tf_local_joy_Y)
//
//DBG_RenderVector( OBJ_PosGet(), tv_grav , 0xFFFF)
//tv_pos_cercle = OBJ_PosGet() + (( v_KK_X * tf_L) + ( v_KK_Y * tf_L))
//tv_pos_cercle.z += tv_grav.z
//
//DBG_RenderCircle( tv_pos_cercle, tf_L, Cv_VerticalVector, 0x00FF)
//tv_pos_cercle = OBJ_PosGet()
//tv_pos_cercle.z += tv_grav.z
//DBG_RenderVector( tv_pos_cercle, v_KK_X * tf_L, 0xFF)
//DBG_RenderVector( tv_pos_cercle, v_KK_Y * tf_L, 0xFF)
//DBG_RenderVector( tv_pos_cercle, OBJ_PosGet() + ( tv_grav - tv_pos_cercle), 0xFFFF)
//
//tf_local_joy_X = tf_L - tf_local_joy_X
//tf_local_joy_Y = tf_L - tf_local_joy_Y
////
//if ( ((tf_local_joy_X * tf_local_joy_X) + (tf_local_joy_Y * tf_local_joy_Y)) < (tf_L * tf_L))
//{
//	// Dans le cercle
//	if ( MATH_AbsFloat( tf_local_joy_X) > MATH_AbsFloat( tf_local_joy_Y))
//	{
//		tf_Kx = (tf_L * tf_L )* ( tf_local_joy_X * tf_local_joy_X)
//		tf_Kx /= (( tf_local_joy_X * tf_local_joy_X) + (tf_local_joy_Y * tf_local_joy_Y))
//		tf_Kx = MATH_FloatSqrt( tf_Kx)
//		
//		tf_Ky = tf_Kx *  ( tf_local_joy_Y / tf_local_joy_X )
//		tf_Kx *= MATH_FloatSign( tf_local_joy_X) 
//		tf_Ky *= MATH_FloatSign( tf_local_joy_Y) 	
//	}
//	else
//	{
//		tf_Ky = (tf_L * tf_L )* ( tf_local_joy_Y * tf_local_joy_Y)
//		tf_Ky /= (( tf_local_joy_Y * tf_local_joy_Y) + (tf_local_joy_X * tf_local_joy_X))
//		tf_Ky = MATH_FloatSqrt( tf_Ky)
//		
//		tf_Kx = tf_Ky *  ( tf_local_joy_X / tf_local_joy_Y )
//		tf_Kx *= MATH_FloatSign( tf_local_joy_X) 
//		tf_Ky *= MATH_FloatSign( tf_local_joy_Y) 	
//	}
//	
//	tf_Kz = tv_grav.z
//	v_grav_pos = v_KK_X * ( tf_L - tf_Kx) 
//	v_grav_pos += v_KK_Y * ( tf_L - tf_Ky) 
//	v_grav_pos.z = tf_Kz
//	MATH_VecSetNorm( v_grav_pos, Cf_G)
//	DBG_RenderVector( OBJ_PosGet(), v_grav_pos, 0xFF0000)
//	tv_grav = MATH_VecNormalize( v_grav_pos)
//	v_grav_pos	+= OBJ_PosGet()
//}

// ORIENTATION
tv_banking = tv_grav

tf_local_joy_Y = MATH_VecDotProduct( v_KK_Y, tv_banking)							// Coordonnée Y sur le repere KK
tf_local_joy_X = MATH_VecDotProduct( v_KK_X, tv_banking)							// Coordonnée X sur le repere KK




//if ( MATH_AbsFloat( tf_local_joy_X) > MATH_AbsFloat(tf_local_joy_Y))
//{
//	tv_banking = (v_KK_X * tf_local_joy_X ) + (Cv_VerticalVector * MATH_VecDotProduct( tv_banking, Cv_VerticalVector ))
//}
//else
//{
//	tv_banking = (v_KK_Y * tf_local_joy_Y) + (Cv_VerticalVector * MATH_VecDotProduct( tv_banking, Cv_VerticalVector ))
//}

if ( MATH_VecNullEpsilon( tv_banking))
	tv_banking = Cv_VerticalVector
MATH_VecSetNormalize(tv_banking)
OBJ_BankingGeneralSet( OBJ_SightGet(), tv_banking)

v_grav_pos = OBJ_PosGet() + ( tv_banking * Cf_G)
f_angle = MATH_FloatMax( f_angle, MATH_AbsFloat( MATH_VecAngle( Cv_VerticalVector, tv_banking, v_local_X)))	// Nouvel angle max repoussè
v_grav_speed = ( v_grav_pos - v_last_pos) / TIME_GetDt()												// Vitesse
f_grav_speed = MATH_VecNorm(v_grav_speed) 															// Vitesse
v_last_pos = v_grav_pos																							// Update

























////	REPERE LOCAL
//if ( !MATH_FloatNullEpsilon(MATH_VecDotProduct(-Cv_VerticalVector, OBJ_BankingGet()) + 1.0))
//{
//	v_local_X = MATH_VecCrossProduct( -Cv_VerticalVector, OBJ_BankingGet())
//	MATH_VecSetHorzNormalize( v_local_X)
//}
//else
//	v_local_X = OBJ_HorizonGet()
//v_local_Y = MATH_VecCrossProduct( OBJ_BankingGet(), v_local_X)
//
//// Repère Kong
//v_KK_X	= @o_grab_actor OBJ_HorizonGet()
//v_KK_Y	= @o_grab_actor OBJ_SightGet()
//
//// Force de Kong
//tv_force = LNK_GrabVectorGet(mid_grabbed_LIAISON_ID)								// Action de KONG
//tv_force = MATH_VecBlend( v_force, tv_force, Cf_ForceKong * TIME_GetDt())	// Blend du Joy
//tf_norm = MATH_VecNorm( tv_force)															// Norm du joy
//DBG_RenderVector( v_grav_pos, v_KK_X * 5.0, 0xFF00)
//DBG_RenderVector( v_grav_pos, v_KK_Y * 5.0, 0xFF00)
//
//
//tf_local_joy_Y = MATH_VecDotProduct( v_KK_Y, tv_force)							// Coordonnée Y sur le repere KK
//tf_local_joy_X = MATH_VecDotProduct( v_KK_X, tv_force)							// Coordonnée X sur le repere KK
//
////DBG_RenderCone( OBJ_PosGet(), cvector( 0.0, 0.0, 10.0), 10.0 * Cf_PiBy180, 0x0BFFFFFF)
////if ( MATH_VecDotProduct( Cv_VerticalVector, OBJ_BankingGet()) > Cf_Cos10)
////{
////	// Quand l arbre est plutot vertical on peux choisir entre les 4 directions de déplacement
////	if ( MATH_AbsFloat( tf_local_joy_X) > MATH_AbsFloat(tf_local_joy_Y))
////		tv_force = v_KK_X * tf_local_joy_X 
////	else
////		tv_force = v_KK_Y * tf_local_joy_Y
////}
////else
////{
////	// Sinon on est contraint dans le mouvement linéraire
////	tf_local_joy_Y = MATH_VecDotProduct( v_local_Y, tv_force)							// Coordonnée Y sur le repere local
////	tv_force = v_local_Y * tf_local_joy_Y	
////}
//
//if ( !MATH_FloatNullEpsilon( tf_norm))
//	MATH_VecSetNorm( tv_force, tf_norm)
//
//DBG_RenderVector( v_grav_pos,tv_force * 5.0, 0xFF)
//tf_local_joy_Y = MATH_VecDotProduct( v_local_Y, tv_force)							// Coordonnée Y sur le repere local
//tf_local_joy_X = MATH_VecDotProduct( v_local_X, tv_force)							// Coordonnée X sur le repere local
//v_force = v_local_Y * tf_local_joy_Y															// La direction principale du mouvement est totale
//v_force += v_local_X * ( tf_local_joy_X	* Cf_X_atenuation)								// La direction latérale sans contact full move
//
//v_grav_pos = OBJ_PosGet() + ( OBJ_BankingGet() * Cf_G )							// Centre de gravité
//
//if ( !MATH_FloatNullEpsilon(tf_norm))
//	MATH_VecSetNorm( v_force, tf_norm)
//v_grav_pos -= cvector( 0.0, 0.0, Cf_ForceGravite * TIME_GetDt())						// Action de la Gravité
//v_grav_pos += v_force * ( Cf_ForceKong * TIME_GetDt() )								// Action de la Force
//
//tv_grav = MATH_VecNormalize( v_grav_pos - OBJ_PosGet())
//if( MATH_VecAbsAngle( Cv_VerticalVector, tv_grav ) > f_angle)
//{
//	// On est dans le dur : resistance
//	if ( f_angle > 0.36)
//		ChangeEtat("ig_casse")
//	tv_speed_Y = v_local_Y * MATH_VecDotProduct( v_local_Y, v_grav_speed)
//	if ( ( MATH_AbsFloat(tf_local_joy_X) > 0.5 * MATH_AbsFloat( tf_local_joy_Y) || (tf_local_joy_Y < 0 || MATH_FloatNullEpsilon(tf_local_joy_Y )))   //
//	|| ( MATH_VecNorm( tv_speed_Y) < 0.2 && i_collision_bord))
//	{
//		// Glisser lateralement sur le dur
//		// Multi mega test pas reussi a trouvre un truc simple grrr
//		i_collision_bord = vrai
//		tv_grav = MATH_VecInCone( tv_grav, Cv_VerticalVector, f_angle, 0)
//		tv_speed_Y = v_local_Y * MATH_VecDotProduct( v_local_Y, v_grav_speed)
//	}
//	else
//	{
//		// S enfoncer ds le dur
//		i_collision_bord = faux
//		v_grav_pos=  OBJ_PosGet() + ( OBJ_BankingGet() * Cf_G )
//		// Application de la l'amorti dans le dur
//		v_grav_pos += tv_speed_Y * ( TIME_GetDt() * Cf_Amortie)									// Action de la Vitesse amortie
//		tv_grav = MATH_VecNormalize( v_grav_pos - OBJ_PosGet())
//	}
//}
//
//// CALCUL intersection avec un cercle ..
//
//// ORIENTATION
//tv_banking = tv_grav
//
//tf_local_joy_Y = MATH_VecDotProduct( v_KK_Y, tv_banking)							// Coordonnée Y sur le repere KK
//tf_local_joy_X = MATH_VecDotProduct( v_KK_X, tv_banking)							// Coordonnée X sur le repere KK
//
//
//if ( MATH_AbsFloat( tf_local_joy_X) > MATH_AbsFloat(tf_local_joy_Y))
//{
//	if ( !MATH_FloatNullEpsilon( tf_local_joy_X))
//	{
//		vector	tv_G
//		tv_G =  v_KK_X * tf_local_joy_X 
//		tv_G += v_KK_Y * tf_local_joy_Y
//		MATH_VecSetNorm( tv_G, tf_local_joy_X) 
//		tv_G.z = tv_banking.z
//		tv_banking = MATH_VecNormalize( tv_G)
//	}
//}
//else
//{
//	if ( !MATH_FloatNullEpsilon( tf_local_joy_Y))
//	{
//		vector	tv_G
//		tv_G =  v_KK_Y * tf_local_joy_Y
//		tv_G += v_KK_X * tf_local_joy_X
//		MATH_VecSetNorm( tv_G, tf_local_joy_Y) 
//		tv_G.z = tv_banking.z
//		tv_banking = MATH_VecNormalize( tv_G)
//	}
//}
//
//
//if ( MATH_VecNullEpsilon( tv_banking))
//	tv_banking = Cv_VerticalVector
//MATH_VecSetNormalize(tv_banking)
//OBJ_BankingGeneralSet( OBJ_SightGet(), tv_banking)
//
//v_grav_pos = OBJ_PosGet() + ( tv_banking * Cf_G)
//f_angle = MATH_FloatMax( f_angle, MATH_AbsFloat( MATH_VecAngle( Cv_VerticalVector, tv_banking, v_local_X)))	// Nouvel angle max repoussè
//v_grav_speed = ( v_grav_pos - v_last_pos) / TIME_GetDt()												// Vitesse
//f_grav_speed = MATH_VecNorm(v_grav_speed) 															// Vitesse
//v_last_pos = v_grav_pos																							// Update
//
//
//
//
//
//
//
//
//
//
//
