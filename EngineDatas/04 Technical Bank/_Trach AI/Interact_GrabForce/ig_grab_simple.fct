#include "ig_defines.var"


vector 	tv_force
vector 	tv_pos
vector	tv_banking
vector	tv_KK_Y, tv_KK_X
vector	tv_pos_main
float		tf_local_joy_X, tf_local_joy_Y
float		tf_sens
float		tf_blend
float		tf_angle_lim
float		tf_angle
float		tf_cos_angle
int			ti_use_grav

if ( i_fin_mode)
{
	// PURGE DU COMPORTEMENT
	// EXEC
	if( MSG_GlobalIsValid( mid_grabbed_LIAISON_ID))
		LNK_GrabStatusSet( mid_grabbed_LIAISON_ID, Ci_LNK_GrabStatus_Pause)
	i_fin_mode = faux
	return
}

// INIT
if ( i_mode != Ci_mode_grabSimple)
{
	i_mode = Ci_mode_grabSimple
	if ( f_last_func)
	{
		i_fin_mode = vrai
		AI_Execute( f_last_func)
	}
	tv_pos  = OBJ_PosGet() + ( OBJ_BankingGet() * 5.0)
	tv_pos -= @o_grab_actor OBJ_SightGet() * 0.25
	@o_snap_mainD OBJ_PosSet( tv_pos - (@o_grab_actor OBJ_HorizonGet() * 1.5))
	@o_snap_mainG OBJ_PosSet( tv_pos + (@o_grab_actor OBJ_HorizonGet() * 1.5))
	f_bonus_force = 1.0
}

// ANALYSE
o_grab_actor = LNK_ServeurGet(Ci_LNK_KKGRAB_FORCE, mid_grabbed_LIAISON_ID, vrai, nofunc, nofunc)
if (!o_grab_actor)
	ChangeEtat("ig_propose")

// Repère Kong
tv_KK_X	= @o_grab_actor OBJ_HorizonGet()
tv_KK_Y	= @o_grab_actor OBJ_SightGet()


// Force de Kong
tv_force = LNK_GrabVectorGet(mid_grabbed_LIAISON_ID)										// Action de KONG
if ( MATH_VecNorm( tv_force) < MATH_VecNorm( v_force))
	tv_force = MATH_VecBlend( v_force, tv_force, 6.0 * TIME_GetDt())						// La force dimine tres vite
else
	tv_force = MATH_VecBlend( v_force, tv_force, 4.0 * TIME_GetDt())						// La force augmente plus lentement
v_force = tv_force

tv_banking = OBJ_BankingGet()
ti_use_grav = faux
tf_sens = MATH_VecDotProduct( tv_banking, tv_force)

tf_blend = Cf_ForceKong * MATH_VecNorm( tv_force) * MATH_RandFloat(0.0, 2.0)

tf_local_joy_Y = tf_blend * MATH_VecDotProduct( tv_KK_Y, tv_force)						// Coordonnée Y sur le repere KK
tf_local_joy_X = tf_blend * MATH_VecDotProduct( tv_KK_X, tv_force)						// Coordonnée X sur le repere KK

tf_cos_angle = MATH_VecDotProduct(Cv_VerticalVector, tv_banking)
if ( tf_cos_angle > f_CosAngleCercle_1
|| ( i_break && ( !MATH_FloatNullEpsilon( tf_cos_angle - f_CosAngleCercle_2) && tf_cos_angle > f_CosAngleCercle_2)))
{
	// Cercle interne on force
	// Ou le grand cercle apres que l on ai KC les 1ere racines
	f_time_force1 = 0.0	
	if ( i_break )
		tf_blend *= Cf_RacineKC

	tv_banking = MATH_VecRotate( tv_banking,tv_KK_Y, -tf_local_joy_X * TIME_GetDt())
	tv_banking = MATH_VecRotate( tv_banking, tv_KK_X, tf_local_joy_Y * TIME_GetDt())
}
else if ( ( !MATH_FloatNullEpsilon( tf_cos_angle - f_CosAngleCercle_2) && tf_cos_angle > f_CosAngleCercle_2))
{
	// Cercle 2 ca casse
	if ( !i_break_en_cours)
	{
		f_time_force2 = 0.0
		if ( MATH_VecDotProduct( tv_force, tv_banking) < 0)
		{
			// Remonter l arbre
			f_time_force1 = 0.0
			tv_banking = MATH_VecRotate( tv_banking,tv_KK_Y, -tf_local_joy_X * TIME_GetDt())
			tv_banking = MATH_VecRotate( tv_banking, tv_KK_X, tf_local_joy_Y * TIME_GetDt())
		}
		else if ( MATH_FloatNullEpsilon( MATH_VecDotProduct( tv_force, tv_banking)))
		{
			// Rien faire
		}
		else if ( f_time_force1 < Cf_Delai_Avt_Casse1)
		{
			f_time_force1 += TIME_GetDt()
		}
		else if ( MATH_VecDotProduct( tv_force, tv_banking) >= 0)
		{
			// Je Joy aide l arbre a casser.
			// L'arbre chute avec la Gravité jusqu'a l angle 2
			i_break_en_cours = vrai
			ti_use_grav = vrai
			tf_angle_lim = Cf_AngleCercle_2
		}		
	}
	else
	{
		// L'arbre chute avec la Gravité jusqu'a l angle 2
		i_break_en_cours = vrai
		ti_use_grav = vrai
		tf_angle_lim = Cf_AngleCercle_2
	}
}
else
{
	i_break = vrai
	if ( MATH_VecDotProduct( tv_force, tv_banking) < 0)
	{
		// Remonter l arbre
		f_time_force2 = 0.0
		tv_banking = MATH_VecRotate( tv_banking,tv_KK_Y, -tf_local_joy_X * TIME_GetDt())
		tv_banking = MATH_VecRotate( tv_banking, tv_KK_X, tf_local_joy_Y * TIME_GetDt())
	}
	else if ( MATH_FloatNullToler( MATH_VecDotProduct( tv_force, tv_banking), 0.1))
	{
		ti_use_grav = vrai
		tf_angle_lim = Cf_AngleCercle_2
	}
	else if ( f_time_force2 < Cf_Delai_Avt_Casse2)
	{
		// Je joueur force sur larbre pour KC mais il faut 1sec de force pour que ca KC	
		tv_banking = MATH_VecRotate( tv_banking,tv_KK_Y, -tf_local_joy_X * TIME_GetDt())
		tv_banking = MATH_VecRotate( tv_banking, tv_KK_X, tf_local_joy_Y * TIME_GetDt())
		tv_banking = MATH_VecInCone( tv_banking, Cv_VerticalVector,  Cf_AngleCercle_2, 0)		// Permet de faire tourner l arbre en forcant
		f_time_force2 += TIME_GetDt()
	}
	else
	{
		if ( MATH_VecDotProduct( tv_KK_Y, LNK_GrabVectorGet(mid_grabbed_LIAISON_ID)) < -Cf_Cos45 && o_grab_actor)
			EVENT_AddEventPaf( C_EVENT_FILTER_Object, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_grab_actor, 1.0 * PAF_Unit, -tv_KK_Y)
	
		DBG_RenderCylinder( OBJ_PosGet(), tv_banking * 15.0, Cf_RayonTron, 0x712C4E8B)
		ChangeEtat("ig_casse")
	}

}

if( ti_use_grav)
{
	// L'abre chute avec gravité entre cercle 1 et crecle 2
	v_grav_pos = OBJ_PosGet() + ( OBJ_BankingGet() * Cf_G )							// Centre de gravité
	v_grav_pos -= cvector( 0.0, 0.0, Cf_ForceGravite* TIME_GetDt())						// Action de la Gravité
	tv_banking = v_grav_pos - OBJ_PosGet()
	MATH_VecSetNorm( tv_banking, Cf_G)
	tv_banking = MATH_VecInCone( tv_banking, Cv_VerticalVector,  tf_angle_lim, 0)
}


OBJ_BankingGeneralSet( OBJ_SightGet(), tv_banking)

DBG_RenderCylinder( OBJ_PosGet(), tv_banking * 15.0, Cf_RayonTron, 0x712C4E8B)


// **************************************
// POSITIONNEMENT DES MAINS
// **************************************
tv_pos = OBJ_PosGet() + ( OBJ_BankingGet() * 5.0)
float	tf_dot
tf_dot = MATH_VecDotProduct( glob_joyvector_get, @o_grab_actor OBJ_SightGet())
if ( MATH_AbsFloat( tf_dot) < 0.05)
{
	tv_pos -= tv_KK_X * 1.5
	tv_pos -= tv_KK_Y * 0.25
}
else if ( tf_dot > 0.0)
{
	tv_pos -= tv_KK_X * 1.0 
	tv_pos -= tv_KK_Y * 0.75
}
else
{
	tv_pos -= tv_KK_X * 1.35 
	tv_pos += tv_KK_Y * 0.25
}

tv_pos =MATH_VecBlendRotate( @o_snap_mainD OBJ_PosGet(), tv_pos, 4.0 * TIME_GetDt())
@o_snap_mainD OBJ_PosSet(tv_pos)
tv_pos -= OBJ_PosGet() + ( OBJ_BankingGet() * 5.0)
@o_snap_mainD OBJ_SightGeneralSet( tv_pos, Cv_VerticalVector)
@o_snap_mainD OBJ_RotateGlobalZ( Cf_PiBy6)
MSG_GlobalSetGao( mid_grabbed_LIAISON_ID, o_snap_mainD, GAO4)
tv_pos = OBJ_PosGet() + ( OBJ_BankingGet() * 5.0)
if ( MATH_AbsFloat( tf_dot) < 0.05)
{
	tv_pos += tv_KK_X * 1.5
	tv_pos -= tv_KK_Y * 0.25
}
else if ( tf_dot > 0.0)
{
	tv_pos += tv_KK_X * 1.0 
	tv_pos -= tv_KK_Y * 0.75
}
else
{
	tv_pos += tv_KK_X * 1.35 
	tv_pos += tv_KK_Y * 0.25
}
tv_pos =MATH_VecBlendRotate( @o_snap_mainG OBJ_PosGet(), tv_pos, 4.0 * TIME_GetDt())
@o_snap_mainG OBJ_PosSet(tv_pos)
tv_pos -= OBJ_PosGet() + ( OBJ_BankingGet() * 5.0)
@o_snap_mainG OBJ_SightGeneralSet( -tv_pos, Cv_VerticalVector)
@o_snap_mainG OBJ_RotateGlobalZ( -Cf_PiBy6)
MSG_GlobalSetGao( mid_grabbed_LIAISON_ID, o_snap_mainG, GAO5)