#include "it_defines.var"

vector	tv_pos
vector	tv_sight
vector	tv_temp

float		z,x,y,dx,dy,f
int			i,j,ni,nj

i_track = vrai

if (OBJ_CapaTest( CAPA_Force_Off ) )
{
	mi_On = faux
	OBJ_CapaSet( 0, CAPA_Allumee | CAPA_Force_On | CAPA_Force_Off )
	AI_TrackCurChange( "it_loop_off" )
	return
}

if (!i_callback)
	SpecialFlag_set( i_SF_State )

tv_pos = mv_FlammeCenter
tv_pos = MATH_VecLocalToGlobal( tv_pos )
tv_pos += OBJ_PosGet()

tv_sight = mv_FlammeAxe * mf_FlammeSize
tv_sight = MATH_VecLocalToGlobal( tv_sight )

if (mi_Vasque)
{
	if ( (mi_GFX == -1) && (mai_GFX[ 0 ] == -1) )
	{
		x = MATH_FloatMin( mv_VasqueSize.x,  3 )
		y = MATH_FloatMin( mv_VasqueSize.y, 3 )
		if ( x <= 1.01 ) ni = 1
		else if (x <= 2.01) ni = 2
		else ni = 3
		if ( y <= 1.01 ) nj = 1
		else if (y <= 2.01) nj = 2
		else nj = 3
		
		dx = x / ni
		dy = y / nj
		mi_GFXnb = 0
		for ( i = 0; i < ni; i++)
		{
			for (j = 0; j < nj; j++)
			{
				f = -(x / 2) + ((i + 0.5) * dx )
				tv_temp = f * OBJ_HorizonGet() 
				f = -(y / 2) + ((j + 0.5) * dy )
				tv_temp += f * OBJ_SightGet() 
				tv_temp.z -= 0.5
				
				z = mv_VasqueSize.z
				z /= MATH_FloatMax( dx, dy ) 

				mav_GFXPos[ mi_GFXnb ] = tv_temp

				mai_GFX[ mi_GFXnb ] = SPG2_FireAdd( tv_pos + tv_temp, 0 )
				SPG2_FireStateSet( mai_GFX[ mi_GFXnb ], 1 )
				SPG2_FireFloatSet( mai_GFX[ mi_GFXnb ], 0, MATH_FloatMax( dx, dy ) )
				SPG2_FireFloatSet( mai_GFX[ mi_GFXnb ], 2, z - 1 )
				mi_GFXnb++
			}
		}
	}
	else
	{
		for (i = 0; i < mi_GFXnb; i++)
			SPG2_FirePosSet( mai_GFX[ i ], tv_pos + mav_GFXPos[ i ] )
	}
}
else
{
//	if (mi_ComplexFlamme )
//	{
//		if (GFX_Flamme2_Halo == -1)
//			LIBGFX_JavelinFire2( tv_pos, tv_sight, 2.0, 1, &GFX_Flamme2[0], GFX_Flamme2_Halo, GFX_Flamme2_lastlastpos, GFX_Flamme2_lastpos)
//	}
//	else
//	{
		if( mi_Type )
			LIBGFX_PoisonGaz(mi_GFX, tv_pos + cvector(0,0,0.25), tv_sight, mi_Type)
		else
		{
			LIBGFX_JavelinFire( mi_GFX, tv_pos, tv_sight )
			if ( (mi_GFX == -1) && (mai_GFX[ 0 ] == -1) )
			{
				GFX_Setv(mi_GFX, 13201, mv_FlammeAxe)            				// Speed min
				GFX_Setv(mi_GFX, 13202, mv_FlammeAxe)           				// Speed max
				GFX_Setf(mi_GFX, 13009, 0.5)              								// Norm speed min
				GFX_Setf(mi_GFX, 13010, 1)              								// Norm speed max
			}
		}
//	}
	
	if (	! mi_Type && mi_Fumee )		// feu, fumée on
		LIGGFX_Fumee(mi_GFX1, mi_GFX2, OBJ_PosGet(), 1)
}
		
if ( (mi_Snd == -1 ) && (!mi_Optim_NoSound) )
{
	SND_RequestPlay( 0 )
	mi_Snd = SND_RequestPlayLoop( 1 )
}

if ( !mi_Optim_NoEvent )
{ 
	if (mi_Vasque )
	{
		if( mi_Type )
			EVENT_AddEventPoisonCylindre( mi_Type, OBJ_Me(), OBJ_PosGet() - cvector(0,0,0.25), OBJ_BankingGet() * (mv_VasqueSize.z * 2), MATH_FloatMax( mv_VasqueSize.x, mv_VasqueSize.y) * mf_VasqueEffectRatio )
		else
			EVENT_AddEventFireCylindre( OBJ_Me(), OBJ_PosGet() - cvector(0,0,0.25), OBJ_BankingGet() * (mv_VasqueSize.z * 2), MATH_FloatMax( mv_VasqueSize.x, mv_VasqueSize.y) * mf_VasqueEffectRatio )
		if ( DBG_IsObjSel() )
			DBG_RenderCylinder( OBJ_PosGet()- cvector(0,0,0.25), OBJ_BankingGet() * (mv_VasqueSize.z * 2), MATH_FloatMax( mv_VasqueSize.x, mv_VasqueSize.y) * mf_VasqueEffectRatio, color_rouge)
	}
	else
	{
		if( mi_Type )
			EVENT_AddEventPoisonSphere(mi_Type, OBJ_Me(), tv_pos, mf_FlammeEffectSize / mf_FlammeSize )
		else
			EVENT_AddEventFireSphere( OBJ_Me(), tv_pos, mf_FlammeEffectSize / mf_FlammeSize )
		if ( DBG_IsObjSel() )
			DBG_RenderSphere( tv_pos, mf_FlammeEffectSize / mf_FlammeSize, color_rouge)
 	}
}

