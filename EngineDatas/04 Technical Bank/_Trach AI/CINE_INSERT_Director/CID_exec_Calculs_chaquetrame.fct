vector	tv_POS_MODULE, tv_POS_CIBLE, tv_delta_pos
object	to_mainactor

to_mainactor = AI_MainActorGet(i_MainActor)

	DBG_EraseAllVectors()
	// CALCULS de placement de la caméra
	// A CHAQUE TRAME
	@get_insert_camera VIEW_AssignObject(0)
//	if	( (@"univ" i_jack != vrai) && (o_acteur_cible1) )
//	{	@to_mainactor des_o_acteur_suividesyeux = o_acteur_cible1	}

	// A CHAQUE TRAME
	if	(i_flags_courants & F_flag_Cam_mouvante)
	{
		// Calcul de la position de la camera "idéale"
		if	(i_flags_courants & F_flag_Placement_BM)
		{
			v_POS_CAM = @o_acteur_cam1 OBJ_PosGet() 
			tv_POS_MODULE = @o_canal_cam OBJ_PosGet()
			v_POS_CAM.z = tv_POS_MODULE.z
			v_POS_CAM += v_decalage
		}
		else
		{
			tv_POS_MODULE = @o_canal_cam OBJ_PosGet()
			v_POS_CAM = tv_POS_MODULE + v_decalage
		}
		// Pour tourner la caméra autour de l'acteur Cam
		if	(i_flags_courants & F_flag_Rotation_axiale)
		{
			tv_POS_CIBLE = MATH_VecNormalize(tv_POS_MODULE - v_POS_CIBLE)
			tv_POS_CIBLE += v_decalage //*= MATH_VecNorm(v_decalage)
//			tv_POS_CIBLE.z = v_decalage.z
			v_POS_CAM = tv_POS_MODULE + tv_POS_CIBLE
		}
		// Je vais borner le déplacement pour ne pas faire trop de chocs
		tv_delta_pos = v_POS_CAM - v_POS_CAM_old
//		DBG_RenderVector(v_POS_CAM, tv_delta_pos, 0xff8f0000)
		if	( ( ! MATH_VecNull(tv_delta_pos))
			&& ( MATH_VecNorm(tv_delta_pos) > F_delta_move_cam_max ) )
		{	tv_delta_pos = MATH_VecNormalize(tv_delta_pos) * F_delta_move_cam_max	}
//		DBG_RenderVector(v_POS_CAM, tv_delta_pos, 0xffff0000)
		v_POS_CAM = v_POS_CAM_old + tv_delta_pos
		v_POS_CAM_old = v_POS_CAM
		///////////////////////////// place la caméra /////////////////////////////
		@get_insert_camera OBJ_PosSet(v_POS_CAM)
	}

	if	(i_flags_courants & F_flag_Cible_mouvante)
	{
		// Calcul de la position de la cible "idéale"
		if	(@o_acteur_cible1 OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims) )
		{
			v_POS_CIBLE = @o_canal_cible OBJ_PosGet() + (v_decalage_cible)
		}
		else
		{
			tv_POS_MODULE = @o_canal_cible BV_MaxGet()
			tv_POS_MODULE.x = 0
			tv_POS_MODULE.y = 0
			v_POS_CIBLE = (@o_canal_cible OBJ_PosGet() + tv_POS_MODULE) + (v_decalage_cible * 2)
		}
		// 2e Calcul pour cibler entre les 2 acteurs
		if	(i_flags_courants & F_flag_Cible_milieu)
		{
			tv_POS_CIBLE = tv_POS_MODULE - v_POS_CIBLE
			tv_POS_CIBLE *= 0.25 //*= MATH_VecNorm(v_decalage)
			DBG_RenderVector(v_POS_CIBLE, tv_POS_CIBLE, 0xff00ffff)
			v_POS_CIBLE += tv_POS_CIBLE
		}
		// Je vais borner le déplacement pour ne pas faire trop de chocs
		tv_delta_pos = v_POS_CIBLE - v_POS_CIBLE_old
		if	( ( ! MATH_VecNull(tv_delta_pos))
			&& (MATH_VecNorm(tv_delta_pos) > F_delta_move_cible_max ) )
		{	tv_delta_pos = MATH_VecNormalize(tv_delta_pos) * F_delta_move_cible_max	}
		v_POS_CIBLE = v_POS_CIBLE_old + tv_delta_pos
		v_POS_CIBLE_old = v_POS_CIBLE
	}

	if	(i_flags_courants & F_flag_Cible_mouvante)
		@get_insert_camera OBJ_SightSet(v_POS_CIBLE - v_POS_CAM)
	f_time_elapsed += TIME_GetDt()
	@get_camera OBJ_CapaSet(OBJ_Capa_0, 0)
	// A CHAQUE TRAME
