procedure void MATH_Global_Rotate_Vector( object po_gao, vector pv_position,  vector pv_from, vector pv_to, float pf_blend)
{
	vector	pv_position_avant, pv_position_apres
	// Position du point d accroche
	pv_position_avant = @po_gao OBJ_PosGet() - pv_position


	pv_position_avant = MATH_VecGlobalToLocal(pv_position_avant)
	pv_to = MATH_VecBlendRotate( pv_from, pv_to, pf_blend)
	@po_gao OBJ_Rotate_FromTo( MATH_VecGlobalToLocal(pv_from), MATH_VecGlobalToLocal( pv_to ))
	pv_position_apres = MATH_VecLocalToGlobal(pv_position_avant)		

	// Positionement de Kong pour que le point d accroche soit conservé
	OBJ_PosSet( pv_position + pv_position_apres )
	// -----------------------------------------------------------------------------------------
}

procedure void MATH_Global_Rotate_Angle( object po_gao, vector pv_position, vector pv_axe, float pf_angle)
{
	// JAMAIS TESTE
	vector	pv_position_avant, pv_position_apres
	// Position du point d accroche
	pv_position_avant = @po_gao OBJ_PosGet() - pv_position


	pv_position_avant = MATH_VecGlobalToLocal(pv_position_avant)
	@po_gao OBJ_RotateAroundVec( pv_axe, pf_angle)
	pv_position_apres = MATH_VecLocalToGlobal(pv_position_avant)		

	// Positionement de Kong pour que le point d accroche soit conservé
	OBJ_PosSet( pv_position + pv_position_apres )
	// -----------------------------------------------------------------------------------------
}
//-------------------------------------------------------------------------------


#define DGB_Finish_Kong						\
	#ifndef _FINAL_								\
		if (! MSG_GlobalIsValid(EVT_ID))	\
			DBG_BreakPoint()					\
		else if (MSG_GlobalGetType(EVT_ID) != ( Ci_LNK_EVENT_OFFSET + Ci_LNK_KKFINISH_ON_KONG))\
			DBG_BreakPoint()					\
	#endif
procedure void	LNK_Finish_ActionSet(messageid EVT_ID, int pi_value)
{
	DGB_Finish_Kong
	MSG_GlobalSetInt(EVT_ID, pi_value, INT2)
}
procedure int	LNK_Finish_ActionGet(messageid EVT_ID)
{
	DGB_Finish_Kong
	return( MSG_GlobalGetInt(EVT_ID, INT2))
}

procedure void LNK_Finish_FinisherTypeSet(messageid EVT_ID, int pi_value)
{
	DGB_Finish_Kong
	MSG_GlobalSetInt(EVT_ID, pi_value, INT3)
}

procedure int LNK_Finish_FinisherTypeGet(messageid EVT_ID)
{
	DGB_Finish_Kong
	return( MSG_GlobalGetInt(EVT_ID, INT3) )
}


//==========================================================
// Finish attack coordination EVENT

#ifdef _FINAL_
#define M_EVENT_InfoFinishSynchroCheck
#endif

#ifndef _FINAL_
#define M_EVENT_InfoFinishSynchroCheck\
	if (! MSG_GlobalIsValid(EVT_ID))\
		DBG_BreakPoint()\
	else if (MSG_GlobalGetType(EVT_ID)	!= C_EVENT_TYPE_Info)\
		DBG_BreakPoint()\
	else if (MSG_GlobalGetInt( EVT_ID, INT1) != C_EVENT_INFOTYPE_FINISHSYNCHRO)\
		DBG_BreakPoint()
#endif

procedure void EVENT_Info_FinishStateSet(messageid EVT_ID, int ti_newState )
{
	M_EVENT_InfoFinishSynchroCheck
	MSG_GlobalSetInt( EVT_ID, ti_newState, INT2)
}

// temp put in GST_EVENT_Lib as soon as it works
procedure int EVENT_Info_FinishStateGet(messageid EVT_ID)
{
	M_EVENT_InfoFinishSynchroCheck
	return(MSG_GlobalGetInt( EVT_ID, INT2))
}

procedure int EVENT_Info_NbFinishParticipant( messageid EVT_ID )
{
	M_EVENT_InfoFinishSynchroCheck
	return(MSG_GlobalGetInt( EVT_ID, INT3))
}

// adds a participant to the finish and adjust finish state
// returns if add was successfull or not
procedure int EVENT_Info_FinishParticipantAdd( messageid EVT_ID, object to_participant )
{
	int ti_accepted

	M_EVENT_InfoFinishSynchroCheck
	ti_accepted = faux
	switch (EVENT_Info_FinishStateGet(EVT_ID))
	{
		case Ci_FINISHSYNCHRO_STATE_NoFinish :
			EVENT_Info_FinishStateSet( EVT_ID, Ci_FINISHSYNCHRO_STATE_Prepare )
			ti_accepted = vrai
			break
			
		case Ci_FINISHSYNCHRO_STATE_Prepare : 
			// just another participant arriving
			ti_accepted = vrai
			break
			
		case Ci_FINISHSYNCHRO_STATE_Finishing : 
			// should not happen participants already finishing
			ti_accepted = faux
			break
	
		default:
			// all done states		
			ti_accepted = faux
			break
	}
	
	if (ti_accepted)
	{
		MSG_GlobalSetInt( EVT_ID, MSG_GlobalGetInt( EVT_ID, INT3) + 1, INT3)
	}
		
	return ti_accepted
}


procedure int EVENT_Info_FinishParticipantRemove( messageid EVT_ID, object to_participant )
{
	int ti_nbParticipants
	M_EVENT_InfoFinishSynchroCheck
	
	ti_nbParticipants = MSG_GlobalGetInt( EVT_ID, INT3)
	if (ti_nbParticipants == 0)
	{
		DBG_BreakPoint()	// mismatch : there is no more to be removed
		return faux
	}
	else
	{
		ti_nbParticipants--
		MSG_GlobalSetInt( EVT_ID, ti_nbParticipants, INT3)
	}

	// last one sets it to no finish
	if (ti_nbParticipants == 0)
	{
		EVENT_Info_FinishStateSet( EVT_ID, Ci_FINISHSYNCHRO_STATE_NoFinish )
		return vrai
	}

	switch (EVENT_Info_FinishStateGet(EVT_ID))
	{
		case Ci_FINISHSYNCHRO_STATE_NoFinish :
			break
			
		case Ci_FINISHSYNCHRO_STATE_Prepare : 
			// a required participant left : we need to abort
			EVENT_Info_FinishStateSet( EVT_ID, Ci_FINISHSYNCHRO_STATE_Done )
			break
			
		case Ci_FINISHSYNCHRO_STATE_Finishing : 
			// should not happen participants already finishing
			EVENT_Info_FinishStateSet( EVT_ID, Ci_FINISHSYNCHRO_STATE_Done )
			break
		
		default:	
			break
	}

	return vrai
}



//==========================================================
// Last Attack data 
//
// The Sender is the gao beeing attacked and there is globally only one message
// to store the data pertaining to attacks perpetrated on him
//
// The last attack data (type / time / attacker gao) are stored in this global message
// down here are the getter and setter functions
// You can retreive the unique message by calling EVENT_Info_LastAttackGetData
// and store it in a local messageid as it will always exist
//
// note: data is up to date if attackers have updated the data

#ifdef _FINAL_
#define M_EVENT_InfoLastAttackCheck
#endif

#ifndef _FINAL_
#define M_EVENT_InfoLastAttackCheck\
	if (! MSG_GlobalIsValid(EVT_ID))\
		DBG_BreakPoint()\
	else if (MSG_GlobalGetType(EVT_ID)	!= C_EVENT_TYPE_Info)\
		DBG_BreakPoint()\
	else if (MSG_GlobalGetInt( EVT_ID, INT1) != C_EVENT_INFOTYPE_LASTATTACK)\
		DBG_BreakPoint()
#endif


procedure void EVENT_Info_LastAttackTypeSet( messageid EVT_ID, int ti_attackType )
{
	M_EVENT_InfoLastAttackCheck
	MSG_GlobalSetInt( EVT_ID, ti_attackType, INT2)
}

procedure int EVENT_Info_LastAttackTypeGet( messageid EVT_ID )
{
	M_EVENT_InfoLastAttackCheck
	return (MSG_GlobalGetInt( EVT_ID, INT2))
}

// TIME is set with the current TIME_Get() typically
// to know how much time has elapsed since last attack, use TIME_Get() - EVENT_Info_LastAttackTimeGet
procedure void EVENT_Info_LastAttackTimeSet( messageid EVT_ID, float tf_attackTime )
{
	vector tv_tmp
	M_EVENT_InfoLastAttackCheck
	tv_tmp.x = tf_attackTime
	tv_tmp.y = 0.0
	tv_tmp.z = 0.0
	MSG_GlobalSetVector( EVT_ID, tv_tmp, VEC1, VEC_X)
}

procedure float EVENT_Info_LastAttackTimeGet( messageid EVT_ID )
{
	vector tv_tmp
	M_EVENT_InfoLastAttackCheck
	tv_tmp = MSG_GlobalGetVector( EVT_ID, VEC1)
	return tv_tmp.x
}

// Last Attacker setter and getter
procedure void EVENT_Info_LastAttackGaoSet( messageid EVT_ID, object to_attacker )
{
	M_EVENT_InfoLastAttackCheck
	MSG_GlobalSetGao( EVT_ID, to_attacker, GAO1)
}

procedure object EVENT_Info_LastAttackGaoGet( messageid EVT_ID )
{
	M_EVENT_InfoLastAttackCheck
	return MSG_GlobalGetGao( EVT_ID, GAO1)
}

// function that has all arguments in one
procedure void EVENT_Info_LastAttackSet( messageid EVT_ID, int ti_type, float tf_time, object to_attacker )
{
	EVENT_Info_LastAttackTypeSet(EVT_ID, ti_type)
	EVENT_Info_LastAttackTimeSet(EVT_ID, tf_time)
	EVENT_Info_LastAttackGaoSet(EVT_ID, to_attacker)
}

procedure void EVENT_Info_LastAttackGet( messageid EVT_ID, byref int ti_type, byref float tf_time, byref object to_attacker )
{
	ti_type = 		EVENT_Info_LastAttackTypeGet(EVT_ID)
	tf_time = 		EVENT_Info_LastAttackTimeGet(EVT_ID)
	to_attacker = 	EVENT_Info_LastAttackGaoGet(EVT_ID)
}



// retreives or creates the global message that keeps the data on the last attack for an actor
// if event is not created yet it creates it
procedure messageid EVENT_Info_LastAttackGetData( object to_actor )
{
	int					ti_rank
	messageid		tmid_info_event
	messageid		tmid_result
	message		tm_tmp
	object			to_me

	MSG_SetNull(tm_tmp)
	tm_tmp.msg_sender = to_actor
	tm_tmp.msg_gao1 = nobody
	tm_tmp.msg_int1 = C_EVENT_INFOTYPE_LASTATTACK

	ti_rank = -1
	tmid_info_event = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Info, &ti_rank, tm_tmp)
	if (MSG_GlobalIsValid(tmid_info_event))	
	{
		tmid_result = tmid_info_event
	}
	else
	{
		MSG_SetNull( tm_tmp )
		tm_tmp.msg_int1 = C_EVENT_INFOTYPE_LASTATTACK
		tmid_result = @to_actor MSG_GlobalSend( C_EVENT_TYPE_Info, 0.0, tm_tmp, C_EVENT_Infini )
	}
	return tmid_result
}

