#include "KCG_Defines.var"

vector	v_KongPos
vector	v_SwingPos
object	o_Bone
int			i_Index
float		f_DT
float		f_Sign
object	o_SubObject
float		f_AbsDistance

v_KongPos 			= @mo_Kong OBJ_PosGet()
v_SwingPos			= @mo_Swing OBJ_PosGet()

// use Kong's distance from the swing to determine how much up or down the system should go
mf_LastSwingMagnitude = mf_SwingMagnitude

mf_SwingMagnitude	= ( ( v_SwingPos.z - v_KongPos.z ) / 10.5 * mf_MaxDistanceTraveledBySwing )

if ( mf_SwingMagnitude > mf_Max_SwingMagnitude * mf_MaxDistanceTraveledBySwing )
{
	mf_SwingMagnitude  = mf_Max_SwingMagnitude * mf_MaxDistanceTraveledBySwing
}

// should we come back up or keep going down towards ground?
if ( ( !mi_ReverseBendDirection && mf_SwingMagnitude < mf_LastSwingMagnitude ) || ( mi_ReverseBendDirection && mf_SwingMagnitude > mf_LastSwingMagnitude ) )
{
	f_Sign = -1.0
	
	if ( !mi_ReverseBendDirection )
	{
		mf_DoReactionarySwing = vrai
	}
}
else
{
	f_Sign = 1.0
	
	if ( mi_ReverseBendDirection )
	{
		mf_DoReactionarySwing = vrai
	}
}

// if not capped, do the bend
if ( mf_DoReactionarySwing )
{
	for ( i_Index = C_FirstBone; i_Index <= C_LastBone; i_Index++ )
	{	
		o_Bone 			= ANI_CanalObjectGet( i_Index )
		o_SubObject	= mao_SubObjects[( i_Index - C_FirstBone + 1 )]
		
		@o_Bone OBJ_BankingSet( ( MATH_VecBlend( ( @o_Bone OBJ_BankingGet() ), ( OBJ_SightGet() * f_Sign ), ( 0.1 * mf_SwingMagnitude * TIME_GetDt() ) ) ) )
		
		if ( o_SubObject )
		{
			@o_SubObject OBJ_PosSet( @o_Bone OBJ_PosGet( ) )
			@o_SubObject OBJ_BankingSet( ( MATH_VecBlend( ( @o_Bone OBJ_BankingGet() ), ( OBJ_SightGet() * f_Sign ), ( 0.1 * mf_SwingMagnitude * TIME_GetDt() ) ) ) )
		}
	}	
}

// check if we have to cap the distance traveled in either direction.
f_AbsDistance = MATH_AbsFloat( MATH_VecDistance( mv_InitialSwingPosition, @mo_Swing OBJ_PosGet() ) )

if ( f_AbsDistance >= mf_MaxDistanceTraveledBySwing )
{
	mf_DoReactionarySwing = faux
}

// re-orient the swing to be in the initial direction
@mo_Swing OBJ_SightSet( mv_InitialSwingSight )

// Kong is not on, wait for him to get back on.
if ( !@mo_Kong Proc_KK_Test_Mode( ETAT_Kong_swing_arch ) || ( @mo_Kong Proc_KK_HotSpotGet() != mo_Swing ) )
{
	AI_TrackCurChange( "KCG_Wait" )
}

