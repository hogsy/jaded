#include "MAF_Defines.var"



AI_Execute("MAF_Exec_ComputePreLoop")

// check to see if player is still inside our <excite> zone
int ti_etatLoop
int ti_i
float tf_timerMin
float tf_timerMax
float tf_tmp
int ti_nbMouchesAroundTgt

string ts_fakeSound
//vector tv_tmp


v_generateurPos = @o_generateur OBJ_PosGet() + v_generateurOffset

v_generateurToTgt = @o_currentTarget OBJ_PosGet() - v_generateurPos
f_generateurToTgtDst = MATH_VecNorm(v_generateurToTgt)

ti_etatLoop = i_etat_courant	// might change in the following lines

//f_aggressivityMeter = 0.0

if (call_trigger(o_exciteTrigger))
{
	//===================
	// intruder INSIDE zone	
	//===================

	f_curTimeBeforeCalm = 0.0	// preparing next time we setup calm timer

	if (i_etat_courant == MAF_ETAT_Calm)
	{
		// was calm
		if (f_curTimeBeforeAggressive == 0.0)
		{
			// intruder just entered
			tf_timerMin = f_timeBeforeAggressive - f_timeBeforeAggressiveVariation
			tf_timerMax = f_timeBeforeAggressive + f_timeBeforeAggressiveVariation
			f_curTimeBeforeAggressive = MATH_RandFloat(tf_timerMin,tf_timerMax)
#ifdef MAF_DBG_TRACE			
			DBG_TraceString("intruder entered - becoming aggressive in ")
			DBG_TraceFloat(f_curTimeBeforeAggressive)
			DBG_TraceEOL()
#endif			
		}
	}	

	if (f_curTimeBeforeAggressive > 0)
	{
		// becoming aggressive countdown active
		f_curTimeBeforeAggressive -= TIME_GetDt()
		if (f_curTimeBeforeAggressive <= 0)
		{
			// countdown over : change
			ti_etatLoop = MAF_ETAT_Aggressive
			f_curTimeBeforeAggressive = 0.0
			f_aggressivityMeter = 1.0
#ifdef MAF_DBG_TRACE
			DBG_TraceString("Now becoming aggressive")
			DBG_TraceEOL()
#endif			
		}
		else
		{
			// adjust the aggressivity meter
			f_aggressivityMeter = 1.0 - (f_curTimeBeforeAggressive / f_timeBeforeAggressive)
			if (f_aggressivityMeter < 0.0)
				f_aggressivityMeter = 0.0
		}
	}
	else
	{
		// some leftover aggressivity... resume where we left off
		if (f_aggressivityMeter != 1.0)
			f_curTimeBeforeAggressive = (1.0-f_aggressivityMeter) * f_timeBeforeAggressive
	}
	

	if (i_nbMouches < i_nbMouchesMax - 1)	// -1 so that we leave room for the Traveling mouches 
	{
		// add another mouche around the target ?
		if (f_timeUntilNextMoucheAdd > 0.0)
		{
			f_timeUntilNextMoucheAdd -= TIME_GetDt()
			if (f_timeUntilNextMoucheAdd <= 0.0)
			{
				// became 0 -> add mouche
				f_timeUntilNextMoucheAdd = 0.0
				i_curMoucheState = MAF_MoucheState_AroundTgt
				AI_Execute("MAF_Exec_AddMouche")
			}
		}
		else
		{
			// add countdown for next add
			f_timeUntilNextMoucheAdd = MATH_RandFloat(0.4,1.5)
		}
	}
		
	if (i_nbMouches < i_nbMouchesMax ) // && i_etat_courant != MAF_ETAT_Calm)
	{
		// add another mouche that travels from nid to target ?
		if (f_timeUntilNextTravelingMouche > 0.0)
		{
			f_timeUntilNextTravelingMouche -= TIME_GetDt()
			if (f_timeUntilNextTravelingMouche <= 0.0)
			{
				// became 0 -> add mouche
				f_timeUntilNextTravelingMouche = 0.0
#ifdef MAF_SEND_HOVERING
				push(1)	// get oldest mouche
				push(-1)
				AI_Execute("MAF_Exec_GetMouche")
				i_curMouche = pop
				if (i_curMouche != -1)
				{
					av_moucheOrbitCenter[i_curMouche] = @ao_moucheList[i_curMouche] OBJ_PosGet()
					af_moucheOrbitTimeline[i_curMouche] = MATH_RandFloat(0,1)
					af_moucheOrbitSpeed[i_curMouche] = MATH_RandFloat(1.0,2.0)//(f_moucheOrbitSpdMin,f_moucheOrbitSpdMax)	// orbits per second
					af_moucheOrbitRadius[i_curMouche] = MATH_RandFloat(0.1,0.4)//(f_orbitRadiusMin,f_orbitRadiusMax)
					af_moucheOrbitRadiusDir[i_curMouche] = MATH_RandFloat(0.1,1)
					if (MATH_RandInt(0,2) == 1)
						af_moucheOrbitRadiusDir[i_curMouche] *= -1.0		// inverse for half of them
					ai_moucheOrbitWay[i_curMouche] = MATH_RandInt(0,2)
					ai_moucheState[i_curMouche] = MAF_MoucheState_GotoTarget
					
					// also add a new mouche near the nid
					i_curMoucheState = MAF_MoucheState_HomeHovering
					AI_Execute("MAF_Exec_AddMouche")
				}
#endif
#ifndef MAF_SEND_HOVERING				
				i_curMoucheState = MAF_MoucheState_GotoTarget
				AI_Execute("MAF_Exec_AddMouche")
#endif
			}
		}
		else
		{
			// add countdown for next add
			f_timeUntilNextTravelingMouche = MATH_RandFloat(0.4,1.5)
		}
	}
}
else
{
	//===================
	// intruder OUTSIDE zone	
	//===================

	f_curTimeBeforeAggressive = 0.0

	if (i_etat_courant != MAF_ETAT_Calm)
	{
		// was not calm
		if (f_curTimeBeforeCalm == 0.0)
		{
			// intruder just left
			tf_timerMin = f_timeBeforeCalm - f_timeBeforeCalmVariation
			tf_timerMax = f_timeBeforeCalm + f_timeBeforeCalmVariation
			f_curTimeBeforeCalm = MATH_RandFloat(tf_timerMin,tf_timerMax)
#ifdef MAF_DBG_TRACE
			DBG_TraceString("intruder left zone - becoming calm in ")
			DBG_TraceFloat(f_curTimeBeforeCalm)
			DBG_TraceEOL()
#endif			
		}
	}	

	if (f_curTimeBeforeCalm > 0)
	{
		f_curTimeBeforeCalm -= TIME_GetDt()
		if (f_curTimeBeforeCalm <= 0)
		{
			// countdown over : change
			ti_etatLoop = MAF_ETAT_Calm
			f_aggressivityMeter = 0.0
			f_curTimeBeforeCalm = 0.0
#ifdef MAF_DBG_TRACE
			DBG_TraceString("Now becoming calm")
			DBG_TraceEOL()
#endif			
		}
		else
		{
			// adjust the buzzing sound
			f_aggressivityMeter = f_curTimeBeforeCalm / f_timeBeforeCalm
			if (f_aggressivityMeter > 1.0)
				f_aggressivityMeter = 1.0
		}
	}
	else
	{
		// some leftover aggressivity... setup the cool down period
		if (f_aggressivityMeter != 0.0)
			f_curTimeBeforeCalm = f_aggressivityMeter * f_timeBeforeCalm
	}

	if (TIME_Get() > (f_timeOfLastDelMouche + 0.5))
	{
		push(MAF_MoucheState_AroundTgt)
		AI_Execute("MAF_Exec_NbMoucheWithState")
		ti_nbMouchesAroundTgt = pop

		for (ti_i = 0; ti_i < i_nbMouchesMax; ti_i++)
		{
			if (	IsMoucheActive(ao_moucheList[ti_i]) && ai_moucheState[ti_i] == MAF_MoucheState_AroundTgt)
			{
				if (ti_i == i_moucheWithSpeaker && ti_nbMouchesAroundTgt > 1)
					continue	// wait until the one with the speaker is the last one					

				if ( (@ao_moucheList[ti_i] OBJ_FlagsStatusGet()) & OBJ_C_StatusFlag_Culled)
				//tv_tmp = @ao_moucheList[ti_i] OBJ_PosGet() - @o_currentTarget OBJ_PosGet()
				//tv_tmp = MATH_VecNormalize(tv_tmp)
			
				//if (MATH_VecDotProduct(@o_currentTarget OBJ_SightGet(),tv_tmp ) < 0.0)
				{
					i_curMouche = ti_i
					AI_Execute("MAF_exec_DelMouche")
#ifdef MAF_DBG_TRACE
					DBG_TraceString("del mouche")
					DBG_TraceInt(ti_i)
					DBG_TraceEOL()
#endif					
					f_timeOfLastDelMouche = TIME_Get()
					break
				}
			}
		}
	}
}

//=========================================
// adjust buzzing sound
if (i_homeBuzzInstance != -1)
{
//	// adjust the distance based volume insert
//	// Insert var 0
//	if (f_generateurToTgtDst >= MAF_SND_Insert0_FarDistance)
//		tf_tmp = 0.0
//	else
//		tf_tmp = 1.0 - (f_generateurToTgtDst / MAF_SND_Insert0_FarDistance)
//	SND_InsertVarSet(i_homeBuzzInstance,0,tf_tmp)
//
//	// adjust the aggressivity based volume insert
//	// Insert var 1
//	SND_InsertVarSet(i_homeBuzzInstance,1,f_aggressivityMeter)
}
	

#ifdef MAF_BUZZ_DBG_STRING
if (f_aggressivityMeter == 1.0)
	ts_fakeSound = "BZ.z.z.z.z.z.z.z.z.z.z (aggressive)"
else if (f_aggressivityMeter > 0.9)
	ts_fakeSound = "BZ.z.z.z.z.z.z.z.z.z."
else if (f_aggressivityMeter > 0.8)
	ts_fakeSound = "BZ.z.z.z.z.z.z.z.z"
else if (f_aggressivityMeter > 0.7)
	ts_fakeSound = "BZ.z.z.z.z.z.z.z."
else if (f_aggressivityMeter > 0.6)
	ts_fakeSound = "BZ.z.z.z.z.z.z."
else if (f_aggressivityMeter > 0.5)
	ts_fakeSound = "BZ.z.z.z.z.z."
else if (f_aggressivityMeter > 0.4)
	ts_fakeSound = "BZ.z.z.z.z."
else if (f_aggressivityMeter > 0.3)
	ts_fakeSound = "BZ.z.z.z."
else if (f_aggressivityMeter > 0.2)
	ts_fakeSound = "BZ.z.z."
else if (f_aggressivityMeter > 0.1)
	ts_fakeSound = "BZ.z."
else
	ts_fakeSound = "BZ (calm)"
STR_CreateText(ts_fakeSound, cvector(0.0, 0.05, 2.0), 0)
#endif

//int ti_capas
//int tb_triggerActif
//tb_triggerActif = OBJ_CapaTest(OBJ_Capa_1)

//switch (i_etat_courant)
//{
//	case MAF_ETAT_Calm :
//		macro_change_etat("MAF_ETAT_Calm")
//		break
		
//	case MAF_ETAT_Aggressive :
//		macro_change_etat("MAF_ETAT_Aggressive")
//		break
		
//	case MAF_ETAT_Pissed :
//		macro_change_etat("MAF_ETAT_Pissed")
//		break
//}




switch (ti_etatLoop)
{
	case MAF_ETAT_Calm :
		AI_Execute("MAF_ETAT_Calm")
		break
		
	case MAF_ETAT_Aggressive :
		AI_Execute("MAF_ETAT_Aggressive")
		break
		
	case MAF_ETAT_Pissed :
		AI_Execute("MAF_ETAT_Pissed")
		break
}

AI_Execute("MAF_Exec_ProcessMouches")

AI_Execute("MAF_Exec_ComputePostLoop")


