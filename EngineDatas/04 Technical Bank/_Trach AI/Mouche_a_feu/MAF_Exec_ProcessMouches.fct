#include "MAF_Defines.var"

//#define MAF_DBG_RENDER_ORBIT_CENTER

vector tv_newPos
vector tv_dirToTarget
vector tv_tmp

float tf_distToTarget
int ti_mouche
object to_mouche
float tf_horizonHeightDelta		// used to move the mouches up or down so that they better follow the camera


if (i_nbMouches == 0)
	return
	
tv_tmp = @o_currentTarget OBJ_SightGet()
tf_horizonHeightDelta = tv_tmp.z * 1.5

for (ti_mouche = 0; ti_mouche < i_nbMouchesMax; ti_mouche++)
{
	to_mouche = ao_moucheList[ti_mouche]

	if (!IsMoucheActive(to_mouche))
		continue

	av_moucheOldPos[ti_mouche] = @ao_moucheList[ti_mouche] OBJ_PosGet()

	i_curMouche = ti_mouche
	switch (ai_moucheState[ti_mouche])
	{
		
	//===========================================================
	//	The mouche is hovering around home
	//
	case MAF_MoucheState_HomeHovering :
	
		if (vrai) //(i_etat_courant == MAF_ETAT_Calm)
		{
			//@orb if (! @o_homeBV COL_BV_PointCollide(@to_mouche OBJ_PosGet()) )
			if (! @o_homeBV COL_BV_PointCollide(av_moucheOrbitCenter[ti_mouche]) )
			{
				// mouche is leaving home
				// for now just invert the vector and replace the mouche inside
				//av_moucheSpd[ti_mouche] *= -1
				// ... or aim close to the center
				ChooseRandomSpeedVector(tv_tmp,1.0,1.0,1.0)
				tv_tmp += @o_homeBV OBJ_PosGet()
				tv_tmp -= av_moucheOrbitCenter[ti_mouche]
				av_moucheSpd[ti_mouche] = tv_tmp
				MATH_VecSetNorm(av_moucheSpd[ti_mouche],MATH_RandFloat(0.2,MAF_MAX_OrbitCenterSpd_X))
			
				tv_newPos = av_moucheOrbitCenter[ti_mouche]
				tv_newPos += av_moucheSpd[ti_mouche] * 0.1
			}
			else
			{
				// mouche is still home
				// ohterwise just move
				
				// if it's close to center, change direction
				// to have a butterfly behaviour, just remove the (0)//
				if (0)//(MATH_VecNorm( av_moucheOrbitCenter[ti_mouche] - (@o_generateur OBJ_PosGet()+v_generateurOffset) ) < 0.5)
				{
					ChooseRandomSpeedVector(
						av_moucheSpd[ti_mouche],
						MAF_MAX_OrbitCenterSpd_X,
						MAF_MAX_OrbitCenterSpd_Y,
						MAF_MAX_OrbitCenterSpd_Z)
					
				}				
		
				tv_newPos = av_moucheOrbitCenter[ti_mouche]
				tv_newPos += TIME_GetDt() * av_moucheSpd[ti_mouche]
				
#ifdef MAF_DBG_RENDER_ORBIT_CENTER
				DBG_RenderVector(av_moucheOrbitCenter[ti_mouche],@ao_moucheList[ti_mouche] OBJ_PosGet() - av_moucheOrbitCenter[ti_mouche],0x80008000)
				DBG_RenderSphere(av_moucheOrbitCenter[ti_mouche],0.1,0x80008000)
#endif
			}
			av_moucheOrbitCenter[ti_mouche] = tv_newPos
			
			i_curMouche = ti_mouche
			AI_Execute("MAF_Exec_MoveMoucheOnOrbit")
		}
		else if (i_etat_courant == MAF_ETAT_Aggressive)
		{
			// needs to reach the player
			//ai_moucheState[ti_mouche] = MAF_MoucheState_GotoTarget
		}
		break

	//===========================================================
	//	The mouche is going towards the target
	//
	case MAF_MoucheState_GotoTarget :

		if (faux) //(i_etat_courant == MAF_ETAT_Calm)
		{
			ai_moucheState[ti_mouche] = MAF_MoucheState_GobackHome
		}
		else
		{
#ifdef MAF_TRAVEL_STRAIGHT
			// move		
			//tv_tmp = @o_currentTarget OBJ_SightGet()
			tv_tmp = @o_currentTarget OBJ_PosGet()
			//tv_tmp *= -2.0
			tv_dirToTarget = (@o_currentTarget OBJ_PosGet() + tv_tmp) - @to_mouche OBJ_PosGet()
			tf_distToTarget = MATH_VecNorm(tv_dirToTarget)
	
			tv_tmp = MATH_VecNormalize(tv_dirToTarget)
			tv_tmp *= (f_moucheTopSpeed * tf_modifiedDT)
			tv_newPos = @to_mouche OBJ_PosGet() + tv_tmp
			
			i_curMouche = ti_mouche
			@to_mouche OBJ_PosSet(tv_newPos)
			
			// if we are close enough, dissapear
			if (tf_distToTarget < MAF_Cf_DistForTargetHovering)
			{
				i_curMouche = ti_mouche
				AI_Execute("MAF_exec_DelMouche")
			}
#endif		
#ifndef MAF_TRAVEL_STRAIGHT
			// move		
			tv_dirToTarget = @o_currentTarget OBJ_PosGet() - av_moucheOrbitCenter[ti_mouche]
			tf_distToTarget = MATH_VecNorm(tv_dirToTarget)
	
			tv_tmp = MATH_VecNormalize(tv_dirToTarget)
			tv_tmp *= (f_moucheTopSpeed * TIME_GetDt())
			tv_newPos = av_moucheOrbitCenter[ti_mouche] + tv_tmp
			
			av_moucheOrbitCenter[ti_mouche] = tv_newPos
			
			i_curMouche = ti_mouche
			AI_Execute("MAF_Exec_MoveMoucheOnOrbit")
			
			// if we are close enough, dissapear
			if (tf_distToTarget < MAF_Cf_DistForTargetHovering)
			{
				i_curMouche = ti_mouche
				AI_Execute("MAF_exec_DelMouche")
			}
#endif		
		
		}
		break
		
	//===========================================================
	//	The mouche is hovering around the target (in front of the camera)
	//
	case MAF_MoucheState_AroundTgt :

			// attempt at re-using orbiting code: no good result
			av_moucheOrbitCenter[ti_mouche] = @o_currentTarget OBJ_PosGet()
			av_moucheOrbitCenter[ti_mouche].z += tf_horizonHeightDelta
			i_curMouche = ti_mouche
			AI_Execute("MAF_Exec_MoveMoucheOnOrbit")

		break
		
		
	//===========================================================
	//	The mouche is going back home
	//
	case MAF_MoucheState_GobackHome :
	
		if (!i_etat_courant == MAF_ETAT_Calm)
		{
			ai_moucheState[ti_mouche] = MAF_MoucheState_GotoTarget
		}
		else
		{
			// move		
			tv_dirToTarget = @o_homeBV OBJ_PosGet() - @to_mouche OBJ_PosGet()
			tf_distToTarget = MATH_VecNorm(tv_dirToTarget)
	
			tv_tmp = MATH_VecNormalize(tv_dirToTarget)
			tv_tmp *= (f_moucheTopSpeed * TIME_GetDt())
			tv_newPos = @to_mouche OBJ_PosGet() + tv_tmp
			
			@to_mouche OBJ_PosSet(tv_newPos)
			
			// if we are close enough, switch
			if (tf_distToTarget < MAF_Cf_DistForTargetHovering)
			{
				ai_moucheState[ti_mouche] = MAF_MoucheState_HomeHovering
			}
		}
		break

	}
	
	if (IsMoucheActive(ao_moucheList[ti_mouche]))
	{
		// adjust sight to match direction of travel
		tv_tmp = (@ao_moucheList[ti_mouche] OBJ_PosGet()) - av_moucheOldPos[ti_mouche]
		if (!MATH_VecNull(tv_tmp))
		{
			tv_tmp = MATH_VecNormalize(tv_tmp)
			@ao_moucheList[ti_mouche] OBJ_SightSet(tv_tmp)
		}
	}
}