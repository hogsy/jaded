#include "PNJ_Scolo_defines.var"

Include_UltraProcedure_Header

#define Cf_pourcentage			0.3333
#define Cf_angle_ondule_ton_corps				0.5

procedure_local void PNJ_Scolo_Del_Interest()
{
	i_perceived_best_actor_index = -1
	if (MSG_GlobalIsValid(mid_best_interet))
	{
		MSG_GlobalDelete(mid_best_interet, C_EVENT_DEL)
		MSG_GlobalSetInvalid(mid_best_interet)
	}
}


procedure_local int PNJ_Scolo_IsWater(vector tv_pos)
{
	int		ti_capa	

	ti_capa = GRID_CapaGet(tv_pos)
	ti_capa &= tag_grid_terrain

	switch(ti_capa)
	{
		case Ci_sol_eau :
		case Ci_sol_eau_basse :
		case Ci_sol_eau_basse_herbe :
		case Ci_sol_eau_herbe :
		case Ci_sol_eau_mouche_feu :
			return(vrai)
		
		default:
			return(faux)
	}
}

procedure_local void PNJ_Scolo_Check_Javelin()
{
	int			ti_i
	int			ti_index
	int			ti_javelin_state
	
	object	to_lance	
	object	to_javelin_master

	if (i_flag_paf)
		return

	for (ti_i = 0; ti_i < 10; ti_i++)
	{
		if ( ao_javelin[ti_i] == nobody)
			continue

		to_lance = ao_javelin[ti_i]
			
		if (i_etat_courant == ETAT_Paf && TIME_Elapsed(f_time_javelin_paf, 3.0))
		{
			i_perfored_module_index = -1
		
			macro_set_javelin_plug_timer(ao_javelin[ti_i], 0.0)
			ao_javelin[ti_i] = nobody
		
			if (ai_javelin_bone_index[ti_i] != -1)
			{
				ai_modules_locked[ai_javelin_bone_index[ti_i]] = faux
				ai_modules_perfored[ai_javelin_bone_index[ti_i]] = faux
				ai_javelin_bone_index[ti_i] = -1
			}

			continue
		}
		
		ti_index = ARR_ObjSearch(&@get_global ao_Lances[ti_i], Ci_bambou_maxinmap, to_lance)
		if (ti_index == -1)
		{
			i_perfored_module_index = -1
		
			ai_modules_locked[ai_javelin_bone_index[ti_i]] = faux
			ai_modules_perfored[ai_javelin_bone_index[ti_i]] = faux
			ai_javelin_bone_index[ti_i] = -1
			ao_javelin[ti_i] = nobody
			continue
		}

		ti_javelin_state = @get_Arme_Lance_path to_lance mi_State 
		to_javelin_master = @get_Arme_Lance_path to_lance o_plug_to_master

		if (ti_javelin_state != Ci_bambou_state_plug || to_javelin_master != OBJ_Me())
		{
			i_perfored_module_index = -1
		
			ai_modules_locked[ai_javelin_bone_index[ti_i]] = faux
			ai_modules_perfored[ai_javelin_bone_index[ti_i]] = faux
			ai_javelin_bone_index[ti_i] = -1
			ao_javelin[ti_i] = nobody
		}
	}
}

procedure_local void PNJ_Scolo_Remove_Life(float tf_life_loss, object to_killer)
{
	float tf_last_lifecur
	
	tf_last_lifecur = f_lifecur

	f_lifecur -= MATH_FloatMin(f_lifecur, tf_life_loss)
	f_lifecur = MATH_FloatRound(f_lifecur, 0.01)
	
	if( Proc_KK_BigScolo() )
		f_lifecur = MATH_FloatMax(f_lifecur, 1.0) 	// KK Big Scolo = mourir d'un finish only et pas d'un paf
	
	if (tf_last_lifecur && !f_lifecur)
	{
		switch (i_modele)
		{
			case Ci_Modele_Cine :
			case Ci_Modele_Clair :
			case Ci_Modele_Standard	 :     	STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Scolo_Normal, 0) break
			case Ci_Modele_Sombre :			STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Scolo_Noir, 0) break
			case Ci_Modele_Big	 :
			case Ci_Modele_Pit	:				STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Scolo_Gros, 0) break
			default: 									STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Unkonwn, 0) break
		}
	}
}

procedure_local void PNJ_Scolo_Minimise_Life(float tf_max_life, object to_killer)
{
	float tf_last_lifecur
	
	tf_last_lifecur = f_lifecur

	f_lifecur = MATH_FloatMin(f_lifecur, tf_max_life)
	f_lifecur = MATH_FloatRound(f_lifecur, 0.01)

	if (tf_last_lifecur && !f_lifecur)
	{
		switch (i_modele)
		{
			case Ci_Modele_Cine :
			case Ci_Modele_Clair :
			case Ci_Modele_Standard	 :     	STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Scolo_Normal, 0) break
			case Ci_Modele_Sombre :			STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Scolo_Noir, 0) break
			case Ci_Modele_Big	 :
			case Ci_Modele_Pit	:				STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Scolo_Gros, 0) break
			default: 									STATS_IncEnemyKilled_New(to_killer, C_EnemyType_Unkonwn, 0) break
		}
	}
}

procedure_local void PNJ_Scolo_Bite_Dead_Meat()
{
	object	to_head_target	

	if (i_perceived_best_actor_index == -1)
		return

	if ( ! ( ai_perceived_status[i_perceived_best_actor_index] & Ci_PERCEIVED_IS_DEAD) )
		return

	if (ai_perceived_ID[i_perceived_best_actor_index] == C_ID_BatCharognard && ! @ao_perceived_actor[i_perceived_best_actor_index] OBJ_CapaTest(OBJ_Capa_15))
		return
		
	if (af_perceived_dist[i_perceived_best_actor_index] < 3.0)
	{
		if (SND_eat_loop == -1)
			SND_eat_loop = SND_RequestPlayLoopOnObjCanal(SND_EAT, Anim_Canal_Tete)

		if (TIME_Elapsed(f_time_eat, 1.0))
		{
			if (i_etat_courant == ETAT_Devore && i_etat_phase >= 2)
			{
				to_head_target = @ao_perceived_actor[i_perceived_best_actor_index] ANI_CanalObjectGet(Anim_Canal_Tete)
				if (! to_head_target )
					to_head_target = ao_perceived_actor[i_perceived_best_actor_index]
				LIBGFX_Mat_Blood(@to_head_target OBJ_PosGet(), 3.0)
			}
		
			f_time_eat = TIME_Get()
			EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_FoodChain, OBJ_Me(), Cf_EVENT_Duree_1Trame, ao_perceived_actor[i_perceived_best_actor_index], 1.0, OBJ_SightGet())

//			if (TIME_Elapsed(f_time_last_bite_sound, 1.0))
//			{
//				f_time_last_bite_sound = TIME_Get()
//				SND_RequestPlay(SND_BITE)
//			}
		}
	}
	else if (SND_eat_loop != -1 && af_perceived_dist[i_perceived_best_actor_index] > 6.0)
	{
		SND_Stop(SND_eat_loop)
		SND_eat_loop = -1
	}
}

procedure_local int PNJ_Scolo_Best_Interet_Update(int ti_index)
{
	int				ti_flag_update_best_interet	
	int				ti_flag_update_pos
	int				ti_flag_update_seen_time

	object		to_identified_actor
	object		to_last_best_interest_target

	if (ti_index == -1)
		return(-1)

	i_perceived_best_actor_index = ti_index
	o_best_interet_target = ao_perceived_actor[ti_index]

	ti_flag_update_pos = faux
	ti_flag_update_seen_time = faux

	if (ai_perceived_seen[ti_index] || o_best_interet_target == o_trigger_target || o_best_interet_target == o_proie || o_best_interet_target == o_predateur)
	{
		ti_flag_update_seen_time = vrai
		ti_flag_update_pos = vrai
		
		to_identified_actor = ao_perceived_actor[ti_index]
	}
	else if (ai_perceived_status[ti_index] & (Ci_PERCEIVED_HEARD | Ci_PERCEIVED_PAF))
	{
		// En cas de paf, je sais d'ou ça vient mais je ne considère pas que je le vois...
		ti_flag_update_pos = vrai
		to_identified_actor = ao_perceived_actor[ti_index]
	}
	
	if (ti_flag_update_pos)
	{
		if (! MSG_GlobalIsValid(mid_best_interet))
		{
			// JE N'AVAIS PAS D'INTERET
			mid_best_interet = EVENT_AddEventInteret(OBJ_Me(), Cf_Infinit, af_perceived_interest[ti_index], av_perceived_position[ti_index], to_identified_actor)
			EVENT_InteretVisionIDSet(mid_best_interet, C_ID_Scolo)
		}	
		else
		{
			to_last_best_interest_target = EVENT_InteretTargetGet(mid_best_interet)

			 if (ao_perceived_actor[ti_index] != to_last_best_interest_target)
			{
				// INTERET DIFFERENT DE L'ANCIEN
				MSG_GlobalDelete(mid_best_interet, C_EVENT_DEL)
				mid_best_interet = EVENT_AddEventInteret(OBJ_Me(), Cf_Infinit, af_perceived_interest[ti_index], av_perceived_position[ti_index], to_identified_actor)
				EVENT_InteretVisionIDSet(mid_best_interet, C_ID_Scolo)
			}
		}

		EVENT_InteretPositionSet(mid_best_interet, av_perceived_position[ti_index])
	}

	if (ti_flag_update_seen_time)
	{
		EVENT_InteretTargetSet(mid_best_interet, to_identified_actor)
		EVENT_InteretSeenTimeSet(mid_best_interet, TIME_Get())
	}

	if (ai_perceived_status[ti_index] & Ci_PERCEIVED_IS_DEAD)
		ai_perceived_status[ti_index] |= Ci_PERCEIVED_BODY_MEMORISED

	return(ti_index)
}

procedure_local void PNJ_Scolo_Test_Human_Collision()
{
	int		ti_i	

	float	tf_size

	tf_size = COL_ZoneSizeGet(C_zdm_pied)
	
	switch(i_etat_courant)
	{
		case ETAT_Attente :
		case ETAT_Apparition	:
			COL_ZoneSizeSet(C_zdm_pied, cvector(0.85, 0.85, 0.85))
			break
	}

	for (ti_i = 0; ti_i < i_perceived_actor_nb; ti_i++)
	{
		if ( ! IsThis_ID_Humain(ai_perceived_ID[ti_i]) )	
			continue

		if ( @"univ" Humains_PafTimer[ai_perceived_ID[ti_i]] )
			continue
	
		if (ai_perceived_status[ti_i] & (Ci_PERCEIVED_IS_DEAD | Ci_PERCEIVED_ALREADY_GRABBED))
			continue
	
		if (! COL_ObjectCollide(ao_perceived_actor[ti_i]) && ! OBJ_LIB_Virtual_Collision(OBJ_Me(), ao_perceived_actor[ti_i], faux) )
			continue
	
		if (ai_perceived_ID[ti_i] == C_ID_Joueur)
		{
			if (f_on_screen_duration < 1.0)
				continue	
		
			f_timer_after_main_collision = 0.5

			if (TIME_Elapsed(f_time_last_bite_sound, 1.0))
			{
				f_time_last_bite_sound = TIME_Get()
				SND_RequestPlay(SND_BITE)
			}

			EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Faible, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_jack, 10.0 * PAF_Unit, OBJ_SightGet())
			
			i_flag_jump = vrai
			v_jump_dest_pos = @ao_perceived_actor[ti_i] OBJ_PosGet()
			v_jump_dest_pos += @ao_perceived_actor[ti_i] OBJ_SightGet() * 4.0
		}
		else if ( ! tutorial ) // || ai_perceived_ID[ti_i] == C_ID_Denham )
		{
//			if( i_flag_kong_mode )		// demande une intéraction à KAnn
//				o_proie = LNK_ThisClientGet(ao_perceived_actor[ti_i], Ci_LNK_INTERACTION, mid_proie_LNK, grab_allowed, "PNJ_Scolo_exec_KK_interaction_add_data", nofunc, "PNJ_Scolo_exec_KK_interaction_init")
//			else
				o_proie = LNK_ThisClientGet(ao_perceived_actor[ti_i], Ci_LNK_GRAB_RAPTOR, mid_proie_LNK, grab_allowed, "PNJ_Scolo_exec_LNK_proie", nofunc, "PNJ_Scolo_exec_LNK_proie")
			if (o_proie)
			{
				PNJ_Scolo_Best_Interet_Update(ti_i)
				break
			}
			else
			{
				if (TIME_Elapsed(f_time_last_bite_sound, 1.0))
				{
					f_time_last_bite_sound = TIME_Get()
					SND_RequestPlay(SND_BITE)
				}
				EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Faible, OBJ_Me(), Cf_EVENT_Duree_1Trame, ao_perceived_actor[ti_i], 10.0 * PAF_Unit, OBJ_SightGet())
			}
		}
	}
	
	COL_ZoneSizeSet(C_zdm_pied, cvector(tf_size, tf_size, tf_size))
}

procedure_local void PNJ_Scolo_Del_Perceived_Actor(int ti_index)
{
	i_perceived_actor_nb--

	// EST-CE QU'ON EFFACE LE MAIN OU LA CIBLE COURANTE ?
//	if (ti_index == i_perceived_main_actor_index)
//		i_perceived_main_actor_index = -1
	if (ti_index == i_perceived_kong_index)
		i_perceived_kong_index = -1
	if (ti_index == i_perceived_jack_index)
		i_perceived_jack_index = -1
		
	if (ti_index == i_perceived_best_actor_index)
		i_perceived_best_actor_index = -1
	
	// EST-CE QU'ON DEPLACE LE MAIN OU LA CIBLE COURANTE ?
//	if (i_perceived_actor_nb == i_perceived_main_actor_index)
//		i_perceived_main_actor_index = ti_index
	if (i_perceived_actor_nb == i_perceived_kong_index)
		i_perceived_kong_index = ti_index
	if (i_perceived_actor_nb == i_perceived_jack_index)
		i_perceived_jack_index = ti_index
		
	if (i_perceived_actor_nb == i_perceived_best_actor_index)
		i_perceived_best_actor_index = ti_index

	// ON ECRASE CET ACTEUR AVEC LE DERNIER
	ai_perceived_accessible[ti_index] = ai_perceived_accessible[i_perceived_actor_nb]
//	ai_perceived_hiding_place_index[ti_index] = ai_perceived_hiding_place_index[i_perceived_actor_nb]
	ai_perceived_ID[ti_index] = ai_perceived_ID[i_perceived_actor_nb]
	ai_perceived_seen[ti_index] = ai_perceived_seen[i_perceived_actor_nb]
	ai_perceived_status[ti_index] = ai_perceived_status[i_perceived_actor_nb]
//	ai_perceived_territory[ti_index] = ai_perceived_territory[i_perceived_actor_nb]
	
	af_perceived_dist[ti_index] = af_perceived_dist[i_perceived_actor_nb]
	af_perceived_interest[ti_index] = af_perceived_interest[i_perceived_actor_nb]
//	af_perceived_life_ratio[ti_index] = af_perceived_life_ratio[i_perceived_actor_nb]
	
	ao_perceived_actor[ti_index] = ao_perceived_actor[i_perceived_actor_nb]
//	ao_perceived_nearest_wp[ti_index] = ao_perceived_nearest_wp[i_perceived_actor_nb]
	
	av_perceived_position[ti_index] = av_perceived_position[i_perceived_actor_nb]

	// ON EFFACE LES DONNEES DU DERNIER 
	ai_perceived_accessible[i_perceived_actor_nb] = faux
//	ai_perceived_hiding_place_index[i_perceived_actor_nb] = -1
	ai_perceived_ID[i_perceived_actor_nb] = -1
	ai_perceived_seen[i_perceived_actor_nb] = faux
	ai_perceived_status[i_perceived_actor_nb] = 0
//	ai_perceived_territory[i_perceived_actor_nb] = -1
	
	af_perceived_dist[i_perceived_actor_nb] = -1.0
	af_perceived_interest[i_perceived_actor_nb] = -1.0
//	af_perceived_life_ratio[i_perceived_actor_nb] = -1.0
	
	ao_perceived_actor[i_perceived_actor_nb] = nobody
//	ao_perceived_nearest_wp[i_perceived_actor_nb] = nobody
	
	av_perceived_position[i_perceived_actor_nb] = Cv_NullVector
}

procedure_local void PNJ_Scolo_Check_Perceived_Actor()
{
	int		ti_i
	
	for (ti_i = 0; ti_i < i_perceived_actor_nb; ti_i++)
	{
		if (i_perceived_bit_field & (1 << ti_i))
			continue
			
		PNJ_Scolo_Del_Perceived_Actor(ti_i)
	}
}

procedure_local int PNJ_Scolo_Add_Perceived_Actor(object to_actor, int ti_status, messageid tmid_visibility_ref)
{
	int					ti_k
	int					ti_index
	int					ti_rank

	float				tf_life_ratio

	object			to_nearest_wp
	object			to_serveur
	
	message		tmsg_filter

	messageid		tmid_lnk	
	messageid		tmid_visibility
	
	if (to_actor == o_ignore_target)
		return(-1)

	if (to_actor == o_ignore_target1)
		return(-1)
	
	if (to_actor == o_ignore_target2)
		return(-1)
		
	if (to_actor == o_ignore_target3)
		return(-1)

	if (to_actor == o_ignore_target4)
		return(-1)

	if (to_actor == o_ignore_target5)
		return(-1)

	if (to_actor == o_ignore_target6)
		return(-1)

	if (to_actor == o_ignore_target7)
		return(-1)

	if (to_actor == o_ignore_target8)
		return(-1)

	if (to_actor == o_ignore_target9)
		return(-1)

	tmid_visibility = tmid_visibility_ref

	tmid_visibility = tmid_visibility_ref

	// EST-CE QU'ON RAJOUTE CE PERSO A LA LISTE DE CEUX QU'ON VOIT ?
	ti_index = ARR_ObjSearch(&ao_perceived_actor[0], i_perceived_actor_nb, to_actor)
	if (ti_index == -1)
	{
		// ON RAJOUTE UN ACTEUR
		if (i_perceived_actor_nb == 20)
		{
			DBG_Error("Trop d'acteur dans cette map")
			return(-1)
		}	
	
		ti_index = i_perceived_actor_nb
		i_perceived_actor_nb ++
	}
		
	// SI ON N'A PAS ENCORE MIS LES INFOS A JOUR CETTE TRAME
	if ( ! (i_perceived_bit_field & (1 << ti_index)) )
	{
		ao_perceived_actor[ti_index] = to_actor

//		ai_perceived_hiding_place_index[ti_index] = -1

		ai_perceived_seen[ti_index] = faux

		ai_perceived_status[ti_index] &= Ci_PERCEIVED_MEMORY_MASK

		if (MSG_GlobalIsValid(tmid_visibility))
		{
			// EST-CE QUE C'EST UN CADAVRE DEJA TRAITE ?
			ai_perceived_ID[ti_index] = EVENT_VisionIDGet(tmid_visibility)

			tf_life_ratio = EVENT_VisionLifeStateGet(tmid_visibility) 

			if (ai_perceived_ID[ti_index] == C_ID_Kong)
			{
//				i_perceived_main_actor_index = ti_index
				i_perceived_kong_index = ti_index
			}
			else if ( IsThis_ID_Humain(ai_perceived_ID[ti_index]))
			{
				dont_scare_budies = faux
			
				if (ai_perceived_ID[ti_index] == C_ID_Joueur)
				{
//					i_perceived_main_actor_index = ti_index
					i_perceived_jack_index = ti_index
				}
				else if ( ! tf_life_ratio && to_actor != o_predateur )
				{
					PNJ_Scolo_Del_Perceived_Actor(ti_index)
					return(-1)
				}

				switch(@"univ" i_weapon_ID[ai_perceived_ID[ti_index]])
				{
					case Ci_weapon_ID_bambou :
					case Ci_weapon_ID_ossement :
//					case Ci_weapon_ID_bambou_moy :
//					case Ci_weapon_ID_bambou_petit :
						//if (@"KingKong/Humain" to_actor i_objet_en_main_param)
						if (@"univ" i_objenmain_param[ @"KingKong/Humain" to_actor i_id_humain ] )
							ai_perceived_status[ti_index] |= Ci_PERCEIVED_GET_FIRE	
						break
				}
			}
			else if (ai_perceived_ID[ti_index] == C_ID_Bidoche)
			{
				ai_perceived_status[ti_index] |= Ci_PERCEIVED_IS_DEAD
				if (@to_actor OBJ_CapaTest(CAPA_Bidoche_Oublie_Moi))
					ai_perceived_status[ti_index] &= ~(Ci_PERCEIVED_BODY_MEMORISED | Ci_PERCEIVED_BODY_UNREACHABLE)
			}
			else
			{
				if (tf_life_ratio > 0.0)
					ai_perceived_status[ti_index] &= ~(Ci_PERCEIVED_BODY_MEMORISED | Ci_PERCEIVED_BODY_UNREACHABLE)
				else
					ai_perceived_status[ti_index]	|= Ci_PERCEIVED_IS_DEAD
			}

			af_perceived_interest[ti_index] = EVENT_VisionInteretGet(tmid_visibility)
			av_perceived_position[ti_index] = EVENT_PositionGet(tmid_visibility)
//			ai_perceived_territory[ti_index] = EVENT_VisionTerritoryGet(tmid_visibility)

			if (ai_perceived_ID[ti_index] == C_ID_Joueur)
//				i_perceived_main_actor_index = ti_index
				i_perceived_jack_index = ti_index
		}
		else
		{
			af_perceived_interest[ti_index] = 30.0
			ai_perceived_ID[ti_index] = -1
			av_perceived_position[ti_index] = @to_actor OBJ_PosGet()
//			ai_perceived_territory[ti_index] = GST_EVENT_Territory_Get(av_perceived_position[ti_index])
		}

		af_perceived_dist[ti_index] = MATH_VecNorm(av_perceived_position[ti_index] - OBJ_PosGet())

		if ( ! BV_ZoneTerritoire || @to_actor COL_Pivot_BVCollide(BV_ZoneTerritoire))
			ai_perceived_accessible[ti_index] = vrai
		else
			ai_perceived_accessible[ti_index] = faux

		ti_rank = -1
		MSG_SetNull(tmsg_filter)
		tmsg_filter.msg_sender = to_actor
//		if( i_flag_kong_mode )
//			tmid_lnk = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_INTERACTION, &ti_rank, tmsg_filter)
//		else
			tmid_lnk = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_GRAB_RAPTOR, &ti_rank, tmsg_filter)
		if (MSG_GlobalIsValid(tmid_lnk))
		{
			to_serveur = MSG_GlobalGetGao(tmid_lnk, SERVEUR)
			if (to_serveur && to_serveur != OBJ_Me())
				ai_perceived_status[ti_index] |= Ci_PERCEIVED_ALREADY_GRABBED
		}

		if (ai_perceived_status[ti_index] & Ci_PERCEIVED_GET_FIRE)
		{
			ai_perceived_status[ti_index] |= Ci_PERCEIVED_NEAR_FIRE
		}
		else
		{ 
			for (ti_k = 0; ti_k < i_fire_gao_nb; ti_k++)
			{
				 if (@to_actor OBJ_SqrDist(ao_fire_gao[ti_k]) < Cf_fire_sqr_dist)
				{
					ai_perceived_status[ti_index] |= Ci_PERCEIVED_NEAR_FIRE
					break
				}
			}
		}

//		if (! ai_perceived_accessible[ti_index] )
//		{
//			to_nearest_wp = PNJ_Scolo_Nearest_Wp_Get(av_perceived_position[ti_index], all, Ci_Capa_Out_Of_Grid | Ci_Capa_Exclusion)
//			if (PNJ_Scolo_Is_Wp_Memorised(to_nearest_wp))
//				ai_perceived_status[ti_index] |= Ci_PERCEIVED_ALREADY_CHECKED
//		}

		i_perceived_bit_field |= 1 << ti_index
	}

	ai_perceived_status[ti_index] |= ti_status

	return(ti_index)
}

procedure_local void PNJ_Scolo_Fill_Fire_Array()
{
	int					ti_i
	int					ti_rank
	
	messageid		tmid_fire
	
	if (@get_global  i_fire_flag_already_checked)
	{
		i_fire_gao_nb = @get_global i_fire_gao_nb
		
		for (ti_i = 0; ti_i < i_fire_gao_nb; ti_i++)
			ao_fire_gao[ti_i] = @get_global ao_fire_gao[ti_i]
	}
	else
	{
		@get_global i_fire_flag_already_checked = vrai	
		@get_global i_fire_gao_nb = 0
	
		i_fire_gao_nb = 0
		ti_rank = -1
		for (tmid_fire = MSG_GlobalScan(C_EVENT_TYPE_Fire, &ti_rank); MSG_GlobalIsValid(tmid_fire); tmid_fire = MSG_GlobalScan(C_EVENT_TYPE_Fire, &ti_rank))
		{
			ao_fire_gao[i_fire_gao_nb] = EVENT_PereGet(tmid_fire)
			@get_global ao_fire_gao[i_fire_gao_nb] = ao_fire_gao[i_fire_gao_nb]

			i_fire_gao_nb++
			@get_global i_fire_gao_nb = i_fire_gao_nb
		}
	}
}

procedure_local void PNJ_Scolo_Update_Near_Fire_Status()
{
	int		ti_i
	int		ti_k
	
	for (ti_i = 0; ti_i < i_perceived_actor_nb; ti_i++)
	{
		if (ai_perceived_status[ti_i] & Ci_PERCEIVED_GET_FIRE)
		{
			ai_perceived_status[ti_i] |= Ci_PERCEIVED_NEAR_FIRE	
			continue
		}

		for (ti_k = 0; ti_k < i_fire_gao_nb; ti_k++)
		{
			 if (@ao_perceived_actor[ti_i] OBJ_SqrDist(ao_fire_gao[ti_k]) < Cf_fire_sqr_dist)
			{
				ai_perceived_status[ti_i] |= Ci_PERCEIVED_NEAR_FIRE
				break
			}
		}
	}
}

procedure_local void PNJ_Scolo_Init_OBBOX(float tf_size_coef)
{
	int			ti_i
	object	to_bone	

	if (f_obbox_size_coef == tf_size_coef)
		return
		
	f_obbox_size_coef = tf_size_coef

	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
	{
		if (ti_i == i_modules_nb - 1)
			to_bone = ANI_CanalObjectGet(Anim_Canal_Bassin)
		else
			to_bone = ANI_CanalObjectGet(ti_i)
		@to_bone OBJ_FlagsIdentitySet(OBJ_C_IdentityFlag_OBBox, none)
		@to_bone BV_OBBoxMinSet(cvector(-0.25 * tf_size_coef, -0.25, -0.25 * tf_size_coef))
		@to_bone BV_OBBoxMaxSet(cvector(0.25 * tf_size_coef, 0.25 , 0.25 * tf_size_coef))
	}
}

procedure_local void PNJ_Scolo_Test_Target()
{
	int						ti_rank	

	float					tf_dist

	vector				tv_temp
	
	if (i_flag_hit)
		return

	if (!o_best_interet_target)
		return

	if (!f_lifecur)
		return

	tf_dist = 1.0
//	tf_dist += @o_best_interet_target COL_ZoneSizeGet(C_zde_corps)
//	tf_dist *= tf_dist

	tv_temp = @o_best_interet_target COL_ZonePosGet(C_zde_corps)
	tv_temp -= OBJ_PosGet()
	if (MATH_VecDotProduct(tv_temp, tv_temp) < tf_dist)
	{
		i_flag_hit = vrai
		EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Repousse, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_best_interet_target, 1.0 * PAF_Unit, OBJ_SightGet())

		if (TIME_Elapsed(f_time_last_bite_sound, 1.0))
		{
			f_time_last_bite_sound = TIME_Get()
			SND_RequestPlay(SND_BITE)
		}
	}
}

procedure_local void PNJ_Scolo_Init_Net()
{
	float		tf_Z_min
	float		tf_net_length

	object	to_wp_1
	object	to_wp_2
	object	to_wp_3
	object	to_sight_gao
	
	vector	tv_vec1
	vector	tv_vec2
	
	vector	tv_normale
	vector	tv_biscectrice

	// On oriente le sight des wp du reseau de maniere à avoir la perpendiculaire de chaques sommets

	if (!i_net_wp_nb || EDIT)
		i_net_wp_nb = WAY_NetFill(n_net, o_start_wp, &ao_net_wp[0])

	if (@ao_net_wp[i_net_wp_nb - 1] WAY_HasLinks(n_net, ao_net_wp[0]))
		i_net_loop = vrai

	if (net_mode)
		return

	if (!AUTO_COMPUTE)
		return

	to_wp_1 = o_start_wp
	if (WAY_GetNumLinks(n_net, to_wp_1) > 1)
	{
		// PLUSIEURS LIEN A CE WP
		DBG_BreakPoint()
	}
	to_wp_2 = WAY_NetNextWP(n_net, to_wp_1, 0, 0)
	if (WAY_GetNumLinks(n_net, to_wp_2) > 1)
	{
		// PLUSIEURS LIEN A CE WP
		DBG_BreakPoint()
	}

	to_wp_3 = WAY_NetNextWP(n_net, to_wp_2, 0, 0)
	
	if (AUTO_BANKING)
	{
		if (COL_RayObject_Dist(@to_wp_1 OBJ_PosGet(), -@to_wp_1 OBJ_BankingGet(), 3.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_normale = COL_RayObject_NormalGet()
			tv_normale.z = 0.0
			@to_wp_1 OBJ_BankingSet(tv_normale)
		}
	
		if (COL_RayObject_Dist(@to_wp_2 OBJ_PosGet(), -@to_wp_2 OBJ_BankingGet(), 3.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_normale = COL_RayObject_NormalGet()
			tv_normale.z = 0.0
			@to_wp_2 OBJ_BankingSet(tv_normale)
		}
	}

	@to_wp_1 OBJ_ZoomSet(1.0)
	@to_wp_1 OBJ_SightGeneralSet(@to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet(), @to_wp_1 OBJ_BankingGet())
	
	tf_net_length = 0.0
	
	// Smooth trajectory
	while (to_wp_2 != o_start_wp && to_wp_3)
	{
//		DBG_RenderVector(@to_wp_2 OBJ_PosGet(), @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet(), color_blanc)	
	
		if (WAY_GetNumLinks(n_net, to_wp_3) > 1)
		{
			// PLUSIEURS LIEN A CE WP
			DBG_BreakPoint()
		}

		tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		tf_net_length += MATH_VecNorm(tv_vec1)
	
		@to_wp_2 OBJ_ZoomSet(1.0)	
		@to_wp_3 OBJ_ZoomSet(1.0)

		if (AUTO_BANKING && COL_RayObject_Dist(@to_wp_3 OBJ_PosGet(), -@to_wp_3 OBJ_BankingGet(), 3.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_normale = COL_RayObject_NormalGet()
			tv_normale.z = 0.0
			@to_wp_3 OBJ_BankingSet(tv_normale)
		}
	
		tv_vec2 = @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		
		tv_normale = MATH_VecCrossProduct(tv_vec1, tv_vec2)
		MATH_VecSetNormalize(tv_normale)
		
		tv_biscectrice = MATH_VecBlendRotate(tv_vec1, tv_vec2, 0.5)

		@to_wp_2 OBJ_SightGeneralSet(MATH_VecCrossProduct(tv_normale, tv_biscectrice), @to_wp_2 OBJ_BankingGet())
	
		to_wp_1 = to_wp_2
		to_wp_2 = to_wp_3
		to_wp_3 = WAY_NetNextWP(n_net, to_wp_2, 0, 0)

		if (to_wp_2 == o_start_wp)
			i_net_loop = vrai

		if ( ! to_wp_3 || to_wp_2 == to_wp_3)
			break 
	}
	
	tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
	tf_net_length += MATH_VecNorm(tv_vec1)
	
	if (to_wp_3)	
	{
		tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		tv_vec2 = @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		
		tv_normale = MATH_VecCrossProduct(tv_vec1, tv_vec2)
		MATH_VecSetNormalize(tv_normale)
		
		tv_biscectrice = MATH_VecBlendRotate(tv_vec1, tv_vec2, 0.5)
	
		@to_wp_2 OBJ_SightGeneralSet(MATH_VecCrossProduct(tv_normale, tv_biscectrice), @to_wp_2 OBJ_BankingGet())
	}
	else
	{
		@to_wp_2 OBJ_SightGeneralSet(@to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet(), @to_wp_2 OBJ_BankingGet())
	}
}

procedure_local void PNJ_Scolo_Init_Modules()
{
	int			ti_i
	
	float		tf_size

	// TETE ============================================================================================
	if (!ao_modules[0])
	{	
		ao_modules[0] = OBJ_Me()
		@ao_modules[0] OBJ_FlagsIdentitySet(none, OBJ_C_IdentityFlag_OBBox)	

		tf_size = i_modules_nb * dist_between_module
	
//		DBG_RenderVector(OBJ_PosGet(), cvector(tf_size, 0.0, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(-tf_size, 0.0, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, tf_size, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, -tf_size, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, 0.0, tf_size), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, 0.0, -tf_size), color_cyan)
//		DBG_RenderSphere(OBJ_PosGet(), tf_size, 0x40FF00FF)

		tf_size *= 1.1

		@ao_modules[0] BV_MinSet(-cvector(tf_size, tf_size, tf_size))
		@ao_modules[0] BV_MaxSet(cvector(tf_size, tf_size, tf_size))

//		@ao_modules[0] OBJ_ZoomSet(f_size_coef)
		@ao_modules[0] OBJ_ScaleSet(@ao_modules[0] OBJ_ScaleGet() * f_size_coef)
	}

	i_current_wp_index = 0

	f_link_coef = (i_modules_nb - 2) * dist_between_module
	f_link_coef += dist_tail

	// CORPS ===========================================================================================
	for (ti_i = 1; ti_i < i_modules_nb - 1; ti_i++)
	{
		af_modules_length[ti_i] = ti_i * dist_between_module

		if (!ao_modules[ti_i])
		{	
			ao_modules[ti_i] = ANI_CanalObjectGet(ti_i)
			@ao_modules[ti_i] OBJ_HierarchyResetCurrent()
//			@ao_modules[ti_i] OBJ_ZoomSet(f_size_coef)
			@ao_modules[ti_i] OBJ_ScaleSet(@ao_modules[ti_i] OBJ_ScaleGet() * f_size_coef)
			@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i - 1] OBJ_PosGet() - (@ao_modules[ti_i - 1] OBJ_SightGet() * dist_between_module))
		}
	}
	
	// QUEUE =============================================================================================
	af_modules_length[ti_i] = af_modules_length[ti_i - 1] + dist_tail

	if (!ao_modules[ti_i])
	{
		ao_modules[ti_i] = ANI_CanalObjectGet(Anim_Canal_Bassin)
		@ao_modules[ti_i] OBJ_HierarchyResetCurrent()
//		@ao_modules[ti_i] OBJ_ZoomSet(f_size_coef)
		@ao_modules[ti_i] OBJ_ScaleSet(@ao_modules[ti_i] OBJ_ScaleGet() * f_size_coef)
		@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i - 1] OBJ_PosGet() - (@ao_modules[ti_i - 1] OBJ_SightGet() * dist_between_module))
	}
	
	PNJ_Scolo_Init_OBBOX(1.4)

	return
}

procedure_local void PNJ_Scolo_Align_Modules()
{
	int			ti_i
	
	// CORPS ===========================================================================================
	for (ti_i = 1; ti_i < i_modules_nb - 1; ti_i++)
	{
		@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i - 1] OBJ_PosGet() - (@ao_modules[ti_i - 1] OBJ_SightGet() * dist_between_module))
		@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet(), @ao_modules[ti_i - 1] OBJ_BankingGet())
	}
	
	// QUEUE =============================================================================================
	@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i - 1] OBJ_PosGet() - (@ao_modules[ti_i - 1] OBJ_SightGet() * dist_tail))
	@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet(), @ao_modules[ti_i - 1] OBJ_BankingGet())
	
	return
}

procedure_local void PNJ_Scolo_Update_Last_Virtual_Wp(object to_module, object to_father)
{
	int			ti_before_index	

	float		tf_Z_offset

	vector	tv_pos	

	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	if (to_father == nobody)
		to_father = OBJ_HierarchyGet()

	ti_before_index = MATH_Modulo(i_virtual_net_last_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

	av_virtual_wp_pos[i_virtual_net_last_wp_index] = @to_module OBJ_PosGet()
	av_virtual_wp_pos[i_virtual_net_last_wp_index] += @to_module OBJ_BankingGet() * f_Z_noise

	ai_virtual_wp_flag[i_virtual_net_last_wp_index] = 0
	if (f_delay_until_last_ground_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_ground_col
	if (f_delay_until_last_wall_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_wall_col
	if (@to_module OBJ_PosGet().z < f_water_Z + tf_Z_offset)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_water_col

	if (ao_virtual_wp_father[ti_before_index])
		tv_pos = @ao_virtual_wp_father[ti_before_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_before_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_before_index])
	else
		tv_pos = av_virtual_wp_pos[ti_before_index]
	af_virtual_link_length[i_virtual_net_last_wp_index] = MATH_VecNorm(tv_pos - av_virtual_wp_pos[i_virtual_net_last_wp_index])

	av_virtual_wp_sight[i_virtual_net_last_wp_index] = @to_module OBJ_SightGet()
	av_virtual_wp_banking[i_virtual_net_last_wp_index] = @to_module OBJ_BankingGet()

	ao_virtual_wp_father[i_virtual_net_last_wp_index] = to_father

	if (to_father)
	{	
		av_virtual_wp_pos[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_pos[i_virtual_net_last_wp_index] - @ao_virtual_wp_father[i_virtual_net_last_wp_index] OBJ_PosGet())
		av_virtual_wp_sight[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_sight[i_virtual_net_last_wp_index])
		av_virtual_wp_banking[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_banking[i_virtual_net_last_wp_index])
	}
}

procedure_local int PNJ_Scolo_Add_Virtual_Wp(object to_module, object to_father)
{
	int				ti_before_index	

	float			tf_Z_offset

	vector		tv_pos
	
	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	if (to_father == nobody)
		to_father = OBJ_HierarchyGet()

	ti_before_index = i_virtual_net_last_wp_index
	i_virtual_net_last_wp_index = MATH_Modulo(i_virtual_net_last_wp_index + 1, Ci_virtual_wp_nb)	

	av_virtual_wp_pos[i_virtual_net_last_wp_index] = @to_module OBJ_PosGet()
	av_virtual_wp_pos[i_virtual_net_last_wp_index] += @to_module OBJ_BankingGet() * f_Z_noise

	ai_virtual_wp_flag[i_virtual_net_last_wp_index] = 0
	if (f_delay_until_last_ground_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_ground_col
	if (f_delay_until_last_wall_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_wall_col
	if (@to_module OBJ_PosGet().z < f_water_Z + tf_Z_offset)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_water_col

	if (ti_before_index != -1)
	{
		if (ao_virtual_wp_father[ti_before_index])
			tv_pos = @ao_virtual_wp_father[ti_before_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_before_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_before_index])
		else
			tv_pos = av_virtual_wp_pos[ti_before_index]
		af_virtual_link_length[i_virtual_net_last_wp_index] = MATH_VecNorm(tv_pos - av_virtual_wp_pos[i_virtual_net_last_wp_index])
	}

	av_virtual_wp_sight[i_virtual_net_last_wp_index] = @to_module OBJ_SightGet()
	av_virtual_wp_banking[i_virtual_net_last_wp_index] = @to_module OBJ_BankingGet()

	ao_virtual_wp_father[i_virtual_net_last_wp_index] = to_father

	if (to_father)
	{
		av_virtual_wp_pos[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_pos[i_virtual_net_last_wp_index] - @ao_virtual_wp_father[i_virtual_net_last_wp_index] OBJ_PosGet())
		av_virtual_wp_sight[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_sight[i_virtual_net_last_wp_index])
		av_virtual_wp_banking[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_banking[i_virtual_net_last_wp_index])
	}

	return(i_virtual_net_last_wp_index)
}

procedure_local void PNJ_Scolo_Virtual_Net_Init(int ti_flag_update_wp_flag, object to_father)
{
	int			ti_i
	int			ti_index

	f_Z_noise = 0.0

	if (ti_flag_update_wp_flag)
	{
		i_on_ground_modules_nb = 0
		i_in_water_modules_nb = 0
	
		f_delay_until_last_ground_col = 1000.0
		f_delay_until_last_wall_col = 1000.0
	}

	for (ti_i = i_modules_nb - 1; ti_i >= 0; ti_i--)
	{
		ti_index = PNJ_Scolo_Add_Virtual_Wp(ao_modules[ti_i], to_father)

		if (ti_flag_update_wp_flag)
			ai_virtual_wp_flag[ti_index] = 0
	}

	return
}

procedure_local void PNJ_Scolo_Finish_Snake(object to_actor, int ti_first_index, float	tf_rigidity_coef, vector tv_father_speed)
{
	int			ti_i
	int			ti_iterations
	
	float		tf_norm
	float		tf_Z_offset
	float		tf_friction	
	float		tf_dot_product
	float		tf_time_offset
	float		tf_inv_dt

	vector	tv_move
	vector	tav_last_pos[15]
	vector	tv_precedent
	vector	tv_temp
	vector	tv_cylindre_pos
	
	object	to_bone

//	to_bone = @o_kk_finish ANI_CanalObjectGet(Anim_Canal_Ventre)
	to_bone = @to_actor ANI_CanalObjectGet(Anim_Canal_Bassin)
	DBG_RenderCylinder(@to_bone OBJ_PosGet() - (@to_bone OBJ_BankingGet() * 5.0), @to_bone OBJ_BankingGet() * 10.0, 2.0, 0x80008000)

	if (ti_first_index >= i_modules_nb )
	{
		v_ray_pos = OBJ_PosGet()
		v_ray_pos.z -= f_size_coef * 10.0
		v_ray_normal = Cv_VerticalVector
		return
	}

	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	// AJOUTER LA VITESSE ET LA GRAVITE
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
		
		tv_move = Cv_NullVector
		if (ti_i > ti_first_index)
			tv_move += 0.6 * av_modules_speed[ti_i]
		tv_move += cvector(0.0, 0.0, -1.0)
		tv_move += tv_father_speed
		tv_move *= TIME_GetDt()
	
		tv_temp = @ao_modules[ti_i] OBJ_PosGet()
		tv_temp += tv_move

		tv_cylindre_pos = tv_temp - @to_bone OBJ_PosGet()
		tf_norm = MATH_VecDotProduct(tv_cylindre_pos, @to_bone OBJ_BankingGet())
		if (tf_norm < 5.0)
		{
			tv_cylindre_pos -= tf_norm * @to_bone OBJ_BankingGet()
			
			tf_norm = MATH_VecSquareNorm(tv_cylindre_pos)
			if (tf_norm < 4.0)
			{
				tf_norm = MATH_FloatSqrt(tf_norm)
				tv_cylindre_pos /= tf_norm
				tf_norm = 2.0 - tf_norm
				tv_cylindre_pos *= tf_norm
				
				tv_temp += tv_cylindre_pos
			}
		}

		tf_dot_product = MATH_VecDotProduct(tv_temp - v_ray_pos, v_ray_normal) - tf_Z_offset
		if (tf_dot_product < 0.0)
		{
			tv_temp -= tf_dot_product * v_ray_normal
			tav_last_pos[ti_i] -= (MATH_VecDotProduct(tav_last_pos[ti_i]  - v_ray_pos, v_ray_normal) - tf_Z_offset) * v_ray_normal
		}
		
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}
	
	// EN SNAKE
	
	// CORPS
	for (ti_i = ti_first_index; ti_i < i_modules_nb - 1; ti_i++)
	{
		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i - 1] OBJ_PosGet()
		MATH_VecSetNormalize(tv_temp)
		tv_temp = MATH_VecBlendRotate(tv_temp, - @ao_modules[ti_i - 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())
		@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_temp, @ao_modules[ti_i - 1] OBJ_BankingGet())	

		tv_temp *= dist_between_module
		tv_temp += @ao_modules[ti_i - 1] OBJ_PosGet()
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}

	// QUEUE
	tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i - 1] OBJ_PosGet()
	MATH_VecSetNormalize(tv_temp)
	tv_temp = MATH_VecBlendRotate(tv_temp, - @ao_modules[ti_i - 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())
	@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_temp, @ao_modules[ti_i - 1] OBJ_BankingGet())	

	tv_temp *= dist_tail
	tv_temp += @ao_modules[ti_i - 1] OBJ_PosGet()
	@ao_modules[ti_i] OBJ_PosSet(tv_temp)

	// ROTATION PAR MODULES
	f_Z_angle += TIME_GetDt() * (DYN_SpeedGet() * 4.0)
	while (f_Z_angle > Cf_2Pi)
		f_Z_angle -= Cf_2Pi

	tf_time_offset = 0.8

	// CALCUL DES SPEED
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * 4)
	
		av_modules_speed[ti_i] = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		av_modules_speed[ti_i] *= tf_inv_dt
	}
}


procedure_local void PNJ_Scolo_Snake(int ti_first_index, float	tf_rigidity_coef, vector tv_father_speed)
{
	int			ti_i
	int			ti_iterations
	
	float		tf_norm
	float		tf_Z_offset
	float		tf_friction	
	float		tf_dot_product
	float		tf_time_offset
	float		tf_inv_dt

	vector	tv_move
	vector	tav_last_pos[15]
	vector	tv_precedent
	vector	tv_temp
	
	if (ti_first_index >= i_modules_nb )
	{
		v_ray_pos = OBJ_PosGet()
		v_ray_pos.z -= f_size_coef * 10.0
		v_ray_normal = Cv_VerticalVector
		return
	}

	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	// AJOUTER LA VITESSE ET LA GRAVITE
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
		
		tv_move = Cv_NullVector
		if (ti_i > ti_first_index)
			tv_move += 0.6 * av_modules_speed[ti_i]
		tv_move += cvector(0.0, 0.0, -1.0)
		tv_move += tv_father_speed
		tv_move *= TIME_GetDt()
	
		tv_temp = @ao_modules[ti_i] OBJ_PosGet()
		tv_temp += tv_move

		tf_dot_product = MATH_VecDotProduct(tv_temp - v_ray_pos, v_ray_normal) - tf_Z_offset
		if (tf_dot_product < 0.0)
		{
			tv_temp -= tf_dot_product * v_ray_normal
			tav_last_pos[ti_i] -= (MATH_VecDotProduct(tav_last_pos[ti_i]  - v_ray_pos, v_ray_normal) - tf_Z_offset) * v_ray_normal
		}
		
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}
	
	// EN SNAKE
	
	// CORPS
	for (ti_i = ti_first_index; ti_i < i_modules_nb - 1; ti_i++)
	{
		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i - 1] OBJ_PosGet()
		MATH_VecSetNormalize(tv_temp)
		tv_temp = MATH_VecBlendRotate(tv_temp, - @ao_modules[ti_i - 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())
		@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_temp, @ao_modules[ti_i - 1] OBJ_BankingGet())	

		tv_temp *= dist_between_module
		tv_temp += @ao_modules[ti_i - 1] OBJ_PosGet()
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}

	// QUEUE
	tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i - 1] OBJ_PosGet()
	MATH_VecSetNormalize(tv_temp)
	tv_temp = MATH_VecBlendRotate(tv_temp, - @ao_modules[ti_i - 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())
	@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_temp, @ao_modules[ti_i - 1] OBJ_BankingGet())	

	tv_temp *= dist_tail
	tv_temp += @ao_modules[ti_i - 1] OBJ_PosGet()
	@ao_modules[ti_i] OBJ_PosSet(tv_temp)

	// ROTATION PAR MODULES
	f_Z_angle += TIME_GetDt() * (DYN_SpeedGet() * 4.0)
	while (f_Z_angle > Cf_2Pi)
		f_Z_angle -= Cf_2Pi

	tf_time_offset = 0.8

	// CALCUL DES SPEED
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * 4)
	
		av_modules_speed[ti_i] = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		av_modules_speed[ti_i] *= tf_inv_dt
	}
}

procedure_local void PNJ_Scolo_Inv_Snake(int ti_first_index, float tf_rigidity_coef, vector tv_father_speed)
{
	int			ti_i
	int			ti_iterations
	
	float		tf_norm
	float		tf_Z_offset
	float		tf_friction	
	float		tf_dot_product
	float		tf_time_offset
	float		tf_inv_dt

	vector	tv_move
	vector	tav_last_pos[15]
	vector	tv_precedent
	vector	tv_temp
	
	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	// AJOUTER LA VITESSE ET LA GRAVITE
	for (ti_i = ti_first_index; ti_i >= 0; ti_i--)
	{
		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
		
		tv_move = Cv_NullVector
		if (ti_i > ti_first_index)
			tv_move += 0.6 * av_modules_speed[ti_i]
		tv_move += cvector(0.0, 0.0, -1.0)
		tv_move += tv_father_speed
		tv_move *= TIME_GetDt()
	
		tv_temp = @ao_modules[ti_i] OBJ_PosGet()
		tv_temp += tv_move

		tf_dot_product = MATH_VecDotProduct(tv_temp - v_ray_pos, v_ray_normal) - tf_Z_offset
		if (tf_dot_product < 0.0)
		{
			tv_temp -= tf_dot_product * v_ray_normal
			tav_last_pos[ti_i] -= (MATH_VecDotProduct(tav_last_pos[ti_i]  - v_ray_pos, v_ray_normal) - tf_Z_offset) * v_ray_normal
		}
		
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}
	
	// EN SNAKE
	
	// CORPS
	for (ti_i = ti_first_index; ti_i >= 0; ti_i--)
	{
		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i + 1] OBJ_PosGet()
		MATH_VecSetNormalize(tv_temp)
		tv_temp = MATH_VecBlendRotate(tv_temp, @ao_modules[ti_i + 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())

		@ao_modules[ti_i] OBJ_SightGeneralSet(tv_temp, @ao_modules[ti_i + 1] OBJ_BankingGet())	

		tv_temp *= dist_between_module
		tv_temp += @ao_modules[ti_i + 1] OBJ_PosGet()
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}

	// CALCUL DES SPEED
	for (ti_i = ti_first_index; ti_i >= 0; ti_i--)
	{
		av_modules_speed[ti_i] = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		av_modules_speed[ti_i] *= tf_inv_dt
	}
}


procedure_local void PNJ_Scolo_Modules_Update(int ti_first_module_index, object to_father)
{
	int			ti_i
	int			ti_current_wp_index
	int			ti_next_wp_index
	int			ti_before_index

	float		tf_dist	
	float		tf_coef
	float		tf_time_offset	
	float		tf_net_length
	float		tf_inv_dt

	object	to_wp	

	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_start_sight
	vector	tv_dest_sight
	vector	tv_start_banking
	vector	tv_dest_banking

//	if (!f_move_length && i_etat_courant != -1)
//		return

//	i_on_ground_modules_nb = 0
	i_on_virtual_net_modules_nb = 0

	tf_time_offset = 0.8
	tf_inv_dt = 1.0 / TIME_GetDt()

	if ( ! ti_first_module_index )
	{
		f_virtual_net_offset = 0.0
	
		ti_current_wp_index = i_virtual_net_last_wp_index
		ti_before_index = MATH_Modulo(i_virtual_net_last_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

		if (ao_virtual_wp_father[ti_before_index])
			tv_point_A = @ao_virtual_wp_father[ti_before_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_before_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_before_index])
		else
			tv_point_A = av_virtual_wp_pos[ti_before_index]
	
		tf_dist = MATH_VecNorm(tv_point_A - OBJ_PosGet())
		if (tf_dist >= dist_between_module)
			PNJ_Scolo_Add_Virtual_Wp(OBJ_Me(), to_father)
		else
			PNJ_Scolo_Update_Last_Virtual_Wp(OBJ_Me(), to_father)

		av_modules_speed[0] = OBJ_PosGet() - v_head_last_pos
		av_modules_speed[0] *= tf_inv_dt

		f_Z_angle += TIME_GetDt() * (MATH_VecNorm(av_modules_speed[0]) * 4.0 / f_size_coef)
		while (f_Z_angle > Cf_2Pi)
			f_Z_angle -= Cf_2Pi
	}

	tf_net_length = f_virtual_net_offset

	ti_current_wp_index = i_virtual_net_last_wp_index
	ti_next_wp_index = MATH_Modulo(ti_current_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

//	for (ti_i = 0; ti_i < Ci_virtual_wp_nb; ti_i++)
//		DBG_RenderVector(av_virtual_wp_pos[ti_i], Cv_VerticalVector, color_bleu)

	for (ti_i = 1; ti_i < i_modules_nb; ti_i++)
	{
		if (ao_virtual_wp_father[ti_current_wp_index] != ao_virtual_wp_father[ti_next_wp_index])
		{
			if (ao_virtual_wp_father[ti_current_wp_index])
				tv_start_pos = @ao_virtual_wp_father[ti_current_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_current_wp_index])
			else
				tv_start_pos = av_virtual_wp_pos[ti_current_wp_index]
		
			if (ao_virtual_wp_father[ti_next_wp_index])
				tv_dest_pos = @ao_virtual_wp_father[ti_next_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_next_wp_index])
			else
				tv_dest_pos = av_virtual_wp_pos[ti_next_wp_index]

			af_virtual_link_length[ti_current_wp_index] = MATH_VecNorm(tv_dest_pos - tv_start_pos)
		}
	
		tf_coef = af_modules_length[ti_i]
		tf_coef -= tf_net_length
		tf_coef /= af_virtual_link_length[ti_current_wp_index]

//		DBG_RenderVector(av_virtual_wp_pos[ai_virtual_wp_index[ti_i]], av_virtual_wp_pos[ai_virtual_wp_index[ti_i] + 1] - av_virtual_wp_pos[ai_virtual_wp_index[ti_i]], color_rouge)	

		// On dépasse la longueur du lien ?
		while(tf_coef > 1.0)
		{
			tf_net_length += af_virtual_link_length[ti_current_wp_index]
		
			ti_current_wp_index = ti_next_wp_index
			ti_next_wp_index = MATH_Modulo(ti_current_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

			if (ao_virtual_wp_father[ti_current_wp_index] != ao_virtual_wp_father[ti_next_wp_index])
			{
				if (ao_virtual_wp_father[ti_current_wp_index])
					tv_start_pos = @ao_virtual_wp_father[ti_current_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_current_wp_index])
				else
					tv_start_pos = av_virtual_wp_pos[ti_current_wp_index]
			
				if (ao_virtual_wp_father[ti_next_wp_index])
					tv_dest_pos = @ao_virtual_wp_father[ti_next_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_next_wp_index])
				else
					tv_dest_pos = av_virtual_wp_pos[ti_next_wp_index]
	
				af_virtual_link_length[ti_current_wp_index] = MATH_VecNorm(tv_dest_pos - tv_start_pos)
			}

			tf_coef = af_modules_length[ti_i]
			tf_coef -= tf_net_length
			tf_coef /= af_virtual_link_length[ti_current_wp_index]
		}

		// Tout module sur un wp virtuel collision ou hierarchisé ou dans l'eau ne sera plus animé en snake
		if (ti_i > i_on_ground_modules_nb)
		{
			if (ao_virtual_wp_father[ti_current_wp_index] && ao_virtual_wp_father[ti_next_wp_index])
				i_on_ground_modules_nb = ti_i
			else if (ai_virtual_wp_flag[ti_current_wp_index] & (Ci_virtual_net_ground_col | Ci_virtual_net_wall_col))
				i_on_ground_modules_nb = ti_i
			else if ( ! ai_virtual_wp_flag[ti_current_wp_index] )
				break
		}
		
		// Ce module est positionné sur le réseau virtuel, c'est à dire qu'il n'est pas "en l'air"
		i_on_virtual_net_modules_nb = ti_i

		if (ti_i < ti_first_module_index)
			continue	

		if (ao_virtual_wp_father[ti_current_wp_index])
		{
			tv_start_pos = @ao_virtual_wp_father[ti_current_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_current_wp_index])
			tv_start_sight = @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_sight[ti_current_wp_index])
			tv_start_banking = @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_banking[ti_current_wp_index])
		}
		else
		{
			tv_start_pos = av_virtual_wp_pos[ti_current_wp_index]
			tv_start_sight = av_virtual_wp_sight[ti_current_wp_index]
			tv_start_banking = av_virtual_wp_banking[ti_current_wp_index]
		}

		if (ao_virtual_wp_father[ti_next_wp_index])
		{
			tv_dest_pos = @ao_virtual_wp_father[ti_next_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_next_wp_index])
			tv_dest_sight = @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_sight[ti_next_wp_index])
			tv_dest_banking = @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_banking[ti_next_wp_index])
		}
		else
		{
			tv_dest_pos = av_virtual_wp_pos[ti_next_wp_index]
			tv_dest_sight = av_virtual_wp_sight[ti_next_wp_index]
			tv_dest_banking = av_virtual_wp_banking[ti_next_wp_index]
		}
		
		// Linear Interpolation
		tv_point_A = MATH_VecBlend(tv_start_pos, tv_dest_pos, tf_coef)
		if (ti_i == ti_first_module_index)
			tv_point_B = MATH_VecBlendRotate(tv_start_sight, tv_dest_sight, tf_coef)
		else
			tv_point_B = @ao_modules[ti_i - 1] OBJ_PosGet() - tv_point_A
		tv_point_C = MATH_VecBlendRotate(tv_start_banking, tv_dest_banking , tf_coef)

		if ( MATH_VecNullEpsilon(tv_point_B))
			tv_point_B = @ao_modules[ti_i] OBJ_SightGet()
		@ao_modules[ti_i] OBJ_SightGeneralSet(tv_point_B, tv_point_C)
		if (ti_i && ai_virtual_wp_flag[ti_current_wp_index] & (Ci_virtual_net_ground_col | Ci_virtual_net_wall_col))
			@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * Cf_angle_ondule_ton_corps)
		tv_point_A += 	f_death_Z * v_ray_normal
	
		av_modules_speed[ti_i] = 	tv_point_A - @ao_modules[ti_i] OBJ_PosGet()
		av_modules_speed[ti_i] *= tf_inv_dt
		@ao_modules[ti_i] OBJ_PosSet(tv_point_A)

//		// Bezier Interpolation
//		tv_point_A = tv_start_pos
//		
//		tv_point_B = tv_point_A 
//		tv_point_B -= tv_start_sight * (af_virtual_link_length[ti_current_wp_index] * Cf_pourcentage)
//		
//		tv_point_D = tv_dest_pos
//			
//		tv_point_C = tv_point_D
//		tv_point_C += tv_dest_sight * (af_virtual_link_length[ti_current_wp_index] * Cf_pourcentage)
//
//		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_dest_sight)
//		
//		// Orientation
//		tv_dest_banking = MATH_VecBlendRotate(tv_start_banking, tv_dest_banking, tf_coef)
//		@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_dest_sight, tv_dest_banking)
//		@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * Cf_angle_ondule_ton_corps)
//			
//		// Position
//		av_modules_speed[ti_i] = (tv_dest_pos - @ao_modules[ti_i] OBJ_PosGet())
//		av_modules_speed[ti_i] *= tf_inv_dt
//		@ao_modules[ti_i] OBJ_PosSet(tv_dest_pos)
	}
	
	// La dernière partie du corps est gérée en snake
	PNJ_Scolo_Snake(ti_i, 6.0, Cv_NullVector)
}

procedure_local void PNJ_Scolo_Renormalisation(int ti_first_index, int ti_last_index, int ti_iteration_nb)
{
	int			ti_i
	int			ti_k

	float		tf_norm
	float		tf_dot_product
	float		tf_Z_offset
	float		tf_inv_dt
	float		tf_move_length

	vector	tv_renormalisation[15]
	vector	tv_temp	
	vector	tv_col_pos
	vector	tv_col_normal

	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	// LES POINTS ONT BOUGE
	for (ti_k = 0; ti_k < ti_iteration_nb; ti_k++)
	{
		for (ti_i = ti_first_index; ti_i <= ti_last_index; ti_i++)
		{
			tv_renormalisation[ti_i] = Cv_NullVector

			if ( ! ti_i )
				continue

			tv_temp = @ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet()
			tf_norm = MATH_VecDotProduct(tv_temp, tv_temp)
			if (tf_norm > 0.001)
			{
				tf_norm = MATH_FloatSqrt(tf_norm)
				tv_temp /= tf_norm
				if (ti_i == i_modules_nb - 1)
					tf_norm -= dist_tail
				else
					tf_norm -= dist_between_module
				tv_temp  *= tf_norm
			}
			else
			{
				tv_temp = @ao_modules[ti_i] OBJ_BankingGet()
				tv_temp *= af_modules_length[ti_i - 1]
			}

			tv_renormalisation[ti_i - 1] -= tv_temp * 0.5
			tv_renormalisation[ti_i] += tv_temp * 0.5
		}
		
		for (ti_i = ti_first_index; ti_i <= ti_last_index; ti_i++)
		{
			if (ai_modules_perfored[ti_i])
				continue
				
			if (ai_modules_locked[ti_i])
				continue

			tv_renormalisation[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(tv_renormalisation[ti_i], av_bone_col_normal[ti_i]), 0.0) * av_bone_col_normal[ti_i]
	
			@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i] OBJ_PosGet() + tv_renormalisation[ti_i])
		}
	}

	return
}


procedure_local void PNJ_Scolo_IK_Init(int ti_modules_nb)
{
	int		ti_i
	
	f_IK_bezier_coef = 0.0

	i_on_ground_modules_nb = i_modules_nb - 1

	for (ti_i = 0; ti_i < ti_modules_nb; ti_i++)
	{
		af_IK_bezier_coef[ti_i] = 0.0
//		av_IK_bone_start_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
	}

	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
		av_bone_col_normal[ti_i] = Cv_NullVector

	v_IK_pos = OBJ_PosGet()
	v_IK_sight = OBJ_SightGet()

	if (ao_virtual_wp_father[i_virtual_net_last_wp_index])
	{
		v_IK_pos = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(v_IK_pos - @ao_virtual_wp_father[i_virtual_net_last_wp_index] OBJ_PosGet())
		v_IK_sight = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(v_IK_sight)
	}
}

procedure_local void PNJ_Scolo_IK2(int ti_modules_nb, vector tv_head_pos, vector tv_head_sight, float tf_IK_coef)
{
	int			ti_i
	int			ti_k
	
	float		tf_borne_inf
	float		tf_borne_sup
	float		tf_coef
	float		tf_totale_norm
	float		tf_pourcentage
	float		tf_step
	float		tf_perfect_length
	float		tf_sqr_length
		
	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_pseudo_bone

	vector	tv_new_sight
	vector	tv_new_banking

	// PAS DU TOUT DE PILOTAGE !!!!
	if (!tf_IK_coef || f_on_screen_pourcent == -1.0)
		return

//	if (o_test_pilotage_tete)
//	{
//		tv_head_pos = @o_test_pilotage_tete OBJ_PosGet()
////		tv_head_pos += @o_test_pilotage_tete OBJ_HorizonGet() * (MATH_Sin(TIME_Get() * 4.0))
//	
//		tv_head_sight = @o_test_pilotage_tete OBJ_SightGet()
////		tv_head_sight = MATH_VecRotate(tv_head_sight, @o_test_pilotage_tete OBJ_BankingGet(), MATH_Sin(TIME_Get() * 8.0) * 0.3)
//	}
	
	tf_step = 1.0 
	tf_step /= ti_modules_nb
	
	tf_perfect_length = ti_modules_nb * dist_between_module
	tf_perfect_length *= 0.99

	f_IK_B_weight = tf_perfect_length * 0.5
	f_IK_C_weight = tf_perfect_length * 0.5

//	f_Z_angle += TIME_GetDt() * 30.0
//	while (f_Z_angle > Cf_2Pi)
//		f_Z_angle -= Cf_2Pi
	
	// C'EST PARTI POUR TROUVER UNE BONNE BEZIER ============================================
	tv_point_A = @ao_modules[ti_modules_nb] OBJ_PosGet()

	tv_point_D = tv_head_pos
	
	tv_point_B = tv_point_A
	tv_point_B += @ao_modules[ti_modules_nb] OBJ_SightGet() * f_IK_B_weight

	tv_point_C = tv_point_D	
	tv_point_C -= tv_head_sight * f_IK_B_weight

#ifndef _FINAL_
	MATH_LIB_Bezier_Display(ti_modules_nb, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
#endif	

	for (ti_i = 1; ti_i < ti_modules_nb - 1; ti_i++)
	{
		tf_coef = 1.0 - (ti_i * tf_step)
		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_new_sight)
		@ao_modules[ti_i] OBJ_PosSet(tv_dest_pos)

		tv_new_banking = MATH_VecCrossProduct(tv_new_sight, @ao_modules[ti_i + 1] OBJ_HorizonGet())
		tv_new_banking = MATH_VecBlendRotate(tv_new_banking, -tv_head_sight, tf_coef * tf_IK_coef)
		@ao_modules[ti_i] OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)
	}

	tv_new_banking = MATH_VecCrossProduct(tv_new_sight, @ao_modules[ti_i + 1] OBJ_HorizonGet())
	tv_new_banking = MATH_VecBlendRotate(tv_new_banking, -tv_head_sight, tf_coef * tf_IK_coef)
	@ao_modules[ti_i] OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)

	@ao_modules[0] OBJ_PosSet(tv_head_pos)
	tv_new_banking = MATH_VecBlendRotate(@ao_modules[ti_i + 1] OBJ_BankingGet(), v_IK_banking, tf_IK_coef)
	@ao_modules[0] OBJ_SightGeneralSet(tv_head_sight, tv_new_banking)

	ai_modules_locked[0] = vrai
	ai_modules_locked[ti_modules_nb] = vrai
	PNJ_Scolo_Renormalisation(0, ti_modules_nb, 5)
	ai_modules_locked[0] = faux
	ai_modules_locked[ti_modules_nb] = faux

	return
}


procedure_local void PNJ_Scolo_IK(int ti_modules_nb, vector tv_head_pos, vector tv_head_sight, float tf_IK_coef)
{
	int			ti_i
	int			ti_k
	
	float		tf_borne_inf
	float		tf_borne_sup
	float		tf_coef
	float		tf_totale_norm
	float		tf_pourcentage
	float		tf_step
	float		tf_perfect_length
	float		tf_sqr_length
		
	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_pseudo_bone

	vector	tv_new_sight
	vector	tv_new_banking

//	if (!IO_KeyPressed(VK_SPACE))
//	{
//		PNJ_Scolo_IK2(ti_modules_nb, tv_head_pos, tv_head_sight, tf_IK_coef)
//		return
//	}

	// PAS DU TOUT DE PILOTAGE !!!!
	if (!tf_IK_coef || f_on_screen_pourcent == -1.0)
		return

//	if (o_test_pilotage_tete)
//	{
//		tv_head_pos = @o_test_pilotage_tete OBJ_PosGet()
////		tv_head_pos += @o_test_pilotage_tete OBJ_HorizonGet() * (MATH_Sin(TIME_Get() * 4.0))
//	
//		tv_head_sight = @o_test_pilotage_tete OBJ_SightGet()
////		tv_head_sight = MATH_VecRotate(tv_head_sight, @o_test_pilotage_tete OBJ_BankingGet(), MATH_Sin(TIME_Get() * 8.0) * 0.3)
//	}
	
	tf_step = 1.0 
	tf_step /= ti_modules_nb
//	tf_step /= 20	

	tf_perfect_length = ti_modules_nb * dist_between_module
	tf_perfect_length *= 0.99

	f_IK_B_weight = tf_perfect_length * 1.25
	f_IK_C_weight = tf_perfect_length * 1.25

//	f_Z_angle += TIME_GetDt() * 30.0
//	while (f_Z_angle > Cf_2Pi)
//		f_Z_angle -= Cf_2Pi
	
	// C'EST PARTI POUR TROUVER UNE BONNE BEZIER ============================================
	tv_point_A = @ao_modules[ti_modules_nb] OBJ_PosGet()
	tv_point_D = tv_head_pos
	
	// =============================================================================
	// On fait une première dichotomie pour trouver en gros une courbe de la même longueur que celle du cou
	// =============================================================================
	tf_borne_inf = 0.0
	tf_borne_sup = 2.0
	ti_k = 0
	tf_totale_norm = 0.0
	while(ti_k < 10)
	{
		ti_k++
	
		tf_totale_norm	= 0.0
	
		tf_pourcentage = tf_borne_inf
		tf_pourcentage += (tf_borne_sup - tf_borne_inf) * 0.5
	
		tv_point_B = tv_point_A
		tv_point_B += @ao_modules[ti_modules_nb] OBJ_SightGet() * (f_IK_B_weight * tf_pourcentage)

		tv_point_C = tv_point_D	
		tv_point_C -= tv_head_sight * (f_IK_B_weight * tf_pourcentage)
	
		tv_start_pos = tv_point_A
		tv_dest_pos = tv_start_pos
	
		for (ti_i = 1; ti_i < ti_modules_nb - 1; ti_i++)
//		for (ti_i = 1; ti_i < 19; ti_i++)
		{
			tf_coef = ti_i * tf_step
			tv_start_pos = tv_dest_pos
			tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_new_sight)
			tf_totale_norm += MATH_VecNorm(tv_dest_pos - tv_start_pos)
		}

		tf_totale_norm	+= MATH_VecNorm(tv_point_D - tv_dest_pos)

		if (MATH_AbsFloat(tf_totale_norm - tf_perfect_length) < 0.02)
		{
			// OK, C'est bon
			ti_k = ti_k
			break
		}
		else if (tf_totale_norm > tf_perfect_length)
		{
			tf_borne_sup -= tf_borne_inf
			tf_borne_sup *= 0.5
			tf_borne_sup += tf_borne_inf 
		}
		else
		{
			tf_borne_inf -= tf_borne_sup
			tf_borne_inf *= 0.5
			tf_borne_inf += tf_borne_sup
		}
	}
	
	if (f_IK_bezier_coef)
		f_IK_bezier_coef = MATH_FloatBlend(f_IK_bezier_coef, tf_pourcentage, 20.0 * TIME_GetDt())
	else
		f_IK_bezier_coef = tf_pourcentage

	tf_pourcentage = f_IK_bezier_coef
	
	// ON A ENFIN NOS 4 POINTS QUI DETERMINE LA COURBE ==============================================
	tv_point_B = tv_point_A
	tv_point_B += @ao_modules[ti_modules_nb] OBJ_SightGet() * (f_IK_B_weight * tf_pourcentage)

	tv_point_C = tv_point_D	
	tv_point_C -= tv_head_sight * (f_IK_C_weight * tf_pourcentage)

#ifndef _FINAL_
	MATH_LIB_Bezier_Display(ti_modules_nb, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
//	MATH_LIB_Bezier_Display(20, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
#endif	

	tf_borne_inf = 0.0
	tv_start_pos = tv_point_A
	
	// =========================================================================
	// Pour les bones, on va rechercher une position sur la courbe telle que la longueur de l'os soit correcte
	// =========================================================================
	for (ti_i = ti_modules_nb - 1; ti_i > 0; ti_i--)
	{
		tf_borne_sup = 1.0
	
		ti_k = 0
	
		tf_sqr_length = dist_between_module
		tf_sqr_length *= 0.98
		tf_sqr_length *= tf_sqr_length
	
		while (ti_k < 10)
		{
			ti_k++
	
			tf_coef = tf_borne_inf 
			tf_coef += (tf_borne_sup - tf_borne_inf) * 0.5
		
			tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_new_sight)
	
			tv_pseudo_bone = tv_dest_pos - tv_start_pos
			tf_totale_norm = MATH_VecDotProduct(tv_pseudo_bone, tv_pseudo_bone)
	
			if (MATH_AbsFloat(tf_totale_norm - tf_sqr_length) < 0.001)
			{
				// OK, C'est bon
				break
			}
			else if (tf_totale_norm > tf_sqr_length)
			{
				tf_borne_sup -= tf_borne_inf
				tf_borne_sup *= 0.5
				tf_borne_sup += tf_borne_inf 
			}
			else
			{
				tf_borne_inf -= tf_borne_sup
				tf_borne_inf *= 0.5
				tf_borne_inf += tf_borne_sup
			}
		}

		if (af_IK_bezier_coef[ti_i])
			af_IK_bezier_coef[ti_i] = MATH_FloatBlend(af_IK_bezier_coef[ti_i], tf_coef, 20.0 * TIME_GetDt())
		else
			af_IK_bezier_coef[ti_i] = tf_coef

		tf_coef = af_IK_bezier_coef[ti_i]
	
		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_new_sight)

		@ao_modules[ti_i] OBJ_PosSet(tv_dest_pos)
	
		tv_new_banking = MATH_VecCrossProduct(tv_new_sight, @ao_modules[ti_i + 1] OBJ_HorizonGet())
		tv_new_banking = MATH_VecBlendRotate(tv_new_banking, -tv_head_sight, tf_coef * tf_IK_coef)
		@ao_modules[ti_i] OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)

//		@ao_modules[ti_i] OBJ_BankingGeneralSet(@ao_modules[ti_i + 1] OBJ_SightGet(), @ao_modules[ti_i + 1] OBJ_BankingGet())
//		@ao_modules[ti_i] OBJ_Rotate_FromTo(cvector(0.0, -1.0, 0.0), @ao_modules[ti_i] MATH_VecGlobalToLocal(tv_new_sight))

		tv_start_pos = tv_dest_pos
	}
	
	@ao_modules[ti_i] OBJ_PosSet(tv_head_pos)

	tv_new_banking = MATH_VecBlendRotate(@ao_modules[ti_i + 1] OBJ_BankingGet(), v_IK_banking, tf_IK_coef)
	@ao_modules[ti_i] OBJ_SightGeneralSet(tv_head_sight, tv_new_banking)
	
//	@ao_modules[ti_i] OBJ_BankingGeneralSet(@ao_modules[ti_i + 1] OBJ_SightGet(), @ao_modules[ti_i + 1] OBJ_BankingGet())
//	@ao_modules[ti_i] OBJ_Rotate_FromTo(cvector(0.0, -1.0, 0.0), @ao_modules[ti_i] MATH_VecGlobalToLocal(tv_head_sight))

//	if (tf_IK_coef < 1.0)
//		PNJ_Scolo_Renormalisation(1, ti_modules_nb - 1, 10)

	return
}

procedure_local void PNJ_Scolo_Position_Set()
{
	int			ti_i
	int			ti_index
	int			ti_nb_link
	int			ti_flag_ok
	int			ti_current_wp_index
	int			ti_next_wp_index

	float		tf_coef
	float		tf_time_offset
	float		tf_link_coef	
	float		tf_link_length

	object	to_wp	

	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	if (! n_net)
	{
		i_current_wp_index = 1
		i_flag_net_end = vrai
		return
	} 

	if (!i_net_loop)
	{
		if (i_flag_net_end && f_move_length > 0.0)
		{
			f_move_length = 0.0

			if (EDIT)
				f_move_speed = 0.0
		}
		else if (i_flag_net_start && f_move_length < 0.0)
		{
			f_move_length = 0.0

			if (EDIT)
				f_move_speed = 0.0
		}
	}

	if (!f_move_length && (i_etat_courant != -1 && !EDIT))
		return

	tf_time_offset = 0.8

	f_Z_angle += TIME_GetDt() * (f_move_speed * 4.0)
	while (f_Z_angle > Cf_2Pi)
		f_Z_angle -= Cf_2Pi

	ti_flag_ok = vrai

	ti_current_wp_index = i_current_wp_index
	ti_next_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)
	o_next_wp = ao_net_wp[ti_next_wp_index]

	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
	{
		if (ti_i == i_modules_nb - 1)
		{
			tf_link_coef -= dist_tail
		}
		else if (ti_i)
		{
			tf_link_coef -= dist_between_module
		}
		else
		{
			tf_link_coef = f_link_coef
			tf_link_coef += f_move_length	
		}

//		if (@ao_net_wp[ti_next_wp_index] OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Generated) || EDIT)
//			tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())
//		else
//			tf_link_length = WAY_LinkWeightGet(n_net, ao_net_wp[ti_current_wp_index], ao_net_wp[ti_next_wp_index])
		tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())

		if (MATH_FloatNullToler(tf_link_length, 0.01))
			DBG_Error("Lien de longueur nulle")

		tf_coef = tf_link_coef / tf_link_length

		tf_coef = MATH_FloatRound(tf_coef, 0.001)
	
//		if (MATH_FloatNullToler(tf_coef, 0.001))	
//			DBG_Error("Positionnement sur wp")

		// On avance ?
		while(tf_coef > 1.0)
		{
			if (@ao_net_wp[ti_next_wp_index] OBJ_CapaTest(Capa_Net_Destroy))
				i_flag_net_death = vrai
			
			if (@ao_net_wp[ti_next_wp_index] OBJ_CapaTest(Capa_Net_Switch_Net_Mode))
			{
				i_flag_net_end = vrai
				return
			}
	
			if (!i_net_loop && ti_current_wp_index == i_net_wp_nb - 2)
			{
				if (i_flag_net_start)
				{
					// LE RESEAU EST TROP COURT !!!
					DBG_TraceObject(OBJ_Me())
					DBG_TraceString(" est sur une réseau trop petit => ")
					DBG_TraceObject(o_start_wp)
					DBG_TraceEOL()

					DBG_Error("Un réseau est trop court !!! REGARDEZ DANS LE LOG")
				}	
	
				if (@ao_net_wp[i_net_wp_nb - 1] OBJ_CapaTest(Capa_Net_Destroy))
					i_flag_net_death = vrai
			
//				i_flag_net_end	= vrai
	
				i_current_wp_index = i_net_wp_nb - 2
				f_link_coef = 0.0

				f_Z_angle -= TIME_GetDt() * (f_move_speed * 4.0)

//				if (@ao_net_wp[ti_next_wp_index] OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Generated) || EDIT)
//					tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())
//				else
//					tf_link_length = WAY_LinkWeightGet(n_net, ao_net_wp[ti_current_wp_index], ao_net_wp[ti_next_wp_index])
				tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())

				f_move_length = tf_link_length

				if (EDIT)
					f_move_speed = 0.0

				PNJ_Scolo_Position_Set()
				return
			}	
		
			ti_current_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)
			ti_next_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)

			tf_link_coef -= tf_link_length

//			if (@ao_net_wp[ti_next_wp_index] OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Generated) || EDIT)
//				tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())
//			else
//				tf_link_length = WAY_LinkWeightGet(n_net, ao_net_wp[ti_current_wp_index], ao_net_wp[ti_next_wp_index])
			tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())

			tf_coef = tf_link_coef / tf_link_length
		}

		// On recule ?
		while(tf_coef < 0.0)
		{
			if (!i_net_loop && !ti_current_wp_index)
			{
				if (i_flag_net_end)
				{
					// LE RESEAU EST TROP COURT !!!
					DBG_BreakPoint()
				}

				i_current_wp_index = 0
				f_link_coef = 0.0

				f_move_length = (i_modules_nb - 2) * dist_between_module
				f_move_length += dist_tail

//				if (EDIT)
				f_move_speed = 0.0

				i_flag_inverse_sight = faux
				i_flag_update_all_modules = vrai
				
				PNJ_Scolo_Position_Set()
				return
			}
	
			ti_current_wp_index = MATH_Modulo(ti_current_wp_index + i_net_wp_nb - 1, i_net_wp_nb)
			ti_next_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)

//			if (@ao_net_wp[ti_next_wp_index] OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Generated) || EDIT)
//				tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())
//			else
//				tf_link_length = WAY_LinkWeightGet(n_net, ao_net_wp[ti_current_wp_index], ao_net_wp[ti_next_wp_index])
			tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())

			tf_link_coef += tf_link_length

			tf_coef = tf_link_coef / tf_link_length
		}

		if ( ! ti_i )
		{
			i_current_wp_index = ti_current_wp_index
			f_link_coef = tf_link_coef

			if (ti_current_wp_index != i_net_wp_nb - 2 || tf_coef < 1.0)
				i_flag_net_end = faux
			else
			{
				i_flag_net_end = vrai
				o_next_wp = nobody
			}
		}
		else if (ti_i == 5)
		{
			if (ti_current_wp_index >= i_net_wp_nb - 2)
				i_flag_half_exited = vrai
			else
				i_flag_half_exited = faux
		}
		else if (ti_i == i_modules_nb - 1)
		{
			if (ti_current_wp_index || tf_coef)
				i_flag_net_start = faux
			else
				i_flag_net_start = vrai
		}
	
		// Smooth trajectory
		tv_point_A = @ao_net_wp[ti_current_wp_index] OBJ_PosGet()
		tv_point_B = tv_point_A 
		tv_point_B += @ao_net_wp[ti_current_wp_index] OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @ao_net_wp[ti_current_wp_index] OBJ_ScaleGet().y))
		
		tv_point_D = @ao_net_wp[ti_next_wp_index] OBJ_PosGet()
			
		tv_point_C = tv_point_D
		tv_point_C -= @ao_net_wp[ti_next_wp_index] OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @ao_net_wp[ti_next_wp_index] OBJ_ScaleGet().y))
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		tv_point_C += (tv_point_D - tv_point_C) * tf_coef
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		
		// Orientation
		tv_point_C = MATH_VecBlendRotate(@ao_net_wp[ti_current_wp_index] OBJ_BankingGet(), @ao_net_wp[ti_next_wp_index] OBJ_BankingGet(), tf_coef)
		if (i_flag_inverse_sight)
			@ao_modules[ti_i] OBJ_SightGeneralSet(tv_point_A - tv_point_B, tv_point_C)
		else
			@ao_modules[ti_i] OBJ_SightGeneralSet(tv_point_B - tv_point_A, tv_point_C)
		
		if (ti_i)
			@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * Cf_angle_ondule_ton_corps)

		if (f_angle_death)
			@ao_modules[ti_i] OBJ_RotateLocalY(f_angle_death)

		// Position
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		@ao_modules[ti_i] OBJ_PosSet(tv_point_A)
		
		if (!EDIT && i_etat_courant != -1 && !i_flag_update_all_modules)
		{
			i_flag_net_start = faux
		
			f_Z_noise = MATH_RandFloat(-0.05, 0.05)
			f_delay_until_last_ground_col = 0.0
			f_delay_until_last_wall_col = 0.0
			PNJ_Scolo_Modules_Update(0, nobody)
			break
		}
	}
	
	i_flag_update_all_modules = faux
}

#ifndef _FINAL_
procedure_local void PNJ_Scolo_DBG_Render_Net()
{
	int			ti_index
	int			ti_nb_link	

	float		tf_coef
	float		tf_link_coef
	float		tf_link_length
	
	object	to_current_wp
	object	to_next_wp
	object	to_wp

	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D

	vector	tv_start_pos

	to_current_wp = o_start_wp
	to_wp = WAY_NetNextWP(n_net, to_current_wp, 0, 0)
	to_next_wp = to_wp

	tf_link_coef = 0.0
	tv_start_pos = @to_current_wp OBJ_PosGet()
	tf_link_length = MATH_VecNorm(@to_next_wp OBJ_PosGet() - @to_current_wp OBJ_PosGet())

	while (to_wp && to_wp != o_start_wp)
	{
		tf_link_coef += STEP_LENGTH
	
		tf_coef = tf_link_coef / tf_link_length
	
		while(tf_coef > 1.0)
		{
			to_wp = WAY_NetNextWP(n_net, to_next_wp, 0, 0)
		
			if (to_wp && to_wp != o_start_wp)	
			{
				to_current_wp = to_next_wp
				to_next_wp = to_wp
				
				tf_link_coef	-= tf_link_length
				tf_link_length = MATH_VecNorm(@to_next_wp OBJ_PosGet() - @to_current_wp OBJ_PosGet())

				tf_coef = tf_link_coef / tf_link_length
			}
			else
			{
				tf_coef = 1.0
			}
		}
		
		// Smooth trajectory
		tv_point_A = @to_current_wp OBJ_PosGet()
		
		tv_point_B = tv_point_A 
		tv_point_B += @to_current_wp OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @to_current_wp OBJ_ScaleGet().y))
		
		tv_point_D = @to_next_wp OBJ_PosGet()
			
		tv_point_C = tv_point_D
		tv_point_C -= @to_next_wp OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @to_next_wp OBJ_ScaleGet().y))
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		tv_point_C += (tv_point_D - tv_point_C) * tf_coef
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		
	//	tv_point_B = @o_current_wp OBJ_PosGet()
	//	tv_point_B += MATH_VecNormalize(@o_next_wp OBJ_PosGet() - @o_current_wp OBJ_PosGet()) * f_link_coef
	//	DBG_RenderVector(tv_point_B, tv_point_A - tv_point_B, color_blanc)
	
		DBG_RenderVector(tv_start_pos, tv_point_A - tv_start_pos, color_blanc)
		tv_start_pos = tv_point_A
	}
}
#endif

//procedure_local void PNJ_Scolo_Destroy_If_Culled()
//{
//	int		ti_i	
//
//	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
//	{
//		if (@ao_modules[ti_i] OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Culled)
//			continue
//		else
//			return
//	}
//
//	OBJ_Destroy()
//}

procedure_local void PNJ_Scolo_UncollideAdd(object to_gao, float tf_duration)
{
	int		ti_index
	
	ti_index = ARR_ObjSearch(&ao_uncollide_gao[0], i_uncollide_gao_nb, to_gao)
	if (ti_index == -1)
	{
		ao_uncollide_gao[i_uncollide_gao_nb] = to_gao
		af_uncollide_duration[i_uncollide_gao_nb] = tf_duration
		i_uncollide_gao_nb++
		COL_UnCollidableAdd(to_gao)
	}
	else
	{
		af_uncollide_duration[ti_index] = tf_duration
	}
}

procedure_local void PNJ_Scolo_Uncollide_KAnn()
{
	int					ti_rank
	int					ti_Ann_Index

	message		tm_filter
	messageid		tmid_link	

//	if (ai_perceived_ID[i_perceived_best_actor_index] != C_ID_Kong)
//		return
//		
//	ti_Ann_Index = ARR_LIB_IntSearch(&ai_perceived_ID[0], i_perceived_actor_nb, C_ID_Ann)
//	if (ti_Ann_Index == -1)
//		return
//
//	ti_rank = -1
//	MSG_SetNull(tm_filter)
//	tm_filter.msg_sender = ao_perceived_actor[ti_Ann_Index]
//	tm_filter.msg_gao1 = ao_perceived_actor[i_perceived_best_actor_index]
//	tm_filter.msg_gao2 = ao_perceived_actor[ti_Ann_Index]
//	tmid_link = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_KKGRAB_OBJECT, &ti_rank, tm_filter)
//
//	if (MSG_GlobalIsValid(tmid_link))
//		PNJ_Scolo_UncollideAdd(ao_perceived_actor[ti_Ann_Index], Cf_EVENT_Duree_1Trame)
}



procedure_local void PNJ_Scolo_UncollideDel(object to_gao)
{
	int		ti_index
	ti_index = ARR_ObjSearch(&ao_uncollide_gao[0], i_uncollide_gao_nb, to_gao)
	if (ti_index != -1)
		af_uncollide_duration[ti_index] = 0.0
}

procedure_local void PNJ_Scolo_UncollideCheck()
{
	int		ti_i
	
	for (ti_i = 0; ti_i < i_uncollide_gao_nb; ti_i++)
	{
		if (af_uncollide_duration[ti_i] == -1.0)
			continue
	
		if (af_uncollide_duration[ti_i] <= 0.0 && ! OBJ_LIB_Virtual_Collision(OBJ_Me(), ao_uncollide_gao[ti_i], faux))
		{
			COL_UnCollidableDel(ao_uncollide_gao[ti_i])
			
			i_uncollide_gao_nb--

			af_uncollide_duration[ti_i] = af_uncollide_duration[i_uncollide_gao_nb]
			ao_uncollide_gao[ti_i] = ao_uncollide_gao[i_uncollide_gao_nb]
			
			af_uncollide_duration[i_uncollide_gao_nb] = -1.0
			ao_uncollide_gao[i_uncollide_gao_nb] = nobody
		}

		af_uncollide_duration[ti_i] -= MATH_FloatMin(af_uncollide_duration[ti_i], TIME_GetDt())
	}
}

procedure_local int PNJ_Scolo_Test_Trigger_Attaque()
{
	int					ti_index	

	message		tmsg_trigger	

	if (i_flag_trigger_attack_used)
		return(vrai)

	i_trigger_attaque_nb = 0

	if ( ! AI_TriggerIsValid(trigger_attaque) )
	{
		i_flag_trigger_attack_used = vrai
		return(vrai)
	}

	i_trigger_attaque_nb = 1

	if (call_trigger(trigger_attaque))
	{
		i_flag_trigger_attack_used = vrai
	
		switch(target_selection)
		{
			case Ci_TARGET_AI :
				if (o_force_target)
					 o_trigger_target = o_force_target
				break
				
			case Ci_TARGET_TRIGGER :
				tmsg_trigger = AI_TriggerGetMsg(trigger_attaque)
				o_trigger_target = tmsg_trigger.msg_gao5
				Check_This_Gao5(o_trigger_target)
				break
		}

		return(vrai)
	}
	
	return(faux)
}

procedure_local int PNJ_Scolo_Test_Trigger_Apparition()
{
	int			ti_trigger_1
	int			ti_trigger_2
	int			ti_trigger_ok_nb
	
	if (i_flag_trigger_appear_used)
		return(vrai)

	i_trigger_apparition_nb = 0
	ti_trigger_ok_nb = 0
	
	if (AI_TriggerIsValid(trigger_apparition))
	{
		i_trigger_apparition_nb++
	 	if (call_trigger(trigger_apparition))
			ti_trigger_ok_nb++
	}
	
	if (AI_TriggerIsValid(trigger_apparition2))
	{
		i_trigger_apparition_nb++
		if (call_trigger(trigger_apparition2))
			ti_trigger_ok_nb++
	}
	
	if (ti_trigger_ok_nb == i_trigger_apparition_nb || (apparition_trigger_test && ti_trigger_ok_nb))
		i_flag_trigger_appear_used = vrai
		
	return(i_flag_trigger_appear_used)
}

//procedure_local void PNJ_Scolo_Explode()
//{
//	int			ti_i
//	int			ti_GFX
//
//	vector	tv_point_A
//	vector	tv_wind
//
//	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
//	{
//		ti_GFX = GFX_Add(13)																// Create the boum
//		
//		GFX_MaterialSet(ti_GFX, get_SFX_light_and_smoke, -1)						// met le materiau
//		GFX_Seti(ti_GFX, 13101, 8)															// Materiau 0
//	
//		GFX_Seti(ti_GFX, 13100, 20)															// *Buffer number of sprite
//		GFX_Seti(ti_GFX, 13106, 20)															// *number of sprite to generate
//	
//		GFX_Setf(ti_GFX, 13003, 0.1)															// Time fase 1
//		GFX_Setf(ti_GFX, 13004, 0.6)															// Time fase 2
//	
//		GFX_Seti(ti_GFX, 13107, 0)															// Sprites non triés
//	
//		GFX_FlagSet(ti_GFX, 0 , 1)
//		GFX_FlagSet(ti_GFX, 2 , 1)
//		
//		GFX_Setf(ti_GFX, 13012, 0.75)														// Time random
//	
//		GFX_Setv(ti_GFX, 13201, cvector(-1.0, -1.0, -1.0))							// Speed min
//		GFX_Setv(ti_GFX, 13202, cvector(1.0, 1.0, 1.0))								// Speed max
//
//		GFX_Setf(ti_GFX, 13000, 0.1)														// Growing speed min
//		GFX_Setf(ti_GFX, 13001, 0.3)														// Growing speed max
//		GFX_Setf(ti_GFX, 13002, 0.0001)													// Friction Grow
//
//		GFX_Setf(ti_GFX, 13007, -5.0)															// Gravity
//				
//		GFX_Setf(ti_GFX, 13005, 0.2)														// Creation size min
//		GFX_Setf(ti_GFX, 13006, 0.4)														// Creation size max
//
//		GFX_Setf(ti_GFX, 13009, 3.0)														// Norm speed min
//		GFX_Setf(ti_GFX, 13010, 3.0)														// Norm speed max
//			
//		GFX_Setv(ti_GFX, 13203, cvector(0.2, 0.2, 0.2))							// friction speed
//		
//		GFX_Seti(ti_GFX, 13103, 0xFFC0C0C0)											// Color fase 0
//		GFX_Seti(ti_GFX, 13104, 0x40C0C0C0)											// Color fase 1
//		GFX_Seti(ti_GFX, 13105, 0x00C0C0C0)											// Color fase 2
//		
//		GFX_Setf(ti_GFX, 13008, 0.01)														// generation rate
//	
//		GFX_Setv(ti_GFX, 13205, Cv_NullVector)										// Mainposspeed
//		GFX_Setv(ti_GFX, 13206, Cv_NullVector)										// Mainpossfriction
//		
//		tv_wind = DYN_SpeedGetVector() * 0.25 
//		GFX_Setv(ti_GFX, 13204, tv_wind)												// wind
//
//		tv_point_A = @ao_modules[ti_i] OBJ_PosGet()
//		tv_point_A -= tv_wind * TIME_GetDt()
//		GFX_Setv(ti_GFX, 13200, tv_point_A) 								// Creation Pos
//	}
//}

procedure_local void PNJ_Scolo_Compute_Module_Speed()
{
	int				ti_i	

	float			tf_friction
	float			tf_ground_friction
	float			tf_water_friction
	float			tf_dt
	float			tf_exp
	float			tf_ground_exp
	float			tf_water_exp
	float			tf_javelin_exp
	float			tf_archimede
	float			tf_Z_offset

	vector		tv_temp

	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)
	
	tf_dt = TIME_GetDt()

	tf_friction = 1.0
	tf_exp = MATH_Exp(-tf_dt * tf_friction)

	tf_ground_friction = 6.0
	tf_ground_exp = MATH_Exp(-tf_dt * tf_ground_friction)

	tf_water_friction = 5.0
	tf_water_exp = MATH_Exp(-tf_dt * tf_water_friction)

	if (i_flag_start_ragdoll_damping)
		f_ragdoll_damping -= MATH_FloatMin(f_ragdoll_damping, TIME_GetDt())
	else
		f_ragdoll_damping = 1.0

	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
	{
//		DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), av_modules_forces[ti_i], color_cyan)	
	
		if (ai_modules_locked[ti_i])
		{
			av_modules_speed[ti_i] = Cv_NullVector
			continue
		}	

		if (ai_modules_perfored[ti_i])
		{
			av_modules_forces[ti_i] = cvector(0.0, 0.0, f_gravity)
			tv_temp = av_modules_forces[ti_i] / tf_ground_friction
			av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_ground_exp )
			continue
		}

		// POUSSEE ARCHIMEDE
//		tf_archimede = MATH_FloatMax(af_modules_water_Z[ti_i] - @ao_modules[ti_i] OBJ_PosGet().z + tf_Z_offset, 0.0)
		tf_archimede = MATH_FloatMax(f_water_Z - @ao_modules[ti_i] OBJ_PosGet().z + tf_Z_offset, 0.0)
		tf_archimede /= tf_Z_offset * MATH_RandFloat(0.95, 1.25)
		tf_archimede = MATH_FloatLimit(tf_archimede, 0.0, 6.0)
		DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), cvector(0.0, 0.0, tf_archimede), color_bleu)
		af_modules_archimede[ti_i] = tf_archimede
		tf_archimede *= -f_gravity

		av_modules_forces[ti_i] += cvector(0.0, 0.0, f_gravity)
		av_modules_forces[ti_i].z += tf_archimede

		tv_temp = av_modules_forces[ti_i]
		
		if (tf_archimede)
		{
			f_ragdoll_damping = 1.0

			tv_temp /= tf_water_friction
//			if (i_flag_kong_mode)
			{
				av_modules_speed[ti_i].x = tv_temp.x - ( (tv_temp.x - av_modules_speed[ti_i].x) * tf_water_exp )
				av_modules_speed[ti_i].y = tv_temp.y - ( (tv_temp.y - av_modules_speed[ti_i].y) * tf_water_exp )
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			}
//			else
//			{
//				av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_water_exp )
//			}
		}
		else if (af_bone_ground_col_timer[ti_i] < 0.15)
		{
			tv_temp /= tf_ground_friction

//			if (i_flag_kong_mode)
			{
				av_modules_speed[ti_i].x = tv_temp.x - ( (tv_temp.x - av_modules_speed[ti_i].x) * tf_ground_exp )
				av_modules_speed[ti_i].y = tv_temp.y - ( (tv_temp.y - av_modules_speed[ti_i].y) * tf_ground_exp )
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			}
//			else
//			{
//				av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_ground_exp )
//			}
		}
		else
		{
			tv_temp /= tf_friction
//			if (i_flag_kong_mode)
			{
				av_modules_speed[ti_i].x = tv_temp.x - ( (tv_temp.x - av_modules_speed[ti_i].x) * tf_exp )
				av_modules_speed[ti_i].y = tv_temp.y - ( (tv_temp.y - av_modules_speed[ti_i].y) * tf_exp )
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			}
//			else
//			{
//				av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_exp )
//			}
		}

		av_modules_speed[ti_i] *= f_ragdoll_damping
	}
}

procedure_local void PNJ_Scolo_Rag_Doll(int ti_first_index)
{
	int			ti_i
	int			ti_iterations
	int			ti_bone_index
	int			ti_flag_paf

	float		tf_norm
	float		tf_Z_offset
	float		tf_dot_product
	float		tf_dt
	float		tf_inv_dt
	float		tf_sqr_n2_dist
	float		tf_sqr_n3_dist
	float		tf_sqr_n5_dist
	float		tf_attenuation
	float		tf_spring
	float		tf_move_length

	vector	tav_last_pos[15]
	vector	tv_temp
	vector	tv_col_pos
	vector	tv_col_normal
	vector	tv_force
	vector	tv_dest_banking
	vector	tv_delta_pos
	vector	tv_delta_speed
	vector	tv_A
	vector	tv_B
	vector	tv_prec
	vector	tv_next
	
	object	to_collided_object

	if (ti_first_index == i_modules_nb - 1)
		return

	tf_sqr_n2_dist = f_n2_dist * f_n2_dist 
	tf_sqr_n3_dist = f_n3_dist * f_n3_dist 
	tf_sqr_n5_dist = f_n5_dist * f_n5_dist

	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)
	tf_Z_offset += f_death_Z

	tf_dt = TIME_GetDt()
	tf_inv_dt = 1.0 / tf_dt

	// DYNAMIQUE DES MODULES
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		if (ti_i == i_snaped_bone_index)
//			continue

		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()

		// GRAVITY
		av_modules_forces[ti_i] = Cv_NullVector

		// PAFs
		if (i_flag_paf)
		{
			if (ti_i == i_modules_pafed_index)
			{
				if (ai_modules_perfored[ti_i])
				{
				}
				else
				{	
					av_modules_speed[ti_i].x = v_module_paf_dir.x
					av_modules_speed[ti_i].y = v_module_paf_dir.y
	
					if (af_bone_ground_col_timer[ti_i] < 0.1 || av_modules_speed[ti_i].z < 0.0)
						av_modules_speed[ti_i].z = MATH_FloatMax(v_module_paf_dir.z, 4.0)
					else
						av_modules_speed[ti_i].z = v_module_paf_dir.z
				}
					
				af_bone_ground_col_timer[ti_i] = 1000.0
			}
			else
			{
				av_modules_speed[ti_i].x += v_module_paf_dir.x * 0.1
				av_modules_speed[ti_i].y += v_module_paf_dir.y * 0.1

				if (af_bone_ground_col_timer[ti_i] < 0.1 || av_modules_speed[ti_i].z < 0.0)
					av_modules_speed[ti_i].z = MATH_FloatMax(v_module_paf_dir.z * 0.1, MATH_RandFloat(1.0, 2.0))
				else
					av_modules_speed[ti_i].z += v_module_paf_dir.z * 0.1

				af_bone_ground_col_timer[ti_i] = 1000.0
			}

			av_modules_speed[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(av_modules_speed[ti_i], av_bone_col_normal[ti_i]), 0.0) * av_bone_col_normal[ti_i]
		}
		else
		{
			// SPRING
			if (0)
			{
				if (ti_i)
				{
					tv_delta_pos = tav_last_pos[ti_i]
					tv_delta_pos -= tav_last_pos[ti_i - 1]
				
					tv_delta_speed = av_modules_speed[ti_i]
					tv_delta_speed -= av_modules_speed[ti_i - 1]
					
					tv_force = tv_delta_pos
					tf_norm = MATH_VecDotProduct(tv_force, tv_force)
					if (tf_norm > 0.001)
					{
						tf_norm = MATH_FloatSqrt(tf_norm)
						tv_force /= tf_norm
	
						tf_attenuation = (MATH_VecDotProduct(tv_delta_speed, tv_delta_pos) / tf_norm) * f_damping_coef
					}
					else
					{
						tv_force = @ao_modules[ti_i] OBJ_SightGet()
						
						tf_attenuation = 0.0
					}
	
					tf_spring = (tf_norm - dist_between_module) * f_spring_coef
	
					tv_force *= tf_attenuation - tf_spring
	
	//				DBG_RenderVector(tav_last_pos[ti_i], tv_force, color_cyan)
	//				DBG_RenderVector(tav_last_pos[ti_i - 1], -tv_force, color_cyan)
				
					av_modules_forces[ti_i] += tv_force
					av_modules_forces[ti_i - 1] -= tv_force
				}
			}
			
		}
	}


	// TENSIONS
	if (1)
	{
		tv_force = tav_last_pos[0]
		tv_force -= tav_last_pos[5]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[0] += tv_force
			av_modules_forces[5] -= tv_force
		}

		tv_force = tav_last_pos[0]
		tv_force -= tav_last_pos[10]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[0] += tv_force
			av_modules_forces[10] -= tv_force
		}

		tv_force = tav_last_pos[0]
		tv_force -= tav_last_pos[14]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[0] += tv_force
			av_modules_forces[14] -= tv_force
		}

		tv_force = tav_last_pos[14]
		tv_force -= tav_last_pos[5]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[14] += tv_force
			av_modules_forces[5] -= tv_force
		}

		tv_force = tav_last_pos[5]
		tv_force -= tav_last_pos[10]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[5] += tv_force
			av_modules_forces[10] -= tv_force
		}
	}

	// RIGIDITE
	if (1)
	{
		tv_next = @ao_modules[1] OBJ_PosGet()
		tv_next  -= @ao_modules[0] OBJ_PosGet()
		tf_norm = MATH_VecDotProduct(tv_next , tv_next )
		if (tf_norm > 0.001)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_next /= tf_norm
		}
		else
		{
			tv_next = @ao_modules[0] OBJ_SightGet()
		}
		
		for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
		{
			if (ti_i && ti_i < i_modules_nb - 1)
			{
				tv_prec = -tv_next
	
				tv_next = @ao_modules[ti_i + 1] OBJ_PosGet()
				tv_next -= @ao_modules[ti_i] OBJ_PosGet()
				tf_norm = MATH_VecNorm(tv_next)

				if (MATH_FloatNullToler(tf_norm, 0.001))
					continue
					
				tv_next /= tf_norm
				
				tf_dot_product = 1.0 + MATH_VecDotProduct(tv_prec, tv_next)	
				tf_dot_product *= 0.5
				tf_dot_product *= tf_dot_product
//				if (tf_dot_product > 0.3)
				{
//					DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), tv_next * dist_between_module, color_jaune)	
//					DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), tv_prec * dist_between_module, color_jaune)	

					tv_temp = MATH_VecCrossProduct(tv_prec, tv_next)
					if ( MATH_FloatNullToler( MATH_VecDotProduct(tv_temp, tv_temp), 0.001) )
						tv_temp = @ao_modules[ti_i] OBJ_HorizonGet()
					
					tv_A = MATH_VecCrossProduct(tv_prec, tv_temp)
					tf_norm = MATH_VecDotProduct(tv_A, tv_A)
					if (tf_norm < 0.001)
						continue

					tf_norm = MATH_FloatSqrt(tf_norm)
					tv_A /= tf_norm
		
					tv_B = MATH_VecCrossProduct(tv_temp, tv_next)
					tf_norm = MATH_VecDotProduct(tv_B, tv_B)
					if (tf_norm < 0.001)
						continue
						
					tf_norm = MATH_FloatSqrt(tf_norm)
					tv_B /= tf_norm
					
					tf_dot_product = MATH_FloatMin(tf_dot_product * 200.0, 20.0)	
			
					tv_A *= tf_dot_product 
					tv_B *= tf_dot_product
					
					av_modules_forces[ti_i - 1] += tv_A
					av_modules_forces[ti_i] -= tv_A + tv_B
					av_modules_forces[ti_i + 1] += tv_B
				}
			}
		}
	}

	// GIGOTAGE
	if (f_lifecur && i_perfored_module_index != -1)
	{
		f_delay_before_bend -= MATH_FloatMin(f_delay_before_bend, TIME_GetDt())
		if ( ! f_delay_before_bend )
		{
			f_delay_before_bend = MATH_RandFloat(0.1, 0.3)
			for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
				av_modules_speed[ti_i] += cvector(MATH_RandFloat(-1.0, 1.0), MATH_RandFloat(-1.0, 1.0), MATH_RandFloat(-1.0, 1.0)) * (f_size_coef * 10.0)
		}
	}

	if (f_ragdoll_damping)
	{
		// CALCUL DE LA DYNAMIQUE
		PNJ_Scolo_Compute_Module_Speed()
	
		// DEPLACEMENT
		for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
		{
			af_bone_col_timer[ti_i] += TIME_GetDt()
			af_bone_ground_col_timer[ti_i] += TIME_GetDt()
	
//			DBG_RenderVector(tav_last_pos[ti_i], av_modules_speed[ti_i], color_jaune)
			@ao_modules[ti_i] OBJ_PosSet(tav_last_pos[ti_i] + (av_modules_speed[ti_i] * tf_dt)) 
		}

		if (i_perfored_module_index != -1 && ! ai_modules_locked[i_perfored_module_index] )
		{
			if (MATH_VecDotProduct(av_modules_speed[i_perfored_module_index], av_modules_speed[i_perfored_module_index]) > 0.001)
				@ao_modules[i_perfored_module_index] OBJ_Rotate_FromTo(av_modules_quat[i_perfored_module_index], @ao_modules[i_perfored_module_index] MATH_VecGlobalToLocal(av_modules_speed[i_perfored_module_index]))
		}
	
		// COLLISIONS
		if (1) // && i_etat_courant != ETAT_Grabbed_By_Kong)
		{
			if (o_KK_Grabbed_actor && @o_KK_Grabbed_actor Proc_KK_Try_To_Hit())
				f_ray_can_paf_duration = 1.0
				
			if (f_ray_can_paf_duration)
				ti_flag_paf = vrai
			else
				ti_flag_paf = faux
		
			for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
			{
				if (ai_modules_locked[ti_i])
				{
					af_bone_col_timer[ti_i] = 0.0
					continue
				}
	
				tv_temp = @ao_modules[ti_i] OBJ_PosGet()
				tv_temp -= tav_last_pos[ti_i]
				tf_norm = MATH_VecNorm(tv_temp)
	
				tf_move_length = tf_norm
	
				ti_iterations = 0
	
				while (tf_norm > 0.001 && ti_iterations < 5)
				{
					ti_iterations++
	
					tv_temp /= tf_norm
				
					if ( ti_iterations == 1)
						COL_CrossableSet(none, i_gmat_water_bit)
					else
						COL_CrossableSet(i_gmat_water_bit, none)

					to_collided_object = COL_RayObject_Dist(tav_last_pos[ti_i], tv_temp, tf_norm + f_size_coef, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
					if (to_collided_object)
					{
						tv_col_pos = COL_RayObject_PosGet()
						tv_col_normal = COL_RayObject_NormalGet()

						if (COL_GMAT_FlagsGet(COL_C_Ray) & i_gmat_water_bit)
						{
							DBG_RenderVector(tv_col_pos, tv_col_normal, color_bleu)

							if (MATH_AbsFloat(tv_col_normal.z) > Cf_Cos60)
							{
//								f_water_Z = MATH_FloatMax(f_water_Z, tv_col_pos.z)
								f_water_Z = tv_col_pos.z
							}
							
							COL_CrossableSet(i_gmat_water_bit, none)
							if (COL_RayObject_Dist(tav_last_pos[ti_i], tv_temp, tf_norm + f_size_coef, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
							{
								tv_col_pos = COL_RayObject_PosGet()
								tv_col_normal = COL_RayObject_NormalGet()
							}
							else
							{
								break
							}
						}

						if (ti_flag_paf)
						{
							to_collided_object = COL_RayObject_ActorGet()
							if (@to_collided_object OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI))
								EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_collided_object, 10.0 * PAF_Unit, tv_temp)	
						}
						
//						DBG_RenderVector(tv_col_pos, tv_col_normal, color_bleu)	
	
						tf_dot_product = MATH_VecDotProduct(tv_temp, -tv_col_normal)
						if (tf_dot_product > 0.3)
							tf_dot_product = -tf_Z_offset / tf_dot_product
						else
							tf_dot_product = 1000.0
							
						if (tf_dot_product < tf_norm + tf_Z_offset)
						{
							tv_temp *= tf_dot_product
							tv_temp += tv_col_pos
						}
						else
						{
							tv_temp = tv_col_pos
							tv_temp += tv_col_normal * tf_Z_offset
						}
	
//						if (MATH_VecDotProduct(tv_temp - tav_last_pos[ti_i], tv_temp - tav_last_pos[ti_i]) < tf_move_length) // * tf_move_length)
						if (MATH_VecNorm(tv_temp - tav_last_pos[ti_i]) < tf_move_length + tf_Z_offset)
						{
							@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	
							if (COL_GMAT_FlagsGet(COL_C_Ray) & i_gmat_death_bit)
								i_flag_force_death = vrai
		
							af_bone_col_timer[ti_i] = 0.0
		
							if (ai_modules_perfored[ti_i])
							{
								ai_modules_locked[ti_i] = vrai
								av_modules_speed[ti_i] = Cv_NullVector
								break
							}
							else
							{
								if (tv_col_normal.z > Cf_Cos45)
									af_bone_ground_col_timer[ti_i] = 0.0	
				
								if (ti_iterations > 1)
									av_bone_col_normal[ti_i] = MATH_VecBlendRotate(av_bone_col_normal[ti_i], tv_col_normal, 0.5)
								else
									av_bone_col_normal[ti_i] = tv_col_normal
		
								// GLISSING !!!
								tv_temp = tav_last_pos[ti_i]
								tv_temp += av_modules_speed[ti_i] * tf_dt
								tv_temp -= @ao_modules[ti_i] OBJ_PosGet()
								tv_temp -= MATH_VecDotProduct(tv_temp, tv_col_normal) * tv_col_normal
								
								// BEUARK FRICTION
								tv_temp *= 0.8
		
								@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i] OBJ_PosGet() + tv_temp)
							
								av_modules_speed[ti_i] -= MATH_VecDotProduct(av_modules_speed[ti_i], tv_col_normal) * tv_col_normal
					
								tv_temp = @ao_modules[ti_i] OBJ_PosGet()
								tv_temp -= tav_last_pos[ti_i]
								tf_norm = MATH_VecNorm(tv_temp)
							}
						}
						else
						{
							break
						}
					}
					else
					{
						break
					}
				}
	
				if (ti_iterations == 0)
				{
					tf_norm = tf_norm
				}
			}
		}
	
	//	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	//		DBG_RenderSphere(@ao_modules[ti_i] OBJ_PosGet(), tf_Z_offset, 0x80804080)	
	
		// RENORMALISATION
//		if (i_etat_courant == ETAT_Grabbed_By_Kong)	
//			PNJ_Scolo_Renormalisation(ti_first_index, i_modules_nb - 1, 20)
//		else
			PNJ_Scolo_Renormalisation(ti_first_index, i_modules_nb - 1, 10)
	}

	i_on_ground_modules_nb = 0
	i_in_water_modules_nb = 0
	
	// CALCUL DES SPEED ET DES ORIENTATIONS
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		if (ti_i == i_snaped_bone_index)
//			continue

//		if (tai_bone_collision[ti_i] && ai_modules_perfored[ti_i])
//			ai_modules_locked[ti_i] = vrai

		if (af_modules_archimede[ti_i])
		{
			i_in_water_modules_nb++

			if (af_modules_archimede[ti_i] < 1.5 && av_modules_speed[ti_i].z > -1.0)
				i_on_ground_modules_nb++
		}
		else if (af_bone_ground_col_timer[ti_i] < 0.15)
		{
			i_on_ground_modules_nb++
		}
		else
		{
			av_bone_col_normal[ti_i] = Cv_NullVector
		}

//		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
//		tv_temp *= tf_inv_dt
//		tv_temp -= MATH_VecDotProduct(tv_temp, av_bone_col_normal[ti_i]) * av_bone_col_normal[ti_i]
//			
//		av_modules_speed[ti_i] = tv_temp

		if (i_perfored_module_index != -1)
		{
			tv_dest_banking = @ao_modules[i_perfored_module_index] OBJ_BankingGet()
		}
		else if (af_bone_col_timer[ti_i] < 0.1)
		{
			tv_dest_banking = av_bone_col_normal[ti_i]
			if ( ! f_lifecur )
				tv_dest_banking *= -1.0
		}
		else
		{
//			tv_dest_banking = v_dest_banking
			if ( f_lifecur )
				tv_dest_banking = Cv_VerticalVector
			else
				tv_dest_banking = -Cv_VerticalVector
		}

		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		tv_temp *= tf_inv_dt
		tv_temp -= MATH_VecDotProduct(tv_temp, av_bone_col_normal[ti_i]) * av_bone_col_normal[ti_i]
			
		av_modules_speed[ti_i] = tv_temp

		if (ti_i)
			tv_dest_banking = MATH_VecBlendRotate(tv_dest_banking, @ao_modules[ti_i - 1] OBJ_BankingGet(), 0.5)
		else
			tv_dest_banking = MATH_VecBlendRotate(tv_dest_banking, @ao_modules[ti_i + 1] OBJ_BankingGet(), 0.5)

		tv_dest_banking = MATH_VecBlendRotate(@ao_modules[ti_i] OBJ_BankingGet(), tv_dest_banking, 4.0 * TIME_GetDt())

		if ( ai_modules_locked[ti_i]  || ai_modules_perfored[ti_i] )
			continue

		if (ti_i == i_modules_nb - 1)
			@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet(), tv_dest_banking)
		else if (!ti_i)
			@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i + 1] OBJ_PosGet(), tv_dest_banking)
		else
			@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i + 1] OBJ_PosGet(), tv_dest_banking)
	}
	
	if (!i_flag_start_ragdoll_damping && i_on_ground_modules_nb == 15)
		i_flag_start_ragdoll_damping = vrai

	COL_CrossableSet(i_gmat_water_bit, none)

	return
}

procedure_local void PNJ_Scolo_KKFinish_Init()
{
	// init params mode finish
	@get_global o_KNMI_finish_leader = OBJ_Me()
	LNK_Finish_ActionSet(mid_kk_finish_LNK, Ci_GrabKong_FinishSePlace)
	LNK_Finish_FinisherTypeSet(mid_kk_finish_LNK, Ci_GrabKong_Finished_Scolo)
}

procedure_local void PNJ_Scolo_KKFinish_Reset()
{
	@get_global o_KNMI_finish_leader = nobody
	o_kk_finish = LNK_ThisClientGet(o_kk_finish, Ci_LNK_KKFINISH_ON_KONG, mid_kk_finish_LNK, faux, nofunc, nofunc, nofunc)
}

procedure_local void PNJ_Scolo_SetGFXTracePointData(int ti_point_index, int ti_color, vector tv_pos, vector tv_speed)
{
	#define noiseprop 0.15
	#define Cf_Water_visual_offset 0.02

	GFX_Seti(GFX_Water_Trace, 12104 , ti_point_index) // Actual point to set
	GFX_Seti(GFX_Water_Trace, 12109 , ti_color) 	// Color
	GFX_Setv(GFX_Water_Trace, 12200, tv_pos) 	// StartPos
	GFX_Setv(GFX_Water_Trace, 12201, (1.0 - noiseprop ) * tv_speed) 	// Speed
	GFX_Setv(GFX_Water_Trace, 12208, noiseprop * 	tv_speed) 	// Random Speed
	GFX_Setf(GFX_Water_Trace, 12003, f_water_Z + Cf_Water_visual_offset)	// Constraint ZMin
}

procedure_local void PNJ_Scolo_GFX_Trace()
{
	float		tf_coef
	float		tf_Z_offset
	vector 	tv_pos
	vector	GX, GY, GZ
	int			ti_temp
	int 		Color

	float		alpha_airtrace	
	float		tf_Z_coef
	float		Largeur_A
	float		Largeur_B
	float		Largeur_C
	float		tf_speed
	float		tf_norm
	
	object	to_visuel	

	#define Force_Jet_SIDE 1.0
	#define Force_Jet_UP 1.0
	
	tv_pos = OBJ_PosGet()

	tf_Z_offset = COL_ZoneSizeGet(C_zdm_pied)

	Largeur_A = tf_Z_offset * 1.5
	Largeur_B = tf_Z_offset * 1.25
	Largeur_C = tf_Z_offset
	
	if (OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna))
		GY = DYN_SpeedGetVector()
	else
		GY = av_modules_speed[0]

	GY.z = 0.0
	tf_speed = MATH_VecNorm(GY)
	if (tf_speed > 0.01)
	{
		GY /= tf_speed
	}
	else
	{
		GY = OBJ_SightGet()
		GY.z = 0.0
		tf_norm = MATH_VecNorm(GY)
		if (tf_norm > 0.01)
			GY /= tf_norm
		else
		{
			GY = - OBJ_BankingGet()
			MATH_VecSetHorzNormalize(GY)
		}
	}

	tf_Z_coef = MATH_AbsFloat(tv_pos.z - f_water_Z)
	tf_Z_coef = MATH_FloatMax(tf_Z_coef - tf_Z_offset, 0.0)
	tf_Z_coef /= tf_Z_offset
	tf_Z_coef = 1.0 - MATH_FloatMin(tf_Z_coef, 1.0)

	if (i_etat_courant == ETAT_Paf)
		tf_coef = MATH_FloatMin(MATH_VecNorm(av_modules_speed[0]), 2.0)
	else
		tf_coef = MATH_FloatMin(DYN_SpeedGet(), 2.0)
	tf_coef /= 2.0
	tf_coef *= tf_Z_coef

	if (i_flag_desappear)
		alpha_airtrace = 0.0
	else
		alpha_airtrace = tf_coef

	if ( ! tf_coef || i_etat_courant == ETAT_Attaque )
	{
		alpha_airtrace	= 0.0	
	
		f_time_trace_off += TIME_GetDt()
	
		if (GFX_Water_Trace == -1)
		{
			return
		}
		else if (f_time_trace_off > 1.0)
		{
			GFX_Del(GFX_Water_Trace)
			GFX_Water_Trace = -1
			return
		}
	}
	else
	{
		if (f_time_trace_off)
			alpha_airtrace	= 0.0

		f_time_trace_off = 0.0
	}

	if(GFX_Water_Trace == -1)
	{
		alpha_airtrace	= 0.0
	
		to_visuel = ANI_CanalObjectGet(0)

		GFX_Water_Trace = GFX_Add(12)
		if (i_modele == Ci_Modele_Standard)
			GFX_MaterialSet(GFX_Water_Trace, to_visuel, 1)	// met le materiau
		else
			GFX_MaterialSet(GFX_Water_Trace, to_visuel, 2)	// met le materiau

//		GFX_MaterialSet(GFX_Water_Trace, get_SFX_light_and_smoke, 0)	// met le materiau

		GFX_Seti(GFX_Water_Trace, 12100 , 6)												// Number of point per profile
		GFX_Seti(GFX_Water_Trace, 12101 , 5) 											// Number of Link per profile
		GFX_Seti(GFX_Water_Trace, 12102 , 16) 											// Number of profiles
		
		GFX_Seti(GFX_Water_Trace, 12103 , 1) 											// start
		GFX_Seti(GFX_Water_Trace, 12111 , 8) 											// UTiler
		
		GFX_Setf(GFX_Water_Trace, 12004 , 0.25) 											// Segment lenght min
		GFX_Setv(GFX_Water_Trace, 12202, cvector(0.01,0.01,0)) 						// Friction
		
		GFX_Seti(GFX_Water_Trace, 12105 , 0) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace, 12106 , 0) 											// Point A
		GFX_Seti(GFX_Water_Trace, 12107 , 1) 											// Point B
		
		GFX_Setf(GFX_Water_Trace, 12001 , 0.0) 											// Point VA
		GFX_Setf(GFX_Water_Trace, 12002 , 0.33) 										// Point VB
			
		GFX_Seti(GFX_Water_Trace, 12105 , 1) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace, 12106 , 1) 											// Point A
		GFX_Seti(GFX_Water_Trace, 12107 , 2) 											// Point B
		
		GFX_Setf(GFX_Water_Trace, 12001 , 0.33) 											// Point VA
		GFX_Setf(GFX_Water_Trace, 12002 , 0.66) 											// Point VB
			
		GFX_Seti(GFX_Water_Trace, 12105 , 2) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace, 12106 , 2) 											// Point A
		GFX_Seti(GFX_Water_Trace, 12107 , 3) 											// Point B
		
		GFX_Setf(GFX_Water_Trace, 12001 , 0.66) 									// Point VA
		GFX_Setf(GFX_Water_Trace, 12002 , 1.0) 										// Point VB
		
		GFX_Seti(GFX_Water_Trace, 12105 , 3) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace, 12106 , 3) 											// Point A
		GFX_Seti(GFX_Water_Trace, 12107 , 4) 											// Point B
		GFX_Setf(GFX_Water_Trace, 12001 , 0.5) 											// Point VA
		GFX_Setf(GFX_Water_Trace, 12002 , 0.75) 											// Point VB
		
		GFX_Seti(GFX_Water_Trace, 12105 , 4) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace, 12106 , 4) 											// Point A
		GFX_Seti(GFX_Water_Trace, 12107 , 5) 											// Point B
		GFX_Setf(GFX_Water_Trace, 12001 , 0.75) 										// Point VA
		GFX_Setf(GFX_Water_Trace, 12002 , 1.0) 											// Point VB
			
		GFX_FlagSet(GFX_Water_Trace, 0 , 1)
		GFX_FlagSet(GFX_Water_Trace, 2 , 1)
	}

//	Color = 0x00C0DFDF
//	ti_temp = alpha_airtrace * 64
//	Color |= (ti_temp << 24)

	if (f_water_Z < -1000.0)
		Color = 0
	else
		Color = COLOR_Blend(0, 0x40C0DFDF, alpha_airtrace)

	// POSITIONNEMENT DES POINTS
	PNJ_Scolo_SetGFXTracePointData(0, Color, cvector(-Largeur_A, 0.0, 0.0), tf_coef * cvector(-Force_Jet_SIDE, 0.0, Force_Jet_UP) * 1.5)
	PNJ_Scolo_SetGFXTracePointData(5, Color, cvector(Largeur_A, 0.0, 0.0), tf_coef * cvector(Force_Jet_SIDE, 0.0, Force_Jet_UP) * 1.5)
	PNJ_Scolo_SetGFXTracePointData(1, Color, cvector(-Largeur_B, 0.0, 0.0), tf_coef * cvector(-Force_Jet_SIDE, 0.0, Force_Jet_UP))
	PNJ_Scolo_SetGFXTracePointData(4, Color, cvector(Largeur_B, 0.0, 0.0), tf_coef * cvector(Force_Jet_SIDE, 0.0, Force_Jet_UP))
	PNJ_Scolo_SetGFXTracePointData(2, Color, cvector(-Largeur_C, 0.0, 0.0), tf_coef * cvector(-Force_Jet_SIDE, 0.0, Force_Jet_UP) * 0.5)
	PNJ_Scolo_SetGFXTracePointData(3, Color, cvector(Largeur_C, 0.0, 0.0), tf_coef * cvector(Force_Jet_SIDE, 0.0, Force_Jet_UP) * 0.5)
	
	GFX_Setf(GFX_Water_Trace, 12000 , -5.0) 									// Gravity
	
	GY *= -1.0
	GZ = Cv_VerticalVector
	GX = MATH_VecCrossProduct(GY, GZ)
//	DBG_RenderVector(OBJ_PosGet(), GX * 5.0, color_rouge)
		
	GFX_Setv(GFX_Water_Trace, 12203, GX) // GX
	GFX_Setv(GFX_Water_Trace, 12204, GY) // GY
	GFX_Setv(GFX_Water_Trace, 12205, GZ) // GZ
	
	tv_pos.z = f_water_Z + Cf_Water_visual_offset
	GFX_Setv(GFX_Water_Trace, 12206, tv_pos) // GT
	
	// SI VUE INTERIEURE
	GFX_Seti(GFX_Water_Trace, 12103 , 1) // Start
}

procedure_local void PNJ_Scolo_Recompute_BV()
{
	int		ti_i

	vector	tv_module_pos		
	vector	tv_bv_min
	vector	tv_bv_max

	tv_bv_min = cvector(Cf_Infinit, Cf_Infinit, Cf_Infinit)
	tv_bv_max = -tv_bv_min

	for (ti_i = 0; ti_i < i_modules_nb; ti_i += 3)
	{
		tv_module_pos = @ao_modules[ti_i] OBJ_PosGet()

		tv_bv_min.x = MATH_FloatMin(tv_module_pos.x, tv_bv_min.x) 
		tv_bv_min.y = MATH_FloatMin(tv_module_pos.y, tv_bv_min.y) 
		tv_bv_min.z = MATH_FloatMin(tv_module_pos.z, tv_bv_min.z) 

		tv_bv_max.x = MATH_FloatMax(tv_module_pos.x, tv_bv_max.x) 
		tv_bv_max.y = MATH_FloatMax(tv_module_pos.y, tv_bv_max.y) 
		tv_bv_max.z = MATH_FloatMax(tv_module_pos.z, tv_bv_max.z) 
	}
	
	tv_bv_min -= OBJ_PosGet()
	tv_bv_max -= OBJ_PosGet()
	
	tv_bv_min -= cvector(f_size_coef, f_size_coef, f_size_coef)
	tv_bv_max += cvector(f_size_coef, f_size_coef, f_size_coef)
	
	BV_MinSet(tv_bv_min)
	BV_MaxSet(tv_bv_max)
}

// Retourne vrai si c'est un BIG SCOLO, faux sinon
procedure_ultra int Proc_KK_BigScolo()
{
	return KK_Grab2Hands
}

procedure_ultra object	Proc_KK_Scolo_Bone( int	pi_ind)
{
	if ( pi_ind >= i_modules_nb)
		pi_ind = i_modules_nb - 1
	return ao_modules[pi_ind]
}

procedure_ultra int Proc_KK_Scolo_canBeDodged()
{
	if( ! Proc_KK_BigScolo() )
		return faux
		
	if( ! f_lifecur )
		return faux
	
	return vrai
}

procedure_local int Proc_KS_Scolo_Pafs_Effects_Check(int ti_paf_type)
{
//	if( i_flag_kong_mode )
	{
		if( ! EVENT_LIFE_CurLifeGet(ID_LIFE) )
		{
			if( i_etat_courant == ETAT_KKIFinish )
				return vrai
			else
				return faux
		}
		if( ti_paf_type & C_PAF_KK_Repousse )
			return faux
		if( Proc_KK_BigScolo() && ti_paf_type & C_PAF_KK_Fort )
			return vrai		// paf fort et big scolo en vie
		if( @o_kong Proc_KK_RAGE_Test() )
			return vrai
	}
	return faux
}

procedure_ultra int Proc_KS_Scolo_Launch_Reward()
{
	return KK_Is_Reward
}

procedure_local void Proc_KK_Scolo_Send_Paf(object to_target)
{
	int		ti_paf
	float		ti_dommage

	if (TIME_Elapsed(f_time_last_bite_sound, 0.3))
	{
		f_time_last_bite_sound = TIME_Get()
		SND_RequestPlay(SND_BITE)
	}

	ti_paf = 0

	if ( Proc_KK_BigScolo() )
	{
		ti_paf = C_PAF_KK_Fort				// Big Scolo already hit Kong
		ti_dommage = 50 * PAF_Unit
	}
	else if (to_target == o_kong && @to_target Proc_KK_Test_Mode(ETAT_Kong_grab_mashing) )
	{
		ti_paf = C_PAF_KK_Moyen		// small scolos hit Kong if he is in pilar mashing
		ti_dommage = 10 * PAF_Unit
	}

	if( ti_paf )
		EVENT_AddEventPaf(C_EVENT_FILTER_All, ti_paf, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_target, ti_dommage, OBJ_SightGet())

	// Change the direction of the speed because it goes through Kong !
	DYN_SpeedSetVector(MATH_VecCrossProduct(DYN_SpeedGetVector(), Cv_VerticalVector) * 0.70)
}

procedure_ultra int Proc_KK_Scolo_Finish_Allowed()
{
	if( f_lifecur > 0.0 && f_lifecur <= Cf_KK_Big_Scolo_Life_Max_For_Allowing_Grab_Finish )
		return vrai
	else
		return faux
}

procedure_local void Proc_KK_Scolo_Kong_a_Gagne()
{
	if( ! i_kk_I_finish_paf )
	{
		i_kk_I_finish_paf = vrai
		f_lifecur = 0.0
		i_flag_death_sound_played = vrai
		SND_RequestPlay(SND_DIE)
		OBJ_CapaSet(OBJ_Capa_15, none)
		STATS_IncEnemyKilled_New(o_kong, C_EnemyType_Scolo_Gros, 0)
	}
}

procedure_local int Proc_KK_Scolo_With_ODE()
{
//	if( i_flag_kong_mode && Proc_KK_BigScolo() )
	if( Proc_KK_BigScolo() )
		return vrai
	else
		return faux
}

// GFX ====================================================================================
procedure_local void Proc_KK_Scolo_GFX_Particules(vector tv_pos, vector tv_paf_dir)
{
	int			pi_GFX_Blood
	color 		materiau_color
	vector	tv_lat2_axis, tv_lat_axis 
	int			ti_nb_sprite
	object	to_light_n_smoke
	
	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
	if( ! to_light_n_smoke )
		return
	
//	if( ! i_flag_kong_mode )		// kong mode only (light & smoke kanada)
//		return
	
	if( Proc_KK_BigScolo() )
		ti_nb_sprite = 60
	else
		ti_nb_sprite = 30
	
	materiau_color = color_test
	
	tv_lat_axis = MATH_VecCrossProduct(tv_paf_dir, Cv_VerticalVector)
	tv_lat2_axis = MATH_VecCrossProduct(tv_paf_dir, tv_lat_axis)
	
	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 1)															// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13100, 60)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, ti_nb_sprite)											// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.05)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 0.4)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.0)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.3)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.5)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.15 )													// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.3 )														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
	GFX_Seti(pi_GFX_Blood, 13103, 0x00000000 + materiau_color)					// Color fase 0
	GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)					// Color fase 1
	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 5)															// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 10)														// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -5.0)														// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, tv_paf_dir)												// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13201, tv_paf_dir + (tv_lat_axis * 0.2) + (tv_lat2_axis * 0.2) )					// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, (tv_paf_dir * 5.0) - (tv_lat_axis * 1.2 ) - (tv_lat2_axis * 1.2 ) )											// Speed max
}


