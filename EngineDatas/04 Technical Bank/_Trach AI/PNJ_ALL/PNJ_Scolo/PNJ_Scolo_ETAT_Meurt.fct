#include "PNJ_Scolo_defines.var"

int				ti_i
int				ti_flag_stop

float			tf_speed
float			tf_coef
float			tf_target_speed

vector		tv_pos
vector		tv_new_sight
vector		tv_new_banking
vector		tv_speed
vector		tv_traction

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux
	PNJ_Scolo_Virtual_Net_Init(vrai, nobody)
	return
}

if (i_etat_courant != ETAT_Meurt)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Meurt
	
	if (i_dernier_etat != ETAT_RAGDOLL)
		macro_change_etat("PNJ_Scolo_ETAT_Ragdoll")

	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()

	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_NeverDynamicFather | DYN_C_NeverDynamicHierarchy | DYN_C_HorizontalGrounds, none)
	DYN_GravitySet(Cv_Scolo_Gravity)
	DYN_FrictionVectorSet(Cv_NullVector)

	COL_ColSetActivationSet(C_bit_zdm_pied, none)
	COL_StartMatrixSet(OBJ_PosGet())

	if (i_modele == Ci_Modele_Big)
	{
	}
	else
	{
		switch(i_dernier_etat)
		{
			case ETAT_Grabbed :
				DYN_SpeedSetVector(av_modules_speed[5])	
				break
		
			case ETAT_Sol :
			case ETAT_Attaque :
			case ETAT_Snap :
				DYN_SpeedSetVector(v_paf_dir)
				break

			case ETAT_Mur :
				tv_speed = DYN_SpeedGetVector()
				tv_speed += OBJ_BankingGet() * 4.0
				DYN_SpeedSetVector(tv_speed)
				break
	
			default:
				tv_speed = OBJ_SightGet() * 8.0
				tv_speed += OBJ_BankingGet() * 4.0
				DYN_SpeedSetVector(tv_speed)
				break
		}
	}
	
	o_grab_actor = LNK_ServeurGet(Ci_LNK_GRAB_RAPTOR, mid_grab_actor_LNK_ID, faux, "PNJ_Scolo_exec_propose_grab", nofunc)

	PNJ_Scolo_Virtual_Net_Init(vrai, nobody)

	DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_jaune)

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}
	
// ANALYSE ===============================================================

AI_Execute("PNJ_Scolo_exec_check_vision")

AI_Execute("PNJ_Scolo_exec_check_paf")
if (f_time_start_etat && i_flag_paf)
	DYN_SpeedSetVector(v_paf_dir)

AI_Execute("PNJ_Scolo_exec_check_best_interet")

if (f_lifecur)
{
	if (f_time_start_etat > 2.0  && ! f_delay_until_last_ground_col)
		macro_change_etat("PNJ_Scolo_ETAT_Sol")
}
//else if (f_time_start_etat > 5.0)
//	OBJ_Destroy()

// COMPORTEMENT =========================================================
if ( ! i_flag_paf && COL_CollideType(COL_C_Ground))
{
	f_delay_until_last_ground_col = 0.0

	v_ground_pos = COL_CollidedPointGet(COL_C_Ground)

	v_ground_normal	= COL_ZonePosGet(C_zdm_pied)
	v_ground_normal -= v_ground_pos
	
	MATH_VecSetNormalize(v_ground_normal)
}
else
{
	f_last_speed = DYN_SpeedGet()

	f_delay_until_last_ground_col += TIME_GetDt()
	
	v_ground_normal = MATH_VecBlendRotate(v_ground_normal, Cv_VerticalVector, f_delay_until_last_ground_col)
}

f_delay_until_last_wall_col = 1000.0

tv_pos = @ao_modules[i_modules_nb - 1] OBJ_PosGet()
tv_pos.z = MATH_FloatMax(tv_pos.z, OBJ_PosGet().z)

if (COL_RayObject_Dist(tv_pos, -Cv_VerticalVector, 10.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
{
	v_ray_pos = COL_RayObject_PosGet()
	v_ray_normal = MATH_VecBlendRotate(v_ray_normal, COL_RayObject_NormalGet(), 4.0 * TIME_GetDt())
}

if (f_delay_until_last_wall_col < 0.2)
{
	DYN_GravitySet(Cv_NullVector)

//	DYN_TractionSet(OBJ_BankingGet() * Cv_Scolo_Gravity.z)

	tv_traction = v_wall_normal * Cv_Scolo_Gravity.z
	tv_traction.x *= DYN_FrictionGet()
	tv_traction.y *= DYN_FrictionGet()
	DYN_TractionSet(tv_traction)

	v_ground_normal = MATH_VecBlendRotate(v_ground_normal, v_wall_normal, 0.5)
}
else
{
	DYN_GravitySet(Cv_Scolo_Gravity)
}

if ( ! f_lifecur )
	v_ground_normal *= -1.0

if (f_delay_until_last_ground_col < 0.2 || f_delay_until_last_wall_col < 0.2)
{
	tf_target_speed = DYN_SpeedGet()

	if (tf_target_speed)
	{
		tv_new_sight = DYN_SpeedGetVector() / tf_target_speed
		tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 6.0 * TIME_GetDt())
	}
	else
	{
		tv_new_sight = OBJ_SightGet()
	}

	tv_new_banking = MATH_VecBlendRotate(OBJ_BankingGet(), v_ground_normal, 4.0 * TIME_GetDt())

//	tf_target_speed = move_speed
//	tf_target_speed *= 1.0 + (MATH_Sin(TIME_Get() * 4.0) * 0.25)

	ti_flag_stop = faux
	if (f_lifecur)
	{
		if (f_ground_dist >= dist_between_module * i_modules_nb)
			ti_flag_stop = vrai
	}
	else
	{
		if (i_on_ground_modules_nb > ( i_modules_nb >> 2) )
			ti_flag_stop = vrai
	}

	if (ti_flag_stop)
	{
		f_move_speed -= MATH_FloatMin(f_move_speed, 6.0 * move_speed * TIME_GetDt())
	}
	else
	{
		f_ground_dist += DYN_SpeedGet() * TIME_GetDt()
	
		tf_coef = i_on_ground_modules_nb
		tf_coef /= i_modules_nb
		tf_coef = 1.0 - tf_coef

		tf_target_speed = MATH_FloatMax(tf_target_speed, f_size_coef * (tf_coef * 4.0))

		tv_new_sight = MATH_VecInCone(tv_new_sight, OBJ_SightGet(), Cf_2Pi * TIME_GetDt(), 1)

		f_move_speed = MATH_FloatBlend(f_move_speed, tf_target_speed, 12.0 * TIME_GetDt())	
	}

	OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)

	if (f_move_speed)
	{
		f_Z_noise = MATH_RandFloat(-0.05, 0.05)
		f_Z_noise *= f_size_coef
	}
		
	tv_speed = OBJ_SightGet() * f_move_speed
	tv_speed.z = DYN_SpeedGetVector().z
	DYN_SpeedSetVector(tv_speed)
}
else
{
	tv_new_banking = MATH_VecBlendRotate(OBJ_BankingGet(), v_ground_normal, 4.0 * TIME_GetDt())
	
	tf_speed = DYN_SpeedGet()
	if (tf_speed)
	{
		tv_new_sight = DYN_SpeedGetVector()
		tv_new_sight /= tf_speed
		tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 6.0 * TIME_GetDt())
	}
	else
	{
		tv_new_sight = OBJ_SightGet()
	}

	OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)
}

PNJ_Scolo_Modules_Update(0, nobody)

