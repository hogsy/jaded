#include "PNJ_Brontosaure_Organizer_defs.var" 

procedure void LIBBronto_Teleport( object po_Bronto, vector pv_Pos, vector pv_Sight );


//==================================================
// CanMove : si les suivant sont devant lui et qu'il y a assez de place
// retourne la vitesse potentielle à adopter
// 0 : bouge pas
//==================================================
procedure_local int Bronto_ComputeSpeed( int ti_Bronto )
{
	int			ti_OtherBronto, ti_color
	object	to_B0, to_B1
	vector	tv_temp, tv_Norm, A, B, C, D
	float		tf_dot, tf_dist, tf_zoom, tf_Width, tf_speed, tf_zoom1, tf_factor
	
	to_B0 = Bronto_Obj[ ti_Bronto ]
	tf_zoom = M_Brontoi( ti_Bronto ) f_Zoom
	
//	switch ( MATH_Modulo( ti_Bronto, 4 ) )
//	{
//		case 0 :	ti_color = color_rouge break
//		case 1 : ti_color = color_bleu break
//		case 2 : ti_color = color_jaune break
//		case 3 : ti_color = color_vert break
//	}
	
	A = @to_B0 OBJ_PosGet() + ((tf_zoom * Bronto_Width) * @to_B0 OBJ_HorizonGet()) + ((tf_zoom * Bronto_DistMin )* @to_B0 OBJ_SightGet() )
	B = @to_B0 OBJ_PosGet() + ((tf_zoom * Bronto_Width) * @to_B0 OBJ_HorizonGet()) - ((tf_zoom * Bronto_DistMin )* @to_B0 OBJ_SightGet() )
	C = @to_B0 OBJ_PosGet() - ((tf_zoom * Bronto_Width) * @to_B0 OBJ_HorizonGet()) - ((tf_zoom * Bronto_DistMin )* @to_B0 OBJ_SightGet() )
	D = @to_B0 OBJ_PosGet() - ((tf_zoom * Bronto_Width) * @to_B0 OBJ_HorizonGet()) + ((tf_zoom * Bronto_DistMin) * @to_B0 OBJ_SightGet() )

//	DBG_RenderVector(A, B - A, ti_color )
//	DBG_RenderVector(B, C - B, ti_color )
//	DBG_RenderVector(C, D - C, ti_color )
//	DBG_RenderVector(D, A - D, ti_color )
			
	for ( ti_OtherBronto = ti_Bronto - 1; ti_OtherBronto >= 0; ti_OtherBronto--)
	{
		to_B1 = Bronto_Obj[ ti_OtherBronto ]
		if ( @to_B1 OBJ_CapaTest( OBJ_Capa_3 ) )
			continue
			
		tv_temp = @to_B1 OBJ_PosGet() - @to_B0 OBJ_PosGet()
		tv_temp.z = 0
		tf_dot = MATH_VecDotProduct( tv_temp, @to_B0 OBJ_SightGet() )
		if (tf_dot < 0 )
		{
			M_Bronto( to_B0 ) troupe_f_speed = 0
			return 0
		}
			
		tf_dist = MATH_VecDotProduct(tv_temp, tv_temp)
		tf_zoom1 = M_Brontoi( ti_OtherBronto ) f_Zoom
		
		// bronto sur le coté
		tv_Norm = tv_temp - (tf_dot * OBJ_SightGet())
		tv_Norm.z = 0
		tf_Width = Bronto_Width * (tf_zoom + tf_zoom1)
		if (MATH_VecDotProduct( tv_Norm, tv_Norm ) > (tf_Width * tf_Width) )
			continue
			
		tv_temp -= tv_Norm
		tf_dot = MATH_VecNorm( tv_temp )
//		DBG_RenderVector( @to_B0 OBJ_PosGet(), tv_temp, color_blanc) 

			
		if ( M_Bronto( to_B0 ) etat_i_courant == 1 )
		{		
			tf_factor = (tf_zoom + tf_zoom1) * (Bronto_DistMin + Bronto_DistMax) / 2
			tf_dot = (tf_dot / tf_factor) - 1.0
		
			M_Bronto( to_B0 ) troupe_f_speed += tf_dot * 0.01
			if ( M_Bronto( to_B0 ) troupe_f_speed < 0)
				M_Bronto( to_B0 ) troupe_f_speed = 0
			else if ( M_Bronto( to_B0 ) troupe_f_speed > Bronto_SpeedFactorMax)
				M_Bronto( to_B0 ) troupe_f_speed = Bronto_SpeedFactorMax

			M_Bronto( to_B1 ) troupe_f_speed -= tf_dot * 0.005
			if ( M_Bronto( to_B1 ) troupe_f_speed < 0)
				M_Bronto( to_B1 ) troupe_f_speed = 0
			else if ( M_Bronto( to_B1 ) troupe_f_speed > Bronto_SpeedFactorMax)
				M_Bronto( to_B1 ) troupe_f_speed = Bronto_SpeedFactorMax
		}
		else if (M_Bronto(to_B0) etat_i_courant == 0 )
		{
			if ( tf_dot > (Bronto_DistMin * (tf_zoom + tf_zoom1)) )
			{
				M_Bronto( to_B0 ) troupe_f_speed += 0.01
			}
		}
		break
	}
	
	if (ti_OtherBronto < 0)
	{
		if ( M_Bronto( to_B0 ) etat_i_courant == 1 )
		{
			if ( M_Bronto( to_B0 ) troupe_f_speed < 1)
				M_Bronto( to_B0 ) troupe_f_speed += 0.01
			if ( M_Bronto( to_B0 ) troupe_f_speed > 1)
				M_Bronto( to_B0 ) troupe_f_speed -= 0.01
		}
		if (M_Bronto(to_B0) etat_i_courant == 0 )
			M_Bronto( to_B0 ) troupe_f_speed = 1
	}
	return 1
}	

//==================================================
// sert plus
//==================================================
procedure_local int Bronto_EnoughSpace( int ti_bronto, vector tv_pos )
{
	return 0
}

//==================================================
// respawn tous les brontos à partir d'une position donnée
//==================================================
procedure_local void Bronto_RespawnAll( vector pv_pos, vector pv_sight )
{
	int			ti_Bronto
	vector	tv_Pos
	float		tf_zoom
	
	tv_Pos = pv_pos
	for (ti_Bronto = 0; ti_Bronto < Bronto_Nb; ti_Bronto++)
	{
		if ( ti_Bronto > 0 )
		{
			tf_zoom = M_Brontoi( ti_Bronto - 1 ) f_Zoom
			tf_zoom += M_Brontoi( ti_Bronto ) f_Zoom
			tf_zoom *= Bronto_DistMin
			tv_Pos -= tf_zoom * pv_sight
		}

		LIBBronto_Teleport( Bronto_Obj[ ti_Bronto], tv_Pos, pv_sight )
	}
	
	// pas de respawn en avant
	Bronto_Respawncount = 0
}

//==================================================
// set optimisation : paf with no paf
//==================================================
procedure_local int LIBBronto_SetOptim_NoPafWithPattes( int on )
{
	int 		ti_Bronto
	int			ti_Patte
	int			ti_on, ti_off
	object	to_Bronto
	object	to_Patte
	
	if (on)
	{
		ti_on = OBJ_Capa_0
		ti_off = 0
	}
	else
	{
		ti_on = 0
		ti_off = OBJ_Capa_0
	}
	
	for (ti_Bronto = 0; ti_Bronto < Bronto_Nb; ti_Bronto++)
	{
		to_Bronto = Bronto_Obj[ ti_Bronto ]
		if ( !to_Bronto ) continue
		
		for ( ti_Patte = 0; ti_Patte < 4; ti_Patte++ )
		{
			to_Patte = M_Bronto( to_Bronto ) Pattes_o_Object[ ti_Patte ]
			if (!to_Patte ) return 0
			@to_Patte OBJ_CapaSet( ti_on, ti_off)
		}
	}
	return on
}

//==================================================
// set optimisation : paf with no paf
//==================================================
procedure_local int LIBBronto_SetOptim_NoIKOnLegs( int on )
{
	int 		ti_Bronto
	int			ti_on, ti_off
	object	to_Bronto
	
	if (on)
	{
		ti_on = OBJ_Capa_1
		ti_off = 0
	}
	else
	{
		ti_on = 0
		ti_off = OBJ_Capa_1
	}
	
	for (ti_Bronto = 0; ti_Bronto < Bronto_Nb; ti_Bronto++)
	{
		to_Bronto = Bronto_Obj[ ti_Bronto ]
		if ( !to_Bronto ) continue
		@to_Bronto OBJ_CapaSet( ti_on, ti_off )
	}
	return on
}
