#include "KBM_defines.var"

int				ti_bigbat_index
int				ti_attack_msg_already_sent
int				ti_attack_wp_index
object		to_bigbat
message	tm_msg


// INITIALISATION =====================================================================
if( i_etat_courant != ETAT_BigBat_Attack )
{
	i_etat_courant = ETAT_BigBat_Attack	
	f_time_start_etat = 0.0
	
	// RAZ CPT ---------------------------
	i_pafs_count = 0
	i_passages_count = 0
}
else
	f_time_start_etat += TIME_GetDt()


// TEST DESACTIVATION DU MANAGER ====================================================
if( ! i_bigbat_count )
{
	if( i_DBG_Manager )
		DBG_TraceString("********** 0 BIG BAT EN VIE -> DESACTIVATION DU MANAGER... (Toi meilleur...)\n")
	OBJ_FlagInactiveSet(vrai)
}


// TEST PASSAGE EN PHASE SPAWNER ==================================================
if( i_passages_count >= KBM_PassagesNbMaxGet() )
{
	if( i_DBG_Manager )
	{
		DBG_TraceString("********** ")
		DBG_TraceInt(i_passages_count)
		DBG_TraceString(" PASSAGES -> PHASE SPAWNER\n")
	}
	AI_TrackCurChangeNow("KBM_ETAT_Spawner")
}
else if( i_pafs_count >= KBM_PafsNbMaxGet() )
{
	if( i_DBG_Manager )
	{
		DBG_TraceString("********** ")
		DBG_TraceInt(i_pafs_count)
		DBG_TraceString(" PAFS -> PHASE SPAWNER\n")
	}
	AI_TrackCurChangeNow("KBM_ETAT_Spawner")
}


// MANAGMENT DES ATTAQUES =========================================================
if( f_spawner_end_reattack_delay )
{
	// délai de ré-attaque après une phase spawner
	f_spawner_end_reattack_delay -= MATH_FloatMin(f_spawner_end_reattack_delay, TIME_GetDt())
}
else
{
	f_bigbat_reattack_delay -= MATH_FloatMin(f_bigbat_reattack_delay, TIME_GetDt())
	
	// Tests états de bats + capa du manager
	for( ti_bigbat_index = 0; ti_bigbat_index < ci_bigbats_nb; ti_bigbat_index++ )
	{
		to_bigbat = ao_bigbats[ti_bigbat_index]
		
		// TEST BAT ACTIVE -----------------------------------------------------------------------------------------------
		if( ! to_bigbat )
			continue		// cette big bat est déjà dead
		
		if( @to_bigbat OBJ_CapaTest(CAPA_BigBat_Dead) )
		{
			ao_bigbats[ti_bigbat_index] = nobody
			i_bigbat_count--
			if( i_DBG_Manager )
				DBG_TraceString("********** 1 BIG BAT EN MOINS !!! (Ouille...)\n")
			continue
		}
		
		// CAPAS PHASE D'ATTAQUE POUR LA KAMERA ----------------------------------------------------
		if( ! f_bigbat_reattack_delay )
		{
			// délai de ré-attaque entre les 2 bats (sinon la caméra part en vrille)
			if( @to_bigbat KBC_BigBat_AttackEnCours_KameraCCKongtoBat() )
			{
				// fin de l'annonce et début de l'attaque (jusqu'à une distance à Kong pour repasser sur la caméra network)
				KBM_CAPA_Kam_CC_Kong_to_Bat(ti_bigbat_index)
			}
			else if( KBM_CetteBigBatAttaqueDeja(to_bigbat) && @to_bigbat OBJ_CapaTest(CAPA_BigBat_Ask_for_Kamera) )
			{
				// la bat va se positionner pour attaquer mais l'attaque n'est pas encore commencée (test capa 11)
				if( o_attack_wp_backup && ! @o_attack_wp_backup OBJ_CapaTest(CAPA_WP_no_kamera_capa) )
					KBM_CAPA_Kam_CC_Bat_to_Kong(ti_bigbat_index)
				else
					KBM_CAPA_Kam_CC_Kong_to_Bat(ti_bigbat_index)	// caméra CC Bat -> KK désactivée, alors on met la caméra CC Kong -> Bat
			}
			else if( @get_PNJ_KBats_path to_bigbat f_release_grab_actor_keep_kamera > 0.0 )
			{
				// La bat vient juste de relacher Ann et elle attend un ordre d'attaque
				KBM_CAPA_Kam_CC_Bat_to_Kong(ti_bigbat_index)
			}
		}
	}
	
	// NEW MESSAGE D'ATTAQUE SI AUCUNE ATTAQUE EN COURS ---------------------------------
	if( ! KBM_UneBigBatAttaqueDeja(-1) )
	{
		// pas de big bat en attaque : teste si l'une d'entre elles est ready to attack (capa 6)
		ti_attack_msg_already_sent = faux
		for( ti_bigbat_index = 0; ti_bigbat_index < ci_bigbats_nb; ti_bigbat_index++ )
		{
			to_bigbat = ao_bigbats[ti_bigbat_index]
			
			if( ! to_bigbat )
				continue		// cette big bat est déjà dead
			
			if( ! ti_attack_msg_already_sent		// ne pas lancer 2 msg d'attack la même trame
				&& @to_bigbat OBJ_CapaTest(CAPA_BigBat_Ready_for_Attack)		// attendre que la big bat soit ready
				&& @to_bigbat KBC_Target_Check(AI_MainActorGet(C_ID_Kong)) )		// ne pas lui envoyer de msg si elle ne peut pas l'attaquer
			{
				ti_attack_msg_already_sent = vrai
				// select wp & envoi message
				ti_attack_wp_index = KBM_GetNearestAttackWPindex(to_bigbat)
				MSG_SetNull(tm_msg)
				tm_msg.msg_gao2 = AI_MainActorGet(C_ID_Kong)
				tm_msg.msg_gao3 = ao_init_attack_wp[ti_attack_wp_index]
				o_attack_wp_backup = ao_init_attack_wp[ti_attack_wp_index]
				tm_msg.msg_gao4 = ao_post_attack_wp[ti_attack_wp_index]
				tm_msg.msg_id = msg_id_KBigBat_Attack
				tm_msg.msg_int1 = 1		// Envole-moi, Envole-moi-ah-aaaah, Loin de cette fatalité qui colle à ma peau...
				@to_bigbat MSG_Send(tm_msg)
				if( i_DBG_Manager )
				{
					DBG_TraceString("********** SEND ATTACK MSG pour ")
					DBG_TraceObject(to_bigbat)
					DBG_TraceString(" -> phase BigBat Attack\n")
				}
			}
		}
	}
}

