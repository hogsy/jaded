#include "CR_defines.var"

float				tf_dot
float				tf_dot_new
float				tf_dist_proj
float				tf_proj_cote
float				tf_calcul_cote
float				tf_dot_Horiz_moveAxis
float				tf_dot_Sight_moveAxis
float				tf_test_cote
float				tf_dist_me_to_actor
float				tf_strafe_rotation_coef
float				tf_cos_strafe
float				tf_dot_normaleWall_to_Actor
float				tf_life_ratio

messageid		tmid_vision

vector			tv_new_sight
vector			tv_new_horizon
vector			tv_me_to_actor
vector			tv_me_to_actor_N
vector			tv_actor_proj_pos
vector			tv_actor_proj_axis
vector			tv_pos_blend_horizon
vector			tv_me_to_pos_blend_horizon
vector			tv_temp
vector			tv_pos
vector			tv_move_axis
vector			tv_gauche
vector			tv_lray_pos
vector			tv_lray_sight

object			to_ray_object
object			to_FA_lray_bone
object			to_my_lray_bone

int					ti_strafeG_ok
int					ti_strafeD_ok


// SORTIE ETAT ==============================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	return
}


// ENTREE ETAT ==============================================================================
if (i_etat_courant != ETAT_FIGHT )
{
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_FIGHT
	
	if (fct_etat_courant)
	{
		i_sort_etat = vrai
		AI_Execute(fct_etat_courant)
	}
	
	fct_etat_courant = AI_TrackCurGet()
	fct_etat_main = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	CR_Fight_Init()
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE ===================================================================================
AI_Execute("CR_exec_CHECK_Vision")

// Paf
AI_Execute("CR_exec_CHECK_Paf")
if( CR_Paf_Check_Change_Etat() )
	macro_change_etat("CR_ETAT_PAF")

// Changement de cible
AI_Execute("CR_exec_CHECK_Target_Change")
if( i_change_target_flag )
	CR_Fight_Init()		// changement de cible
else if( ! MSG_GlobalIsValid(mid_best_interet) )
	macro_change_etat("CR_ETAT_IDLE")	// perte d'intérêt et aucune autre cible -> IDLE

// COMPORTEMENT =============================================================================

// INTERET (cible ou cadavre) ----------------------------------------------------------------
if( CR_Perceived_Actor_Check(o_fight_actor, tmid_vision) || CR_Cadavre_Find(o_fight_actor) )
	CR_Interet_Update(mid_best_interet, C_EVENT_InteretStatusAttack, o_fight_actor, tmid_vision)


// DEPLACEMENT  ------------------------------------------------------------------------------
tv_new_sight = Cv_NullVector
tv_me_to_actor = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
tv_me_to_actor_N = MATH_VecNormalize(tv_me_to_actor)
tf_dist_me_to_actor = MATH_VecNorm(tv_me_to_actor)
tv_gauche = MATH_VecCrossProduct(Cv_VerticalVector, OBJ_SightGet())

// CALCUL DU DEPLACEMENT RESTANT
v_way_dest_pos = EVENT_InteretPositionGet(mid_best_interet)
//DBG_RenderVector(v_way_dest_pos, Cv_VerticalVector * 10, color_bleu)
AI_Execute("CR_exec_WAY_Move")

tv_move_axis = tv_me_to_actor
//DBG_RenderVector(OBJ_PosGet(), v_joy_dir * f_way_length, color_jaune)
DBG_RenderVector(OBJ_PosGet(), tv_me_to_actor, color_vert)

tf_dot_Horiz_moveAxis = MATH_VecDotProduct(OBJ_HorizonGet(), MATH_VecNormalize(tv_move_axis))
tf_dot_Sight_moveAxis = MATH_VecDotProduct(OBJ_SightGet(), MATH_VecNormalize(tv_move_axis))

// ACTION -------------------------------------------------------------------------------------------
switch( ACT_ActionGet() )
{
	case ACTION_Intimidation :
		// INTIMIDATION =============================================================================
		if( ACT_ActionFinished() )
		{
			CR_Intimidation_Delay_Random()
			ACT_ActionSet(ACTION_Attente)
			CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
		}
		break
		
	case ACTION_AttackG :
	case ACTION_AttackD :
		// ATTAQUE EN COURS ======================================================================
		if( ACT_ActionFinished() )
		{
			// FIN D'ATTAQUE
			i_attack_paf_done = faux
			f_attack_delay = MATH_RandFloat(f_attack_delay_min, f_attack_delay_max)
			ACT_ActionSet(ACTION_Attente)
		}
		else
		{
			// TEST PAF
			if( ! i_attack_paf_done && COL_ZDE_ZDECollide(o_fight_actor, C_zde_fight, C_zde_corps) )
			{
				DBG_TraceString("=== ")
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" paffe ")
				DBG_TraceObject(o_fight_actor)
				DBG_TraceString(" ZDE Fight / ZDE Corps")
				DBG_TraceEOL()
				i_attack_paf_done = vrai
				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, i_paf_to_send_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, Ci_paf_dmg_pince, OBJ_SightGet())
				CR_Paffed_Actor_Add(o_fight_actor)
			}
		}
		break
	
	default:
		// ATTENTE OU DEPLACEMENT =============================================================
		if( ! f_joy_norm )
		{
			// DEPLACEMENT TERMINE ---------------------------------------------------------
			
			// ORIENTATION VERS CIBLE
			if( tf_dot_Sight_moveAxis < f_way_cos_attack_pince )
			{
				// se tourne pour se mettre en face de la cible pour porter un coup de pince (paf ou grab)
				ACT_ActionSet(ACTION_SurPlace)
				CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
			}
			// SINON DEBUT D'INTIMIDATION
			else if( i_DBG_fight_intimidation && ! i_attack_intimidation_done && ! CR_Cadavre_Find(o_fight_actor) )
			{
				ACT_ActionSet(ACTION_Intimidation)
				i_attack_intimidation_done = vrai
				CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
			}
			// MA CIBLE EST UN CADAVRE ET QU'IL EST BIEN MORT
			else if( CR_Cadavre_Find(o_fight_actor) )
			{
				macro_change_etat("CR_ETAT_MANGE")
			}
			// SINON (PAS CADAVRE OU CADAVRE PAS MORT) DELAI DEBUT D'ATTAQUE
			else if( ! f_attack_delay )
			{
				to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
				to_my_lray_bone = o_bone_carapace
				tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
				tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
				DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
				to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
				if( to_ray_object || CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, C_EVENT_InteretStatusGrab, vrai) ) 
				{
					// PAS LE DROIT D'ATTAQUER (MUR, DEJA GRABBE PAR UN BUDY....)
					ACT_ActionSet(ACTION_Attente)
					CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
				}
				else
				{
					// PAS D'OBSTACLE ENTRE MA CIBLE ET MOI
					tv_new_sight = tv_me_to_actor
					if( MATH_VecDotProduct(OBJ_HorizonGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet()) > 0 )
					{
						// GAUCHE
						if( i_grab )
						{
							ACT_ActionSet(ACTION_GrabGdeb)
							macro_change_etat("CR_ETAT_GRAB")
						}
						else
						{
							ACT_ActionSet(ACTION_AttackG)
							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
						}
					}
					else
					{
						// DROITE
						if( i_grab )
						{
							ACT_ActionSet(ACTION_GrabDdeb)
							macro_change_etat("CR_ETAT_GRAB")
						}
						else
						{
							ACT_ActionSet(ACTION_AttackD)
							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
						}
					}
				}
			}
			// SINON ATTENTE
			else
			{
				ACT_ActionSet(ACTION_Attente)
				CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
			}
		}
		else
		{
			// IL Y A UN DEPLACEMENT A EFFECTUER -------------------------------------
			tf_cos_strafe = CR_Way_Strafe_Cosinus_Get()
			
			if( tf_dot_Horiz_moveAxis < tf_cos_strafe && tf_dot_Horiz_moveAxis > - tf_cos_strafe )
			{
				// CIBLE DEVANT OU DERRIERE MAIS PAS DANS LES CONES DE STRAFE
				i_way_mode_strafe = Ci_way_mode_strafe_requin
				if( tf_dot_Sight_moveAxis < 0 )
				{
					// CIBLE DERRIERE
					TOURNE:
					i_way_mode = Ci_way_mode_cible_derriere
					ACT_ActionSet(ACTION_SurPlace)
					CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
				}
				else
				{
					// CIBLE DEVANT MOI
					i_way_mode = Ci_way_mode_cible_devant
					if( ! CR_Way_Grid_Check_Dir(OBJ_SightGet(), 0.0) )
					{
						// OBSTACLE DEVANT LE CRABE ??? (A VALIDER)
						if( f_way_strafe_sens_pref == 0.0 )
							CR_Way_Get_Obstacle()		// initialiser la 1ere fois, pas les autres
						
						if( f_way_obstacle_dist > tf_dist_me_to_actor )
							goto PAS_D_OBSTACLE_DEVANT
						else
						{
							// OBSTACLE DEVANT LE CRABE
							tf_dot_new = MATH_VecDotProduct(OBJ_SightGet(), v_way_obstacle_normale)
							if( tf_dot_new < 0 && tf_dot_new > - Cf_Cos45 )
								goto PAS_D_OBSTACLE_DEVANT
							
							tv_new_sight = - v_way_obstacle_normale
							i_way_obstacle_strafe_flag = vrai
							
							DBG_RenderVector(OBJ_PosGet(), MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale) * 10.0, color_jaune)
							
							if( f_way_strafe_sens_pref == 0.0 )
							{
								// PAS DE SENS PREFERENCIEL DE STRAFE
//								f_way_strafe_sens_pref = CR_Strafe_Cote_Select(tf_dot_Horiz_moveAxis, tv_gauche)
								if( ! CR_Strafe_Cote_Select(1.0, MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale), f_way_strafe_sens_pref) )
									goto TOURNE
							}
							
							// TEST DEBUT / CHANGEMENT DE STRAFE
							if( ! CR_Strafe_En_Cours() || CR_Strafe_Cote_Get() != f_way_strafe_sens_pref )
								CR_Strafe_Begin_No_Duration(f_way_strafe_sens_pref)
							
							// TEST OBSTACLE DU COTE DU STRAFE
//							if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche, CR_Strafe_Cote_Get()) )
							if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale), CR_Strafe_Cote_Get()) )
							{
								// OBSTACLE DU COTE DU STRAFE (PAS BESOIN DE VALIDATION...)
								// ATTENTION !!!!!! : ne pas récupérer les infos du nouvel obstacle, on conserve les infos de l'ancien (on ne suit pas le décor, mais on choisit de contourner le 1er obstacle dans l'autre sens !!!!!
								
								if( CR_Way_Grid_Check_Dir( - CR_Strafe_Cote_Get() * MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale), CR_Strafe_Cote_Get()) )
									f_way_strafe_sens_pref *= -1.0	// change de sens
								else
									goto TOURNE
							}
						}
					}
					else
					{
						// PAS D'OBSTACLE DEVANT
						PAS_D_OBSTACLE_DEVANT:
						
						f_way_strafe_sens_pref = 0.0		// RAZ sens préférentiel de strafe
						i_way_obstacle_strafe_flag = faux
						
						if( ! f_way_intimidation_delay
							&& MATH_VecDotProduct( @o_fight_actor OBJ_SightGet(), - tv_me_to_actor_N) < Cf_Cos30
							&& MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_actor_N) > Cf_Cos30
							&& tf_dist_me_to_actor > f_way_dist_strafe_fight_rot 
							&& ! i_way_obstacle_strafe_flag 
							&& ! CR_Cadavre_Find(o_fight_actor) )
						{
							// PASSAGE EN INTIMIDATION : fin d'un strafe ou timer + pas dans le sight de la cible + la cible est dans mon sight + pas au contact
							ACT_ActionSet(ACTION_Intimidation)
							CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
						}
						else
						{
							// PAS D'INTIMIDATION : DEPLACEMENT
							if( CR_Strafe_Allowed() )
							{
								// timer strafe ok
								if( ! CR_Strafe_En_Cours() )
								{
									// Passage en strafe : test des 2 côtés
									ti_strafeG_ok = CR_Way_Grid_Check_Dir(tv_gauche, 1.0)
									ti_strafeD_ok = CR_Way_Grid_Check_Dir( - tv_gauche, -1.0)
									if( f_way_last_obstacle_time <= Cf_obstacle_strafe_cote_backup_delay )
									{
										// délai pendant lequel le crabe ne repartira pas en strafe du côté duquel il vient après avori strafé pour éviter un obstacle
										if( f_way_obstacle_cote_backup == 1.0 )
											ti_strafeD_ok = faux		// j'ai contourné par la gauche, je n'ai pas le droit de repartir vers la droite
										else if( f_way_obstacle_cote_backup == -1.0 )
											ti_strafeG_ok = faux		// j'ai contourné par la droite, je n'ai pas le droit de repartir vers la gauche
									}
									
									// Passage en strafe : choix du côté de strafe
									if( ti_strafeG_ok && ti_strafeD_ok )
										CR_Strafe_Begin_With_Duration(MATH_FloatSign(MATH_RandFloat(-1.0,1.0)))
									else if( ti_strafeG_ok )
										CR_Strafe_Begin_With_Duration(1.0)
									else if( ti_strafeD_ok )
										CR_Strafe_Begin_With_Duration(-1.0)
									else
										goto AVANCE
								}
								else
								{
									// Déjà en strafe : check obstacle dans le sens du strafe
									if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche, CR_Strafe_Cote_Get()) )
									{
										// OBSTACLE DU COTE DU STRAFE ??? (A VALIDER) 
										CR_Way_Get_Obstacle()
										if( CR_Strafe_Cote_Get() == MATH_FloatSign(tf_dot_Horiz_moveAxis) )
										{
											// ma cible est derrière l'obstacle : est-ce que je dois le contourner ???
											if( tf_dot_Sight_moveAxis > Cf_Cos45 )
											{
												// ma cible est devant moi -> je coupe le strafe mais l'obstacle ne me gène pas
												CR_Strafe_End_And_Delay()
												goto AVANCE
											}
											else
											{
												// ma cible et le mur sont du même côté, test de la distance au mur et de la distance à la cible :
												if( f_way_obstacle_dist > tf_dist_me_to_actor )
													goto AVANCE			// je coupe le strafe mais l'obstacle ne me gène pas
												else
												{
													// OBSTACLE DU COTE DU STRAFE
													tv_new_sight = - v_way_obstacle_normale
												}
											}
										}
										else
										{
											// l'obstacle n'est pas du même côté (horizon) que ma cible -> je coupe le strafe mais l'obstacle ne me gène pas
											CR_Strafe_End_And_Delay()
											goto AVANCE
										}
									}
									else
									{
										// PAS D'OBSTACLE DU COTE DU STRAFE : rotation en strafe pour se rapprocher de la cible
										tv_new_sight = tv_me_to_actor
										tv_new_sight = MATH_VecRotate(tv_new_sight, Cv_VerticalVector, - CR_Strafe_Cote_Get() * Cf_PiBy8)
									}
								}
							}
							else
							{
								// timer strafe pas ok
								if( CR_Strafe_En_Cours() )
									CR_Strafe_End_And_Delay()
								
								AVANCE:
								ACT_ActionSet(ACTION_Avance_Attaque)
								CR_Rotation_Coef_Set(Ci_rotation_coef_avance)
							}
						}
					}
				}
			}
			else
			{
				// CIBLE DANS LES CONES DE STRAFE : calcul d'un point devant la cible vers lequel strafer
				i_way_mode_strafe = Ci_way_mode_strafe_direct
				i_way_mode = Ci_way_mode_cible_de_cote
				
				if( ! CR_Strafe_En_Cours() )
					CR_Strafe_Begin_With_Duration(MATH_FloatSign(tf_dot_Horiz_moveAxis))
				
				if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche, CR_Strafe_Cote_Get()) )
				{
					// OBSTACLE DANS LE SENS DU STRAFE
					CR_Way_Get_Obstacle()
					CR_Strafe_Duration_Reset()
					i_way_obstacle_strafe_flag = vrai
					tv_new_sight = - v_way_obstacle_normale
				}
				else
				{
					// PAS D'OBSTACLE DANS LE SENS DU STRAFE
					i_way_obstacle_strafe_flag = faux
					f_way_strafe_sens_pref = 0.0
					
					if( tf_dist_me_to_actor > f_way_dist_strafe_fight_rot )
						tf_strafe_rotation_coef = 0.0			// loin : strafe en ligne droite vers la cible
					else
						tf_strafe_rotation_coef = 1.0 - ( MATH_FloatMax(tf_dist_me_to_actor, f_way_dist_position_fight / 2.0) / f_way_dist_strafe_fight_rot )		// proche : strafe en tournant autour de la cible
					
					tv_new_horizon = CR_Strafe_Cote_Get() * tv_me_to_actor
					tv_new_horizon = MATH_VecRotate(tv_new_horizon, Cv_VerticalVector, CR_Strafe_Cote_Get() * Cf_PiBy2 * tf_strafe_rotation_coef )
					tv_new_sight = MATH_VecCrossProduct(tv_new_horizon, Cv_VerticalVector)
					DBG_RenderVector(OBJ_PosGet(), tv_new_horizon, color_bleu)
					DBG_RenderVector(OBJ_PosGet(), tv_new_sight, color_rouge)
				}
			}
		}
		break		// switch action
}


// ORIENTATION ---------------------------------------------------------------------------
if( MATH_VecNullEpsilon(tv_new_sight) )
	tv_new_sight = tv_me_to_actor
else
	DBG_RenderVector(OBJ_PosGet(), tv_new_sight * 10.0, color_rouge)		// aff sight calculé

OBJ_BankingGeneralSet(
	MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, f_way_rotation_coef * TIME_GetDt()),
//	MATH_VecBlendRotate(OBJ_BankingGet(), v_ground_normale, 6.0 * TIME_GetDt()))
	Cv_VerticalVector)

// INTIMIDATION DEBUT COMBAT ------------------------------------------------
if( f_way_length >= 15.0 )
	i_attack_intimidation_done = faux

// DELAIS STRAFE ET INTIMIDATION
if( i_way_obstacle_strafe_flag )
{
	CR_Intimidation_Delay_Random()
	CR_Strafe_Delay_Random()
	if( ! i_way_rot_mult_done )
	{
		i_way_rot_mult_done = vrai
		CR_Rotation_Coef_Multiply(1.25)
	}
}
else
{
	CR_Rotation_Coef_Multiply(1.0)
	i_way_rot_mult_done = faux
}
