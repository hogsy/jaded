//#include "CR_defines.var"
//
//float				tf_dot
//float				tf_dot_new
//float				tf_dist_proj
//float				tf_proj_cote
//float				tf_calcul_cote
//float				tf_dot_Horiz_moveAxis
//float				tf_dot_Sight_moveAxis
//float				tf_test_cote
//float				tf_dist_me_to_actor
//float				tf_strafe_rotation_coef
//float				tf_cos_strafe
//float				tf_dot_normaleWall_to_Actor
//float				tf_life_ratio
//float				tf_cote
//
//messageid		tmid_vision
//
//vector			tv_new_sight
//vector			tv_new_horizon
//vector			tv_me_to_actor
//vector			tv_me_to_actor_N
//vector			tv_actor_proj_pos
//vector			tv_actor_proj_axis
//vector			tv_pos_blend_horizon
//vector			tv_me_to_pos_blend_horizon
//vector			tv_temp
//vector			tv_pos
//vector			tv_move_axis
//vector			tv_gauche
//vector			tv_lray_pos
//vector			tv_lray_sight
//vector			tv_check_grid
//
//object			to_ray_object
//object			to_FA_lray_bone
//object			to_my_lray_bone
//
//int					ti_strafeG_ok
//int					ti_strafeD_ok
//
//
//// SORTIE ETAT ==============================================================================
//if (i_sort_etat)
//{
//	i_antre_move_flag = faux
//	
//	i_sort_etat = faux
//	return
//}
//
//
//// ENTREE ETAT ==============================================================================
//if (i_etat_courant != ETAT_FIGHT )
//{
//	i_etat_ancien = i_etat_courant
//	i_etat_courant = ETAT_FIGHT
//	
//	if (fct_etat_courant)
//	{
//		i_sort_etat = vrai
//		AI_Execute(fct_etat_courant)
//	}
//	
//	fct_etat_courant = AI_TrackCurGet()
//	fct_etat_main = AI_TrackCurGet()
//	f_time_start_etat = 0.0
//	
//	if( i_antre_move_flag )
//		EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)		// raz intérêt
//	
//	CR_Fight_Init()
//	
//	if( i_DBG_trace_etat )
//	{
//		DBG_TraceObject(OBJ_Me())
//		DBG_TraceString(" : ETAT FIGHT : ")
//		if( i_antre_move_flag )
//		{
//			DBG_TraceString("retour à mon antre")
//		}
//		else if( CR_Cadavre_Find(o_fight_actor) )
//		{
//			DBG_TraceString("cadavre : ")
//			DBG_TraceObject(o_fight_actor)
//		}
//		else if( o_fight_actor )
//		{
//			DBG_TraceString("proie : ")
//			DBG_TraceObject(o_fight_actor)
//		}
//		else
//		{
//			DBG_Error("pas de proie ???? ")
//		}
//		DBG_TraceEOL()
//	}
//}
//else
//{
//	f_time_start_etat += TIME_GetDt()
//}
//
//
//// ANALYSE ===================================================================================
//AI_Execute("CR_exec_CHECK_Vision")
//
//// Paf
//AI_Execute("CR_exec_CHECK_Paf")
//if( CR_Paf_Check_Change_Etat() )
//	macro_change_etat("CR_ETAT_PAF")
//
//// valide la cible
//if( ! i_antre_move_flag )
//	if( ! CR_Target_Check(o_fight_actor) )
//		EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)		// raz intérêt
//
//
//if( ! MSG_GlobalIsValid(mid_best_interet) )
//	o_fight_actor = nobody
//
//AI_Execute("CR_exec_CHECK_Target")
//if( i_change_target_flag )
//{
//	i_antre_move_flag = faux		
//	CR_Fight_Init()		// changement de cible
//}
//
//if( ! i_antre_move_flag && ! o_fight_actor )
//{
//	if( i_DBG_trace_etat )
//	{
//		DBG_TraceObject(OBJ_Me())
//		DBG_TraceString(" : en fight mais aucun intérêt = je n'ai pas trouvé d'autre cible -> idle")
//		DBG_TraceEOL()
//	}
//	macro_change_etat("CR_ETAT_IDLE")	// perte d'intérêt et aucune autre cible -> IDLE
//}
//
//
//// COMPORTEMENT =============================================================================
//
//// INTERET (cible ou cadavre) ----------------------------------------------------------------
//if( ! i_antre_move_flag )
//	if( CR_Perceived_Actor_Check(o_fight_actor, tmid_vision) || CR_Cadavre_Find(o_fight_actor) )
//		CR_Interet_Update(mid_best_interet, C_EVENT_InteretStatusAttack, o_fight_actor, tmid_vision)
//
//
//// DEPLACEMENT  ------------------------------------------------------------------------------
//tv_new_sight = Cv_NullVector
//if( i_way_obstacle_avance_flag || i_way_obstacle_avance_flag || i_way_obstacle_strafe_flag )
//{
//	// obstacle
//	v_way_dest_pos = v_way_move_dest_backup
//}
//else if( i_antre_move_flag )
//{
//	// vers mon antre
//	v_way_dest_pos = v_antre_pos
//	v_way_move_dest_backup = v_way_dest_pos
//}
//else
//{
//	// vers ma cible / mon cadavre
//	v_way_dest_pos = EVENT_InteretPositionGet(mid_best_interet)
//	v_way_move_dest_backup = v_way_dest_pos
//}
//tv_me_to_actor = v_way_dest_pos - OBJ_PosGet()
//tv_me_to_actor_N = tv_me_to_actor
//if( ! MATH_VecNullEpsilon(tv_me_to_actor_N) )
//	MATH_VecSetNormalize(tv_me_to_actor_N)
//tf_dist_me_to_actor = MATH_VecNorm(tv_me_to_actor)
//tv_gauche = MATH_VecCrossProduct(Cv_VerticalVector, OBJ_SightGet())
//
////DBG_RenderVector(v_way_dest_pos, Cv_VerticalVector * 10, color_bleu)
//AI_Execute("CR_exec_WAY_Move")
//
////DBG_RenderVector(OBJ_PosGet(), v_joy_dir * f_way_length, color_jaune)
//DBG_RenderVector(OBJ_PosGet(), tv_me_to_actor, color_vert)
//tv_move_axis = tv_me_to_actor
//if( ! MATH_VecNullEpsilon(tv_move_axis) )
//	MATH_VecSetNormalize(tv_move_axis)
//tf_dot_Horiz_moveAxis = MATH_VecDotProduct(OBJ_HorizonGet(), tv_move_axis)
//tf_dot_Sight_moveAxis = MATH_VecDotProduct(OBJ_SightGet(), tv_move_axis)
//
//
//
//// STRAFE REQUIN AUTORISE OU PAS ----------------------------------------------
//if( ! f_way_strafe_delay )
//{
//	// je peux passer en requin
//	if( tf_dist_me_to_actor <= f_way_dist_strafe_requin_allowed )
//	{
//		// je suis trop près pour faire un strafe requin
//		if( ! i_strafe_requin_force_flag )
//		{
//			// je force un strafe requin après un paf (anim paf ou paf en grab)
//			// sinon je ne passe pas en strafe requin (trop proche)
//			CR_Strafe_Delay_Random()		// je repousse le temps pour commencer le strafe, mais je ne coupe pas le strafe en cours (DurationReset)
//		}
//	}
//}
//
//// ACTION -------------------------------------------------------------------------------------------
//switch( ACT_ActionGet() )
//{
//	case ACTION_Intimidation :
//		// INTIMIDATION =============================================================================
//		if( ACT_ActionFinished() )
//		{
//			CR_Intimidation_Delay_Random()
//			ACT_ActionSet(ACTION_Attente)
//			CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//		}
//		break
//		
//	case ACTION_AttackG :
//	case ACTION_AttackD :
//		// ATTAQUE EN COURS ======================================================================
//		if( ACT_ActionFinished() )
//		{
//			// FIN D'ATTAQUE
//			i_attack_paf_done = faux
//			ACT_ActionSet(ACTION_Attente)
//			
//			if( i_modele == MODELE_Petit )
//				i_attack_intimidation_done = faux		// les petits crabes intimident avant chaque attaque
//		}
//		else
//		{
//			// TEST PAF
//			if( ! i_attack_paf_done && COL_ZDE_ZDECollide(o_fight_actor, C_zde_fight, C_zde_corps) )
//			{
//				DBG_TraceString("=== ")
//				DBG_TraceObject(OBJ_Me())
//				DBG_TraceString(" paffe ")
//				DBG_TraceObject(o_fight_actor)
//				DBG_TraceString(" ZDE Fight / ZDE Corps")
//				DBG_TraceEOL()
//				i_attack_paf_done = vrai
//				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, i_paf_to_send_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, Ci_paf_dmg_pince, OBJ_SightGet())
//				CR_Paffed_Actor_Add(o_fight_actor)
//			}
//		}
//		break
//	
//	default:
//		// ATTENTE OU DEPLACEMENT =============================================================
//		if( ! f_joy_norm && ! i_strafe_requin_force_flag )
//		{
//			// DEPLACEMENT TERMINE ---------------------------------------------------------
//			if( i_antre_move_flag )
//			{
//				DBG_TraceObject(OBJ_Me())
//				DBG_TraceString(" a atteint son antre")
//				DBG_TraceEOL()
//				macro_change_etat("CR_ETAT_IDLE")
//			}
//			
//			// ORIENTATION VERS CIBLE
//			if( tf_dot_Sight_moveAxis < f_way_cos_attack_pince )
//			{
//				// se tourne pour se mettre en face de la cible pour porter un coup de pince (paf ou grab)
//				ACT_ActionSet(ACTION_SurPlace)
//				CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
//			}
//			// SINON DEBUT D'INTIMIDATION
//			else if( ! i_attack_intimidation_done && ! CR_Cadavre_Find(o_fight_actor) )
//			{
//				ACT_ActionSet(ACTION_Intimidation)
//				i_attack_intimidation_done = vrai
//				CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
//			}
//			// MA CIBLE EST UN CADAVRE ET QU'IL EST BIEN MORT
//			else if( CR_Cadavre_Find(o_fight_actor) )
//			{
//				macro_change_etat("CR_ETAT_MANGE")
//			}
//			// SINON (PAS CADAVRE OU CADAVRE PAS MORT) DELAI DEBUT D'ATTAQUE
//			else if( ! f_attack_delay && CR_Attack_Enabled() )
//			{
//				to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//				to_my_lray_bone = o_bone_carapace
//				tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
//				tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
//				DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//				to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//				if( to_ray_object || CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, C_EVENT_InteretStatusGrab, vrai) ) 
//				{
//					// PAS LE DROIT D'ATTAQUER (MUR, DEJA GRABBE PAR UN BUDY....)
//					ACT_ActionSet(ACTION_Attente)
//					CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//				}
//				else
//				{
//					// PAS D'OBSTACLE ENTRE MA CIBLE ET MOI
//					tv_new_sight = tv_me_to_actor
//					if( MATH_VecDotProduct(OBJ_HorizonGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet()) > 0 )
//					{
//						// GAUCHE
//						if( i_grab )
//						{
//							ACT_ActionSet(ACTION_GrabGdeb)
//							macro_change_etat("CR_ETAT_GRAB")
//						}
//						else
//						{
//							ACT_ActionSet(ACTION_AttackG)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
//						}
//					}
//					else
//					{
//						// DROITE
//						if( i_grab )
//						{
//							ACT_ActionSet(ACTION_GrabDdeb)
//							macro_change_etat("CR_ETAT_GRAB")
//						}
//						else
//						{
//							ACT_ActionSet(ACTION_AttackD)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
//						}
//					}
//				}
//			}
//			// SINON ATTENTE
//			else
//			{
//				ACT_ActionSet(ACTION_Attente)
//				CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//			}
//		}
//		else
//		{
//			// IL Y A UN DEPLACEMENT A EFFECTUER -------------------------------------
//			tf_cos_strafe = CR_Way_Strafe_Cosinus_Get()
//			
//			if( ! i_way_obstacle_avance_flag && ( i_way_obstacle_strafe_flag || (tf_dot_Horiz_moveAxis < tf_cos_strafe && tf_dot_Horiz_moveAxis > - tf_cos_strafe) ) )
//			{
//				// EN TRAIN DE LONGER UN MUR OU [CIBLE DEVANT OU DERRIERE MAIS PAS DANS LES CONES DE STRAFE]
//				if( i_way_mode_strafe == Ci_way_mode_strafe_attack_cote )
//				{
//					// raz mode strafe si on vient d'une attaque strafe côté mais pas si on vient d'une attaque strafe face
//					i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin
//				}
//				else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face )
//				{
//					// je reviens du mode attaque strafe de face
//					CR_Strafe_Attack_Face_Delay_Random()
//					i_way_mode_strafe = Ci_way_mode_strafe_attack_face_retour
//					// repart en strafe requin (plus joli visuellement)
//					CR_Strafe_Delay_Reset()
//					CR_Strafe_Duration_Random()
//				}
//				
//				if( tf_dot_Sight_moveAxis < 0 && i_way_mode_strafe != Ci_way_mode_strafe_attack_face_retour )
//				{
//					// CIBLE DERRIERE
//					TOURNE:
//					ACT_ActionSet(ACTION_SurPlace)
//					CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
//				}
//				else
//				{
//					// CIBLE DEVANT MOI
//					CIBLE_DEVANT:
//					
//					if( ! CR_Way_Grid_Check_Dir(OBJ_SightGet(), 0.0) )
//					{
//						// OBSTACLE DEVANT LE CRABE ??? (A VALIDER)
//						CR_Way_Get_Obstacle()		// initialiser la 1ere fois, pas les autres
//						
//						if( f_way_obstacle_dist > tf_dist_me_to_actor )
//							goto PAS_D_OBSTACLE_DEVANT
//						else
//						{
//							// OBSTACLE DEVANT LE CRABE
//							tf_dot_new = MATH_VecDotProduct(OBJ_SightGet(), v_way_obstacle_normale)
////							if( tf_dot_new < 0 && tf_dot_new > - Cf_Cos45 )
//							if( tf_dot_new < 0 && tf_dot_new > - Cf_Cos60 )
//								goto PAS_D_OBSTACLE_DEVANT
//							
//							tv_new_sight = - v_way_obstacle_normale
//							i_way_obstacle_strafe_flag = vrai
//							
//							DBG_RenderVector(OBJ_PosGet(), MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale) * 10.0, color_jaune)
//							
//							if( f_way_strafe_sens_pref == 0.0 )
//							{
//								// PAS DE SENS PREFERENCIEL DE STRAFE
//								if( ! CR_Strafe_Cote_Select(1.0, MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale), f_way_strafe_sens_pref) )
//								{
//									tv_new_sight = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, MATH_FloatSign(tf_dot_Horiz_moveAxis) * Cf_PiBy4)		// pour forcer à tourner
//									goto TOURNE
//								}
//							}
//							
//							// TEST DEBUT / CHANGEMENT DE STRAFE
//							if( ! CR_Strafe_En_Cours() || CR_Strafe_Cote_Get() != f_way_strafe_sens_pref )
//								CR_Strafe_Begin_No_Duration(f_way_strafe_sens_pref)
//							  
//							// TEST OBSTACLE DU COTE DU STRAFE
//							if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale), CR_Strafe_Cote_Get()) )
//							{
//								// OBSTACLE DU COTE DU STRAFE (PAS BESOIN DE VALIDATION...)
//								// ATTENTION !!!!!! : ne pas récupérer les infos du nouvel obstacle, on conserve les infos de l'ancien (on ne suit pas le décor, mais on choisit de contourner le 1er obstacle dans l'autre sens !!!!!
//								if( CR_Way_Grid_Check_Dir( - CR_Strafe_Cote_Get() * MATH_VecCrossProduct(- Cv_VerticalVector, v_way_obstacle_normale), CR_Strafe_Cote_Get()) )
//									f_way_strafe_sens_pref *= -1.0	// change de sens
//								else
//								{
//									tv_new_sight = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, MATH_FloatSign(tf_dot_Horiz_moveAxis) * Cf_PiBy4)		// pour forcer à tourner
//									goto TOURNE
//								}
//							}
//						}
//					}
//					else
//					{
//						// PAS D'OBSTACLE DEVANT
//						PAS_D_OBSTACLE_DEVANT:
//						
//						f_way_strafe_sens_pref = 0.0		// RAZ sens préférentiel de strafe
//						i_way_obstacle_strafe_flag = faux
//						
//						if( ! i_antre_move_flag
//							&& ! f_intimidation_delay
//							&& ( i_modele == MODELE_Petit || MATH_VecDotProduct( @o_fight_actor OBJ_SightGet(), - tv_me_to_actor_N) < Cf_Cos30 )
//							&& MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_actor_N) > Cf_Cos30
//							&& ( i_modele == MODELE_Petit || tf_dist_me_to_actor > f_way_dist_strafe_fight_rot )
//							&& ! i_way_obstacle_strafe_flag 
//							&& ! CR_Cadavre_Find(o_fight_actor) )
//						{
//							// PASSAGE EN INTIMIDATION : fin d'un strafe ou timer + pas dans le sight de la cible + la cible est dans mon sight + pas au contact
//							ACT_ActionSet(ACTION_Intimidation)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
//						}
//						else
//						{
//							// PAS D'INTIMIDATION : DEPLACEMENT
//							if( CR_Strafe_Allowed() )
//							{
//								// timer strafe ok
//								if( ! CR_Strafe_En_Cours() )
//								{
//									// Passage en strafe : test des 2 côtés
//									ti_strafeG_ok = CR_Way_Grid_Check_Dir(tv_gauche, 1.0)
//									ti_strafeD_ok = CR_Way_Grid_Check_Dir( - tv_gauche, -1.0)
//									if( f_way_last_obstacle_time <= Cf_obstacle_strafe_cote_backup_delay )
//									{
//										// délai pendant lequel le crabe ne repartira pas en strafe du côté duquel il vient après avori strafé pour éviter un obstacle
//										if( f_way_obstacle_cote_backup == 1.0 )
//											ti_strafeD_ok = faux		// j'ai contourné par la gauche, je n'ai pas le droit de repartir vers la droite
//										else if( f_way_obstacle_cote_backup == -1.0 )
//											ti_strafeG_ok = faux		// j'ai contourné par la droite, je n'ai pas le droit de repartir vers la gauche
//									}
//									
//									// Passage en strafe : choix du côté de strafe
//									if( ti_strafeG_ok && ti_strafeD_ok )
//										CR_Strafe_Begin_With_Duration(MATH_FloatSign(MATH_RandFloat(-1.0,1.0)))
//									else if( ti_strafeG_ok )
//										CR_Strafe_Begin_With_Duration(1.0)
//									else if( ti_strafeD_ok )
//										CR_Strafe_Begin_With_Duration(-1.0)
//									else
//										goto AVANCE
//								}
//								else
//								{
//									// Déjà en strafe : check obstacle dans le sens du strafe
//									if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche, CR_Strafe_Cote_Get()) )
//									{
//										// OBSTACLE DU COTE DU STRAFE ??? (A VALIDER) 
//										CR_Way_Get_Obstacle()
//										if( CR_Strafe_Cote_Get() == MATH_FloatSign(tf_dot_Horiz_moveAxis) )
//										{
//											// ma cible est derrière l'obstacle : est-ce que je dois le contourner ???
//											if( tf_dot_Sight_moveAxis > Cf_Cos45 )
//											{
//												// ma cible est devant moi -> je coupe le strafe mais l'obstacle ne me gène pas
//												CR_Strafe_End_And_Delay()
//												goto AVANCE
//											}
//											else
//											{
//												// ma cible et le mur sont du même côté, test de la distance au mur et de la distance à la cible :
//												if( f_way_obstacle_dist > tf_dist_me_to_actor )
//													goto AVANCE			// je coupe le strafe mais l'obstacle ne me gène pas
//												else
//												{
//													// OBSTACLE DU COTE DU STRAFE
//													tv_new_sight = - v_way_obstacle_normale
//												}
//											}
//										}
//										else
//										{
//											// l'obstacle n'est pas du même côté (horizon) que ma cible -> je coupe le strafe mais l'obstacle ne me gène pas
//											CR_Strafe_End_And_Delay()
//											goto AVANCE
//										}
//									}
//									else
//									{
//										// PAS D'OBSTACLE DU COTE DU STRAFE : rotation en strafe pour se rapprocher de la cible
//										tv_new_sight = tv_me_to_actor
//										tv_new_sight = MATH_VecRotate(tv_new_sight, Cv_VerticalVector, - CR_Strafe_Cote_Get() * f_way_requin_radian)
//									}
//								}
//							}
//							else
//							{
//								// timer strafe requin pas ok
//								
//								// test timer attaque strafe de face
//								if( ! f_attack_strafe_face_delay )
//								{
//									if( CR_Strafe_Attack_Face_Allowed() )
//									{
//										i_way_mode_strafe = Ci_way_mode_strafe_attack_face
//										CR_Strafe_Attack_Begin_With_Duration(MATH_FloatSign(tf_dot_Horiz_moveAxis))
//									}
//									else
//										goto AVANCE
//								}
//								else
//									goto AVANCE
//								
//								if( 0 )
//								{
//									AVANCE:
//									if( CR_Strafe_En_Cours() )
//										CR_Strafe_End_And_Delay()
//									if( ! ACT_ActionIsTransition() )
//									{
//										// ne pas couper les transitions avance/strafe
//										ACT_ActionSet(ACTION_Avance_Attaque)
//										CR_Rotation_Coef_Set(Ci_rotation_coef_avance)
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//			else
//			{
//				// CIBLE DANS LES CONES DE STRAFE : calcul d'un point devant la cible vers lequel strafer
//				if( f_attack_strafe_face_duration )
//				{
//					// je passe ici à cause d'une attaque strafe -> à la fin de mon attaque je me remet face à elle
//					i_way_mode_strafe = Ci_way_mode_strafe_attack_face
//				}
//				else
//				{
//					i_way_mode_strafe = Ci_way_mode_strafe_attack_cote
//				}
//								
//				if( i_way_obstacle_tourne_flag )
//				{
//					tf_cote = 0.0		// qd j'ai un obstacle du côté du strafe et que je suis en train de me tourner, je checke devant
//					tv_check_grid = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, - CR_Strafe_Cote_Get() * Cf_PiBy4)
//					DBG_RenderVector(OBJ_PosGet(), tv_check_grid, color_jaune)
//				}
//				else
//				{
//					f_way_strafe_sens_pref = 0.0
//					tf_cote = MATH_FloatSign(tf_dot_Horiz_moveAxis)
//					tv_check_grid = tf_cote * tv_gauche
//				}
//				
//				if( ! CR_Way_Grid_Check_Dir(tv_check_grid, tf_cote) )	// on fait un test de grille sur le côté même si on force un déplacement avant
//				{
//					// OBSTACLE DANS LE SENS DU STRAFE
//					CR_Way_Get_Obstacle()
//					
//					// OBSTACLE DEVANT LE CRABE
//					tf_dot_new = MATH_VecDotProduct(OBJ_SightGet(), v_way_obstacle_normale)
////					if( ! i_way_obstacle_tourne_flag && MATH_AbsFloat(tf_dot_new) > Cf_Cos30 )
//					if( ! i_way_obstacle_tourne_flag && tf_dot_new < - Cf_Cos30 )
//					{
//						CR_Strafe_End_And_Delay()		// Avancer, ne pas partir en strafe
//						i_way_obstacle_strafe_flag = faux
//						i_way_obstacle_avance_flag = vrai
//						ACT_ActionSet(ACTION_Avance_Attaque)
//						CR_Rotation_Coef_Set(Ci_rotation_coef_null)		// NULL !!!!
//					}
//					else
//					{
//						CR_Strafe_Duration_Reset()
//						tv_new_sight = - v_way_obstacle_normale
//						
//						if( i_way_obstacle_avance_flag )
//						{
//							f_way_strafe_sens_pref = - tf_cote			// impose un côté pour ne pas repartir en arrière dès qu'il n'y a plus collision mur
//							CR_Strafe_Begin_With_Duration(f_way_strafe_sens_pref)		// si je forçais un depl avant, je pars en strafe dans l'autre sens
//							i_way_obstacle_avance_flag = faux
//							i_way_obstacle_strafe_flag = faux
//							i_way_obstacle_tourne_flag = vrai
//						}
//						else if( ! i_way_obstacle_tourne_flag )
//						{
//							i_way_obstacle_strafe_flag = vrai
//							if( ! CR_Strafe_En_Cours() )
//								CR_Strafe_Begin_With_Duration(tf_cote)			// sinon strafe vers ma cible
//						}
//					}
//				}
//				else
//				{
//					// PAS D'OBSTACLE DANS LE SENS DU STRAFE
//					PAS_D_OBSTACLE_EN_STRAFE:
//					i_way_obstacle_tourne_flag = faux
//					
//					if( tf_cote == 0.0 ) 	// i_way_obstacle_tourne_flag
//						tf_cote = MATH_FloatSign(tf_dot_Horiz_moveAxis)
//					
//					if( ! CR_Strafe_En_Cours() )
//						CR_Strafe_Begin_With_Duration(tf_cote)
//					
//					i_way_obstacle_strafe_flag = faux
//					i_way_obstacle_avance_flag = faux
//					
//					f_way_strafe_sens_pref = 0.0
//					
//					if( tf_dist_me_to_actor > f_way_dist_strafe_fight_rot )
//						tf_strafe_rotation_coef = 0.0			// loin : strafe en ligne droite vers la cible
//					else
//						tf_strafe_rotation_coef = 1.0 - ( MATH_FloatMax(tf_dist_me_to_actor, f_way_dist_position_fight / 2.0) / f_way_dist_strafe_fight_rot )		// proche : strafe en tournant autour de la cible
//					
//					tv_new_horizon = CR_Strafe_Cote_Get() * tv_me_to_actor
//					tv_new_horizon =  MATH_VecRotate(tv_new_horizon, Cv_VerticalVector, CR_Strafe_Cote_Get() * Cf_PiBy2 * tf_strafe_rotation_coef )
//					tv_new_sight = MATH_VecCrossProduct(tv_new_horizon, Cv_VerticalVector)
//					DBG_RenderVector(OBJ_PosGet(), tv_new_horizon, color_bleu)
//					DBG_RenderVector(OBJ_PosGet(), tv_new_sight, color_rouge)
//				}
//			}
//		}
//		break		// switch action
//}
//
//
//// ORIENTATION ---------------------------------------------------------------------------
//if( MATH_VecNullEpsilon(tv_new_sight) )
//	tv_new_sight = tv_me_to_actor
//else
//	DBG_RenderVector(OBJ_PosGet(), tv_new_sight * 10.0, color_rouge)		// aff sight calculé
//
//OBJ_BankingGeneralSet(
//	MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, f_way_rotation_coef * TIME_GetDt()),
//	MATH_VecBlendRotate(OBJ_BankingGet(), v_ground_normale, 6.0 * TIME_GetDt()))
//
//// INTIMIDATION DEBUT COMBAT ------------------------------------------------
//if( f_way_length >= f_way_dist_reset_intimid )
//	i_attack_intimidation_done = faux
//
//// DELAIS STRAFE ET INTIMIDATION
//if( i_way_obstacle_strafe_flag )
//{
//	CR_Intimidation_Delay_Random()
//	CR_Strafe_Delay_Random()
//	if( ! i_way_rot_mult_done )
//	{
//		i_way_rot_mult_done = vrai
//		CR_Rotation_Coef_Multiply(1.25)
//	}
//}
//else
//{
//	CR_Rotation_Coef_Multiply(1.0)
//	i_way_rot_mult_done = faux
//}
//
//
//// COEF DE VITESSE --------------------------------------------------
//CR_Speed_Coef_Multiply()
//
//