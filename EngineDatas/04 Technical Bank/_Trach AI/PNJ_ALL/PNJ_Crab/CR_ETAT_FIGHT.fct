#include "CR_defines.var"

#define			Cf_front_delay			1.0

messageid		tmid_vision

vector			tv_pos_target
vector			tv_me_to_target
vector			tv_me_to_target_N
vector			tv_new_sight
vector			tv_new_speed
vector			tv_last_speed
vector			tv_pos
vector			tv_offset
vector			tv_new_horizon
vector			tv_lray_pos
vector			tv_lray_sight
vector			tv_my_sight
vector			tv_my_horizon
vector			tv_target_sight
vector			tv_2d_pos

int					ti_main
int					ti_sec
int					ti_main_new
int					ti_sec_new
int					ti_case
int					ti_test
int					ti_action
int					ti_obstacle
int					ti_move
int					ti_gauche
int					ti_frame
int					ti_children_nb
int					ti_target_just_lost

float				tf_speed
float				tf_pos_offset
float				tf_dist_to_target
float				tf_dot_Horiz_moveAxis
float				tf_dot_Sight_moveAxis
float				tf_cos_strafe
float				tf_strafe_rotation_coef 
float				tf_speed_coef
float				tf_cote
float				tf_target_Z
float				tf_requin_coef
float				tf_wp_repli_wait_delai

object			to_ray_object
object			to_FA_lray_bone
object			to_my_lray_bone
object			to_camera
object			tao_children[10]
object			to_wp


tv_2d_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())


// SORTIE ETAT ==============================================================================
if (i_sort_etat)
{
	CR_SND_Charge45_Stop()		// charge interrompue ?
	i_repli_wp_count = 0
	
	i_sort_etat = faux
	return
}


// ENTREE ETAT ==============================================================================
if (i_etat_courant != ETAT_FIGHT )
{
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_FIGHT
	str_etat = "Fight"
	if (fct_etat_courant)
	{
		i_sort_etat = vrai
		AI_Execute(fct_etat_courant)
	}
	
	fct_etat_courant = AI_TrackCurGet()
	fct_etat_main = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	CR_Fight_Init()					// changement de cible
	CR_Fight_Mode_Init()			// init mode fight	

	if( i_fight_mode == Ci_fight_mode_retour )
		EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)		// raz intérêt
	
	if( i_fight_mode == Ci_fight_mode_target && o_fight_actor && @o_fight_actor AI_IsModel(get_Humain_path) )
		CR_Human_Attack_Add(OBJ_Me())
	else
		CR_Human_Attack_Del(OBJ_Me())
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// EMERGENCY ABORT =============================
o_emergency_abort_actor = o_fight_actor
Macro_Emergency_Abort

// ANALYSE ===================================================================================
AI_Execute("CR_exec_CHECK_Vision")
     
// Paf
AI_Execute("CR_exec_CHECK_Paf")
if( CR_Paf_Check_Change_Etat() || ! f_HP_cur )		// blindage pour si mon paf actor est dans la cache
	macro_change_etat("CR_ETAT_PAF")

// valide la cible
if( i_fight_mode == Ci_fight_mode_target && ! CR_Target_Check(o_fight_actor) && ! i_fight_end_countdown_done )
{
	// ma proie s'est cachée
	EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)		// cible invalide -> raz intérêt -> raz fight_actor
	f_fight_end_countdown = MATH_RandFloat(0.75,1.75)											// hystérésis avant de changer de proie
	i_fight_end_countdown_done = vrai
	if( i_DBG_trace_etat )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : ")
		DBG_TraceObject(o_fight_actor)
		DBG_TraceString(" vient de se cacher, délai de fin d'attaque : ")
		DBG_TraceFloat(f_fight_end_countdown)
		DBG_TraceEOL()
	}
}

// Petit crabe : test humain agonisant => changer de cible
if( i_modele == MODELE_Petit && i_fight_mode == Ci_fight_mode_target && ! i_agonisant_change_target_done && @o_fight_actor AI_IsModel(get_Humain_path) && o_fight_actor != o_main_actor  )
{
	tmid_vision = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, o_fight_actor, nobody)
	if( MSG_GlobalIsValid(tmid_vision) && EVENT_VisionLifeStateGet(tmid_vision) <= Cf_Life_Agonisant )
	{
		// un humain (sauf le joueur) qui vient de passer agonisant : je checke s'il y a une autre target avant de l'acharner sur lui
		i_zone_restreinte_flag = vrai
		i_agonisant_change_target_done = vrai
		o_agonisant_change_target_gao = o_fight_actor
	}
}


ti_target_just_lost = faux
if( o_fight_actor && i_fight_end_countdown_done && ! f_fight_end_countdown ) // && ! MSG_GlobalIsValid(mid_best_interet) )
{
	// il est temps d'oublier pour de bon mon ancienne cible
	ti_target_just_lost = vrai
	i_zone_restreinte_flag = vrai
	o_fight_actor = nobody		// cible invalide -> raz intérêt -> raz fight_actor
	CR_Human_Attack_Del(OBJ_Me())
	if( i_DBG_trace_etat )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : délai de fin d'attaque écoulé")
		DBG_TraceEOL()
	}
}

AI_Execute("CR_exec_CHECK_Target")
o_agonisant_change_target_gao = nobody
if( i_change_target_flag )
{
	i_antre_move_flag = faux		// j'ai une cible : j'arrête mon retour à la maison
	CR_Fight_Init()					// changement de cible
	CR_Fight_Mode_Init()			// init mode fight
}
else if( ti_target_just_lost )
{
	if( i_DBG_trace_etat )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : passe en mode recherche : ")
		DBG_TraceEOL()
	}
	i_fight_mode = Ci_fight_mode_cherche							// je vais chercher ma proie qui s'est cachée
	i_fight_comportement = Ci_fight_comportement_wait			// raz sous mode pou la recherche
	// init 1er point à aller checker ------------------------------
	o_repli_wp = nobody
	if( o_repli_wp_father )
	{
		ti_children_nb = @o_repli_wp_father OBJ_HierarchyGetChilds(&tao_children[0])
		i_repli_first_wp_index = MATH_RandInt(0, ti_children_nb)
		i_repli_cur_wp_nb = i_repli_first_wp_index
		i_repli_wp_count = 0
		CR_Repli_Get_Next_WP(o_repli_wp_father, i_repli_cur_wp_nb, o_repli_wp)
		f_repli_wp_wait = 0.0
	}
}

// REPASSER EN IDLE ====================================================
switch( i_fight_mode )
{
	case Ci_fight_mode_target :
		str_etat = "Fight / Target"
		if( ! o_fight_actor )
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : en fight mais aucun intérêt = je n'ai pas trouvé d'autre cible -> idle")
				DBG_TraceEOL()
			}
			macro_change_etat("CR_ETAT_IDLE")	// perte d'intérêt et aucune autre cible -> IDLE
		}
		break
		
	case Ci_fight_mode_cadavre :
		str_etat = "Fight / Cadavre"
		if( @o_fight_actor AI_IsModel(get_PNJ_Bidoche_path) && @o_fight_actor OBJ_CapaTest(CAPA_Bidoche_Snapped_Jack) )
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : ma proie était une bidoche qui vient d'être ramassée")
				DBG_TraceEOL()
			}
			macro_change_etat("CR_ETAT_IDLE")	// perte d'intérêt et aucune autre cible -> IDLE
		}
		break
		
	case Ci_fight_mode_retour :
		str_etat = "Fight / Retour"
		break
		
	case Ci_fight_mode_cherche :
		str_etat = "Fight / Cherche"
		if( ! o_repli_wp && ! i_repli_wp_count )
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : pas de point de recherche : -> IDLE (retourne à la maison)")
				DBG_TraceEOL()
			}
			macro_change_etat("CR_ETAT_IDLE")
		}
		break
}


// PAFS COLLISION =============================================================================
//AI_Execute("CR_exec_CHECK_Collision")


// INTERET (cible ou cadavre) ----------------------------------------------------------------
//if( o_fight_actor && (CR_Perceived_Actor_Check(o_fight_actor, tmid_vision) || CR_Cadavre_Find(o_fight_actor)) )
if( i_fight_mode == Ci_fight_mode_target || i_fight_mode == Ci_fight_mode_cadavre )
	CR_Interet_Update(mid_best_interet, C_EVENT_InteretStatusAttack, o_fight_actor, tmid_vision)


// DELAIS DE STRAFE ==========================================
if( ! f_strafe_requin_duration && CR_Strafe_En_Cours() && i_way_mode_strafe == Ci_way_mode_strafe_aucun_ou_requin )
{
	CR_Strafe_Requin_Delay_Random()		// fin du strafe requin : délai pour le prochain
}
if( ! f_attack_strafe_face_duration && CR_Strafe_En_Cours() && i_way_mode_strafe == Ci_way_mode_strafe_attack_face_marche )
{
	CR_Strafe_Attack_Face_Delay_Random()		// fin du l'attaque strafe de face : délai pour la prochaine
}


// CALCUL DE LA DESTINATION ==================================
switch( i_fight_mode )
{
	case Ci_fight_mode_retour :
		// vers mon antre
		if( ! net_idle )
			tv_pos_target = v_antre_pos
		else
		{
			to_wp = WAY_WPNearestOfOBJ(net_idle, all, none, Ci_Filter_CapaFlag)		// 1er wp pas encore atteint
			tv_pos_target = @to_wp OBJ_PosGet()
		}
		break
		
	case Ci_fight_mode_target :
	case Ci_fight_mode_cadavre :
		// vers ma cible / mon cadavre
		tv_pos_target = EVENT_InteretPositionGet(mid_best_interet)
		break

	case Ci_fight_mode_cherche :
		if( o_repli_wp )
			tv_pos_target = @o_repli_wp OBJ_PosGet()		// j'ai un point de rechercher à aller checker
		else
			tv_pos_target = OBJ_PosGet()		// j'ai checké tous les points de recherche, j'attend ici...
		break
}

// offset positionnement
tf_pos_offset = CR_Pos_Offset_Get()
tv_me_to_target = tv_pos_target - OBJ_PosGet()
tf_target_Z = tv_pos_target.z
tv_me_to_target.z = 0.0
tf_dist_to_target = MATH_VecNorm(tv_me_to_target)
tv_me_to_target_N = tv_me_to_target
if( ! MATH_VecNullEpsilon(tv_me_to_target_N) )
	MATH_VecSetNormalize(tv_me_to_target_N)

// orientation et vitesse
tv_new_sight = tv_me_to_target
tv_new_speed = OBJ_SightGet()

// angles
tv_my_sight = OBJ_SightGet()
tv_my_sight.z = 0.0
if( ! MATH_VecNullEpsilon(tv_my_sight) )
	MATH_VecSetNormalize(tv_my_sight)

tv_my_horizon = OBJ_HorizonGet()
tv_my_horizon.z = 0.0
if( ! MATH_VecNullEpsilon(tv_my_horizon) )
	MATH_VecSetNormalize(tv_my_horizon)

tf_dot_Horiz_moveAxis = MATH_VecDotProduct(tv_my_horizon, tv_me_to_target_N)
tf_dot_Sight_moveAxis = MATH_VecDotProduct(tv_my_sight, tv_me_to_target_N)


ti_obstacle = faux
ti_move = faux

if( o_fight_actor )
{
	tv_target_sight = @o_fight_actor OBJ_SightGet()
	tv_target_sight.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_target_sight) )
		MATH_VecSetNormalize(tv_target_sight)
}


// ACTION -------------------------------------------------------------------------------------------
switch( ACT_ActionGet() )
{
	case ACTION_Intimidation :
		// INTIMIDATION =============================================================================
		if( ACT_ActionFinished() )
		{
			CR_Intimidation_Delay_Random()
			ti_move = vrai
		}
		break
		
	case ACTION_AttackHaut :
		// ATTAQUE EN COURS ======================================================================
		if( ACT_ActionFinished() )
		{
			// FIN D'ATTAQUE
			i_attack_paf_done = faux
			ti_move = vrai
			CR_Attack_Delay_Random()
			
			if( i_modele == MODELE_Petit )
				if( o_fight_actor != o_main_actor )		// tmp ne pas intimider le joueur
					i_attack_intimidation_done = faux		// les petits crabes intimident avant chaque attaque
		}
		else
		{
			// TEST PAF
			ti_frame = ANI_CurrentFrameGet(0)
			if( ! i_attack_paf_done && o_fight_actor && COL_ZDE_ZDECollide(o_fight_actor, C_zde_fight, C_zde_corps) && ti_frame >= 35 && ti_frame <= 45 )
			{
				// rajout de "&& o_fight_actor" car il peut devenir invalide pendant l'action (s'il meurt...)
				if( i_DBG_trace_etat )
				{
					DBG_TraceObject(OBJ_Me())
					DBG_TraceString(" paffe ")
					DBG_TraceObject(o_fight_actor)
					DBG_TraceString(" ZDE Fight / ZDE Corps")
					DBG_TraceEOL()
				}
				i_attack_paf_done = vrai
				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, i_paf_to_send_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, Ci_paf_dmg_pince, OBJ_SightGet())
				CR_Paffed_Actor_Add(o_fight_actor)
				SND_RequestPlay(Ci_SND_Bite)
			}
		}
		break
	
	default:
		ti_move = vrai
		break
}

if( ti_move )
{
	// ATTENTE OU DEPLACEMENT =============================================================
	if( i_fight_mode == Ci_fight_mode_cadavre && tf_dist_to_target <= 3.0 )
	{
		if( CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, -1, faux, vrai) )
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : ")
				DBG_TraceObject(o_fight_actor)
				DBG_TraceString(" est déjà sélectionné par quelqu'un, je le laisse...")
				DBG_TraceEOL()
			}
			EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)
			macro_change_etat("CR_ETAT_IDLE")
		}
	}
	if( tf_dist_to_target <= tf_pos_offset && ! f_time_force_requin )
	{
		// DEPLACEMENT TERMINE ---------------------------------------------------------------------------------------------------------------------------
		if( i_fight_mode == Ci_fight_mode_retour )
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" a atteint son antre")
				DBG_TraceEOL()
			}
			i_net_idle_return_done = vrai
			macro_change_etat("CR_ETAT_IDLE")
		}
		else if( i_fight_mode == Ci_fight_mode_cherche )
		{
			// passe au wp suivant
			f_repli_wp_wait += TIME_GetDt()
			if( i_modele == MODELE_Geant )
				tf_wp_repli_wait_delai = MATH_RandFloat(2.5, 4.5)
			else
				tf_wp_repli_wait_delai = MATH_RandFloat(1.0, 2.0)
			if( f_repli_wp_wait > tf_wp_repli_wait_delai )
			{
				f_repli_wp_wait = 0.0
				CR_Repli_Get_Next_WP(o_repli_wp_father, i_repli_cur_wp_nb, o_repli_wp)
				return
			}
			else
			{
				CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
				return
			}
		}
		
		// ORIENTATION VERS CIBLE
		if( tf_dot_Sight_moveAxis < f_way_cos_attack_pince )
		{
			// se tourne pour se mettre en face de la cible pour porter un coup de pince (paf ou grab)
			CR_ActionSet(ACTION_SurPlace, Ci_rotation_coef_sur_place)
		}
		// SINON DEBUT D'INTIMIDATION
//		else if( i_modele == MODELE_Geant && i_fight_mode == Ci_fight_mode_target && ! i_attack_intimidation_done )
		else if( i_fight_mode == Ci_fight_mode_target && ! i_attack_intimidation_done )
		{
			// ce n'est pas un cadavre, je suis un crabe géant qui n'a pas encore fait son intimidation
			if( i_modele == MODELE_Petit && o_fight_actor == o_main_actor )
				i_attack_intimidation_done = vrai
			else if( f_time_last_paf > 0.5 )
			{
				i_attack_intimidation_done = vrai
				SND_RequestPlay(Ci_SND_Intimid)
				CR_ActionSet(ACTION_Intimidation, Ci_rotation_coef_intimidation)
			}
			else
				CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
		}
		// MA CIBLE EST UN CADAVRE
		else if( i_fight_mode == Ci_fight_mode_cadavre )
		{
			macro_change_etat("CR_ETAT_MANGE")
		}
		// SINON (PAS CADAVRE OU CADAVRE PAS MORT) => TEST DELAI DEBUT D'ATTAQUE
		else if( f_attack_delay <= 0.0 && CR_Attack_Enabled() )
		{
			to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
			if( ! to_FA_lray_bone )
				to_FA_lray_bone = o_fight_actor
			to_my_lray_bone = o_bone_carapace
			tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
			tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
			DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
			to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			if( to_ray_object || CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, C_EVENT_InteretStatusGrab, vrai, faux) ) 
			{
				// PAS LE DROIT D'ATTAQUER (MUR, DEJA GRABBE PAR UN BUDY....)
				CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
			}
			else
			{
				// PAS D'OBSTACLE ENTRE MA CIBLE ET MOI
				if( i_attaque_en_hauteur || tf_target_Z <= (OBJ_PosGet().z + f_attaque_hauteur_Z ) )
				{
					i_positionnement_force_requin = CR_Need_Strafe_Positionnement(tv_me_to_target_N, tv_target_sight)
					if( i_positionnement_force_requin )
						// PETITS CRABES > Eviter les paf hors champs qui sont injustes: le crabe doit chercher à se mettre face au joueur, si ce n’est pas possible il fait son intimidation
						goto DEPLACEMENT_NECESSAIRE
					else
					{
						tv_new_sight = tv_me_to_target
						if( i_DBG_force_cote_grab == 1 )
							ti_gauche = vrai		// force gauche
						else if( i_DBG_force_cote_grab == 2 ) 
							ti_gauche = faux		// force droite
						else
						{
							ti_gauche = faux		// standard
							if( MATH_VecDotProduct(OBJ_HorizonGet(), tv_me_to_target) > 0 )
								ti_gauche = vrai
						}
//						SND_RequestPlay(Ci_SND_Attack)
						if( i_grab && ( o_fight_actor != o_main_actor || i_modele == MODELE_Geant ) )
						{
							if( ti_gauche )
								ACT_ActionSet(ACTION_GrabGdeb)
							else
								ACT_ActionSet(ACTION_GrabDdeb)
							macro_change_etat("CR_ETAT_GRAB")
						}
						else
						{
		//					if( ti_gauche )
		//						CR_ActionSet(ACTION_AttackG, Ci_rotation_coef_attaque)
		//					else
		//						CR_ActionSet(ACTION_AttackD, Ci_rotation_coef_attaque)

//							CR_ActionSet(ACTION_AttackHaut, Ci_rotation_coef_attaque)
							if( i_modele == MODELE_Petit && i_fight_mode == Ci_fight_mode_target )
								i_fight_comportement = Ci_fight_comportement_fight		// s'il n'est pas passé en mode 45° (cible trop proche)
							ACT_ActionSet(ACTION_AttackHaut | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero )		// possibilité d'enchaîner les attaques
							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque, vrai)
						}
					}
				}
				else
				{
					CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
				}
			}
		}
		// SINON ATTENTE
		else
		{
			CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
		}
	} // fin "plus de déplacement"
	else
	{
		// DEPLACEMENT NECESSAIRE ---------------------------------------------------------------------------------------------------------------------------
		DEPLACEMENT_NECESSAIRE:
		ti_obstacle = vrai
		
		// Test de la grille pour la nouvelle trame
		ai_grille_stop[0] = Ci_sol_mur
		i_grille_stop_nb = 1
		tv_pos = OBJ_PosGet()
		i_grid[0] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[0], cvector(1.0, 0.0, 0.0), i_grid_nb_case_check, 0, i_last_frontB, i_DBG_render_grille_check )
		i_grid[1] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[1], cvector(0.0, -1.0, 0.0), i_grid_nb_case_check, 1, i_last_frontB, i_DBG_render_grille_check )
		i_grid[2] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[2], cvector(-1.0, 0.0, 0.0), i_grid_nb_case_check, 2, i_last_frontB, i_DBG_render_grille_check )
		i_grid[3] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[3], cvector(0.0, 1.0, 0.0), i_grid_nb_case_check, 3, i_last_frontB, i_DBG_render_grille_check )
		i_last_frontB = -1		// reset backup front lock trame précédente
		
		//   0
		// 3 - 1
		//   2
		
		// Si y a plus rien devant on reset le lock d'axe
		if( i_last_front != -1 && ! i_grid[i_last_front] )
		{
			i_last_front = -1
			i_last_side = -1
		}
		
		
		// Récup des N°s d'axe pour l'orientation courante
		ti_main = CRAB_GRID_Get_Sight_ID(tv_me_to_target, ti_sec)
		if( i_last_front == -1 )
		{
			// PAS ENCORE LOCKE EN STRAFE FACE A UN MUR ==================================
			// Je ne suis pas locké en Axe. (Le front touche)
			i_last_front = ti_main
			i_last_sec = ti_sec
		}
		else
		{
			// LOCKE EN STRAFE FACE A UN MUR =============================================
			// Je teste si maintenant la direction n'est pas dans mon dos
			if( ti_main != MATH_Modulo(i_last_front+2,4) && ti_sec != MATH_Modulo(i_last_front+2,4) )
			{
				// Non, je garde les anciennes valeurs locké (KEEP STRAFF)
				ti_main = i_last_front
				ti_sec = i_last_sec
			}
		}
		
		if (i_grid[ti_main])
		{
			// IL Y A UN MUR DEVANT MOI ===================================================
			// S'il n'y a pas de sens d'esquive de stocké, je prend celui que je prefere (side) sinon j'alterne (side opposé).
			if (i_last_side == -1)
				i_last_side = ti_sec												// Mon preferé
			else if ( i_grid[i_last_side] )
				i_last_side = MATH_Modulo(i_last_side + 2, 4)			// Mon symetrique
		
			// Deplacement en SIDE (Straff)
			tv_new_sight = v_grid_normale[ti_main]
			tv_new_speed	= v_grid_normale[i_last_side]
			
			i_front_lock = ti_main
			i_last_frontB = ti_main			// backup front lock
			f_front_delay = Cf_front_delay
			
			if( MATH_VecDotProduct(OBJ_HorizonGet(), tv_new_speed) > 0 )
				CR_ActionSet(ACTION_StrafeG, Ci_rotation_coef_strafe)
			else
				CR_ActionSet(ACTION_StrafeD, Ci_rotation_coef_strafe)
		}
		else
		{
			// IL N'Y A PAS DE MUR DEVANT MOI =============================================
			// Je peux eventuellement longer a droite ou a gauche
			ti_sec_new = ti_sec
			ti_main_new = ti_main
			
			// Rajout sur les SIDEs du coin plus plus dans ma direction
			f_front_delay -= MATH_FloatMin(f_front_delay, TIME_GetDt() ) 
			if (f_front_delay)
			{
				// Je rajoute au side du coté ou je veux aller la case du coin
				ti_test = ti_sec
				if (ti_test == i_front_lock)
					ti_test = ti_main
				
				ti_sec_new = ti_test
				ti_main_new = i_front_lock
				
				if (ti_main == i_front_lock || ti_sec == i_front_lock )
				{
					// Je rajoute a mon side la case qui est au coin de ti_sec et de i_front_lock
					tv_offset = v_corner_pos[i_front_lock][ti_test]
					DBG_RenderVector( GRID_PosGet(tv_pos + tv_offset) + cvector(0.03,0.03,0),cvector(0,0,100000),color_bleu)
					ti_case = CRAB_GRID_Check(tv_pos+tv_offset, cvector(0.0, 0.0, 0.0), 1, 0, -1, i_DBG_render_grille_check)		// test d'un case
					i_grid[ti_test] += ti_case
				}
				else
					f_front_delay = 0.0		// Break on veut aller dans le dos du dernier lock
			}
			
			if (i_grid[ti_sec_new])
			{
				// il y a un mur de mon coté preféré, je le longe
		
				// Deplacement en FRONT
				tv_new_sight = v_grid_normale[ti_main_new]
				tv_new_speed = tv_new_sight
				CR_ActionSet(ACTION_Avance, Ci_rotation_coef_avance)
			}
			else
			{
				// il n'y a de mur ni devant moi, ni sur mon côté préféré : mon déplacement est totalement liiiiiiiibre !!!!! :)
				ti_obstacle = faux
				
				//===============================================================================================
				// MODE DE DEPLACEMENT
				//===============================================================================================
				
				if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face_debut )
				{
					ATTAQUE_STRAFE_DEBUT:
					// je me tourne pour faire une attaque strafe 45°
					@get_global f_CRAB_next_attaque_45degre = TIME_Get() + MATH_RandFloat(0.5, 1.5)
					i_attack_intimidation_done = faux		// oblige une intimidation après une strafe 45°
					
					if( i_modele == MODELE_Petit && i_fight_mode == Ci_fight_mode_target )
						i_fight_comportement = Ci_fight_comportement_fight
					
//					tv_new_sight = OBJ_SightGet()		// suivre l'orientation de l'anim
					tv_new_sight = tv_me_to_target		// orientation vers ma cible
					if( ACT_ActionGet() != ACTION_TourneD45debut && ACT_ActionGet() != ACTION_TourneG45debut && ACT_ActionGet() != ACTION_TourneD45marche && ACT_ActionGet() != ACTION_TourneG45marche )
					{
						if( tf_dot_Horiz_moveAxis > 0.0 )
						{
//							if( i_attaque45pasenface_flag )		// new new new 
//								CR_ActionSet(ACTION_TourneG45debut, Ci_rotation_coef_null)			// new new new 
//							else
//								CR_ActionSet(ACTION_TourneD45debut, Ci_rotation_coef_null)
							CR_ActionSet(ACTION_TourneD45debut, Ci_rotation_coef_attaque)
						}
						else
						{
//							if( i_attaque45pasenface_flag )		// new new new 
//								CR_ActionSet(ACTION_TourneD45debut, Ci_rotation_coef_null)			// new new new 
//							else
//								CR_ActionSet(ACTION_TourneG45debut, Ci_rotation_coef_null)
								CR_ActionSet(ACTION_TourneG45debut, Ci_rotation_coef_attaque)
						}
					}
					else if( ACT_ActionGet() == ACTION_TourneD45debut && ACT_ActionFinished() )
					{
						CR_SND_Charge45_Play()
//						if( i_attaque45pasenface_flag )		// new new new 
//							CR_ActionSet(ACTION_TourneG45marche, Ci_rotation_coef_strafe)		// new new new 
//						else
							CR_ActionSet(ACTION_TourneD45marche, Ci_rotation_coef_strafe)
						i_way_mode_strafe = Ci_way_mode_strafe_attack_face_marche		// fini de tourner
					}
					else if( ACT_ActionGet() == ACTION_TourneG45debut && ACT_ActionFinished() )
					{
						CR_SND_Charge45_Play()
//						if( i_attaque45pasenface_flag )		// new new new 
//							CR_ActionSet(ACTION_TourneD45marche, Ci_rotation_coef_strafe)		// new new new 
//						else
							CR_ActionSet(ACTION_TourneG45marche, Ci_rotation_coef_strafe)
						i_way_mode_strafe = Ci_way_mode_strafe_attack_face_marche		// fini de tourner
					}
				}
				else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face_marche )
				{
					//ATTAQUE_STRAFE_MARCHE:
					// je suis en train de faire une attaque strafe 45°
//					tv_new_sight = OBJ_SightGet()		// suivre l'orientation de l'anim
					tv_new_sight = tv_me_to_target		// orientation vers ma cible
					tf_cos_strafe = CR_Way_Strafe_Cosinus_Get()
					if( ( ! CR_Strafe_Attack_Face_Allowed(tf_dist_to_target) ) ) // || tf_dot_Horiz_moveAxis > tf_cos_strafe || tf_dot_Horiz_moveAxis < - tf_cos_strafe )
					{
						// timer terminé ou trop proche ou ma cible est passée sur le côté
						i_way_mode_strafe = Ci_way_mode_strafe_attack_face_retour		// attaque terminée
						CR_SND_Charge45_Stop()
					}
				}
				else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face_retour )
				{
					//ATTAQUE_STRAFE_RETOUR:
					// je coupe mon strafe attaque 45° pour me remette face à ma cible
//					tv_new_sight = OBJ_SightGet()		// suivre l'orientation de l'anim
					tv_new_sight = tv_me_to_target		// orientation vers ma cible
					if( ACT_ActionGet() == ACTION_TourneD45marche )
					{
						CR_ActionSet(ACTION_TourneD45fin, Ci_rotation_coef_null)
					}
					else if( ACT_ActionGet() == ACTION_TourneG45marche )
					{
						CR_ActionSet(ACTION_TourneG45fin, Ci_rotation_coef_null)
					}
					else if( 
						( ACT_ActionGet() != ACTION_TourneG45fin && ACT_ActionGet() != ACTION_TourneD45fin ) 
						|| ACT_ActionFinished() )
					{
						// fini de tourner
//						i_attaque45pasenface_flag = faux
						if( ! o_paf_actor )
						{
							// intimide après un strafe attack de face (sauf si je viens de prendre un paf)
							CR_Intimidation_Delay_Reset()
							CR_Attack_Delay_Reset()
						}
						CR_Strafe_Attack_Face_Delay_Random()
						i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin			// retour en position de face terminé
					}
				}
				else
				{
					// aucun strafe OU strafe requin OU strafe côté ----------------------------------------------------------------------------------
					tf_cos_strafe = CR_Way_Strafe_Cosinus_Get()
					if( tf_dot_Horiz_moveAxis < tf_cos_strafe && tf_dot_Horiz_moveAxis > - tf_cos_strafe )
					{
						// CIBLE DEVANT MOI OU DERRIERE MOI (AUCUN STRAFE OU STRAFE REQUIN)
						i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin
						if( tf_dot_Sight_moveAxis < 0 ) // && i_way_mode_strafe != Ci_way_mode_strafe_attack_face_retour )
						{
							// CIBLE DERRIERE MOI
							CR_ActionSet(ACTION_SurPlace, Ci_rotation_coef_sur_place)
						}
						else
						{
							// CIBLE DEVANT MOI
							if( i_fight_mode == Ci_fight_mode_target 
								&& ! f_intimidation_delay
								&& ( i_modele == MODELE_Petit || MATH_VecDotProduct( @o_fight_actor OBJ_SightGet(), - tv_me_to_target_N) < Cf_Cos30 )
								&& MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_target_N) > Cf_Cos30
								&& ( i_modele == MODELE_Petit || tf_dist_to_target > f_way_dist_strafe_fight_rot )
								&& tf_dist_to_target > f_way_dist_intimidation 
								&& i_fight_comportement == Ci_fight_comportement_wait )
							{
								// PASSAGE EN INTIMIDATION : fin d'un strafe ou timer + pas dans le sight de la cible + la cible est dans mon sight + pas au contact
								SND_RequestPlay(Ci_SND_Intimid)
								CR_ActionSet(ACTION_Intimidation, Ci_rotation_coef_intimidation)
							}
							else
							{
								// PAS D'INTIMIDATION : DEPLACEMENT
								//if( o_fight_actor && ! CR_Cadavre_Find(o_fight_actor) )
								if( i_fight_mode == Ci_fight_mode_target )
								{
									// vers une proie vivante
									
									i_positionnement_force_requin = CR_Need_Strafe_Positionnement(tv_me_to_target_N, tv_target_sight)			// test fin de strafe de positionnement
									
									if( 0 && f_time_force_requin )		// réactiver pour supprimer le test "tir dessus = passe en attaque « fonce sur toi »"
									{
										goto STRAFE_REQUIN_ALLOWED
									}
									else if( CR_Strafe_Attack_Face_Allowed(tf_dist_to_target) )
									{
										// attaque strafe alors qu'on est de face : je me tourne du côté de ma cible pour attaquer + vite
										i_way_mode_strafe = Ci_way_mode_strafe_attack_face_debut
										goto ATTAQUE_STRAFE_DEBUT
									}
									else if( CR_Strafe_Requin_Allowed(tf_dist_to_target) )
									{
										STRAFE_REQUIN_ALLOWED:
										// strafe requin : côté aléatoire
										if( CR_Strafe_En_Cours() )
										{
											if( CR_Strafe_Cote_Get() == 1.0 )
												ti_action = ACTION_StrafeG
											else
												ti_action = ACTION_StrafeD
										}
										else
										{
											if( i_positionnement_force_requin )
											{
												// force le strafe pour aller devant la cible
												if( MATH_FloatSign(MATH_VecDotProduct(@o_fight_actor OBJ_HorizonGet(), - tv_me_to_target)) > 0.0 )
													ti_action = ACTION_StrafeG		// je suis sur la gauche de ma target : je strafe à gauche pour venir face à elle
												else
													ti_action = ACTION_StrafeD
											}
											else
											{
												// jack
												if( o_fight_actor == o_main_actor )
												{
													if( f_on_screen_pourcent > 0.5 )
													{
														// dans le champ : côté aléatoire (comportement imprévisible) 
														if( MATH_RandFloat(-1.0,1.0) < 0.0 )
															ti_action = ACTION_StrafeG
														else
															ti_action = ACTION_StrafeD
													}
													else
													{
														// presque hors champ : vers la caméra
														to_camera = @get_global o_camera
														if( MATH_FloatSign(MATH_VecDotProduct(@to_camera OBJ_HorizonGet(), - tv_me_to_target)) > 0.0 )
															ti_action = ACTION_StrafeG		// je suis sur la gauche de jack : je strafe à gauche pour venir face à lui
														else
															ti_action = ACTION_StrafeD
													}
												}
												else
												{
													// pnj : côté aléatoire (comportement imprévisible) 
													if( MATH_RandFloat(-1.0,1.0) < 0.0 )
														ti_action = ACTION_StrafeG
													else
														ti_action = ACTION_StrafeD
												}
											}
										}
										
										if( CR_ActionSet(ti_action, Ci_rotation_coef_strafe) )
										{
											// raz timers attaque strafe de face
											CR_Strafe_Attack_Face_Delay_Random()
											CR_Strafe_Attack_Face_Duration_Reset()
											if( i_positionnement_force_requin )
												tf_requin_coef = 0.0
											else
												tf_requin_coef = f_way_requin_coef
											f_way_requin_radian = tf_requin_coef * Cf_PiBy2
											tv_new_sight = MATH_VecRotate(tv_new_sight, Cv_VerticalVector, - CR_Strafe_Cote_Get() * f_way_requin_radian)
										}
									}
									else
									{
										// avance
										CR_ActionSet(ACTION_Avance, Ci_rotation_coef_avance)
									}
								}
								else
								{
									// cadavre ou retour à mon antre : avance
									CR_ActionSet(ACTION_Avance, Ci_rotation_coef_avance)
								}
							}
						} // fin "cible devant moi"
					}  // fin "cible devant ou derrière moi" (aucun strafe ou strafe requin)
					else
					{
						// CIBLE SUR LES COTES =================================================
						
						if( i_modele == MODELE_Petit )
						{
//							if( i_fight_mode == Ci_fight_mode_target )
//								i_fight_comportement = Ci_fight_comportement_fight		// force la charge 45°
							
							goto STRAFE_REQUIN_ALLOWED
							
//							switch( i_way_mode_strafe )
//							{
//								case Ci_way_mode_strafe_aucun_ou_requin :
//								case Ci_way_mode_strafe_attack_cote :
////									i_attaque45pasenface_flag = vrai
////									i_way_mode_strafe = Ci_way_mode_strafe_attack_face_debut
////									goto ATTAQUE_STRAFE_DEBUT
//									if( tf_dot_Horiz_moveAxis > 0.0 )
//										CR_ActionSet(ACTION_TourneD45marche, Ci_rotation_coef_strafe)
//									else
//										CR_ActionSet(ACTION_TourneG45marche, Ci_rotation_coef_strafe)
//									i_way_mode_strafe = Ci_way_mode_strafe_attack_face_marche
//									goto ATTAQUE_STRAFE_MARCHE
//									break
//									
//								case Ci_way_mode_strafe_attack_face_marche :
//									goto ATTAQUE_STRAFE_MARCHE
//									break
//									
//								case Ci_way_mode_strafe_attack_face_retour :
//									goto ATTAQUE_STRAFE_RETOUR
//									break
//							}
						}
						
						// CRABE GEANT =======================================
						if( i_modele == MODELE_Geant )
							i_attack_intimidation_done = faux		// refaire l'intimidation après un strafe latéral
						
						i_way_mode_strafe = Ci_way_mode_strafe_attack_cote
						
						// ma cible essaie de me passer sur le côté : je strafe vers elle mais je tourne à la fin pour me retrouver face à elle
						if( tf_dist_to_target > f_way_dist_strafe_fight_rot )
							tf_strafe_rotation_coef = 0.0			// loin : strafe en ligne droite vers la cible
						else
							tf_strafe_rotation_coef  = 1.0 - ( MATH_FloatMax(tf_dist_to_target, CR_Fight_Actor_Pos_Offset_Get() / 2.0) / f_way_dist_strafe_fight_rot )		// proche : strafe en tournant autour de la cible
							
						if( ! CR_Strafe_En_Cours() )
							tf_cote = MATH_FloatSign(tf_dot_Horiz_moveAxis)
						else
							tf_cote = CR_Strafe_Cote_Get()
	
						if( tf_cote == 1.0 )
							ti_action = ACTION_StrafeG
						else
							ti_action = ACTION_StrafeD
	
						if( CR_ActionSet(ti_action, Ci_rotation_coef_strafe) )
						{
							tv_new_horizon = CR_Strafe_Cote_Get() * tv_me_to_target
							tv_new_horizon =  MATH_VecRotate(tv_new_horizon, Cv_VerticalVector, CR_Strafe_Cote_Get() * Cf_PiBy2 * tf_strafe_rotation_coef )
							tv_new_sight = MATH_VecCrossProduct(tv_new_horizon, Cv_VerticalVector)
						}
					} // fin de "strafe côté"
				} // fin de "aucun strafe OU strafe requin OU strafe côté"
			} // fin de "mon déplacement est liiiibre !!!!"
		} // fin "pas de mur devant"
	} // fin "déplacement nécessaire"'
} // fin if( ti_move )


if( i_DBG_display_fight_stats )
{
	Str_DisplayVectorOnce(tv_me_to_target, cvector(0,0,0) )
	Str_DisplayIntOnce(ti_main, cvector(0,0.1,0) )
	Str_DisplayIntOnce(ti_sec, cvector(0.1,0.1,0) )
}


// ORIENTATION --------------------------------------------------------------------
DBG_RenderVector(OBJ_PosGet() + cvector(0.0,0.5,0.0), tv_new_sight * 10, color_vert)
CR_Rotation_Coef_Blend()
OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, f_way_rotation_coef_cur * TIME_GetDt()), macro_banking)

// VITESSE -----------------------------------------------------------------------------
tf_speed_coef = CR_Speed_Coef_Get(ti_obstacle)
if( ti_obstacle )
{
	// CONTOURNEMENT
	i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin

	tv_last_speed = DYN_SpeedGetVector()
	tf_speed = MATH_VecNorm(tv_last_speed)
	if( tf_speed )
		MATH_VecSetNorm(tv_new_speed, tf_speed)
	
	DYN_SpeedSetVector(MATH_VecBlend(tv_last_speed, tv_new_speed, 10.0 * TIME_GetDt()))
	DBG_RenderVector(OBJ_PosGet(), tv_new_speed * 10, color_cyan)
	
	CR_Intimidation_Delay_Random()
	CR_Strafe_Requin_Delay_Random()
	CR_Strafe_Attack_Face_Delay_Random()
}
ACT_LIB_ActionFrequencyMultiply(tf_speed_coef)


// INTIMIDATION DEBUT COMBAT ------------------------------------------------
if( tf_dist_to_target >= f_way_dist_reset_intimid )
	i_attack_intimidation_done = faux

DBG_RenderVector(CRAB_GRID_PosGet(OBJ_PosGet()), Cv_VerticalVector * 3, color_cyan)

if( i_DBG_vague && @get_global i_CRAB_vague_attaque_flag )
	Str_DisplayTextOnce("vague d'attaque", cvector(0.5,0,0))

