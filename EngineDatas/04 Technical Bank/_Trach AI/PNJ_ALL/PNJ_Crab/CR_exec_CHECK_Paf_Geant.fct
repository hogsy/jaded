#include "CR_defines.var"

int					ti_rank
int					ti_paf_canal
int					ti_paf_type
int					ti_j_ai_pris_un_paf
int					ti_just_paf_grab_lache_flag
int					ti_shotgun
int					ti_shotgun_any
int					ti_lance
int					ti_lance_any

message		tm_msg_filter

messageid		tmid_paf_event
messageid		tmid_vision_event

float				tf_puissance
float				tf_puissance_init
float				tf_best_puissance
float				tf_recul_norm
float				tf_paf_max_norm
float				tf_angle_inclinaison
float				tf_norm
float				tf_HP_init

object			to_pere
object			to_best_pere
object			to_tmp

vector			tv_speed
vector			tv_paf_dir
vector			tv_2D_pos
vector			tv_paf_position
vector			tv_caparace_paf
vector			tv_caparace_paf_cumul

int					ti_tmp_paf_important_flag
int					ti_tmp_paf_moyen_flag
int					ti_tmp_paf_faible_flag



o_paf_actor = nobody

if (i_paf_check_flag)
	return

tf_HP_init = f_HP_cur

i_paf_check_flag = vrai
i_paf_main_actor_flag = faux
v_paf_dir = Cv_NullVector
to_best_pere = nobody
tf_best_puissance = 0.0
ti_j_ai_pris_un_paf = faux
tv_caparace_paf_cumul = Cv_NullVector
tv_caparace_paf = Cv_NullVector

MSG_SetNull(tm_msg_filter)
tm_msg_filter.msg_gao1 = OBJ_Me()
ti_rank = -1

i_paf_important_flag = faux
i_paf_moyen_flag = faux
i_paf_faible_flag = faux
i_paf_repousse_flag = faux
i_paf_grab_lache_flag = faux
i_paf_explose_flag = faux
i_paf_lance_flag = faux
ti_shotgun_any = faux
ti_lance_any = faux

for (	tmid_paf_event = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_rank, tm_msg_filter);
		MSG_GlobalIsValid(tmid_paf_event);
		tmid_paf_event = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_rank, tm_msg_filter)	)
{
	// INFOS DU PAF
	ti_tmp_paf_important_flag = faux
	ti_tmp_paf_moyen_flag = faux
	ti_tmp_paf_faible_flag = faux

	tv_paf_dir = EVENT_PafDirGet(tmid_paf_event)
	ti_paf_type = EVENT_PafTypeGet(tmid_paf_event)
	tf_puissance = EVENT_PafPuisGet(tmid_paf_event)
	tf_puissance_init = tf_puissance
	if( tf_puissance >= Cf_shotgun_paf_pointblank && tf_puissance < 1000.0 )
	{
		ti_shotgun = vrai
		ti_shotgun_any = vrai
	}
	else
		ti_shotgun = faux
	ti_paf_canal = EVENT_PafCanalGet(tmid_paf_event)
	to_pere = EVENT_PereGet(tmid_paf_event)
	tmid_vision_event = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_pere, nobody)
	tv_paf_position = EVENT_PafPositionGet( tmid_paf_event)
//	DBG_RenderVector(OBJ_PosGet(), tv_paf_position - OBJ_PosGet(), color_blanc)
//	DBG_RenderVector(tv_paf_position, Cv_VerticalVector, color_blanc)
	
	ti_just_paf_grab_lache_flag = faux
	
	// PAF VIANDE
	if( ti_paf_type & C_EVENT_PAF_Viande )
	{
		f_viande_cur -= MATH_FloatMin(f_viande_cur, tf_puissance)
		continue
	}
	
	ti_j_ai_pris_un_paf = vrai
	
	// FLAG PAF MAIN ACTOR
	if( to_pere == o_main_actor )
	{
		i_paf_main_actor_flag = vrai
	}
	
	// GRAB END CHECK
	if( i_DBG_grab_end_any_paf_for_marin && MSG_GlobalIsValid(mid_grab) && o_fight_actor != o_main_actor )
	{
		// Je grabbe un marin et il peut être libéré grâce à n'importe quel paf
		i_paf_grab_lache_flag = vrai
		ti_just_paf_grab_lache_flag = vrai
	}
	
	if( i_DBG_trace_paf )
	{
		DBG_TraceString("==================")
		DBG_TraceEOL()
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : paffé par : ")
		DBG_TraceObject(to_pere)
		DBG_TraceString(" (canal ")
		DBG_TraceInt(ti_paf_canal)
		DBG_TraceString(") ")
	}
	
	// INCLINAISON CARAPACE
	if( ti_paf_canal == Crab_Canal_Carapace || ti_paf_canal == Crab_Canal_Vulnerable_Devant || ti_paf_canal == Crab_Canal_Vulnerable_Derriere )
	{
		tv_caparace_paf = MATH_FloatMax(1.0, tf_puissance) * tv_paf_dir
		DBG_RenderVector(tv_paf_position, tv_caparace_paf, color_rouge)
		DBG_RenderVector(@o_bone_pere OBJ_PosGet(), tv_paf_position - @o_bone_pere OBJ_PosGet(), color_blanc)
		tv_caparace_paf += tv_paf_position - @o_bone_pere OBJ_PosGet()
		tv_caparace_paf_cumul +=  tv_caparace_paf		// pour avoir un minimum d'inclinaison même s'il y a 0 dmg
	}
	
	// TEST ZONE VULNERABLE
//	if( ( ti_paf_canal == Crab_Canal_Vulnerable_Devant && ( ACT_CustomBitTest(CBit_Vulnerable_Devant) || f_time_invulnerable <= Cf_time_min_invulnerable ) )
//	|| ( ti_paf_canal == Crab_Canal_Vulnerable_Derriere && ( ACT_CustomBitTest(CBit_Vulnerable_Derriere) || f_time_invulnerable <= Cf_time_min_invulnerable ) )
//	|| ( ti_shotgun && f_time_invulnerable <= Cf_time_min_invulnerable && MATH_VecDotProduct(OBJ_SightGet(), @to_pere OBJ_PosGet() - OBJ_PosGet()) > 0 ) )
	if( ( ti_paf_canal == Crab_Canal_Vulnerable_Devant && ( ACT_CustomBitTest(CBit_Vulnerable_Devant) || f_time_hyst_carapace <= Cf_time_hyst_carapace ) )
	|| ( ti_paf_canal == Crab_Canal_Vulnerable_Derriere && ( ACT_CustomBitTest(CBit_Vulnerable_Derriere) || f_time_hyst_carapace <= Cf_time_hyst_carapace ) )
	|| ( ti_shotgun && f_time_hyst_carapace <= Cf_time_hyst_carapace && MATH_VecDotProduct(OBJ_SightGet(), @to_pere OBJ_PosGet() - OBJ_PosGet()) > 0 ) )
	{
		// VULNERABLE (canal + anim ou délai) ou shotgun de devant et délai
		if( i_DBG_trace_paf )
			DBG_TraceString(" : PAF ZONE VULNERABLE !!! ")
		
		if( MSG_GlobalIsValid(mid_grab) )
		{
			// lacher le grab
			i_paf_grab_lache_flag = vrai
			ti_just_paf_grab_lache_flag = vrai
		}
		
		// JAVELOT RESTE PAS PLANTE SUR LES CRABES GEANTS
//		if( ti_paf_type & C_EVENT_PAF_Perforant && i_modele == MODELE_Geant)
//		{
//			to_tmp = EVENT_Gao2Get(tmid_paf_event)						// dans le cas d'un paf par lance, l'objet lance est stocké dans le gao2 du message correspondant
//			macro_set_javelin_plug_timer(to_tmp, 0.0)
//		}
			
		// ANIM SPECIALE PAF JAVELOT DANS BOUCHE
		if( ti_paf_type & C_EVENT_PAF_Perforant )
		{
			ti_lance_any = vrai
			ti_lance = vrai
		}
		
		if( to_pere == o_main_actor )
		{
			// MULTIPLICATEUR
			tf_puissance *= f_paf_dmg_multiplicateur
			if( i_DBG_display_paf )
			{
				tv_2D_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())
				
				Str_DisplayTextOnce("x ", tv_2D_pos + cvector(-0.17, -0.2, 0.0))
				Str_DisplayFloatOnce(f_paf_dmg_multiplicateur, tv_2D_pos + cvector(-0.15, -0.2, 0.0))
				Str_DisplayTextOnce(" !!!", tv_2D_pos + cvector(-0.10, -0.2, 0.0))
			}
		}
	}
	else
	{
		// PAS VULNERABLE
		tf_puissance -= MATH_FloatMin(tf_puissance, f_paf_dmg_reduction)

		// JAVELOT RESTE PLANTE UNIQUEMENT DANS LES ZONES SENSIBLES
		if( ti_paf_type & C_EVENT_PAF_Perforant)
		{
			to_tmp = EVENT_Gao2Get(tmid_paf_event)						// dans le cas d'un paf par lance, l'objet lance est stocké dans le gao2 du message correspondant
			macro_set_javelin_plug_timer(to_tmp, 0.0)
		}
	}
	
		
	// SPECIAL : PAF TUANT
	if( ti_paf_type & C_EVENT_PAF_Tuant )
	{
		tf_puissance = f_HP_cur
	}
	
	// NIVEAU DE PAF ET VITESSE DE RECUL
	if( ti_paf_type & C_EVENT_PAF_Repousse )
	{
		i_paf_repousse_flag = vrai
		tf_puissance = 0.0
		if( i_paf_grab_lache_flag )
			tv_speed = tv_paf_dir * f_paf_grab_lache_norm
		else
			tv_speed = tv_paf_dir * f_paf_repousse_norm
	}
	else if( i_modele == MODELE_Petit && tf_puissance >= f_paf_explose_dmg && ti_shotgun )
	{
		i_paf_explose_flag = vrai
		ti_tmp_paf_important_flag = vrai
		tv_speed = tv_paf_dir * f_paf_important_norm
	}
	else if( tf_puissance >= f_paf_important_dmg)
	{
		i_paf_important_flag = vrai
		ti_tmp_paf_important_flag = vrai
		tv_speed = tv_paf_dir * f_paf_important_norm
	}
	else if( tf_puissance >= f_paf_moyen_dmg)
	{
		i_paf_moyen_flag = vrai
		ti_tmp_paf_moyen_flag = vrai
		tv_speed = tv_paf_dir * f_paf_moyen_norm
	}
	else
	{
		i_paf_faible_flag = vrai
		ti_tmp_paf_faible_flag = vrai
		tv_speed = tv_paf_dir * f_paf_faible_norm
	}
	v_paf_dir += tv_speed
	
	// TRACE + DISPLAY
	if( i_DBG_display_paf )
	{
		tv_2D_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())
		Str_DisplayFloatOnce(tf_puissance, tv_2D_pos + cvector(-0.05, -0.2, 0.0))
	}
	
	if( i_DBG_trace_paf )
	{
		DBG_TraceString(" : ")
		DBG_TraceFloat(tf_puissance)
		DBG_TraceString(" dmg")
		DBG_TraceEOL()
	}
	
	// POINTS DE VIE ET VISION
	f_HP_cur -= MATH_FloatMin(f_HP_cur, tf_puissance)
	if( f_HP_cur && CR_Gao_in_BV(to_pere, o_territoire) )
	{
		if( ! CR_Perceived_Actor_Add(to_pere, tmid_vision_event) )
		{
			DBG_Error("l''event visibility de l'acteur n'est pas accesssible ???")
		}
	}
	
	// BEST PAF ???
	if( ! to_best_pere || to_pere == o_main_actor || (tf_puissance >= tf_best_puissance && to_pere != o_main_actor) )
	{
		// c le main actor ou alors le paf est + puissant et je n'ai pas encore choisi le main actor
		to_best_pere = to_pere
		tf_best_puissance = tf_puissance
	}
	
	// QUATERNION POUR CHAQUE PAF
	if( i_DGB_paf_quaternion && ( ti_paf_canal == Crab_Canal_Carapace || ti_paf_canal == Crab_Canal_Vulnerable_Devant || ti_paf_canal == Crab_Canal_Vulnerable_Derriere ) && TIME_Elapsed(f_quat_last_time, 0.15) )
	{
		if( i_modele == MODELE_Geant )
		{
			if (TIME_Elapsed(f_quat_last_time, 0.5))
				af_quat_coef[i_quat_index] = 0.18
			else
				af_quat_coef[i_quat_index] = 0.12
		}
		else
		{
			if (TIME_Elapsed(f_quat_last_time, 0.5))
			{
				if( ti_tmp_paf_moyen_flag || ti_tmp_paf_important_flag )
					af_quat_coef[i_quat_index] = 0.6
				else
					af_quat_coef[i_quat_index] = 0.25
			}
			else
				af_quat_coef[i_quat_index] = 0.20
		}
		
		f_quat_last_time = TIME_Get()
		af_quat_time[i_quat_index] = f_quat_last_time
		
		av_quat_start[i_quat_index] = EVENT_PafPositionGet(tmid_paf_event)
		av_quat_start[i_quat_index] -= @o_bone_carapace OBJ_PosGet()
		MATH_VecSetNormalize(av_quat_start[i_quat_index])
		
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(tv_paf_dir, av_quat_start[i_quat_index])
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(av_quat_start[i_quat_index], av_quat_end[i_quat_index])
		
		MATH_VecSetNormalize(av_quat_end[i_quat_index])
		
		i_quat_index = MATH_Modulo(i_quat_index + 1, 10)
	}
}


// ON NE MEMORISE QUE LE + FORT NIVEAU DE PAF
if( i_paf_explose_flag )
{
	i_paf_important_flag = faux
	i_paf_moyen_flag = faux
	i_paf_faible_flag = faux
}


// MORT DU PERSO
if( tf_HP_init && ! f_HP_cur )
{
	i_paf_important_flag = vrai
	if( i_modele == MODELE_Petit )
	{
		// PETIT CRABE > Lorsqu’on le tue, jouer l’anim paf qui ouvre + recul. Actuellement il meurt en 2 étapes, ce n’est pas clair qu’on l’a tué : il n’ y a pas de sentiment d’accomplissement.
		ti_lance_any = vrai
	}
}


if( i_paf_important_flag )
{
	i_paf_moyen_flag = faux
	i_paf_faible_flag = faux
	
	if( i_DBG_trace_paf )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : paf IMPORTANT !!!")
		DBG_TraceEOL()
	}
}

if( i_paf_moyen_flag )
{
	i_paf_faible_flag = faux
	
	if( i_DBG_trace_paf )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : paf moyen !!!")
		DBG_TraceEOL()
	}
}

// CUMUL DES PETIS PAFS ==========================================================
if( i_paf_faible_flag )
{
	CR_Paf_Cumul_Add(tf_puissance_init)

	if( CR_Paf_Cumul_Check_Cumul() )
	{
		i_paf_moyen_flag = vrai
		i_paf_faible_flag = faux

		if( i_DBG_trace_paf )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : paf cumul ************")
			DBG_TraceEOL()
		}
	}
	else if( i_DBG_trace_paf )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : paf faible")
		DBG_TraceEOL()
	}
}


// PAF ACTOR
o_paf_actor = to_best_pere

if( o_paf_actor && i_etat_courant != ETAT_MORT )
{
	// RECUL =======================================================================
	if( ! MATH_VecNullEpsilon(v_paf_dir) )		// peut etre null à cause d'un paf repousse
		MATH_VecSetNormalize(v_paf_dir)
	
	 if( i_paf_important_flag || i_paf_explose_flag )
		tf_recul_norm = f_paf_important_norm
	else if( i_paf_moyen_flag )
		tf_recul_norm = f_paf_moyen_norm
	else if( i_paf_faible_flag )
		tf_recul_norm = f_paf_faible_norm
	else if( i_paf_repousse_flag )
		tf_recul_norm = f_paf_repousse_norm
	else
		tf_recul_norm = 0.0
	
	 if( i_paf_grab_lache_flag )
	 	tf_recul_norm = MATH_FloatMax(tf_recul_norm, f_paf_grab_lache_norm)

	if( tf_recul_norm )
	{
		tf_paf_max_norm = tf_recul_norm
		if( i_paf_faible_flag )
			tf_paf_max_norm = MATH_FloatMin(tf_recul_norm, f_paf_dyn_cumul_max)		// borne les reculs de cumul de petits pafs
		
		v_paf_dyn_speed += (tf_recul_norm * v_paf_dir)
		tf_norm = MATH_VecNorm(v_paf_dyn_speed)
		if (tf_norm)
		{
			v_paf_dyn_speed /= tf_norm
			v_paf_dyn_speed *= MATH_FloatMin(tf_norm, tf_paf_max_norm)
		}

		v_paf_dyn_pos = OBJ_PosGet()
	}
}


// ROTATION CRABE
if( ti_j_ai_pris_un_paf )
{
	f_time_last_paf = 0.0
	if( i_modele == MODELE_Petit )
	{
		// pas pour un paf faible
		f_paf_rotation_coef = 0.0
		CR_Paf_Rotation_Add( OBJ_PosGet(), OBJ_SightGet(), tv_paf_position, v_paf_dir, f_paf_rotation_force)
	}
}

// INCLINAISON CARAPACE (POUR LE CUMUL DES PAFS)
if( ! i_DGB_paf_quaternion && ! MATH_VecNullEpsilon(tv_caparace_paf_cumul) )
{
	DBG_RenderVector(@o_bone_pere OBJ_PosGet(), tv_caparace_paf_cumul, color_vert)
	DBG_RenderVector(@o_bone_pere OBJ_PosGet(), @o_bone_pere MATH_VecLocalToGlobal(v_carapace_banking_initial), color_jaune)
	if( ti_shotgun_any )
		tf_angle_inclinaison = f_angle_inclinaison_max_shotgun
	else
		tf_angle_inclinaison = f_angle_inclinaison_max
	tv_caparace_paf_cumul = MATH_VecInCone(tv_caparace_paf_cumul, @o_bone_pere MATH_VecLocalToGlobal(v_carapace_banking_initial), tf_angle_inclinaison, 0)
	DBG_RenderVector(@o_bone_pere OBJ_PosGet(), tv_caparace_paf_cumul, color_vert)
	tv_caparace_paf_cumul = @o_bone_pere MATH_VecGlobalToLocal(tv_caparace_paf_cumul)
	DBG_RenderVector(@o_bone_pere OBJ_PosGet(), @o_bone_pere MATH_VecLocalToGlobal(v_carapace_banking_neutral), color_bleu)
	v_carapace_banking_neutral = tv_caparace_paf_cumul
}


// PETIT CRABE > Un tir au shotgun à bout portant dans la carapace doit le mettre en état vulnérable (yeux bouche visible), de sorte qu’on peut ensuite l’achever.
if( i_modele == MODELE_Petit && ti_shotgun_any )
{
	ti_lance_any = vrai
}

// ANIM PAF LANCE
if( ti_lance_any )
{
	// paf lance dans tête ou dernier paf
	i_paf_lance_flag = vrai					// remis à faux à chaque test de paf
	i_paf_lance_backup_flag = vrai		// backup
}

//f_HP_cur = f_HP_max

