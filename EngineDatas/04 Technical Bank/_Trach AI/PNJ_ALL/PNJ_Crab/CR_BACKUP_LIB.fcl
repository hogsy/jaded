
//===================================================================================
// Multiplie le coef de rotation
//===================================================================================
//procedure_local void CR_Rotation_Coef_Multiply(float tf_mult)
//{
//	f_way_rotation_coef *= tf_mult
//}
//


//===================================================================================
// Retourne vrai si le crabe est en collision avec un mur en avançant tout droit
//===================================================================================
//procedure_local int CR_Collide_Wall_Avance()
//{
//	object		to_gao
//	vector 		tv_normale
//	float			tf_dot
//	
//	if( COL_CollideType(COL_C_Wall) )
//	{
//		to_gao = COL_ObjectGet(COL_C_Wall)
//		if( ! @to_gao OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) )
//		{
//			tv_normale = COL_NormalGet(COL_C_Wall)
//			DBG_RenderVector(OBJ_PosGet() - tv_normale, tv_normale, color_rouge)
//			tf_dot = MATH_VecDotProduct(OBJ_SightGet(), tv_normale)
//			if( tf_dot < - Cf_Cos30 )
//				return vrai
//		}
//	}
//	return faux
//}


//===================================================================================
// Retourne vrai si le crabe est en collision avec un mur en avançant en strafe
//===================================================================================
//procedure_local int CR_Collide_Wall_Strafe()
//{
//	object		to_gao
//	vector 		tv_normale
//	vector		tv_horizon
//	float			tf_dot
//	
//	if( COL_CollideType(COL_C_Wall) )
//	{
//		to_gao = COL_ObjectGet(COL_C_Wall)
//		if( ! @to_gao OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) )
//		{
//			tv_normale = COL_NormalGet(COL_C_Wall)
//			DBG_RenderVector(OBJ_PosGet() - tv_normale, tv_normale, color_rouge)
//			tv_horizon = OBJ_HorizonGet()
//			if( MATH_VecDotProduct(tv_horizon, tv_normale) > 0 )
//				tv_horizon *= -1
//			tv_horizon.z = 0.0
//			if( ! MATH_VecNullEpsilon(tv_horizon) )
//				MATH_VecSetNormalize(tv_horizon)
//			tf_dot = MATH_VecDotProduct(tv_horizon, tv_normale)
//			if( tf_dot < - Cf_Cos45 )
//			{
//				f_way_strafe_delay = MATH_RandFloat(f_way_strafe_delay_min, f_way_strafe_delay_max)			// ne pas repartir en strafe après avoir touché un mur en strafe
//				return vrai
//			}
//		}
//	}
//	return faux
//}


//===================================================================================
// Retourne vrai si le crabe est autorisé à passer / rester en strafe, faux sinon
//===================================================================================
//procedure_local int CR_Strafe_Allowed()
//{
//	if( i_strafe_requin_force_flag || ( ! CR_Strafe_En_Cours() && ! f_way_strafe_delay ) || ( CR_Strafe_En_Cours() && f_way_strafe_duration ) )
//	{
//		i_strafe_requin_force_flag = faux	//	(après un paf ou un paf pendant grab)
//		return vrai
//	}
//	else
//		return faux
//}


//===================================================================================
// Impose un délai pour pouvoir strafer de nouveau
//===================================================================================
//procedure_local void CR_Strafe_Delay_Random()
//{
//	f_way_strafe_delay = MATH_RandFloat(f_way_strafe_delay_min, f_way_strafe_delay_max)
//}


//===================================================================================
// Resete le délai pour pouvoir strafer de nouveau
//===================================================================================
//procedure_local void CR_Strafe_Delay_Reset()
//{
//	f_way_strafe_delay = 0.0
//}


//===================================================================================
// Impose un délai pour pouvoir strafer de nouveau
//===================================================================================
//procedure_local void CR_Strafe_Duration_Random()
//{
//	f_way_strafe_duration = MATH_RandFloat(f_way_strafe_duration_min, f_way_strafe_duration_max)
//}


//===================================================================================
// Impose un délai pour pouvoir strafer de nouveau
//===================================================================================
//procedure_local void CR_Strafe_Duration_Reset()
//{
//	f_way_strafe_duration = 0.0
//}


//===================================================================================
// Termine le mouvement de strafe et ajoute un délai avant de pouvoir refaire un strafe
//===================================================================================
//procedure_local void CR_Strafe_End_And_Delay()
//{
//	f_way_strafe_duration = 0.0
//	CR_Strafe_Delay_Random()
//}


//===================================================================================
// Termine le mouvement de strafe
//===================================================================================
//procedure_local void CR_Strafe_End_No_Delay()
//{
//	f_way_strafe_duration = 0.0
//	CR_Strafe_Delay_Reset()
//}


//===================================================================================
// Initialise le mouvement de strafe (sans durée min)
//===================================================================================
//procedure_local void CR_Strafe_Begin_No_Duration(float tf_cote)
//{
//	CR_Strafe_Duration_Reset()
//	CR_Strafe_Begin(tf_cote)
//}

//===================================================================================
// Initialise le mouvement de strafe (sans durée min)
//===================================================================================
//procedure_local void CR_Strafe_Begin_With_Duration(float tf_cote)
//{
//	CR_Strafe_Duration_Random()
//	CR_Strafe_Begin(tf_cote)
//}


//================================================================================================
// Calcule la normale de l'obstacle par LRAY, Cv_NullVector si aucun LRAY ne touche
// Retourne vrai si 1 LRAY touche, faux sinon
//================================================================================================
//procedure_local int CR_Way_Get_Normale(vector tv_lray_pos, vector tv_lray_sight, byref vector tv_normale)
//{
//	float				tf_decal_length
//	int					ti_i
//	float				tf_decal
//	int					ti_lray_done
//	object			to_ray_object
//	vector			tv_lray_decal_axis
//	
//	tv_normale = Cv_NullVector
//	ti_lray_done = faux
//	
//	// TEST LRAY POUR RECUPERER LA NORMALE
//	if( CR_Strafe_En_Cours() )
//		tv_lray_decal_axis = OBJ_SightGet()			// strafe : tests multiples sur l'axe du sight
//	else
//		tv_lray_decal_axis = OBJ_HorizonGet()		// avance : tests multiples sur l'axe de l'horizon
//	tv_lray_decal_axis.z = 0.0
//	if( ! MATH_VecNullEpsilon(tv_lray_decal_axis) )
//		MATH_VecSetNormalize(tv_lray_decal_axis)
//
//	for( ti_i = 0; ti_i < 9; ti_i++)
//	{
//		if( ti_lray_done )
//			break
//		
//		switch( ti_i )
//		{
//			case 0 :
//				tf_decal = 0.0
//				tf_decal_length = 0.0
//				break
//			case 1 :
//				tf_decal = 1.0
//				tf_decal_length = 1.0
//				break
//			case 2 :
//				tf_decal = -1.0
//				tf_decal_length = 1.0
//				break
//			case 3 :
//				tf_decal = 1.0
//				tf_decal_length = 2.0
//				break
//			case 4 :
//				tf_decal = -1.0
//				tf_decal_length = 2.0
//				break
//			case 5 :
//				tf_decal = 1.0
//				tf_decal_length = 3.0
//				break
//			case 6 :
//				tf_decal = -1.0
//				tf_decal_length = 3.0
//				break
//			case 7 :
//				tf_decal = 1.0
//				tf_decal_length = 4.0
//				break
//			case 8 :
//				tf_decal = -1.0
//				tf_decal_length = 4.0
//				break
//		}
//		
//		if( i_modele == MODELE_Petit )
//			tf_decal_length *= 0.5		// espaces de 0.5m et pas de 1m pour les petits
//		
//		// j'ai de grandes chances que l'obstacle soit un angle, donc si je suis en strafe, je vais décaler mon LRAY pour m'assurer qu'il touche bien l'obstacle, sinon il va passer à côté
//		tv_lray_pos += tf_decal * tv_lray_decal_axis * tf_decal_length
//		DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//		to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//		if( to_ray_object )
//		{
//			tv_normale = COL_RayObject_NormalGet()
////			DBG_RenderVector(tv_lray_pos, tv_normale, color_bleu)
//			ti_lray_done = vrai
//		}
//	}
//	
//	return ti_lray_done
//}


//================================================================================================
// Initialise la position et la distance à l'obstacle
//================================================================================================
//procedure_local void CR_Way_Get_Obstacle()
//{
//	vector			tv_lray_pos
//	vector			tv_lray_sight
//	
//	v_way_obstacle_pos = @get_global v_grid_lib_last_blocked_pos
//	DBG_RenderVector(v_way_obstacle_pos, Cv_VerticalVector * 10, color_rouge)
//	v_way_obstacle_dir = v_way_obstacle_pos - OBJ_PosGet()
//	v_way_obstacle_dir.z = 0.0
//	v_way_obstacle_dir_N = v_way_obstacle_dir
//	if( ! MATH_VecNullEpsilon(v_way_obstacle_dir_N) )
//		MATH_VecSetNormalize(v_way_obstacle_dir_N)
//	f_way_obstacle_dist = MATH_VecNorm(v_way_obstacle_dir)
//	
//	tv_lray_sight = ( f_way_obstacle_dist + 5.0 ) * v_way_obstacle_dir_N		// LRAY 2 m + loin pour bien rentrer dans le mur
//	tv_lray_pos = OBJ_PosGet() + Cv_VerticalVector
//	if( ! CR_Way_Get_Normale(tv_lray_pos, tv_lray_sight, v_way_obstacle_normale) )
//	{
////		DBG_Error("Impossible de trouver la normale par LRAY (afficher les vecteurs SVP)")
////		v_way_obstacle_normale = - OBJ_SightGet()		// le moins pire !!!!
//		v_way_obstacle_normale = - v_way_obstacle_dir 	// le moins pire !!!!
//	}
//	
//	DBG_RenderVector(v_way_obstacle_pos, v_way_obstacle_normale * 5.0, color_bleu)
//}


////================================================================================================
//// Initialise la position et la distance à l'obstacle
////================================================================================================
//procedure_local void CR_Way_Get_Obstacle()
//{
//	vector			tv_lray_pos
//	vector			tv_lray_sight
//	object			to_ray_object
//	int					tf_decal
//	int					ti_lray_done
//	int					ti_i
//	vector			tv_lray_decal_axis
//	float				tf_decal_length
//	
//	v_way_obstacle_pos = @get_global v_grid_lib_last_blocked_pos
//	DBG_RenderVector(v_way_obstacle_pos, Cv_VerticalVector * 10, color_rouge)
//	v_way_obstacle_dir = v_way_obstacle_pos - OBJ_PosGet()
//	v_way_obstacle_dir.z = 0.0
//	v_way_obstacle_dir_N = MATH_VecNormalize(v_way_obstacle_dir)
//	f_way_obstacle_dist = MATH_VecNorm(v_way_obstacle_dir)
//	
//	// TEST LRAY POUR RECUPERER LA NORMALE
//	if( CR_Strafe_En_Cours() )
//		tv_lray_decal_axis = OBJ_SightGet()			// strafe : tests multiples sur l'axe du sight
//	else
//		tv_lray_decal_axis = OBJ_HorizonGet()		// avance : tests multiples sur l'axe de l'horizon
//	MATH_VecSetHorzNormalize(tv_lray_decal_axis)
//	ti_lray_done = faux
//	
//	v_way_obstacle_normale = Cv_NullVector
//	
//	for( ti_i = 0; ti_i < 9; ti_i++)
//	{
//		if( ti_lray_done )
//			break
//		
//		switch( ti_i )
//		{
//			case 0 :
//				tf_decal = 0.0
//				tf_decal_length = 0.0
//				break
//			case 1 :
//				tf_decal = 1.0
//				tf_decal_length = 1.0
//				break
//			case 2 :
//				tf_decal = -1.0
//				tf_decal_length = 1.0
//				break
//			case 3 :
//				tf_decal = 1.0
//				tf_decal_length = 2.0
//				break
//			case 4 :
//				tf_decal = -1.0
//				tf_decal_length = 2.0
//				break
//			case 5 :
//				tf_decal = 1.0
//				tf_decal_length = 3.0
//				break
//			case 6 :
//				tf_decal = -1.0
//				tf_decal_length = 3.0
//				break
//			case 7 :
//				tf_decal = 1.0
//				tf_decal_length = 4.0
//				break
//			case 8 :
//				tf_decal = -1.0
//				tf_decal_length = 4.0
//				break
//		}
//		
//		if( i_modele == MODELE_Petit )
//			tf_decal_length *= 0.5		// espaces de 0.5m et pas de 1m pour les petits
//		
//		tv_lray_sight = ( f_way_obstacle_dist + 5.0 ) * v_way_obstacle_dir_N		// LRAY 2 m + loin pour bien rentrer dans le mur
//		tv_lray_pos = OBJ_PosGet() + Cv_VerticalVector
//		// j'ai de grandes chances que l'obstacle soit un angle, donc si je suis en strafe, je vais décaler mon LRAY pour m'assurer qu'il touche bien l'obstacle, sinon il va passer à côté
//		tv_lray_pos += tf_decal * tv_lray_decal_axis * tf_decal_length
//		DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//		to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//		if( to_ray_object )
//		{
//			v_way_obstacle_normale = COL_RayObject_NormalGet()
//			DBG_RenderVector(tv_lray_pos, v_way_obstacle_pos - tv_lray_pos, color_vert)
//			ti_lray_done = vrai
//		}
//	}
//	
//	if( ! ti_lray_done )
//	{
//		DBG_Error("Impossible de trouver la normale par LRAY (afficher les vecteurs SVP)")
//		v_way_obstacle_normale = - OBJ_SightGet()		// le moins pire !!!!
//	}
//}


//=================================================================================================
// Retourne vrai s'il n'y a pas d'obstacle dans le sens indiqué (sur la grille)
//=================================================================================================
//procedure_local int CR_Way_Grid_Check_Dir(vector tv_sens, float tf_strafe_cote_test)
//{
//	vector		tv_pos_debut
//	vector		tv_pos_fin
//	vector		tv_offset_init_pos
//	int				ti_width
//	float			tf_length
//
//	if( ! MATH_VecNullEpsilon(tv_sens) )
//		MATH_VecSetNormalize(tv_sens)
//	
//	if( tf_strafe_cote_test == 0.0 )
//	{
//		// je teste devant moi
//		tv_pos_debut = OBJ_PosGet() + MATH_VecLocalToGlobal(v_way_grid_avance_offset)
//		tv_pos_fin = tv_pos_debut + (f_way_grid_avance_length * tv_sens)
//		tf_length = f_way_grid_avance_length
//		if( i_way_obstacle_strafe_flag )
//			ti_width = i_way_grid_avance_width_obstacle
//		else
//			ti_width = i_way_grid_avance_width
//	}
//	else
//	{
//		// je teste sur le côté
//		tv_offset_init_pos = v_way_grid_strafe_offset
//		if( tf_strafe_cote_test == -1.0 )
//			tv_offset_init_pos.x *= - 1.0
//		tv_pos_debut = OBJ_PosGet() + MATH_VecLocalToGlobal(tv_offset_init_pos)
//		tv_pos_fin = tv_pos_debut + (f_way_grid_strafe_length * tv_sens)
//		tf_length = f_way_grid_strafe_length
//		if( i_way_obstacle_strafe_flag )
//			ti_width = i_way_grid_strafe_width_obstacle
//		else
//			ti_width = i_way_grid_strafe_width
//	}
//	DBG_RenderVector(tv_pos_debut, Cv_VerticalVector * 5, color_blanc)
//	DBG_RenderVector(tv_pos_fin, Cv_VerticalVector * 5, color_blanc)
//	if( GRID_LIB_IsReachableFrom(tv_pos_debut, tv_pos_fin, 0b0, tf_length, i_DGB_render_grille_check, ti_width) )
//		return vrai
//	else
//		return faux
//}


//=========================================================================================
// Retourne le côté choisi pour strafer (G=+1.0 / D=-1.0)
//=========================================================================================
//procedure_local int CR_Strafe_Cote_Select(float tf_dot_Horiz_moveAxis, vector tv_gauche, byref float tf_way_strafe_sens_pref)
//{
//	float			tf_test_cote
//	int				ti_width
//	
//	tf_test_cote = MATH_FloatSign(tf_dot_Horiz_moveAxis)
//	if( CR_Way_Grid_Check_Dir(tf_test_cote * tv_gauche, tf_test_cote) )
//	{
//		// PAS D'OBSTACLE DU COTE DE LA CIBLE
//		tf_way_strafe_sens_pref = tf_test_cote
//		return vrai
//	}
//	else if( CR_Way_Grid_Check_Dir( - tf_test_cote * tv_gauche, - tf_test_cote) )
//	{
//		// PAS D'OBSTACLE DE L'AUTRE COTE
//		tf_way_strafe_sens_pref = - tf_test_cote
//		return vrai
//	}
//	else
//	{
//		// OBSTACLE DEVANT ET DES DEUX COTES
////		DBG_Error("Obstacles Devant moi et des 2 côtés !!!! demi-tour dans un cul-de-sac pas encore implémenté !!! (1)")
////		return MATH_FloatSign(MATH_RandFloat(-1.0, 1.0))
//		tf_way_strafe_sens_pref = 0.0
//		return faux
//	}
//}


//===================================================================================
// Initialise le mouvement de strafe (sans durée min)
//===================================================================================
//procedure_local void CR_Strafe_Attack_Begin_No_Duration(float tf_cote)
//{
//	CR_Strafe_Attack_Face_Duration_Reset()
//	CR_Strafe_Begin(tf_cote)
//}

//===================================================================================
// Initialise le mouvement de strafe (sans durée min)
//===================================================================================
//procedure_local void CR_Strafe_Attack_Begin_With_Duration(float tf_cote)
//{
//	CR_Strafe_Attack_Face_Duration_Random()
//	CR_Strafe_Begin(tf_cote)
//}


//================================================================================================
// Retourne le cosinus du test devant/côté/derrière
//================================================================================================
//procedure_local float CR_Way_Strafe_Cosinus_Get()
//{
//	if( i_way_obstacle_strafe_flag )
//	{
//		// en train de contourner un obstacle : cos comme si la cible était de côté
//		return f_way_cos_attack_strafe
//	}
//	else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face )
//	{
//		// petit crabe trop loin, j'attaque comme si ma cible était sur le côté
//		if( f_attack_strafe_face_duration )
//			return 0.0
//		else
//			return 1.0		// retour en mode normal
//	}
//	else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face_retour )
//	{
//		return 1.0		// retour en mode normal
//	}
//	else if( i_way_mode_strafe == Ci_way_mode_strafe_aucun_ou_requin )
//	{
//		// la cible est devant
//		return f_way_cos_attack_strafe
//	}
//	else
//	{
//		// la cible est sur le côté
//		return f_way_cos_strafe_exit
//	}
//}


////====================================================================
//// Calcul de la rotation ajoutée due au paf
////====================================================================
//procedure_local void CR_Paf_Rotation_Add( vector tv_axe_pos, vector tv_axe_sight, vector tv_paf_position, vector tv_paf_sens, byref float tf_add_rotation)
//{
//	float			tf_angle
//	float			tf_proj
//	float			tf_coef
//	vector		tv_pt_impact
//	vector		tv_norm
//	
//	if( i_modele == MODELE_Geant || MATH_VecNullEpsilon(tv_paf_position) )
//		tf_add_rotation = 0.0
//	else
//	{
//		// point d'impact spécifié -> on peut calculer la rotation
//		tf_proj = MATH_VecDotProduct( tv_paf_position - tv_axe_pos, tv_axe_sight)
//		tv_pt_impact = OBJ_PosGet() + (tf_proj * tv_axe_sight)
//		DBG_RenderVector(tv_pt_impact, Cv_VerticalVector, color_jaune)
//		
//		tv_norm = MATH_VecCrossProduct(tv_axe_sight, Cv_VerticalVector)
//		if( ! MATH_VecNullEpsilon(tv_norm) )
//			MATH_VecSetNormalize(tv_norm)
//		DBG_RenderVector(OBJ_PosGet(), tv_norm, color_bleu)
//		DBG_RenderVector(tv_paf_position, tv_paf_sens, color_blanc)
//		tf_angle = - MATH_VecDotProduct( tv_norm, tv_paf_sens )
//		if( MATH_VecDotProduct( tv_pt_impact - tv_axe_pos, tv_axe_sight ) < 0 )
//			tf_angle *= -1		// dans le dos -> sens trigo inversé
//		tf_add_rotation = tf_angle
//		
//		// Rotation diminuée pour les crabes géants
////		if( i_paf_important_flag )
////			tf_coef = 1.0
////		else if( i_paf_moyen_flag )
////			tf_coef = 0.8
////		else if( i_paf_faible_flag )
////			tf_coef = 0.6
////		else
////			tf_coef = 0.0
////		tf_add_rotation *= tf_coef
//	}
//}


////====================================================================
//// Calcul de la rotation ajoutée due au paf
////====================================================================
//procedure_local void CR_Paf_Rotation_Add( vector tv_inertie_pos, vector tv_axe_sight, vector tv_paf_position, vector tv_paf_sens, byref float tf_add_rotation)
//{
//	vector			tv_point_dimpact
//	float				tf_sens_modif
//	float				tf_sens_paf
//	vector			tv_axe_horizon
//	float				tf_proj
//	
//	if( MATH_VecNullEpsilon(tv_paf_position) )
//		tf_add_rotation = 0.0
//	else
//	{
//		// Calcul du sens de la rotation -----------------------------------------
//		tv_point_dimpact = tv_paf_position - tv_inertie_pos
//		tv_axe_horizon = MATH_VecCrossProduct(Cv_VerticalVector, tv_axe_sight)
//		tf_sens_paf = - MATH_FloatSign(MATH_VecDotProduct(tv_axe_horizon, tv_paf_sens))
//		if( MATH_VecDotProduct(tv_axe_horizon, tv_point_dimpact) > 0 )
//			tf_sens_modif = 1.0			// à gauche : paf sens trigo.
//		else
//			tf_sens_modif = -1.0			// à droite : paf sens inv. trigo.
////		if( MATH_VecDotProduct(tv_axe_sight, tv_paf_sens) > 0 )
////			tf_sens_modif *= -1.0			// sens inversé
//		
//		// Calcul de la puissance de la rotation -----------------------------------------
//		tf_proj = MATH_VecDotProduct(tv_point_dimpact, tv_axe_sight)
//		
//		// Rotation
//		tf_add_rotation = tf_sens_paf * tf_sens_modif * tf_proj
//	}
//}


////====================================================================
//// Calcul de la rotation ajoutée due au paf
////====================================================================
//procedure_local void CR_Paf_Rotation_Add( vector tv_inertie_pos, vector tv_axe_sight, vector tv_paf_position, vector tv_paf_sens, byref float tf_add_rotation)
//{
//	vector			tv_point_dimpact
//	float				tf_sens_rot
//	float				tf_horiz_paf
//	vector			tv_axe_horizon
//	float				tf_proj
//	int					ti_paf_devant
//	int					ti_paf_a_gauche
//	int					ti_paf_oppose_sight
//	
//	if( MATH_VecNullEpsilon(tv_paf_position) )
//		tf_add_rotation = 0.0
//	else
//	{
//		// Calcul du sens de la rotation -----------------------------------------
//		tv_point_dimpact = tv_paf_position - tv_inertie_pos
//		tv_axe_horizon = MATH_VecCrossProduct(Cv_VerticalVector, tv_axe_sight)
//		
//		tf_horiz_paf = MATH_FloatSign(MATH_VecDotProduct(tv_axe_horizon, tv_paf_sens))
//		
//		// test paf devant / derrière
//		if( MATH_VecDotProduct(tv_axe_sight, tv_point_dimpact) > 0 )
//			ti_paf_devant = vrai
//		else
//			ti_paf_devant = faux
//		
//		// test paf sur la G/D
//		if( MATH_VecDotProduct(tv_axe_horizon, tv_point_dimpact) > 0 )
//			ti_paf_a_gauche = vrai
//		else
//			ti_paf_a_gauche = faux
//		
//		// test sens du paf dans le sens de mon sight ou pas
//		if( MATH_VecDotProduct(tv_axe_sight, tv_paf_sens) < 0 )
//			ti_paf_oppose_sight = vrai
//		else
//			ti_paf_oppose_sight = faux
//		
////		if( ti_paf_devant )
////		{
//			if( ti_paf_a_gauche )
//			{
//				if( ti_paf_oppose_sight )
//					tf_sens_rot = 1.0
//				else
//					tf_sens_rot = -1.0
//			}
//			else
//			{
//				if( ti_paf_oppose_sight )
//					tf_sens_rot = -1.0
//				else
//					tf_sens_rot = 1.0
//			}
////		}
////		else
////		{
////			if( ti_paf_a_gauche )
////			{
////				if( ti_paf_oppose_sight )
////					tf_sens_rot = 1.0
////				else
////					tf_sens_rot = -1.0
////			}
////			else
////			{
////				if( ti_paf_oppose_sight )
////					tf_sens_rot = -1.0
////				else
////					tf_sens_rot = 1.0
////			}
////		}
//
//		// Calcul de la puissance de la rotation -----------------------------------------
//		tf_proj = MATH_AbsFloat(MATH_VecDotProduct(tv_point_dimpact, tv_axe_sight))
//		
//		// Rotation
////		tf_horiz_paf = 1.0
//		tf_sens_rot = 1.0
//		if( ! ti_paf_devant )
//			tf_horiz_paf *= -1.0
//		tf_add_rotation = tf_sens_rot * tf_horiz_paf * tf_proj
//	}
//}


//=============================================================================================
// Choix de l'action en réaction à un paf
//=============================================================================================
//procedure_local void CR_Paf_Select_Action()
//{
//	if( i_etat_courant == ETAT_MORT )
//		ACT_ActionSet(ACTION_Paf_Mort | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero)
//	else if( i_paf_lance_flag )
//		ACT_ActionSet(ACTION_Paf_Lance_deb | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero)
//	else if( i_paf_important_flag )
//		ACT_ActionSet(ACTION_Paf_Important | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero)
//	else if( i_paf_moyen_flag )
//		ACT_ActionSet(ACTION_Paf_Moyen | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero)
//}



//================================================================================================
// Retourne le cosinus du test devant/côté/derrière BACKUP AVANT ANIMS 45° !!!!!
//================================================================================================
//procedure_local float CR_Way_Strafe_Cosinus_Get()
//{
//	if( f_time_force_requin || i_positionnement_force_requin || i_way_mode_strafe == Ci_way_mode_strafe_aucun_ou_requin )
//	{
//		// la cible est devant
//		return f_way_cos_attack_strafe
//	}
//	else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face_debut )
//	{
//		return 0.0		// force la cible de côté
//	}
//	else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face )
//	{
//		// petit crabe trop loin, j'attaque comme si ma cible était sur le côté
//		if( f_attack_strafe_face_duration )
//			return 0.0	// force la cible de côté
//		else
//			return 1.0	// temps d'attaque strafe écoulé OU crabe trop proche : se retourne : force la cible de face
//	}
//	else if( i_way_mode_strafe == Ci_way_mode_strafe_attack_face_retour )
//	{
//		return 1.0		// force la cible de face
//	}
//	else
//	{
//		// la cible est sur le côté
//		// Ci_way_mode_strafe_attack_cote
//		// Ci_way_mode_strafe_attack_cote_tourne
//		return f_way_cos_strafe_exit
//	}
//}
//

