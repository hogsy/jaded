#include "CR_defines.var"

vector			tv_ground_normale
vector			tv_ground_normale_perfect
vector			tv_speed
vector			tv_pos
vector			tv_2D_pos
vector			tv_me_to_dest
vector			tv_temp

float				tf_liferatio
float				tf_snd_dist
float				tf_cos_strafe
float				tf_normale_blend_coef

int					ti_ani_mode
int					ti_color
int					ti_get_normale

if( ! f_HP_cur && CR_Human_Attack_Find(OBJ_Me()) )
	CR_Human_Attack_Del(OBJ_Me())

i_zone_restreinte_flag = faux

f_LD_time_attack_forbidden -= MATH_FloatMin(f_LD_time_attack_forbidden, TIME_GetDt())
f_grab_mange_paf_delay -= MATH_FloatMin(f_grab_mange_paf_delay, TIME_GetDt())

// SOUND ==============================================
if( ! CR_SND_Move_Enabled() )
{
	CR_SND_Move_Stop()
}
else
{
	if( i_modele == MODELE_Geant )
		tf_snd_dist = 30
	else
		tf_snd_dist = 20
	tf_snd_dist *= tf_snd_dist
	if( OBJ_SqrDist(o_main_actor) < tf_snd_dist )
		CR_SND_Move_Play()
	else
		CR_SND_Move_Stop()
}


// FACE DE MORT ========================================
if( CR_Face_De_Mort() )
	OBJ_Destroy()


// DELAIS ========================================================================
f_attack_delay -= MATH_FloatMin(f_attack_delay, TIME_GetDt())									// délai pour porter une attaque
f_way_strafe_delay -= MATH_FloatMin(f_way_strafe_delay, TIME_GetDt())						// délai pour passer en strafe
f_way_strafe_duration -= MATH_FloatMin(f_way_strafe_duration, TIME_GetDt())					// délai pour passer en strafe
f_intimidation_delay -= MATH_FloatMin(f_intimidation_delay, TIME_GetDt())						// délai faire une intimidation pendant un déplacement
f_delay_blood_gen -= MATH_FloatMin(f_delay_blood_gen, TIME_GetDt())							// délai pour générer une odeur de sang
f_time_grab_no_coll_paf -= MATH_FloatMin(f_time_grab_no_coll_paf , TIME_GetDt())			// délai pour ne pas paffer en collision mon ancien grab actor
f_time_force_requin -= MATH_FloatMin(f_time_force_requin, TIME_GetDt())						// délai pour forcer à se déplacer
f_delay_change_target -= MATH_FloatMin(f_delay_change_target, TIME_GetDt())				// délai pour changer de cible
f_time_last_paf += TIME_GetDt()																				// durée écoulée depuis le dernier paf
if( MSG_GlobalIsValid(mid_grab) && i_modele == MODELE_Petit && ( i_etat_courant == ETAT_TRAINE || i_etat_courant == ETAT_MANGE) )
	f_grab_traine_duration += TIME_GetDt()
else
	f_grab_traine_duration = 0.0
f_fight_end_countdown -= MATH_FloatMin(f_fight_end_countdown, TIME_GetDt())				// hystérésis fin d'attaque


// ATTAQUE STRAFE DE FACE
f_attack_strafe_face_delay -= MATH_FloatMin(f_attack_strafe_face_delay, TIME_GetDt())	// délai pour une attaque strafe de face
f_attack_strafe_face_duration -= MATH_FloatMin(f_attack_strafe_face_duration, TIME_GetDt())	// durée pour une attaque strafe de face

// STRAFE REQUIN
f_strafe_requin_delay -= MATH_FloatMin(f_strafe_requin_delay, TIME_GetDt())					// délai pour un strafe requin
f_strafe_requin_duration -= MATH_FloatMin(f_strafe_requin_duration, TIME_GetDt())			// durée pour un strafe requin


//// délai pendant lequel le crabe ne repartira pas en strafe du côté duquel il vient après avori strafé pour éviter un obstacle
//if( ACT_ActionGet() != ACTION_Intimidation )
//{
//	f_way_last_obstacle_time += TIME_GetDt()
//}


// COLLISION HUMAINS =============================================================
CR_Paffed_Actor_Check_Time()

// CUMUL DES PETIS PAFS ==========================================================
CR_Paf_Cumul_Check_Time()

// UNCOL BUDDIES =========================================
//for( ti_i = 0; ti_i < i_budy_nb; ti_i++)
//{
//	if( ARR_ObjSearch(&ao_uncol_budy[0], i_uncol_budy_nb, ao_budy[ti_i]) == -1 )
//	{
//		COL_UnCollidableAdd(ao_budy[ti_i])
//		ao_uncol_budy[i_uncol_budy_nb] = ao_budy[ti_i]
//		i_uncol_budy_nb++
//	}
//}

// ANALYSE ======================================================================
i_paf_check_flag = faux
i_paf_main_actor_flag = faux
i_vision_check_flag = faux
i_budy_nb = 0
i_perceived_actor_nb = 0

// SCREEN VISIBILITY ===============================================================
if (f_on_screen_pourcent > 0.5)
	f_on_screen_duration += TIME_GetDt()
else
	f_on_screen_duration = 0.0

// DYNAMIQUE ====================================================================
if (OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna))
{
	// RECUL DES PAFS --------------------------------------------------------------------------------------------
	if( f_paf_dyn_speed > f_paf_dyn_min_norm )
	{
		// interdire les reculs de titan
//		tf_recul_max = 2.5 * f_zoom
//		MATH_VecSetNorm(v_paf_dyn_speed, MATH_FloatMin(tf_recul_max, MATH_VecNorm(v_paf_dyn_speed)))
		// calcul position
		v_paf_dyn_pos = DYN_LIB_Position_After_N_Seconds(v_paf_dyn_pos, v_paf_dyn_speed, cvector(f_paf_dyn_friction, f_paf_dyn_friction, 0.0), DYN_GravityVectorGet(), TIME_GetDt(), 0.0)
		v_paf_dyn_speed.z = 0.0
		DBG_RenderVector(v_paf_dyn_pos, v_paf_dyn_speed, color_jaune)
	}
	
	DYN_FlagsSet(DYN_C_OptimizeColDisable, none)
	DYN_TractionSet(Cv_NullVector)		// SOFT COLL
	
	// GROUND NORMALE --------------------------------------------------------------------------------------------
	switch( i_etat_courant )
	{
		case ETAT_MORT : 
			if( f_mort_delai_depuis_dernier_paf < 0.5 )
				ti_get_normale = vrai
			else
				ti_get_normale = faux
			break
			
		case ETAT_GRAB :
			if( f_time_start_etat < 0.5 )
				ti_get_normale = vrai
			else
				ti_get_normale = faux
			break
			
		default:
			ti_get_normale = vrai
			break
	}
	if( ti_get_normale )
	{
		// ne pas rechecker la normale du sol en mort (sauf si paf) ou en grab (pour ne pas trembler)
		tv_ground_normale = Cv_NullVector
		tv_ground_normale_perfect = Cv_NullVector
		if (COL_CollideType(COL_C_Ground))
		{
			f_delay_until_last_ground_col = 0.0
	
			tv_ground_normale = COL_NormalGet(COL_C_Ground)
			
			if( i_DBG_render_ground_normale )
				DBG_RenderVector(COL_CollidedPointGet(COL_C_Ground), tv_ground_normale * 2.0 * f_zoom, color_blanc)
			
			if( ! MATH_VecNullEpsilon(tv_ground_normale) )
				MATH_VecSetNormalize(tv_ground_normale)
			
			if (tv_ground_normale.z < 0.0)
				tv_ground_normale*= -1.0
				
			ti_color = color_bleu
		}
		else
		{
			if( f_delay_until_last_ground_col > 3.0 )
				OBJ_Destroy()
			
			f_delay_until_last_ground_col += TIME_GetDt()
			
			if (f_delay_until_last_ground_col > 0.2)
				tv_ground_normale = Cv_VerticalVector
			
			ti_color = color_rouge
		}
	
		ti_ani_mode = ANI_ModeGet(0)
		switch( ti_ani_mode )
		{
			case ani_mode3 :	// speed from dyna
				break
			
			default:		// speed from anim....
				tv_speed = DYN_SpeedGetVector()
				tv_speed.z = MATH_FloatMin(tv_speed.z, 0.0)
				DYN_SpeedSetVector(tv_speed)
		}
		
		if( ! MATH_VecNullEpsilon(tv_ground_normale) )
		{
			tv_ground_normale_perfect = tv_ground_normale
			v_ground_normale_old = tv_ground_normale
			if( i_modele == MODELE_Geant )
				tf_normale_blend_coef = 4.0
			else
				tf_normale_blend_coef = 8.0
			v_ground_normale = MATH_VecBlendRotate(v_ground_normale, tv_ground_normale_perfect, tf_normale_blend_coef * TIME_GetDt())
		}
	}
	else
		ti_color = color_cyan		// banking figé
	if( i_DBG_render_ground_normale )
		DBG_RenderVector(OBJ_PosGet(), v_ground_normale * 2.0 * f_zoom, ti_color)
}


// EVENT VISIBILITY =================================================================
if( ! i_paf_explose && i_etat_courant != ETAT_FADE && (i_modele == MODELE_Petit || i_etat_courant != ETAT_MORT) )
{
	// pas de vision en fade ou même en mort pour le crabe géant
	tf_liferatio = f_HP_cur / f_HP_max
	if( ! tf_liferatio && ! f_viande_cur )
		tf_liferatio = -1.0
	EVENT_AddEventVision
	(
		i_id_modele,
		C_EVENT_FILTER_Enemy, 
		OBJ_Me(), 
		Cf_EVENT_Duree_1Trame, 
		OBJ_PosGet(),
		C_EVENT_Visibility_Full_Mvt, 
		Cf_CRAB_rayon_default * f_zoom, 
		Cf_CRAB_Interet, 
		C_EVENT_CONTEXT_STANDARD, 
		0,
		tf_liferatio
	)
}


// EVENT OLFACTIF ==================================================================
//if( f_HP_cur <= f_HP_max * Cf_Life_Blesse )
//{
//	if( ! f_delay_blood_gen )
//	{
//		if( tf_liferatio <= Cf_Life_Dead )
//			ti_etat = C_EVENT_ETAT_MORT
//		else if( tf_liferatio <= Cf_Life_Agonisant )
//			ti_etat = C_EVENT_ETAT_MOURANT
//		else if( tf_liferatio <= Cf_Life_Blesse )
//			ti_etat = C_EVENT_ETAT_BLESSE
//		else 
//			ti_etat = C_EVENT_ETAT_NORMAL
//		
//		EVENT_AddEventOlfactif( C_EVENT_FILTER_All, OBJ_Me(), Cf_delay_blood_gen, 1.0, OBJ_PosGet(), 15.0, ti_etat)
//		f_delay_blood_gen = Cf_delay_blood_gen
//	}
//}


// TRACE CONES =================================
if( i_DBG_render_cone_strafe )
{
	tf_cos_strafe = CR_Way_Strafe_Cosinus_Get()
	
	tv_temp = MATH_VecRotate(OBJ_HorizonGet(), Cv_VerticalVector, MATH_ACos(tf_cos_strafe))
	DBG_RenderVector(OBJ_PosGet() + cvector(0,0,0.5), tv_temp * 20.0, color_cyan)
	tv_temp = MATH_VecRotate(OBJ_HorizonGet(), Cv_VerticalVector, - MATH_ACos(tf_cos_strafe))
	DBG_RenderVector(OBJ_PosGet() + cvector(0,0,0.5), tv_temp * 20.0, color_cyan)
	tv_temp = MATH_VecRotate( - OBJ_HorizonGet(), Cv_VerticalVector, MATH_ACos(tf_cos_strafe))
	DBG_RenderVector(OBJ_PosGet() + cvector(0,0,0.5), tv_temp * 20.0, color_cyan)
	tv_temp = MATH_VecRotate( - OBJ_HorizonGet(), Cv_VerticalVector, - MATH_ACos(tf_cos_strafe))
	DBG_RenderVector(OBJ_PosGet() + cvector(0,0,0.5), tv_temp * 20.0, color_cyan)
	
	
	tv_temp = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, MATH_ACos(f_way_cos_attack_pince))
	DBG_RenderVector(OBJ_PosGet() + cvector(0,0,0.5), tv_temp * 20.0, color_blanc)
	tv_temp = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, - MATH_ACos(f_way_cos_attack_pince))
	DBG_RenderVector(OBJ_PosGet() + cvector(0,0,0.5), tv_temp * 20.0, color_blanc)
}

if( i_DBG_display_fight_stats )
{
	Str_DisplayTextOnce("REQUIN", cvector(0,0.25,0))
	Str_DisplayTextOnce("délai : ", cvector(0,0.3,0))
	Str_DisplayFloatOnce(f_strafe_requin_delay, cvector(0.05,0.3,0))
	Str_DisplayTextOnce("durée: ", cvector(0,0.35,0))
	Str_DisplayFloatOnce(f_strafe_requin_duration, cvector(0.05,0.35,0))
	
	
	Str_DisplayTextOnce("ATTAQUE FACE", cvector(0,0.45,0))
	Str_DisplayTextOnce("délai : ", cvector(0,0.5,0))
	Str_DisplayFloatOnce(f_attack_strafe_face_delay, cvector(0.05,0.5,0))
	Str_DisplayTextOnce("durée: ", cvector(0,0.55,0))
	Str_DisplayFloatOnce(f_attack_strafe_face_duration, cvector(0.05,0.55,0))
//	if( o_fight_actor || i_antre_move_flag )
	if( i_fight_mode == Ci_fight_mode_target || i_fight_mode == Ci_fight_mode_retour )
	{
//		if( o_fight_actor )
		if( i_fight_mode == Ci_fight_mode_target )
			tv_pos = @o_fight_actor OBJ_PosGet()
		else 
			tv_pos = v_antre_pos
		tv_me_to_dest = tv_pos
		tv_me_to_dest -= OBJ_PosGet()
		tv_me_to_dest.z = 0.0
		Str_DisplayTextOnce("dist : ", cvector(0,0.6,0))
		Str_DisplayFloatOnce(MATH_VecNorm(tv_me_to_dest), cvector(0.05,0.6,0))
	}
	
	Str_DisplayTextOnce("INTIMIDATION", cvector(0,0.7,0))
	Str_DisplayTextOnce("délai : ", cvector(0,0.75,0))
	Str_DisplayFloatOnce(f_intimidation_delay, cvector(0.05,0.75,0))
	
	Str_DisplayTextOnce("SPEED", cvector(0,0.8,0))
	Str_DisplayFloatOnce(DYN_SpeedGet() * CR_Speed_Coef_Get(0), cvector(0,0.85,0))
}

if( i_DBG_display_attack45_timer && DBG_IsObjSel() && i_modele == MODELE_Petit )
{
	// GESTION DES VAGUES D'ATTAQUES A 45°
	Str_DisplayTextOnce("GESTION DES VAGUES D'ATTAQUES A 45°", cvector(0.3,0.75,0.0))
	Str_DisplayTextOnce("mode = ", cvector(0.4,0.8,0.0))
	switch ( i_fight_comportement )
	{
		case 1 : 
			Str_DisplayTextOnce("wait...", cvector(0.5,0.8,0.0))
			break
		case 2 : 
			Str_DisplayTextOnce("attaque !!!", cvector(0.5,0.8,0.0))
			break
		default:
			Str_DisplayTextOnce("default", cvector(0.5,0.8,0.0))
			break
	}
	//Str_DisplayIntOnce(i_fight_comportement, cvector(0.5,0.5,0.0))
	Str_DisplayTextOnce("global = ", cvector(0.4,0.85,0.0))
	Str_DisplayFloatOnce(@get_global f_CRAB_next_attaque_45degre, cvector(0.5,0.85,0.0))
	Str_DisplayTextOnce("time = ", cvector(0.4,0.9,0.0))
	Str_DisplayFloatOnce(TIME_Get(), cvector(0.5,0.9,0.0))
	Str_DisplayTextOnce("intim ok = ", cvector(0.4,0.95,0.0))
	Str_DisplayIntOnce(i_attack_intimidation_done, cvector(0.5,0.95,0.0))
}


//if( AI_TriggerIsValid(trig_test) && call_trigger(trig_test) )
//{
//	Str_DisplayTextOnce("trigger valide", cvector(0.5,0.5,0))
//}


// CHEAT AFFICHAGE DES POINTS DE VIE ===========================
tv_2D_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())
if( @"univ" i_cheat_page == 3 )
{
	Str_DisplayFloatOnce(f_HP_cur, tv_2D_pos)
}


