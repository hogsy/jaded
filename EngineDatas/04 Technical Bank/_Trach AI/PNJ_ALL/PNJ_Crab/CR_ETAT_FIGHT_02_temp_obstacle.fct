//#include "CR_defines.var"
//
//float				tf_dist_proj
//float				tf_calcul_cote
//float				tf_dot_Horiz_moveAxis
//float				tf_dot_Sight_moveAxis
//float				tf_obstacle_dist
//float				tf_cote
//
//int					ti_strafeG_ok
//int					ti_strafeD_ok
//
//messageid		tmid_vision
//
//vector			tv_new_sight
//vector			tv_me_to_actor
//vector			tv_actor_proj_pos
//vector			tv_actor_proj_axis
//vector			tv_pos_blend_horizon
//vector			tv_me_to_pos_blend_horizon
//vector			tv_temp
//vector			tv_pos
//vector			tv_lray_pos
//vector			tv_lray_sight
//vector			tv_move_axis
//vector			tv_obstacle_pos
//vector			tv_start_to_dest
//vector			tv_ortho_dir
//
//object			to_ray_object
//object			to_my_lray_bone
//object			to_FA_lray_bone
//
//
//// SORTIE ETAT ==============================================================================
//if (i_sort_etat)
//{
//	i_sort_etat = faux
//	return
//}
//
//
//// ENTREE ETAT ==============================================================================
//if (i_etat_courant != ETAT_FIGHT )
//{
//	i_etat_ancien = i_etat_courant
//	i_etat_courant = ETAT_FIGHT
//	
//	if (fct_etat_courant)
//	{
//		i_sort_etat = vrai
//		AI_Execute(fct_etat_courant)
//	}
//	
//	fct_etat_courant = AI_TrackCurGet()
//	fct_etat_main = AI_TrackCurGet()
//	f_time_start_etat = 0.0
//	
//	o_fight_actor = EVENT_InteretTargetGet(mid_best_interet)
//	
//	i_attack_paf_done = faux
//	f_way_intimidation_delay = MATH_RandFloat(f_way_intimidation_delay_min, f_way_intimidation_delay_max)
//	i_way_mode = Ci_way_mode_avance		// par défaut le crabe avance vers sa proie
//	i_way_obstacle_flag = faux
//	i_way_strafe_flag_select_cote = faux
//}
//else
//{
//	f_time_start_etat += TIME_GetDt()
//}
//
//
//// ANALYSE ===================================================================================
//AI_Execute("CR_exec_CHECK_Vision")
//
//AI_Execute("CR_exec_CHECK_Paf")
//if( CR_Paf_Check_Change_Etat() )
//	macro_change_etat("CR_ETAT_PAF")
//
//if( ! MSG_GlobalIsValid(mid_best_interet) )
//	macro_change_etat("CR_ETAT_IDLE")
//
//// COMPORTEMENT =============================================================================
//
//// INTERET ------------------------------------------------------------------------------------------
//if( CR_Perceived_Actor_Check(o_fight_actor, tmid_vision) )
//	CR_Interet_Update(mid_best_interet, C_EVENT_InteretStatusAttack, o_fight_actor, tmid_vision)
//
//// DEPLACEMENT  ------------------------------------------------------------------------------
//v_way_dest_pos = EVENT_InteretPositionGet(mid_best_interet)
////DBG_RenderVector(OBJ_PosGet(), v_way_dest_pos - OBJ_PosGet(), color_vert)
//AI_Execute("CR_exec_WAY_Move")
//DBG_RenderVector(OBJ_PosGet(), v_joy_dir * f_way_length, color_jaune)
//
//// ACTION -------------------------------------------------------------------------------------------
//tv_move_axis = v_joy_dir
//tv_new_sight = Cv_NullVector
//tv_me_to_actor = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
//
//switch( ACT_ActionGet() )
//{
//	case ACTION_Intimidation :
//		// INTIMIDATION EN COURS ======================================================
//		tv_new_sight = tv_me_to_actor
//		if( ACT_ActionFinished() )
//		{
//			f_way_intimidation_delay = MATH_RandFloat(f_way_intimidation_delay_min, f_way_intimidation_delay_max)
//			ACT_ActionSet(ACTION_Attente)
//			CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//			// conservation de i_way_mode (obstacles !!!)
//		}
//		break
//		
//	case ACTION_AttackG :
//	case ACTION_AttackD :
//		// ATTAQUE EN COURS =========================================================
//		if( ACT_ActionFinished() )
//		{
//			// FIN D'ATTAQUE ------------------------------------
//			i_attack_paf_done = faux
//			f_attack_delay = MATH_RandFloat(3.0, 5.0)
//			ACT_ActionSet(ACTION_Attente)
//			CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//			i_way_mode = Ci_way_mode_avance
//		}
//		else
//		{
//			// TEST PAF -------------------------------------------
//			if( ! i_attack_paf_done && COL_ZDE_ZDECollide(o_fight_actor, C_zde_fight, C_zde_corps) )
//			{
//				DBG_TraceString("=== ")
//				DBG_TraceObject(OBJ_Me())
//				DBG_TraceString(" paffe ")
//				DBG_TraceObject(o_fight_actor)
//				DBG_TraceString(" ZDE Fight / ZDE Corps")
//				DBG_TraceEOL()
//				i_attack_paf_done = vrai
//				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, C_EVENT_PAF_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, PAF_Unit * 5, OBJ_SightGet())
//				CR_Paffed_Actor_Add(o_fight_actor)
//			}
//		}
//		break
//	
//	default:
//		// PASSAGE EN INTIMIDATION ==================================================
//		if( ! f_way_intimidation_delay && MATH_VecDotProduct(@o_fight_actor OBJ_SightGet(), MATH_VecNormalize(OBJ_PosGet() - @o_fight_actor OBJ_PosGet())) < Cf_Cos30 )
//		{
//			ACT_ActionSet(ACTION_Intimidation)
//			CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
//		}
//		// ATTENTE ===============================================================
//		else if( ! f_joy_norm )
//		{
//			// DEBUT D'INTIMIDATION -----------------------------------------------
//			if( ! i_attack_intimidation_done )
//			{
//				i_attack_intimidation_done = vrai
//				ACT_ActionSet(ACTION_Intimidation)
//				CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
//			}
//			// ATTENTE TIMER --------------------------------------------------------
//			else if( f_attack_delay )
//			{
//				ACT_ActionSet(ACTION_Attente)
//				CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//			}
//			// DEBUT D'ATTAQUE ---------------------------------------------------
//			else
//			{
//				to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//				to_my_lray_bone = o_bone_carapace
//				tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
//				tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
//				DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//				to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//				if( to_ray_object || CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, C_EVENT_InteretStatusGrab, vrai) ) 
//				{
//					// PAS LE DROIT D'ATTAQUER ----------------------------
//					ACT_ActionSet(ACTION_Attente)
//					CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//				}
//				else
//				{
//					// ATTAQUE POSSIBLE ----------------------------------------
//					if( MATH_VecDotProduct(OBJ_HorizonGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet()) > 0 )
//					{
//						// GAUCHE
//						if( i_grab )
//						{
//							ACT_ActionSet(ACTION_GrabGdeb)
//							macro_change_etat("CR_ETAT_GRAB")
//						}
//						else
//						{
//							ACT_ActionSet(ACTION_AttackG)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
//						}
//					}
//					else
//					{
//						// DROITE
//						if( i_grab )
//						{
//							ACT_ActionSet(ACTION_GrabDdeb)
//							macro_change_etat("CR_ETAT_GRAB")
//						}
//						else
//						{
//							ACT_ActionSet(ACTION_AttackD)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
//						}
//					}
//				}
//			}
//		}
//		else
//		{
//			// DEPLACEMENT ==========================================================
//			
//			// REINIT INTIMIDATION DEBUT COMBAT --------------------------
//			if( f_way_length >= 15.0 )
//				i_attack_intimidation_done = faux
//			
//			// DEPLACEMENT ------------------------------------------------------------
//			tf_dot_Horiz_moveAxis = MATH_VecDotProduct(OBJ_HorizonGet(), tv_move_axis)
//			tf_dot_Sight_moveAxis = MATH_VecDotProduct(OBJ_SightGet(), tv_move_axis)
//			
//			// CHOIX DU SENS DE STRAFE ---------------------------------------
//			if( i_way_strafe_flag_select_cote )
//			{
//				// Choix du côté de strafe
//				i_way_strafe_flag_select_cote = faux
//				tf_cote = 0.0
//				
//				switch( i_way_mode )
//				{
//					case Ci_way_mode_strafe_attack_cote :
//					case Ci_way_mode_strafe_attack_devant :
//						tf_cote = MATH_FloatSign(tf_dot_Horiz_moveAxis)
//						break
//					
//					case Ci_way_mode_strafe_requin :
//						// test à gauche
//						tv_pos = OBJ_PosGet()
//						tv_temp = MATH_VecCrossProduct(Cv_VerticalVector, v_joy_dir)
//						MATH_VecSetNormalize(tv_temp)
//						tv_pos += f_way_grid_avance_length * tv_temp
//						if( GRID_LIB_IsReachableFrom(OBJ_PosGet(), tv_pos, 0b0, f_way_grid_avance_length, vrai, 0))
//							ti_strafeG_ok = vrai
//						else
//							ti_strafeG_ok = faux
//						
//						// test à droite
//						tv_pos = OBJ_PosGet()
//						tv_temp = MATH_VecCrossProduct(v_joy_dir, Cv_VerticalVector)
//						MATH_VecSetNormalize(tv_temp)
//						tv_pos += f_way_grid_avance_length * tv_temp
//						if( GRID_LIB_IsReachableFrom(OBJ_PosGet(), tv_pos, 0b0, f_way_grid_avance_length, vrai, 0))
//							ti_strafeD_ok = vrai
//						else
//							ti_strafeD_ok = faux
//						
//						// comparatif des tests
//						if( ti_strafeG_ok && ti_strafeD_ok )
//							tf_cote = MATH_FloatSign(MATH_RandFloat(-1.0,1.0))
//						else if( ti_strafeG_ok )
//							tf_cote = 1.0
//						else if( ti_strafeD_ok )
//							tf_cote = -1.0
//						else
//						{
//							f_way_strafe_delay = MATH_RandFloat(f_way_strafe_delay_min, f_way_strafe_delay_max)			// strafe interdit pour l'instant !!!
//							i_way_mode = Ci_way_mode_avance
//						}
//						break
//				}
//				
//				if( tf_cote != 0.0 )
//					CR_Strafe_Begin(tf_cote)
//			}
//			
//			// SOUS-MODE DE DEPLACEMENT --------------------------------
//			switch( i_way_mode )
//			{
//				case Ci_way_mode_avance :
//					DBG_TraceString("Ci_way_mode_avance")
//					DBG_TraceEOL()
//					if( i_way_obstacle_flag )
//					{
//						i_way_strafe_flag_select_cote = vrai
//						i_way_mode = Ci_way_mode_strafe_obstacle
//						f_way_time_degagement_obstacle = 0.0
//						i_way_obstacle_flag_init = vrai
//					}
//					else
//					{
//						if( tf_dot_Sight_moveAxis < 0.0 && (tf_dot_Horiz_moveAxis > Cf_Cos30 && tf_dot_Horiz_moveAxis < - Cf_Cos30) )
//						{
//							// perso derrière moi : je me tourne sur place
//							i_way_mode = Ci_way_mode_tourne
//						}
//						else
//						{
//							// délai passage en strafe ok
//							if( f_way_length > f_way_strafe_dist_requin_ou_attack )
//							{
//								// distance strafe attack pas ok
//								if( ! f_way_strafe_delay )
//								{
//									// délai strafe ok
//									i_way_strafe_flag_select_cote = vrai
//									i_way_mode = Ci_way_mode_strafe_requin
//								}
//								else
//								{
//									// avance
////									if( f_joy_norm > f_way_distance_avance_attack )
//										ACT_ActionSet(ACTION_Avance_Attaque)
////									else
////										ACT_ActionSet(ACTION_Avance_Standard)
//									CR_Rotation_Coef_Set(Ci_rotation_coef_avance)
//								}
//							}
//							else
//							{
//								// distance strafe attack ok : plus de délai
//								i_way_strafe_flag_select_cote = vrai
//								if( tf_dot_Horiz_moveAxis > Cf_Cos30 || tf_dot_Horiz_moveAxis < - Cf_Cos30 )
//									i_way_mode = Ci_way_mode_strafe_attack_cote
//								else
//									i_way_mode = Ci_way_mode_strafe_attack_devant
//							}
//						}
//					}
//					break
//				
//				case Ci_way_mode_tourne :
//					DBG_TraceString("Ci_way_mode_tourne")
//					DBG_TraceEOL()
//					if( f_way_length > f_way_strafe_dist_requin_ou_attack )
//					{
//						// trop loin pour faire une attaque strafe -> se tourne plus
//						if( tf_dot_Sight_moveAxis > 0 )
//							i_way_mode = Ci_way_mode_avance
//						else
//							goto TOURNE
//					}
//					else
//					{
//						// assez près pour faire une attaque strafe -> se tourne moins
//						if( tf_dot_Horiz_moveAxis > Cf_Cos30 || tf_dot_Horiz_moveAxis < - Cf_Cos30 )
//							i_way_mode = Ci_way_mode_avance
//						else
//							goto TOURNE
//					}
//					
//					TOURNE:
//						ACT_ActionSet(ACTION_SurPlace)
//						CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
//					break
//				
//				case Ci_way_mode_strafe_requin :
//					if( ! f_way_strafe_duration || CR_Collide_Wall_Strafe() )
//						i_way_mode = Ci_way_mode_avance
//					
//					tv_new_sight = tv_me_to_actor
//					// tourner un peu mon sight du côté opposé du strafe pour que le strafe me fasse avancer
//					tv_new_sight = MATH_VecRotate(tv_new_sight, Cv_VerticalVector, - CR_Strafe_Cote_Get() * Cf_PiBy8)
//					break
//				
//				case Ci_way_mode_strafe_attack_devant :
//					DBG_TraceString("Ci_way_mode_strafe_attack_devant")
//					DBG_TraceEOL()
//					if( ! f_way_strafe_duration || CR_Collide_Wall_Strafe() )
//						i_way_mode = Ci_way_mode_avance
//					else
//						tv_new_sight = CR_Strafe_Cote_Get() * MATH_VecCrossProduct(tv_move_axis, Cv_VerticalVector)
//					break
//				
//				case Ci_way_mode_strafe_attack_cote :
//					// calcul d'un point devant la cible vers lequel strafer	
//					DBG_TraceString("Ci_way_mode_strafe_attack_cote")
//					DBG_TraceEOL()
//					if( ! f_way_strafe_duration || CR_Collide_Wall_Strafe() )
//						i_way_mode = Ci_way_mode_avance
//					else
//					{
//						// perso complètement sur ma gauche ou sur ma droite
//						tf_dist_proj = MATH_VecDotProduct(CR_Strafe_Cote_Get() * OBJ_HorizonGet(), tv_move_axis)
//						DBG_RenderVector(OBJ_PosGet(), CR_Strafe_Cote_Get() * OBJ_HorizonGet() * tf_dist_proj, color_blanc)
//						tv_actor_proj_pos = OBJ_PosGet() + ( CR_Strafe_Cote_Get() * OBJ_HorizonGet() * tf_dist_proj )
//						DBG_RenderVector(OBJ_PosGet(), tv_actor_proj_pos - OBJ_PosGet(), color_jaune)
//						tv_actor_proj_axis = tv_actor_proj_pos - @o_fight_actor OBJ_PosGet()
//						MATH_VecSetNormalize(tv_actor_proj_axis)
//						if( MATH_VecDotProduct(OBJ_SightGet(), tv_actor_proj_axis) > 0 )
//							tv_actor_proj_axis *= -1			// je force le calcul d'une position derrière moi pour m'orienter en strafe, sinon je pourrai me retrouver dos à lui
//						DBG_RenderVector(@o_fight_actor OBJ_PosGet(), tv_actor_proj_axis, color_blanc)
//						tv_pos_blend_horizon = @o_fight_actor OBJ_PosGet() + ( Cf_distance_anticipation_actor * f_zoom * tv_actor_proj_axis )
//						tv_me_to_pos_blend_horizon = tv_pos_blend_horizon - OBJ_PosGet()
//						DBG_RenderVector(@o_fight_actor OBJ_PosGet(), tv_pos_blend_horizon - @o_fight_actor OBJ_PosGet(), color_vert)
//						DBG_RenderVector(OBJ_PosGet(), tv_me_to_pos_blend_horizon, color_bleu)
//						
//						tv_new_sight = tf_calcul_cote * MATH_VecCrossProduct(tv_me_to_pos_blend_horizon, Cv_VerticalVector)
//						DBG_RenderVector(OBJ_PosGet(), tv_new_sight, color_rouge)
//					}
//					break
//				
//				case Ci_way_mode_strafe_obstacle :
////					tv_new_sight = OBJ_SightGet()		// strafe perpendiculaire à l'obstacle
////					if( ! i_way_flag_obstacle )
////					{
////						f_way_time_degagement_obstacle += TIME_GetDt()
////						if( f_way_time_degagement_obstacle > 0.5 )
////							i_way_mode = Ci_way_mode_avance
////					}
//
//
////					tv_new_sight = - CR_Strafe_Cote_Get() * MATH_VecCrossProduct(tv_move_axis, Cv_VerticalVector)
//					
//					// CALCUL INIT DE L'AXE DE CONTOURNEMENT DE L'OBSTACLE
//					if( i_way_obstacle_flag_init )
//					{
//						i_way_obstacle_flag_init = faux
//						to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//						to_my_lray_bone = o_bone_carapace
//						tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
//						tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
//						DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//						to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//						if( ! to_ray_object )
//							DBG_Error("???? lray null alors que je suis censé avoir un obstacle ???")
//						else
//						{
//							v_way_obstacle_pos = COL_RayObject_PosGet()
//							f_way_obstacle_dist = MATH_VecNorm(v_way_obstacle_pos - OBJ_PosGet())
//							v_way_obstacle_normale = COL_RayObject_NormalGet()
////							v_way_obstacle_move = CR_Strafe_Cote_Get() * MATH_VecCrossProduct(Cv_VerticalVector, - v_way_obstacle_normale)
//							DBG_RenderVector(tv_lray_pos, v_way_obstacle_pos - OBJ_PosGet(), color_vert)
//							f_way_obstacle_cote_backup = CR_Strafe_Cote_Get()
//						}
//					}
//					// TEST FIN DE CONTOURNEMENT
//					else
//					{
//						if( ! CR_Strafe_En_Cours() )
//							CR_Strafe_Begin(f_way_obstacle_cote_backup)
//						to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//						to_my_lray_bone = o_bone_carapace
//						tv_lray_pos = @to_my_lray_bone OBJ_PosGet() + MATH_VecLocalToGlobal( - f_way_obstacle_cote_backup * cvector(2.0 * f_zoom, 0.0, 0.0))
//						tv_lray_sight = - v_way_obstacle_normale * (f_way_obstacle_dist + 1.0)	// pour bien rentrer dans le mur
//						DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//						to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//						if( ! to_ray_object ) 
//							i_way_mode = Ci_way_mode_avance
//						else if( CR_Collide_Wall_Strafe() )
//							DBG_Error("je suis en mode Ci_way_mode_strafe_obstacle et je collisionne de côté... je fais quoi ???")
//					}
//					
//					// CALCUL DE L'AXE DE CONTOURNEMENT DE L'OBSTACLE
////					tv_obstacle_pos = v_way_obstacle_pos
////					tv_start_to_dest = tv_obstacle_pos - OBJ_PosGet()
////					tf_obstacle_dist = MATH_VecNorm(tv_start_to_dest)
////					tv_ortho_dir = tv_start_to_dest / tf_obstacle_dist
////					tv_ortho_dir.z = tv_ortho_dir.x
////					tv_ortho_dir.x = tv_ortho_dir.y
////					tv_ortho_dir.y = tv_ortho_dir.z
////					tv_ortho_dir.z = 0.0
////					
////					DBG_RenderVector(OBJ_PosGet(), tv_ortho_dir * 10, color_rouge)
//					
////					tv_new_sight = CR_Strafe_Cote_Get() * MATH_VecCrossProduct(Cv_VerticalVector, tv_move_axis)
//					tv_new_sight = - v_way_obstacle_normale
//					break
//			}
//		}
//		break
//}
//
//
//// MODIF FREQUENCE DE L'ANIM -----------------------------------------------
////if( ! ACT_ActionIsTransition() )
////{
////	switch( ACT_ActionGet() )
////	{
////		case ACTION_SurPlace :
////		case ACTION_Avance_Normal :
////		case ACTION_Avance_Attaque :
////		case ACTION_StrafeD :
////		case ACTION_StrafeG :
////			ACT_LIB_ActionFrequencyMultiply(f_action_speed_coef)
////			break
////	}
////}
//
//// ORIENTATION ---------------------------------------------------------------------------
//if( MATH_VecNullEpsilon(tv_new_sight) )
//	tv_new_sight = tv_me_to_actor
//
//DBG_RenderVector(OBJ_PosGet(), MATH_VecNormalize(tv_new_sight) * 10.0, color_cyan)
//OBJ_BankingGeneralSet(
//	MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, f_way_rotation_coef * TIME_GetDt()),
//	MATH_VecBlendRotate(OBJ_BankingGet(), v_ground_normale, 6.0 * TIME_GetDt()))
//
//