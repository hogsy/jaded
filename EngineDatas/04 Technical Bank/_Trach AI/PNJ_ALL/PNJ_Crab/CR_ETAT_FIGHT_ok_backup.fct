//#include "CR_defines.var"
//
//// GRILLE ===========
//#define			Cf_front_delay			1.0
//vector			tv_pos_target
//vector			tv_me_to_target
//vector			tv_me_to_target_N
//vector			tv_new_sight
//vector			tv_new_speed
//vector			tv_last_speed
//vector			tv_pos
//vector			tv_offset
//int					ti_main
//int					ti_sec
//int					ti_main_break
//int					ti_sec_break
//int					ti_main_new
//int					ti_sec_new
//int					i_case
//int					ti_test
//float				tf_speed
//// FIGHT ==================
//messageid		tmid_vision
//float				tf_pos_offset
//float				tf_dist_to_target
//float				tf_dot_Horiz_moveAxis
//float				tf_dot_Sight_moveAxis
//vector			tv_lray_pos
//vector			tv_lray_sight
//object			to_ray_object
//object			to_FA_lray_bone
//object			to_my_lray_bone
//float				tf_cos_strafe
//int					ti_action
//vector			tv_new_horizon
//float				tf_strafe_rotation_coef 
//float				tf_speed_coef
//int					ti_obstacle
//int					ti_move
//int					ti_gauche
//
//
//// SORTIE ETAT ==============================================================================
//if (i_sort_etat)
//{
////	i_antre_move_flag = faux
//	
//	i_sort_etat = faux
//	return
//}
//
//
//// ENTREE ETAT ==============================================================================
//if (i_etat_courant != ETAT_FIGHT )
//{
//	i_etat_ancien = i_etat_courant
//	i_etat_courant = ETAT_FIGHT
//	
//	if (fct_etat_courant)
//	{
//		i_sort_etat = vrai
//		AI_Execute(fct_etat_courant)
//	}
//	
//	fct_etat_courant = AI_TrackCurGet()
//	fct_etat_main = AI_TrackCurGet()
//	f_time_start_etat = 0.0
//	
//	if( i_antre_move_flag )
//		EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)		// raz intérêt
//	
//	CR_Fight_Init()
//	
//	if( i_DBG_trace_etat )
//	{
//		DBG_TraceObject(OBJ_Me())
//		DBG_TraceString(" : ETAT FIGHT : ")
//		if( i_antre_move_flag )
//		{
//			DBG_TraceString("retour à mon antre")
//		}
//		else if( CR_Cadavre_Find(o_fight_actor) )
//		{
//			DBG_TraceString("cadavre : ")
//			DBG_TraceObject(o_fight_actor)
//		}
//		else if( o_fight_actor )
//		{
//			DBG_TraceString("proie : ")
//			DBG_TraceObject(o_fight_actor)
//		}
//		else
//		{
//			DBG_Error("pas de proie ???? ")
//		}
//		DBG_TraceEOL()
//	}
//}
//else
//{
//	f_time_start_etat += TIME_GetDt()
//}
//
//
//
//// ANALYSE ===================================================================================
//AI_Execute("CR_exec_CHECK_Vision")
//
//// Paf
//AI_Execute("CR_exec_CHECK_Paf")
//if( CR_Paf_Check_Change_Etat() )
//	macro_change_etat("CR_ETAT_PAF")
//
//// valide la cible
//if( ! CR_Target_Check(o_fight_actor) )
//	EVENT_Delete(mid_best_interet, C_EVENT_EOFDEL)		// raz intérêt
//
//
//if( ! MSG_GlobalIsValid(mid_best_interet) )
//	o_fight_actor = nobody
//
//AI_Execute("CR_exec_CHECK_Target")
//if( i_change_target_flag )
//{
//	i_antre_move_flag = faux
//	CR_Fight_Init()		// changement de cible
//}
//
//if( ! i_antre_move_flag && ! o_fight_actor )
//{
//	if( i_DBG_trace_etat )
//	{
//		DBG_TraceObject(OBJ_Me())
//		DBG_TraceString(" : en fight mais aucun intérêt = je n'ai pas trouvé d'autre cible -> idle")
//		DBG_TraceEOL()
//	}
//	macro_change_etat("CR_ETAT_IDLE")	// perte d'intérêt et aucune autre cible -> IDLE
//}
//
//
//// PAFS COLLISION
//AI_Execute("CR_exec_CHECK_Collision")
//
//
//// COMPORTEMENT =============================================================================
//
//// INTERET (cible ou cadavre) ----------------------------------------------------------------
//if( CR_Perceived_Actor_Check(o_fight_actor, tmid_vision) || CR_Cadavre_Find(o_fight_actor) )
//	CR_Interet_Update(mid_best_interet, C_EVENT_InteretStatusAttack, o_fight_actor, tmid_vision)
//
//
//// DEPLACEMENT  ------------------------------------------------------------------------------
//
//
//// DELAIS DE STRAFE
////if( i_strafe_requin_end_flag && i_way_mode_strafe == Ci_way_mode_strafe_aucun_ou_requin )
//if( ! f_strafe_requin_duration && CR_Strafe_En_Cours() && i_way_mode_strafe == Ci_way_mode_strafe_aucun_ou_requin )
//{
//	CR_Strafe_Requin_Delay_Random()
//}
////if( i_attack_strafe_face_end_flag && i_way_mode_strafe == Ci_way_mode_strafe_attack_face )
//if( ! f_attack_strafe_face_duration && CR_Strafe_En_Cours() && i_way_mode_strafe == Ci_way_mode_strafe_attack_face )
//{
//	CR_Strafe_Attack_Face_Delay_Random()
//}
//
//
//if( i_antre_move_flag )
//{
//	// vers mon antre
//	tv_pos_target = v_antre_pos
//	tf_pos_offset = Cf_antre_delta_pos * OBJ_ZoomGet()
//}
//else
//{
//	// vers ma cible / mon cadavre
//	tv_pos_target = EVENT_InteretPositionGet(mid_best_interet)
//	if( CR_Cadavre_Find(o_fight_actor) )
//		tf_pos_offset = f_way_dist_position_cadavre
//	else if( ! CR_Strafe_En_Cours() )
//		tf_pos_offset = CR_Fight_Actor_Pos_Offset_Get()
//	else
//		tf_pos_offset = f_way_dist_position_fight_strafe
//}
//
//// offset positionnement
//tv_me_to_target = tv_pos_target - OBJ_PosGet()
//tf_dist_to_target = MATH_VecNorm(tv_me_to_target)
//tv_me_to_target_N = tv_me_to_target
//if( ! MATH_VecNullEpsilon(tv_me_to_target_N) )
//	MATH_VecSetNormalize(tv_me_to_target_N)
//
//// orientation et vitesse
//tv_new_sight = tv_me_to_target
//tv_new_speed = OBJ_SightGet()
//
//// angles
//tf_dot_Horiz_moveAxis = MATH_VecDotProduct(OBJ_HorizonGet(), tv_me_to_target_N)
//tf_dot_Sight_moveAxis = MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_target_N)
//
//
//ti_obstacle = faux
//ti_move = faux
//
//
//// ACTION -------------------------------------------------------------------------------------------
//switch( ACT_ActionGet() )
//{
//	case ACTION_Intimidation :
//		// INTIMIDATION =============================================================================
//		if( ACT_ActionFinished() )
//		{
//			CR_Intimidation_Delay_Random()
//			ti_move = vrai
//		}
//		break
//		
//	case ACTION_AttackG :
//	case ACTION_AttackD :
//	case ACTION_AttackHaut :
//		// ATTAQUE EN COURS ======================================================================
//		if( ACT_ActionFinished() )
//		{
//			// FIN D'ATTAQUE
//			i_attack_paf_done = faux
//			ti_move = vrai
//			
//			if( i_modele == MODELE_Petit )
//				i_attack_intimidation_done = faux		// les petits crabes intimident avant chaque attaque
//		}
//		else
//		{
//			// TEST PAF
//			if( ! i_attack_paf_done && COL_ZDE_ZDECollide(o_fight_actor, C_zde_fight, C_zde_corps) )
//			{
//				if( i_DBG_trace_etat )
//				{
//					DBG_TraceObject(OBJ_Me())
//					DBG_TraceString(" paffe ")
//					DBG_TraceObject(o_fight_actor)
//					DBG_TraceString(" ZDE Fight / ZDE Corps")
//					DBG_TraceEOL()
//				}
//				i_attack_paf_done = vrai
//				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, i_paf_to_send_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, Ci_paf_dmg_pince, OBJ_SightGet())
//				CR_Paffed_Actor_Add(o_fight_actor)
//			}
//		}
//		break
//	
//	default:
//		ti_move = vrai
//		break
//}
//
//if( ti_move )
//{
//	// ATTENTE OU DEPLACEMENT =============================================================
//	if( tf_dist_to_target <= tf_pos_offset && ! f_time_force_requin )
//	{
//		// DEPLACEMENT TERMINE ---------------------------------------------------------------------------------------------------------------------------
//		if( i_antre_move_flag )
//		{
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(" a atteint son antre")
//			DBG_TraceEOL()
//			macro_change_etat("CR_ETAT_IDLE")
//		}
//		
//		// ORIENTATION VERS CIBLE
//		if( tf_dot_Sight_moveAxis < f_way_cos_attack_pince )
//		{
//			// se tourne pour se mettre en face de la cible pour porter un coup de pince (paf ou grab)
//			CR_ActionSet(ACTION_SurPlace, Ci_rotation_coef_sur_place)
//		}
//		// SINON DEBUT D'INTIMIDATION
//		else if( ! i_attack_intimidation_done && ! CR_Cadavre_Find(o_fight_actor) )
//		{
//			if( f_time_last_paf > 0.5 )
//			{
//				i_attack_intimidation_done = vrai
//				CR_ActionSet(ACTION_Intimidation, Ci_rotation_coef_intimidation)
//			}
//			else
//				CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
//		}
//		// MA CIBLE EST UN CADAVRE
//		else if( CR_Cadavre_Find(o_fight_actor) )
//		{
//			macro_change_etat("CR_ETAT_MANGE")
//		}
//		// SINON (PAS CADAVRE OU CADAVRE PAS MORT) => TEST DELAI DEBUT D'ATTAQUE
//		else if( ! f_attack_delay && CR_Attack_Enabled() )
//		{
//			to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//			if( ! to_FA_lray_bone )
//				to_FA_lray_bone = o_fight_actor
//			to_my_lray_bone = o_bone_carapace
//			tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
//			tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
//			DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//			to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//			if( to_ray_object || CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, C_EVENT_InteretStatusGrab, vrai) ) 
//			{
//				// PAS LE DROIT D'ATTAQUER (MUR, DEJA GRABBE PAR UN BUDY....)
//				CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
//			}
//			else
//			{
//				// PAS D'OBSTACLE ENTRE MA CIBLE ET MOI
//				tv_new_sight = tv_me_to_target
//				ti_gauche = faux
//				if( MATH_VecDotProduct(OBJ_HorizonGet(), tv_me_to_target) > 0 )
//					ti_gauche = vrai
//				
//				if( i_grab )
//				{
//					if( ti_gauche )
//						ACT_ActionSet(ACTION_GrabGdeb)
//					else
//						ACT_ActionSet(ACTION_GrabDdeb)
//					macro_change_etat("CR_ETAT_GRAB")
//				}
//				else
//				{
////					if( ti_gauche )
////						CR_ActionSet(ACTION_AttackG, Ci_rotation_coef_attaque)
////					else
////						CR_ActionSet(ACTION_AttackD, Ci_rotation_coef_attaque)
//
//					CR_ActionSet(ACTION_AttackHaut, Ci_rotation_coef_attaque)
//				}
//			}
//		}
//		// SINON ATTENTE
//		else
//		{
//			CR_ActionSet(ACTION_Attente, Ci_rotation_coef_attente)
//		}
//	} // fin "plus de déplacement"
//	else
//	{
//		// DEPLACEMENT NECESSAIRE ---------------------------------------------------------------------------------------------------------------------------
//		ti_obstacle = vrai
//		
//		// Test de la grille pour la nouvelle trame
//		tv_pos = OBJ_PosGet()
//		i_grid[0] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[0], cvector(1.0, 0.0, 0.0), i_grid_nb_case_check, 0, i_last_frontB, i_DGB_render_grille_check )
//		i_grid[1] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[1], cvector(0.0, -1.0, 0.0), i_grid_nb_case_check, 1, i_last_frontB, i_DGB_render_grille_check )
//		i_grid[2] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[2], cvector(-1.0, 0.0, 0.0), i_grid_nb_case_check, 2, i_last_frontB, i_DGB_render_grille_check )
//		i_grid[3] = CRAB_GRID_Check(tv_pos+v_grid_check_offset[3], cvector(0.0, 1.0, 0.0), i_grid_nb_case_check, 3, i_last_frontB, i_DGB_render_grille_check )
//		i_last_frontB = -1		// reset backup front lock trame précédente
//		
//		//   0
//		// 3 - 1
//		//   2
//		
//		// Si y a plus rien devant on reset le lock d'axe
//		if( i_last_front != -1 && ! i_grid[i_last_front] )
//		{
//			i_last_front = -1
//			i_last_side = -1
//		}
//		
//		
//		// Récup des N°s d'axe pour l'orientation courante
//		ti_main = CRAB_GRID_Get_Sight_ID(tv_me_to_target, ti_sec)
//		if( i_last_front == -1 )
//		{
//			// PAS ENCORE LOCKE EN STRAFE FACE A UN MUR ==================================
//			// Je ne suis pas locké en Axe. (Le front touche)
//			i_last_front = ti_main
//			i_last_sec = ti_sec
//		}
//		else
//		{
//			// LOCKE EN STRAFE FACE A UN MUR =============================================
//			// Je teste si maintenant la direction n'est pas dans mon dos
//			if( ti_main != MATH_Modulo(i_last_front+2,4) && ti_sec != MATH_Modulo(i_last_front+2,4) )
//			{
//				// Non, je garde les anciennes valeurs locké (KEEP STRAFF)
//				ti_main = i_last_front
//				ti_sec = i_last_sec
//			}
//		}
//		
//		if (i_grid[ti_main])
//		{
//			// IL Y A UN MUR DEVANT MOI ===================================================
//			// S'il n'y a pas de sens d'esquive de stocké, je prend celui que je prefere (side) sinon j'alterne (side opposé).
//			if (i_last_side == -1)
//				i_last_side = ti_sec												// Mon preferé
//			else if ( i_grid[i_last_side] )
//				i_last_side = MATH_Modulo(i_last_side + 2, 4)			// Mon symetrique
//		
//			// Deplacement en SIDE (Straff)
//			tv_new_sight = v_grid_normale[ti_main]
//			tv_new_speed	= v_grid_normale[i_last_side]
//			
//			i_front_lock = ti_main
//			i_last_frontB = ti_main			// backup front lock
//			f_front_delay = Cf_front_delay
//			
//			if( MATH_VecDotProduct(OBJ_HorizonGet(), tv_new_speed) > 0 )
//				CR_ActionSet(ACTION_StrafeG, Ci_rotation_coef_strafe)
//			else
//				CR_ActionSet(ACTION_StrafeD, Ci_rotation_coef_strafe)
//		}
//		else
//		{
//			// IL N'Y A PAS DE MUR DEVANT MOI =============================================
//			// Je peux eventuellement longer a droite ou a gauche
//			ti_sec_new = ti_sec
//			ti_main_new = ti_main
//			
//			// Rajout sur les SIDEs du coin plus plus dans ma direction
//			f_front_delay -= MATH_FloatMin(f_front_delay, TIME_GetDt() ) 
//			if (f_front_delay)
//			{
//				// Je rajoute au side du coté ou je veux aller la case du coin
//				ti_test = ti_sec
//				if (ti_test == i_front_lock)
//					ti_test = ti_main
//				
//				ti_sec_new = ti_test
//				ti_main_new = i_front_lock
//				
//				if (ti_main == i_front_lock || ti_sec == i_front_lock )
//				{
//					// Je rajoute a mon side la case qui est au coin de ti_sec et de i_front_lock
//					tv_offset = v_corner_pos[i_front_lock][ti_test]
//					DBG_RenderVector( GRID_PosGet(tv_pos + tv_offset) + cvector(0.03,0.03,0),cvector(0,0,100000),color_bleu)
//					i_case = CRAB_GRID_Check(tv_pos+tv_offset, cvector(0.0, 0.0, 0.0), 1, 0, -1, i_DGB_render_grille_check)		// test d'un case
//					i_grid[ti_test] += i_case
//				}
//				else
//					f_front_delay = 0.0		// Break on veut aller dans le dos du dernier lock
//			}
//			
//			if (i_grid[ti_sec_new])
//			{
//				// il y a un mur de mon coté preféré, je le longe
//		
//				// Deplacement en FRONT
//				tv_new_sight = v_grid_normale[ti_main_new]
//				tv_new_speed = tv_new_sight
//				CR_ActionSet(ACTION_Avance_Attaque, Ci_rotation_coef_avance)
//			}
//			else
//			{
//				// il n'y a de mur ni devant moi, ni sur mon côté préféré : mon déplacement est totalement liiiiiiiibre !!!!! :)
//				ti_obstacle = faux
//				
//				tf_cos_strafe = CR_Way_Strafe_Cosinus_Get()
//				if( tf_dot_Horiz_moveAxis < tf_cos_strafe && tf_dot_Horiz_moveAxis > - tf_cos_strafe )
//				{
//					// Mode de strafe ----------------------------------------------------------------------------------------------------------------
//					
//					switch( i_way_mode_strafe )
//					{
//						case Ci_way_mode_strafe_attack_cote :
//							// raz mode strafe si on vient d'une attaque strafe côté mais pas si on vient d'une attaque strafe face
//							i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin
//							break
//							
//						case Ci_way_mode_strafe_attack_face :
//							// je reviens du mode attaque strafe de face
//							CR_Strafe_Attack_Face_Delay_Random()
//							i_way_mode_strafe = Ci_way_mode_strafe_attack_face_retour
//							break
//						
//						case Ci_way_mode_strafe_attack_face_retour :
//							if( tf_dot_Horiz_moveAxis < f_way_cos_attack_strafe && tf_dot_Horiz_moveAxis > - f_way_cos_attack_strafe )
//							{
//								i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin
//								CR_Intimidation_Delay_Reset()		// intimide après un strafe attack de face
//							}
//							break
//						
//						default: 
//							// Ci_way_mode_strafe_aucun_ou_requin => rien à changer...
//							break
//					}
//					
//					// Comportement ----------------------------------------------------------------------------------------------------------------
//					
//					// CIBLE DEVANT MOI OU DERRIERE MOI
//					if( tf_dot_Sight_moveAxis < 0 && i_way_mode_strafe != Ci_way_mode_strafe_attack_face_retour )
//					{
//						// CIBLE DERRIERE MOI
//						CR_ActionSet(ACTION_SurPlace, Ci_rotation_coef_sur_place)
//					}
//					else
//					{
//						// CIBLE DEVANT MOI
//						if( ! i_antre_move_flag
//							&& ! f_intimidation_delay
//							&& ( i_modele == MODELE_Petit || MATH_VecDotProduct( @o_fight_actor OBJ_SightGet(), - tv_me_to_target_N) < Cf_Cos30 )
//							&& MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_target_N) > Cf_Cos30
//							&& ( i_modele == MODELE_Petit || tf_dist_to_target > f_way_dist_strafe_fight_rot )
//							&& ! CR_Cadavre_Find(o_fight_actor) )
//						{
//							// PASSAGE EN INTIMIDATION : fin d'un strafe ou timer + pas dans le sight de la cible + la cible est dans mon sight + pas au contact
//							CR_ActionSet(ACTION_Intimidation, Ci_rotation_coef_intimidation)
//						}
//						else
//						{
//							// PAS D'INTIMIDATION : DEPLACEMENT
//							if( o_fight_actor && ! CR_Cadavre_Find(o_fight_actor) )
//							{
//								// j'ai une cible, et il ne s'agit pas d'un cadavre
//								if( CR_Strafe_Attack_Face_Allowed(tf_dist_to_target) )
//								{
//									// attaque strafe alors qu'on est de face : je me tourne du côté de ma cible pour attaquer + vite
//									i_way_mode_strafe = Ci_way_mode_strafe_attack_face
//									if( CR_Strafe_En_Cours() )
//									{
//										if( CR_Strafe_Cote_Get() == 1.0 )
//											ti_action = ACTION_StrafeG
//										else
//											ti_action = ACTION_StrafeD
//									}
//									else if( MATH_VecDotProduct(OBJ_HorizonGet(), tv_me_to_target) > 0 )
//										ti_action = ACTION_StrafeG
//									else
//										ti_action = ACTION_StrafeD
//									if( CR_ActionSet(ti_action, Ci_rotation_coef_strafe) )
//									{
//										// raz timers strafe requin
//										CR_Strafe_Requin_Delay_Random()
//										CR_Strafe_Requin_Duration_Reset()
//									}
//								}
//								else if( CR_Strafe_Requin_Allowed(tf_dist_to_target) )
//								{
//									// strafe requin : côté aléatoire
//									if( CR_Strafe_En_Cours() )
//									{
//										if( CR_Strafe_Cote_Get() == 1.0 )
//											ti_action = ACTION_StrafeG
//										else
//											ti_action = ACTION_StrafeD
//									}
//									else if( MATH_RandFloat(-1.0,1.0) < 0.0 )
//										ti_action = ACTION_StrafeG
//									else
//										ti_action = ACTION_StrafeD
//									if( CR_ActionSet(ti_action, Ci_rotation_coef_strafe) )
//									{
//										// raz timers attaque strafe de face
//										CR_Strafe_Attack_Face_Delay_Random()
//										CR_Strafe_Attack_Face_Duration_Reset()
//										f_way_requin_radian = f_way_requin_coef * Cf_PiBy2
//										tv_new_sight = MATH_VecRotate(tv_new_sight, Cv_VerticalVector, - CR_Strafe_Cote_Get() * f_way_requin_radian)
//									}
//								}
//								else
//								{
//									// avance
//									CR_ActionSet(ACTION_Avance_Attaque, Ci_rotation_coef_avance)
//								}
//							}
//							else
//							{
//								// cadavre ou retour à mon antre : avance
//								CR_ActionSet(ACTION_Avance_Attaque, Ci_rotation_coef_avance)
//							}
//						}
//					} // fin "cible devant moi"
//				}  // fin "cible devant ou derrière moi"
//				else
//				{
//					// CIBLE SUR LES COTES
//					
//					// Mode de strafe ----------------------------------------------------------------------------------------------------------------
//					if( CR_Strafe_Attack_Face_Allowed(tf_dist_to_target) )
//					{
//						// je passe ici à cause d'une attaque strafe -> à la fin de mon attaque je me remet face à elle
//						i_way_mode_strafe = Ci_way_mode_strafe_attack_face
//					}
//					else
//					{
//						i_way_mode_strafe = Ci_way_mode_strafe_attack_cote
//					}
//					
//					// Comportement ----------------------------------------------------------------------------------------------------------------
//					
//					if( tf_dist_to_target > f_way_dist_strafe_fight_rot )
//						tf_strafe_rotation_coef = 0.0			// loin : strafe en ligne droite vers la cible
//					else
//						tf_strafe_rotation_coef  = 1.0 - ( MATH_FloatMax(tf_dist_to_target, CR_Fight_Actor_Pos_Offset_Get() / 2.0) / f_way_dist_strafe_fight_rot )		// proche : strafe en tournant autour de la cible
//					
//					if( ! CR_Strafe_En_Cours() )
//						CR_Strafe_Begin(MATH_FloatSign(tf_dot_Horiz_moveAxis))
//					
//					tv_new_horizon = CR_Strafe_Cote_Get() * tv_me_to_target
//					tv_new_horizon =  MATH_VecRotate(tv_new_horizon, Cv_VerticalVector, CR_Strafe_Cote_Get() * Cf_PiBy2 * tf_strafe_rotation_coef )
//					tv_new_sight = MATH_VecCrossProduct(tv_new_horizon, Cv_VerticalVector)
////					DBG_RenderVector(OBJ_PosGet(), tv_new_horizon, color_bleu)
////					DBG_RenderVector(OBJ_PosGet(), tv_new_sight, color_rouge)
//					
//					if( CR_Strafe_Cote_Get() == 1.0 )
//						ti_action = ACTION_StrafeG
//					else
//						ti_action = ACTION_StrafeD
//					CR_ActionSet(ti_action, Ci_rotation_coef_strafe)
//				}
//			}
//		} // fin "pas de mur devant"
//	} // fin "déplacement nécessaire"'
//} // fin if( ti_move )
//
//
//if( i_DBG_display_fight_stats )
//{
//	Str_DisplayVectorOnce(tv_me_to_target, cvector(0,0,0) )
//	Str_DisplayIntOnce(ti_main, cvector(0,0.1,0) )
//	Str_DisplayIntOnce(ti_sec, cvector(0.1,0.1,0) )
//}
//
//
//// ORIENTATION --------------------------------------------------------------------
//DBG_RenderVector(OBJ_PosGet(), tv_new_sight * 10, color_vert)
//OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, f_paf_rotation_coef * 3.0 * TIME_GetDt()),Cv_VerticalVector)
//
//
//// VITESSE -----------------------------------------------------------------------------
//tf_speed_coef = CR_Speed_Coef_Get(ti_obstacle)
//if( ti_obstacle )
//{
//	// CONTOURNEMENT
//	i_way_mode_strafe = Ci_way_mode_strafe_aucun_ou_requin
//
//	tv_last_speed = DYN_SpeedGetVector()
//	tf_speed = MATH_VecNorm(tv_last_speed)
//	if( tf_speed )
//		MATH_VecSetNorm(tv_new_speed, tf_speed)
//	
//	DYN_SpeedSetVector(MATH_VecBlend(tv_last_speed, tv_new_speed, 10.0 * TIME_GetDt()))
//	DBG_RenderVector(OBJ_PosGet(), tv_new_speed * 10, color_cyan)
//	
//	CR_Intimidation_Delay_Random()
//	CR_Strafe_Requin_Delay_Random()
//	CR_Strafe_Attack_Face_Delay_Random()
//}
//ACT_LIB_ActionFrequencyMultiply(tf_speed_coef)
//
//
//// INTIMIDATION DEBUT COMBAT ------------------------------------------------
//if( tf_dist_to_target >= f_way_dist_reset_intimid )
//	i_attack_intimidation_done = faux
//
//if( i_paf_faible_flag )
//{
//	CR_Intimidation_Delay_Random()
//}
//