//#include "CR_defines.var"
//
//float				tf_dot
//float				tf_dist_proj
//float				tf_proj_cote
//float				tf_calcul_cote
//float				tf_dot_Horiz_moveAxis
//float				tf_dot_Sight_moveAxis
//float				tf_test_cote
//float				tf_dist_me_to_actor
//float				tf_strafe_rotation_coef
//float				tf_cos_strafe
//float				tf_dot_normaleWall_to_Actor
//
//messageid		tmid_vision
//
//vector			tv_new_sight
//vector			tv_new_horizon
//vector			tv_me_to_actor
//vector			tv_me_to_actor_N
//vector			tv_actor_proj_pos
//vector			tv_actor_proj_axis
//vector			tv_pos_blend_horizon
//vector			tv_me_to_pos_blend_horizon
//vector			tv_temp
//vector			tv_pos
//vector			tv_lray_pos
//vector			tv_lray_sight
//vector			tv_move_axis
//vector			tv_gauche
//
//int					ti_strafeG_ok
//int					ti_strafeD_ok
//
//object			to_ray_object
//object			to_my_lray_bone
//object			to_FA_lray_bone
//
//
//// SORTIE ETAT ==============================================================================
//if (i_sort_etat)
//{
//	i_sort_etat = faux
//	return
//}
//
//
//// ENTREE ETAT ==============================================================================
//if (i_etat_courant != ETAT_FIGHT )
//{
//	i_etat_ancien = i_etat_courant
//	i_etat_courant = ETAT_FIGHT
//	
//	if (fct_etat_courant)
//	{
//		i_sort_etat = vrai
//		AI_Execute(fct_etat_courant)
//	}
//	
//	fct_etat_courant = AI_TrackCurGet()
//	fct_etat_main = AI_TrackCurGet()
//	f_time_start_etat = 0.0
//	
//	o_fight_actor = EVENT_InteretTargetGet(mid_best_interet)
//	
//	i_attack_paf_done = faux
//	f_way_intimidation_delay = MATH_RandFloat(f_way_intimidation_delay_min, f_way_intimidation_delay_max)
//	i_way_mode = Ci_way_mode_no_obstacle
//	i_way_mode_strafe = Ci_way_mode_strafe_requin
//}
//else
//{
//	f_time_start_etat += TIME_GetDt()
//}
//
//
//// ANALYSE ===================================================================================
//AI_Execute("CR_exec_CHECK_Vision")
//
//AI_Execute("CR_exec_CHECK_Paf")
//if( CR_Paf_Check_Change_Etat() )
//	macro_change_etat("CR_ETAT_PAF")
//
//if( ! MSG_GlobalIsValid(mid_best_interet) )
//	macro_change_etat("CR_ETAT_IDLE")
//
//// COMPORTEMENT =============================================================================
//
//// INTERET ------------------------------------------------------------------------------------------
//if( CR_Perceived_Actor_Check(o_fight_actor, tmid_vision) )
//	CR_Interet_Update(mid_best_interet, C_EVENT_InteretStatusAttack, o_fight_actor, tmid_vision)
//
//// DEPLACEMENT  ------------------------------------------------------------------------------
//tv_new_sight = Cv_NullVector
//tv_me_to_actor = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
//tv_me_to_actor_N = MATH_VecNormalize(tv_me_to_actor)
//tf_dist_me_to_actor = MATH_VecNorm(tv_me_to_actor)
//tv_gauche = MATH_VecCrossProduct(Cv_VerticalVector, OBJ_SightGet())
//
//// CALCUL DU DEPLACEMENT RESTANT
//v_way_dest_pos = EVENT_InteretPositionGet(mid_best_interet)
//DBG_RenderVector(v_way_dest_pos, Cv_VerticalVector * 10, color_bleu)
//AI_Execute("CR_exec_WAY_Move")
//
//tv_move_axis = tv_me_to_actor
////DBG_RenderVector(OBJ_PosGet(), v_joy_dir * f_way_length, color_jaune)
//DBG_RenderVector(OBJ_PosGet(), tv_me_to_actor, color_vert)
////DBG_RenderVector(OBJ_PosGet(), tv_gauche * 5, color_bleu)
//
//
//tf_dot_Horiz_moveAxis = MATH_VecDotProduct(OBJ_HorizonGet(), MATH_VecNormalize(tv_move_axis))
//tf_dot_Sight_moveAxis = MATH_VecDotProduct(OBJ_SightGet(), MATH_VecNormalize(tv_move_axis))
//
//// ACTION -------------------------------------------------------------------------------------------
//switch( ACT_ActionGet() )
//{
//	case ACTION_Intimidation :
//		// INTIMIDATION =============================================================================
//		if( ACT_ActionFinished() )
//		{
//			f_way_intimidation_delay = MATH_RandFloat(f_way_intimidation_delay_min, f_way_intimidation_delay_max)
//			ACT_ActionSet(ACTION_Attente)
//			CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//		}
//		break
//		
//	case ACTION_AttackG :
//	case ACTION_AttackD :
//		// ATTAQUE EN COURS ======================================================================
//		if( ACT_ActionFinished() )
//		{
//			// FIN D'ATTAQUE
//			i_attack_paf_done = faux
//			f_attack_delay = MATH_RandFloat(3.0, 5.0)
//			ACT_ActionSet(ACTION_Attente)
//		}
//		else
//		{
//			// TEST PAF
//			if( ! i_attack_paf_done && COL_ZDE_ZDECollide(o_fight_actor, C_zde_fight, C_zde_corps) )
//			{
//				DBG_TraceString("=== ")
//				DBG_TraceObject(OBJ_Me())
//				DBG_TraceString(" paffe ")
//				DBG_TraceObject(o_fight_actor)
//				DBG_TraceString(" ZDE Fight / ZDE Corps")
//				DBG_TraceEOL()
//				i_attack_paf_done = vrai
//				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, i_paf_to_send_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, PAF_Unit * 5, OBJ_SightGet())
//				CR_Paffed_Actor_Add(o_fight_actor)
//			}
//		}
//		break
//	
//	default:
//		// ATTENTE OU DEPLACEMENT =============================================================
//		if( ! f_way_intimidation_delay
//			&& MATH_VecDotProduct( @o_fight_actor OBJ_SightGet(), - tv_me_to_actor_N) < Cf_Cos30
//			&& MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_actor_N) > Cf_Cos30
//			&& tf_dist_me_to_actor > f_way_dist_strafe_fight_rot 
//			&& i_way_mode == Ci_way_mode_no_obstacle )
//		{
//			// PASSAGE EN INTIMIDATION : fin d'un strafe ou timer + pas dans le sight de la cible + la cible est dans mon sight + pas au contact
//			ACT_ActionSet(ACTION_Intimidation)
//			CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
//		}
//		else if( f_joy_norm )
//		{
//			// IL Y A UN DEPLACEMENT A EFFECTUER -------------------------------------
//			switch( i_way_mode )
//			{
//				// PAS D'OBSTACLE =================================================================
//				case Ci_way_mode_no_obstacle :
//					if( i_way_mode_strafe == Ci_way_mode_strafe_requin )
//						tf_cos_strafe = f_way_cos_attack_strafe		// cos pour passer en strafe
//					else if( i_way_mode_strafe == Ci_way_mode_strafe_direct )
//						tf_cos_strafe = f_way_cos_strafe_exit			// cos pour quitter le strafe attaque
//					else
//					{
//						DBG_TraceString("i_way_mode_strafe inconnu = ")
//						DBG_TraceInt(i_way_mode_strafe)
//						DBG_TraceEOL()
//						DBG_Error("i_way_mode_strafe inconnu ???")
//					}
//					
//					if( tf_dot_Horiz_moveAxis < tf_cos_strafe && tf_dot_Horiz_moveAxis > - tf_cos_strafe )
//					{
//						// CIBLE DEVANT OU DERRIERE MAIS PAS DANS LES CONES DE STRAFE
//						i_way_mode_strafe = Ci_way_mode_strafe_requin
//						if( tf_dot_Sight_moveAxis < 0 )
//						{
//							// CIBLE DERRIERE
//							ACT_ActionSet(ACTION_SurPlace)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
//						}
//						else
//						{
//							// CIBLE DEVANT MOI
//							if( CR_Way_Grid_Check_Dir(OBJ_SightGet()) )
//							{
//								// PAS D'OBSTACLE DEVANT
//								PAS_D_OBSTACLE_DEVANT:
//								
//								f_way_strafe_sens_pref = 0.0
//								if( CR_Strafe_Allowed() )
//								{
//									// timer strafe ok
//									if( ! CR_Strafe_En_Cours() )
//									{
//										// Passage en strafe : test des 2 côtés
//										ti_strafeG_ok = CR_Way_Grid_Check_Dir(tv_gauche)
//										ti_strafeD_ok = CR_Way_Grid_Check_Dir( - tv_gauche)
//										if( f_way_last_obstacle_time <= Cf_obstacle_strafe_cote_backup_delay )
//										{
//											// délai pendant lequel le crabe ne repartira pas en strafe du côté duquel il vient après avori strafé pour éviter un obstacle
//											if( f_way_obstacle_cote_backup == 1.0 )
//												ti_strafeD_ok = faux		// j'ai contourné par la gauche, je n'ai pas le droit de repartir vers la droite
//											else if( f_way_obstacle_cote_backup == -1.0 )
//												ti_strafeG_ok = faux		// j'ai contourné par la droite, je n'ai pas le droit de repartir vers la gauche
//										}
//										
//										// Passage en strafe : choix du côté de strafe
//										if( ti_strafeG_ok && ti_strafeD_ok )
//											CR_Strafe_Begin(MATH_FloatSign(MATH_RandFloat(-1.0,1.0)))
//										else if( ti_strafeG_ok )
//											CR_Strafe_Begin(1.0)
//										else if( ti_strafeD_ok )
//											CR_Strafe_Begin(-1.0)
//										else
//											goto AVANCE
//									}
//									else
//									{
//										// Déjà en strafe : check obstacle dans le sens du strafe
//										if( ! CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche) )
//										{
//											// Obstacle du côté du strafe
//											if( CR_Strafe_Cote_Get() == MATH_FloatSign(tf_dot_Horiz_moveAxis) )
//											{
//												// ma cible est derrière l'obstacle : est-ce que je dois le contourner ???
//												if( tf_dot_Sight_moveAxis > Cf_Cos45 )
//												{
//													// ma cible est devant moi -> je coupe le strafe mais l'obstacle ne me gène pas
//													CR_Strafe_End_And_Delay()
//													goto AVANCE
//												}
//												else
//												{
//													// ma cible est sur le côté, le mur me gène
//													i_way_mode = Ci_way_mode_obstacle_tourne
//													i_way_obstacle_flag_init = vrai
//													i_way_mode_obstacle_init = Ci_way_mode_obstacle_init_strafe
//												}
//											}
//											else
//											{
//												// l'obstacle n'est pas du même côté (horizon) que ma cible -> je coupe le strafe mais l'obstacle ne me gène pas
//												CR_Strafe_End_And_Delay()
//												goto AVANCE
//											}
//										}
//										else
//										{
//											// pas d'obstacle en strafe : rotation en strafe pour se rapprocher de la cible
//											tv_new_sight = tv_me_to_actor
//											tv_new_sight = MATH_VecRotate(tv_new_sight, Cv_VerticalVector, - CR_Strafe_Cote_Get() * Cf_PiBy8)
//										}
//									}
//								}
//								else
//								{
//									// timer strafe pas ok
//									if( CR_Strafe_En_Cours() )
//										CR_Strafe_End_And_Delay()
//									
//									AVANCE:
//									ACT_ActionSet(ACTION_Avance_Attaque)
//									CR_Rotation_Coef_Set(Ci_rotation_coef_avance)
//								}
//							}
//							else
//							{
//								// OBSTACLE DEVANT LE CRABE
//								CR_Way_Get_Obstacle_Pos()
//								if( f_way_obstacle_dist > tf_dist_me_to_actor )
//									goto PAS_D_OBSTACLE_DEVANT
//								
//								i_way_mode = Ci_way_mode_obstacle_tourne
//								i_way_obstacle_flag_init = vrai
//								i_way_mode_obstacle_init = Ci_way_mode_obstacle_init_devant
//							}
//						}
//					}
//					else
//					{
//						// CIBLE DANS LES CONES DE STRAFE : calcul d'un point devant la cible vers lequel strafer
//						i_way_mode_strafe = Ci_way_mode_strafe_direct
//						
//						if( ! CR_Strafe_En_Cours() )
//							CR_Strafe_Begin(MATH_FloatSign(tf_dot_Horiz_moveAxis))
//						
//						if( CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche) )
//						{
//							// PAS D'OBSTACLE DANS LE SENS DU STRAFE
//							if( tf_dist_me_to_actor > f_way_dist_strafe_fight_rot )
//								tf_strafe_rotation_coef = 0.0			// loin : strafe en ligne droite vers la cible
//							else
//								tf_strafe_rotation_coef = 1.0 - ( MATH_FloatMax(tf_dist_me_to_actor, f_way_dist_position_fight / 2.0) / f_way_dist_strafe_fight_rot )		// proche : strafe en tournant autour de la cible
//							
//							tv_new_horizon = CR_Strafe_Cote_Get() * tv_me_to_actor
//							tv_new_horizon = MATH_VecRotate(tv_new_horizon, Cv_VerticalVector, CR_Strafe_Cote_Get() * Cf_PiBy2 * tf_strafe_rotation_coef )
//							tv_new_sight = MATH_VecCrossProduct(tv_new_horizon, Cv_VerticalVector)
//							DBG_RenderVector(OBJ_PosGet(), tv_new_horizon, color_bleu)
//							DBG_RenderVector(OBJ_PosGet(), tv_new_sight, color_rouge)
//						}
//						else
//						{
//							// OBSTACLE DANS LE SENS DU STRAFE
//							i_way_mode = Ci_way_mode_obstacle_tourne
//							i_way_obstacle_flag_init = vrai
//							i_way_mode_obstacle_init = Ci_way_mode_obstacle_init_strafe
//						}						
//					}
//					break
//				
//				// OBSTACLE (TOURNE) ======================================================================
//				case Ci_way_mode_obstacle_tourne :
//					if( i_way_obstacle_flag_init )
//					{
//						// INIT contournement d'obstacle
//						i_way_obstacle_flag_init = faux
//						
//						i_way_mode_strafe = Ci_way_mode_strafe_requin		// RAZ mode de strafe
//						
//						CR_Way_Get_Obstacle_Pos()
//						
//						tv_lray_sight = ( f_way_obstacle_dist + 1.0 ) * v_way_obstacle_dir_N		// LRAY 1 m + loin pour bien rentrer dans le mur
//						tv_lray_pos = OBJ_PosGet() + Cv_VerticalVector
//						DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//						
//						to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//						if( ! to_ray_object )
//							DBG_Error("???? lray null alors que je suis censé avoir un obstacle ???")
//						else
//						{
//							v_way_obstacle_normale = COL_RayObject_NormalGet()
//							DBG_RenderVector(tv_lray_pos, v_way_obstacle_pos - tv_lray_pos, color_vert)
//						}
//					}
//					else
//					{
//						// je tourne sur place pour m'aligner au mur, ensuite je le longerai...
//						if( MATH_VecDotProduct(OBJ_SightGet(), - v_way_obstacle_normale) > Cf_Cos20 )
//							i_way_mode = Ci_way_mode_obstacle_strafe
//					} 
//					// action (après les init car j'ai besoin de savoir le côté du strafe courant pour les calculs)
//					ACT_ActionSet(ACTION_SurPlace)
//					CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
//					tv_new_sight = - v_way_obstacle_normale
//					break
//				
//				// OBSTACLE (LONGE) ======================================================================
//				case Ci_way_mode_obstacle_strafe :
//					// le crabe longe le mur...
//					tv_new_sight = - v_way_obstacle_normale
//					if( ! CR_Strafe_En_Cours() )
//					{
//						tf_dot_normaleWall_to_Actor = MATH_VecDotProduct(- v_way_obstacle_normale, tv_me_to_actor)
//						f_way_strafe_sens_pref = CR_Strafe_Cote_Select(tf_dot_normaleWall_to_Actor, tv_gauche)
//						CR_Strafe_Begin(f_way_strafe_sens_pref)
//						f_way_obstacle_cote_backup = f_way_strafe_sens_pref			// memorise le sens du strafe pour contourner
//					}
//					
//					if( CR_Way_Grid_Check_Dir(CR_Strafe_Cote_Get() * tv_gauche) )
//					{
//						// Pas d'obstacle du côté du strafe
//						to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//						to_my_lray_bone = o_bone_carapace
//						tv_lray_pos = @to_my_lray_bone OBJ_PosGet() + MATH_VecLocalToGlobal( - CR_Strafe_Cote_Get() * cvector(2.0 * f_zoom, 0.0, 0.0))	// LRAY sur le côté pour s'assurer qu'on a bien dépassé le mur
//						tv_lray_sight = - v_way_obstacle_normale * (f_way_obstacle_dist + 1.0)	// pour bien rentrer dans le mur
//						DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//						to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//						if( ! to_ray_object ) 
//						{
//							i_way_mode = Ci_way_mode_no_obstacle		// obstacle contourné !!!!
//							f_way_strafe_sens_pref = 0.0			// le sens de strafe n'est plus imposé
//							f_way_last_obstacle_time = 0.0
//						}
//					}
//					else
//					{
//						// nouvel obstacle dans le sens du strafe
////						i_way_mode = Ci_way_mode_obstacle_tourne
////						i_way_obstacle_flag_init = vrai
////						i_way_mode_obstacle_init = Ci_way_mode_obstacle_init_strafe
//						v_way_obstacle_pos = @get_global v_grid_lib_last_blocked_pos
//						f_way_strafe_sens_pref *= -1
//						CR_Strafe_Begin(f_way_strafe_sens_pref)
//						f_way_obstacle_cote_backup = f_way_strafe_sens_pref			// memorise le sens du strafe pour contourner
//					}
//					break
//				
//				default:
//					DBG_TraceString("i_way_mode inconnu = ")
//					DBG_TraceInt(i_way_mode)
//					DBG_TraceEOL()
//					DBG_Error("i_way_mode inconnu ???")
//					break
//			}
//		}
//		else
//		{
//			// DEPLACEMENT TERMINE ---------------------------------------------------------
//			
//			// ORIENTATION VERS CIBLE
//			if( tf_dot_Sight_moveAxis < f_way_cos_attack_pince )
//			{
//				// se tourne pour se mettre en face de la cible pour porter un coup de pince (paf ou grab)
//				ACT_ActionSet(ACTION_SurPlace)
//				CR_Rotation_Coef_Set(Ci_rotation_coef_sur_place)
//			}
//			// SINON DEBUT D'INTIMIDATION
//			else if( i_DBG_fight_intimidation && ! i_attack_intimidation_done )
//			{
//				ACT_ActionSet(ACTION_Intimidation)
//				i_attack_intimidation_done = vrai
//				CR_Rotation_Coef_Set(Ci_rotation_coef_intimidation)
//			}
//			// SINON DEBUT D'ATTAQUE
//			else if( ! f_attack_delay )
//			{
//				to_FA_lray_bone = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
//				to_my_lray_bone = o_bone_carapace
//				tv_lray_pos = @to_my_lray_bone OBJ_PosGet()
//				tv_lray_sight = @to_FA_lray_bone OBJ_PosGet() - tv_lray_pos
//				DBG_RenderVector(tv_lray_pos, tv_lray_sight, color_blanc)
//				to_ray_object = COL_RayObject_Vector(tv_lray_pos, tv_lray_sight, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//				if( to_ray_object || CR_Check_Presence_Interet_Statut_Model(o_fight_actor, faux, C_EVENT_InteretStatusGrab, vrai) ) 
//				{
//					// PAS LE DROIT D'ATTAQUER (MUR, DEJA GRABBE PAR UN BUDY....)
//					ACT_ActionSet(ACTION_Attente)
//					CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//				}
//				else
//				{
//					// PAS D'OBSTACLE ENTRE MA CIBLE ET MOI
//					tv_new_sight = tv_me_to_actor
//					if( MATH_VecDotProduct(OBJ_HorizonGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet()) > 0 )
//					{
//						// GAUCHE
//						if( i_grab )
//						{
//							ACT_ActionSet(ACTION_GrabGdeb)
//							macro_change_etat("CR_ETAT_GRAB")
//						}
//						else
//						{
//							ACT_ActionSet(ACTION_AttackG)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
//						}
//					}
//					else
//					{
//						// DROITE
//						if( i_grab )
//						{
//							ACT_ActionSet(ACTION_GrabDdeb)
//							macro_change_etat("CR_ETAT_GRAB")
//						}
//						else
//						{
//							ACT_ActionSet(ACTION_AttackD)
//							CR_Rotation_Coef_Set(Ci_rotation_coef_attaque)
//						}
//					}
//				}
//			}
//			// SINON ATTENTE
//			else
//			{
//				ACT_ActionSet(ACTION_Attente)
//				CR_Rotation_Coef_Set(Ci_rotation_coef_attente)
//			}
//		}
//		break
//}
//
//
//// ORIENTATION ---------------------------------------------------------------------------
//if( MATH_VecNullEpsilon(tv_new_sight) )
//	tv_new_sight = tv_me_to_actor
//else
//	DBG_RenderVector(OBJ_PosGet(), tv_new_sight * 10.0, color_rouge)		// aff sight calculé
//
//OBJ_BankingGeneralSet(
//	MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, f_way_rotation_coef * TIME_GetDt()),
//	MATH_VecBlendRotate(OBJ_BankingGet(), v_ground_normale, 6.0 * TIME_GetDt()))
//
//// INTIMIDATION DEBUT COMBAT ------------------------------------------------
//if( f_way_length >= 15.0 )
//	i_attack_intimidation_done = faux
//
//