#include "PNJ_Plane_defines.var"

#define Cf_pourcentage			0.3333
#define Cf_angle_ondule_ton_corps				0.5

procedure_local void PNJ_Plane_Init_Net()
{
	int			ti_i	

	float		tf_Z_min
	float		tf_net_length

	object	to_wp_1
	object	to_wp_2
	object	to_wp_3
	object	to_sight_gao
	
	vector	tv_vec1
	vector	tv_vec2
	
	vector	tv_normale
	vector	tv_biscectrice

	// On oriente le sight des wp du reseau de maniere à avoir la perpendiculaire de chaques sommets

	if (!i_net_wp_nb || EDIT)
	{
		i_net_wp_nb = WAY_NetFill(n_net, o_start_wp, &ao_net_wp[0])

		for (ti_i = 0; ti_i < i_net_wp_nb; ti_i++)
		{
			@ao_net_wp[ti_i] OBJ_FlagsIdentitySet(OBJ_C_IdentityFlag_DesignStruct, none)

			if (@ao_net_wp[ti_i] OBJ_CapaTest(Capa_Water))
				f_last_valid_water_Z = MATH_FloatMax(f_last_valid_water_Z, @ao_net_wp[ti_i] OBJ_PosGet().z)
		}
	}

	if (@ao_net_wp[i_net_wp_nb - 1] WAY_HasLinks(n_net, ao_net_wp[0]))
		i_net_loop = vrai

	if (!AUTO_COMPUTE)
		return

	to_wp_1 = o_start_wp
	if (WAY_GetNumLinks(n_net, to_wp_1) > 1)
	{
		// PLUSIEURS LIEN A CE WP
		DBG_BreakPoint()
	}
	to_wp_2 = WAY_NetNextWP(n_net, to_wp_1, 0, 0)
	if (WAY_GetNumLinks(n_net, to_wp_2) > 1)
	{
		// PLUSIEURS LIEN A CE WP
		DBG_BreakPoint()
	}

	to_wp_3 = WAY_NetNextWP(n_net, to_wp_2, 0, 0)
	
//	if (AUTO_BANKING)
//	{
//		if (COL_RayObject_Dist(@to_wp_1 OBJ_PosGet(), -@to_wp_1 OBJ_BankingGet(), 3.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//		{
//			tv_normale = COL_RayObject_NormalGet()
//			tv_normale.z = 0.0
//			@to_wp_1 OBJ_BankingSet(tv_normale)
//		}
//	
//		if (COL_RayObject_Dist(@to_wp_2 OBJ_PosGet(), -@to_wp_2 OBJ_BankingGet(), 3.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//		{
//			tv_normale = COL_RayObject_NormalGet()
//			tv_normale.z = 0.0
//			@to_wp_2 OBJ_BankingSet(tv_normale)
//		}
//	}

	@to_wp_1 OBJ_ZoomSet(1.0)
	@to_wp_1 OBJ_SightGeneralSet(@to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet(), @to_wp_1 OBJ_BankingGet())
	
	tf_net_length = 0.0
	
	// Smooth trajectory
	while (to_wp_2 != o_start_wp && to_wp_3)
	{
//		DBG_RenderVector(@to_wp_2 OBJ_PosGet(), @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet(), color_blanc)	
	
		if (WAY_GetNumLinks(n_net, to_wp_3) > 1)
		{
			// PLUSIEURS LIEN A CE WP
			DBG_BreakPoint()
		}

		tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
//		DBG_RenderVector(@to_wp_1 OBJ_PosGet(), @to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet(), color_blanc)	
		tf_net_length += MATH_VecNorm(tv_vec1)
	
		@to_wp_2 OBJ_ZoomSet(1.0)	
		@to_wp_3 OBJ_ZoomSet(1.0)

		if (AUTO_BANKING && COL_RayObject_Dist(@to_wp_3 OBJ_PosGet(), -@to_wp_3 OBJ_BankingGet(), 3.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_normale = COL_RayObject_NormalGet()
			tv_normale.z = 0.0
			@to_wp_3 OBJ_BankingSet(tv_normale)
		}
	
		tv_vec2 = @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		
		tv_normale = MATH_VecCrossProduct(tv_vec1, tv_vec2)
		MATH_VecSetNormalize(tv_normale)
		
		tv_biscectrice = MATH_VecBlendRotate(tv_vec1, tv_vec2, 0.5)

		@to_wp_2 OBJ_SightGeneralSet(MATH_VecCrossProduct(tv_normale, tv_biscectrice), @to_wp_2 OBJ_BankingGet())
	
		to_wp_1 = to_wp_2
		to_wp_2 = to_wp_3
		to_wp_3 = WAY_NetNextWP(n_net, to_wp_2, 0, 0)

		if (to_wp_2 == o_start_wp)
			i_net_loop = vrai

		if ( ! to_wp_3 || to_wp_2 == to_wp_3)
			break 
	}
	
	tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
//	DBG_RenderVector(@to_wp_1 OBJ_PosGet(), @to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet(), color_blanc)
	tf_net_length += MATH_VecNorm(tv_vec1)
	
	if (to_wp_3)	
	{
		tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		tv_vec2 = @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
		
		tv_normale = MATH_VecCrossProduct(tv_vec1, tv_vec2)
		MATH_VecSetNormalize(tv_normale)
		
		tv_biscectrice = MATH_VecBlendRotate(tv_vec1, tv_vec2, 0.5)
	
		@to_wp_2 OBJ_SightGeneralSet(MATH_VecCrossProduct(tv_normale, tv_biscectrice), @to_wp_2 OBJ_BankingGet())
	}
	else
	{
		@to_wp_2 OBJ_SightGeneralSet(@to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet(), @to_wp_2 OBJ_BankingGet())
	}
	
	STEP_LENGTH = tf_net_length / 200
	
	for (ti_i = 0; ti_i < i_net_wp_nb; ti_i++)
	{
		if (@ao_net_wp[ti_i] OBJ_PosGet().z < f_last_valid_water_Z + 0.5)
			@ao_net_wp[ti_i] OBJ_SightGeneralSet(@ao_net_wp[ti_i] OBJ_SightGet(), Cv_VerticalVector)
	}
}

procedure_local void PNJ_Plane_Position_Set()
{
	int			ti_index
	int			ti_nb_link
	int			ti_flag_ok
	int			ti_current_wp_index
	int			ti_next_wp_index

	float		tf_coef
	float		tf_time_offset
	float		tf_link_coef	
	float		tf_link_length
	float		tf_dist_to_next_wp
	float		tf_time_to_reach_next_wp

	object	to_wp	

	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	if (! n_net)
	{
		i_current_wp_index = 1
		i_flag_net_end = vrai
		return
	} 

	if (!i_net_loop)
	{
		if (i_flag_net_end && f_move_length > 0.0)
		{
			f_move_length = 0.0

			if (EDIT)
				f_move_speed = 0.0
		}
		else if (i_flag_net_start && f_move_length < 0.0)
		{
			f_move_length = 0.0

			if (EDIT)
				f_move_speed = 0.0
		}
	}

	if (!f_move_length && (i_etat_courant != -1 && !EDIT))
		return

	tf_time_offset = 0.8

	ti_flag_ok = vrai

	ti_current_wp_index = i_current_wp_index
	ti_next_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)

	o_next_wp = ao_net_wp[ti_next_wp_index]

	tf_link_length = WAY_LinkWeightGet(n_net, ao_net_wp[ti_current_wp_index], ao_net_wp[ti_next_wp_index])

	f_snap_coef -= MATH_FloatMin(f_snap_coef, TIME_GetDt())

	if (@o_next_wp OBJ_CapaTest(Capa_Stop))
	{
		tf_dist_to_next_wp = tf_link_length - f_link_coef
		tf_time_to_reach_next_wp = tf_dist_to_next_wp / f_move_speed
		
		if (tf_time_to_reach_next_wp < 1.0)
		{	
			// il faut ralentir
			f_snap_coef = 1.0 - tf_time_to_reach_next_wp
		
			f_move_length = MATH_FloatMax(f_move_speed * tf_time_to_reach_next_wp, 0.1) * TIME_GetDt()
		}
	}

	tf_link_coef = f_link_coef
	tf_link_coef += f_move_length

//	if (@ao_net_wp[ti_next_wp_index] OBJ_CapaTest(Capa_Stop) && tf_link_coef > tf_link_length - 1.0)

	tf_coef = tf_link_coef / tf_link_length

	tf_coef = MATH_FloatRound(tf_coef, 0.001)

	// On avance ?
	while(tf_coef > 1.0)
	{
//		if (@ao_net_wp[ti_next_wp_index] OBJ_CapaTest(Capa_Water))
//			i_flag_in_water	 =  vrai
//		else
//			i_flag_in_water	 = faux

		if (!i_net_loop && ti_current_wp_index == i_net_wp_nb - 2)
		{
			i_flag_destroy = vrai
		
			i_current_wp_index = i_net_wp_nb - 2
			f_link_coef = 0.0
			tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())

			f_move_length = tf_link_length

			if (EDIT)
				f_move_speed = 0.0

			PNJ_Plane_Position_Set()
			return
		}	
	
		ti_current_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)
		ti_next_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)

		if (ao_net_wp[ti_current_wp_index].des_float1 > 0.001)
			f_move_dest_speed = ao_net_wp[ti_current_wp_index].des_float1

		tf_link_coef -= tf_link_length
		tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())

		tf_coef = tf_link_coef / tf_link_length
	}

	// On recule ?
	while(tf_coef < 0.0)
	{
		if (!i_net_loop && !ti_current_wp_index)
		{
			if (i_flag_net_end)
			{
				// LE RESEAU EST TROP COURT !!!
				DBG_BreakPoint()
			}

			i_current_wp_index = 0
			f_link_coef = 0.0

			f_move_length = 0.0

			if (EDIT)
				f_move_speed = 0.0
			
			PNJ_Plane_Position_Set()
			return
		}

//		if (@ao_net_wp[ti_next_wp_index] OBJ_CapaTest(Capa_Water))
//			i_flag_in_water	 =  vrai
//		else
//			i_flag_in_water	 = faux

		ti_current_wp_index = MATH_Modulo(ti_current_wp_index + i_net_wp_nb - 1, i_net_wp_nb)
		ti_next_wp_index = MATH_Modulo(ti_current_wp_index + 1, i_net_wp_nb)

		if (ao_net_wp[ti_current_wp_index].des_float1 > 0.001)
			f_move_dest_speed = ao_net_wp[ti_current_wp_index].des_float1

		tf_link_length = MATH_VecNorm(@ao_net_wp[ti_next_wp_index] OBJ_PosGet() - @ao_net_wp[ti_current_wp_index] OBJ_PosGet())
		tf_link_coef += tf_link_length

		tf_coef = tf_link_coef / tf_link_length
	}

	if (EDIT != ETAT_TEST && @ao_net_wp[ti_current_wp_index] OBJ_CapaTest(Capa_Stop))
	{
		f_snap_coef = 1.0
	
		f_move_speed = 0.0
		f_move_length = 0.0

		tf_coef = 0.0
		tf_link_coef = 0.0
	}

	i_current_wp_index = ti_current_wp_index
	f_link_coef = tf_link_coef

	if (tf_coef || i_current_wp_index)
		i_flag_net_start = faux

	if (ti_current_wp_index != i_net_wp_nb - 2 || tf_coef < 1.0)
	{
		i_flag_net_end = faux
	}
	else
	{
		i_flag_net_end = vrai
		o_next_wp = nobody
	}

	// Smooth trajectory
	tv_point_A = @ao_net_wp[ti_current_wp_index] OBJ_PosGet()
	tv_point_B = tv_point_A 
	tv_point_B += @ao_net_wp[ti_current_wp_index] OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @ao_net_wp[ti_current_wp_index] OBJ_ScaleGet().y))
	
	tv_point_D = @ao_net_wp[ti_next_wp_index] OBJ_PosGet()
		
	tv_point_C = tv_point_D
	tv_point_C -= @ao_net_wp[ti_next_wp_index] OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @ao_net_wp[ti_next_wp_index] OBJ_ScaleGet().y))
	
	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
	tv_point_C += (tv_point_D - tv_point_C) * tf_coef
	
	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
	
	// Orientation
	v_spline_sight = MATH_VecNormalize(tv_point_B - tv_point_A)
	tv_point_C = MATH_VecBlendRotate(@ao_net_wp[ti_current_wp_index] OBJ_BankingGet(), @ao_net_wp[ti_next_wp_index] OBJ_BankingGet(), tf_coef)
	OBJ_SightGeneralSet(v_spline_sight, tv_point_C)

	// Position
	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	OBJ_PosSet(tv_point_A)
}

procedure_local void PNJ_Plane_DBG_Render_Net()
{
#ifndef _FINAL_
	int			ti_index
	int			ti_nb_link	
	int			ti_flag_no_cycl

	float		tf_coef
	float		tf_link_coef
	float		tf_link_length
	
	object	to_current_wp
	object	to_next_wp
	object	to_wp

	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D

	vector	tv_start_pos

	to_current_wp = o_start_wp
	to_wp = WAY_NetNextWP(n_net, to_current_wp, 0, 0)
	to_next_wp = to_wp

	tf_link_coef = 0.0	tv_start_pos = @to_current_wp OBJ_PosGet()
	tf_link_length = MATH_VecNorm(@to_next_wp OBJ_PosGet() - @to_current_wp OBJ_PosGet())

	ti_flag_no_cycl = faux

	while (to_wp)
	{
		tf_link_coef += STEP_LENGTH
	
		tf_coef = tf_link_coef / tf_link_length
	
		while(tf_coef > 1.0)
		{
			to_wp = WAY_NetNextWP(n_net, to_next_wp, 0, 0)
			if (to_next_wp == o_start_wp)
				to_wp = nobody
	
			if (to_wp)	
			{
				to_current_wp = to_next_wp
				to_next_wp = to_wp
				
				tf_link_coef	-= tf_link_length
				tf_link_length = MATH_VecNorm(@to_next_wp OBJ_PosGet() - @to_current_wp OBJ_PosGet())

				tf_coef = tf_link_coef / tf_link_length
			}
			else
			{
				tf_coef = 1.0
			}
		}
		
		// Smooth trajectory
		tv_point_A = @to_current_wp OBJ_PosGet()
		
		tv_point_B = tv_point_A 
		tv_point_B += @to_current_wp OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @to_current_wp OBJ_ScaleGet().y))
		
		tv_point_D = @to_next_wp OBJ_PosGet()
			
		tv_point_C = tv_point_D
		tv_point_C -= @to_next_wp OBJ_SightGet() * (tf_link_length * (Cf_pourcentage * @to_next_wp OBJ_ScaleGet().y))
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		tv_point_C += (tv_point_D - tv_point_C) * tf_coef
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		
		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		
	//	tv_point_B = @o_current_wp OBJ_PosGet()
	//	tv_point_B += MATH_VecNormalize(@o_next_wp OBJ_PosGet() - @o_current_wp OBJ_PosGet()) * f_link_coef
	//	DBG_RenderVector(tv_point_B, tv_point_A - tv_point_B, color_blanc)
	
		DBG_RenderVector(tv_start_pos, tv_point_A - tv_start_pos, color_blanc)
		tv_start_pos = tv_point_A
	}
#endif
}

procedure_local void PNJ_Plane_Roll()
{
	vector	tv_last_pos	
	vector	tv_water_move_offset

	float		tf_inv_dt
	float		tf_coef
	float		tf_friction
	float		tf_friction_coef

	vector	tv_speed
	vector	tv_acceleration
	vector	tv_forces
	vector	tv_pivot_pos	

	object	to_canal

	to_canal = ANI_CanalObjectGet(0)

	tf_inv_dt = 1.0 / TIME_GetDt()

	tv_speed = @to_canal OBJ_PosGet() - v_last_pos
	tv_speed *= tf_inv_dt

	v_last_pos = @to_canal OBJ_PosGet()

	tv_acceleration = tv_speed - v_last_speed
	tv_acceleration *= tf_inv_dt

	v_last_speed = tv_speed

	OBJ_SightGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
	@to_canal OBJ_RestoreInitMatrix()
	@to_canal OBJ_SightGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
	
	tv_pivot_pos = @to_canal MATH_VecGlobalToLocal(OBJ_PosGet() - @to_canal OBJ_PosGet())

	f_in_water_coef = MATH_FloatLimit(((f_last_valid_water_Z + 2.0) - OBJ_PosGet().z) / 2.0, 0.0, 1.0)

	tv_forces = Cv_NullVector

//	tf_coef = MATH_VecDotProduct(tv_acceleration * 0.015, @to_canal OBJ_HorizonGet())
//	tf_coef = MATH_FloatLimit(tf_coef, -1.0, 1.0)
//	tf_coef *= 5.0
//	tf_coef *= 1.0 - MATH_FloatMin(f_in_water_coef * 2.0, 1.0)
//
//	tv_forces -= OBJ_HorizonGet() * tf_coef
//	DBG_RenderVector(OBJ_PosGet(), tv_forces, color_jaune)	

//	v_grav_pos += MATH_VecDotProduct(@to_canal OBJ_PosGet() - v_grav_pos, @to_canal OBJ_SightGet()) * @to_canal OBJ_SightGet()
	tv_last_pos = v_grav_pos

	tf_friction = 0.75

	tf_friction_coef = MATH_FloatMin(f_move_speed / 10.0, 1.0)
//	tf_friction_coef = MATH_FloatMax(tf_friction_coef, 1.0 - f_in_water_coef)

	tv_water_move_offset = MATH_VecRotate(cvector(1.0, 0.0, 0.0), Cv_VerticalVector, 0.85 * TIME_Get()) * (1.0 + (MATH_Sin(TIME_Get() * 3.2) * 0.5))
//	tv_water_move_offset *= 1.0 - (f_snap_coef * 0.8)
	tv_water_move_offset *= 1.0 - tf_friction_coef

	DBG_RenderVector(OBJ_PosGet() + cvector(0.0, 0.0, 5.0), tv_water_move_offset, color_jaune)

//	tv_forces += cvector(0.0, 0.0, -40.0)
	tv_forces += tv_water_move_offset

	tv_forces /= tf_friction

	v_grav_speed = tv_forces - ((tv_forces - v_grav_speed) * MATH_Exp(-tf_friction * TIME_GetDt()))
	v_grav_speed.z += -30.0 * TIME_GetDt()

	v_grav_pos += v_grav_speed * TIME_GetDt()
	
	v_grav_pos -= @to_canal OBJ_PosGet()
	v_grav_pos -= (tf_friction_coef * MATH_VecDotProduct(v_grav_pos, @to_canal OBJ_SightGet())) * @to_canal OBJ_SightGet()
	MATH_VecSetNorm(v_grav_pos, 5.0)
//	v_grav_pos = MATH_VecInCone(v_grav_pos, -OBJ_BankingGet(), Cf_PiBy6, 0)
		
	DBG_RenderVector(@to_canal OBJ_PosGet(), v_grav_pos, color_bleu)	
	@to_canal OBJ_BankingGeneralSet(@to_canal OBJ_SightGet(), - MATH_VecRotate(v_grav_pos, -@to_canal OBJ_HorizonGet(), f_in_water_coef * 0.1))
//	OBJ_BankingGeneralSet(OBJ_SightGet(), - v_grav_pos)

	v_grav_pos += @to_canal OBJ_PosGet()
	v_grav_speed = (v_grav_pos - tv_last_pos) / TIME_GetDt()

	tv_pivot_pos = @to_canal MATH_VecLocalToGlobal(tv_pivot_pos)
	tv_pivot_pos += @to_canal OBJ_PosGet()
	tv_pivot_pos -= OBJ_PosGet()
	
	DBG_RenderVector(OBJ_PosGet(), tv_pivot_pos, color_blanc)
	@to_canal OBJ_PosSet(@to_canal OBJ_PosGet() - MATH_VecBlend(Cv_NullVector, tv_pivot_pos, f_in_water_coef))

	DBG_RenderVector(@to_canal OBJ_PosGet() + v_grav_pos, v_grav_speed, color_jaune)
}

procedure_local void PNJ_Plane_Shoot()
{
	int			ti_sound	
	int			ti_canal

	float		tf_norm	

	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_ray_dir
	vector	tv_impact
	vector	tv_normal

	object	to_object

	return

	if (IO_ButtonPressed(joy_button_R2) && TIME_Elapsed(f_time_last_shoot, 0.1))
	{
		f_time_last_shoot = TIME_Get()
		
		tv_start_pos = @o_camera OBJ_PosGet()
		tv_ray_dir = @o_camera OBJ_SightGet()

		COL_SpecificCrossableSet(none)
		to_object = COL_RayObject_Dist(tv_start_pos, tv_ray_dir, 1000.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel_and_bone_volumes | COL_C_Ray_use_SpecificCrossableSet)
		if (to_object)
		{
			DBG_RenderVector(tv_start_pos, COL_RayObject_PosGet() - tv_start_pos, color_rouge)	

			to_object = COL_RayObject_ActorGet()
			
			ti_canal = COL_RayObject_CanalGet()
			tv_impact = COL_RayObject_PosGet()
			tv_normal = COL_RayObject_NormalGet()
			ti_sound = COL_RayObject_SoundGet()

			LIBGFX_GunsImpact( tv_impact, tv_normal, to_object, ti_canal, 0 , ti_sound )

			EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_object, 10.0, tv_ray_dir)
		}
	}
}

procedure_local void PNJ_Plane_GFX_Ripple()
{
	int	 ripple

	vector	tv_pos

	if ( ! TIME_Elapsed(f_time_ripple, 1.0) )
		return

	f_time_ripple = TIME_Get()

	ripple = GFX_Add(20)
	GFX_MaterialSet(ripple, get_SFX_light_and_smoke, 16 )
	GFX_FlagSet(ripple,0,1) // activation de leffet
	GFX_FlagSet(ripple, 2, 1) // matériau transparent
	GFX_Setf(ripple,20000, MATH_RandFloat(3.0, 4.0))		// durée de vie
	GFX_Setf(ripple,20001, MATH_RandFloat(2.0, 4.0))		// vitesse 
	GFX_Setf(ripple,20002,0)		// frequence gen sprites
	GFX_Setf(ripple,20003,0)		// speed
	GFX_Setf(ripple,20004, MATH_RandFloat(0.5, 1.0))		// size
	
	GFX_Seti(ripple, 20100, 1)		// Nbre
	GFX_Seti(ripple, 20100, -2)	// Pour destruction auto
	GFX_Seti(ripple, 20101, 0xFFFFFFFF)
	GFX_Seti(ripple, 20102, 0x00000000)
	
	tv_pos = OBJ_PosGet()
	tv_pos.z = f_last_valid_water_Z + 0.1

	GFX_Setv(ripple,20200, tv_pos)	// pos	
	GFX_Setv(ripple,20201, Cv_VerticalVector)	// pos		
	GFX_Setv(ripple,20202, cvector(1,0,0))	// pos		
	GFX_LifeTimeSet(ripple, 4.0)
}

procedure_local void PNJ_Plane_GFX_Trace()
{
	float		tf_coef
	vector 	tv_pos
	vector	GX, GY, GZ
	int			ti_temp
	int 		LColor
	int 		RColor
	
	float		tf_Z_coef
	float		Largeur_A
	float		Largeur_B
	float		Largeur_C
	
	object	to_visuel	

	#define tf_Y_offset 0
	#define tf_left_coef 0.0
	#define tf_right_coef 0.0
	#define tf_Y_speed 0.0
	#define noiseprop 0.15
	#define Cf_Water_visual_offset 0.15
	#define LForce_Jet_SIDE 3.0
	#define RForce_Jet_SIDE 3.0
	#define LForce_Jet_UP 3.0
	#define RForce_Jet_UP 3.0
	
	Largeur_A = 1.2
	Largeur_B = 0.9
	Largeur_C = 0.7

	tv_pos = OBJ_PosGet()
	
	tf_coef = MATH_FloatLimit(f_move_speed + 0.5, 0.0, 10.0) / 10.0
	tf_Z_coef = MATH_FloatLimit(((f_last_valid_water_Z + 3.0) - tv_pos.z) / 3.0, 0.0, 1.0)
	tf_coef *= tf_Z_coef
//	tf_coef *= MATH_FloatLimit((f_last_valid_water_Z + 1.0) - tv_pos.z, 0.0, 1.0)

	alpha_airtrace = tf_coef

	if ( ! tf_coef || (GFX_Water_Trace_Left == -1 && tf_Z_coef < 1.0))
	{
		f_time_trace_off += TIME_GetDt()
	
		if (GFX_Water_Trace_Left == -1)
		{
			return
		}
		else if (f_time_trace_off > 1.0)
		{
			GFX_Del(GFX_Water_Trace_Left)
			GFX_Water_Trace_Left = -1
			return
		}
	}
	else
	{
		f_time_trace_off = 0.0
	}

	if (tf_coef && f_move_speed <= 3.0)
		PNJ_Plane_GFX_Ripple()

	if(GFX_Water_Trace_Left == -1)
	{
		alpha_airtrace	= 0.0
	
		to_visuel = ANI_CanalObjectGet(0)

		GFX_Water_Trace_Left = GFX_Add(12)
		GFX_MaterialSet(GFX_Water_Trace_Left, to_visuel, 3)	// met le materiau
	
		GFX_Seti(GFX_Water_Trace_Left, 12100 , 6)												// Number of point per profile
		GFX_Seti(GFX_Water_Trace_Left, 12101 , 5) 											// Number of Link per profile
		GFX_Seti(GFX_Water_Trace_Left, 12102 , 24) 											// Number of profiles
		
		GFX_Seti(GFX_Water_Trace_Left, 12103 , 1) 											// start
		GFX_Seti(GFX_Water_Trace_Left, 12111 , 16) 											// UTiler
		
		GFX_Setf(GFX_Water_Trace_Left, 12004 , 1.0) 											// Segment lenght min
		GFX_Setv(GFX_Water_Trace_Left, 12202, cvector(0.01,0.01,0)) 						// Friction
		
		GFX_Seti(GFX_Water_Trace_Left, 12105 , 0) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace_Left, 12106 , 0) 											// Point A
		GFX_Seti(GFX_Water_Trace_Left, 12107 , 1) 											// Point B
		
		GFX_Setf(GFX_Water_Trace_Left, 12001 , 0.0) 											// Point VA
		GFX_Setf(GFX_Water_Trace_Left, 12002 , 0.33) 										// Point VB
			
		GFX_Seti(GFX_Water_Trace_Left, 12105 , 1) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace_Left, 12106 , 1) 											// Point A
		GFX_Seti(GFX_Water_Trace_Left, 12107 , 2) 											// Point B
		
		GFX_Setf(GFX_Water_Trace_Left, 12001 , 0.33) 											// Point VA
		GFX_Setf(GFX_Water_Trace_Left, 12002 , 0.66) 											// Point VB
			
		GFX_Seti(GFX_Water_Trace_Left, 12105 , 2) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace_Left, 12106 , 2) 											// Point A
		GFX_Seti(GFX_Water_Trace_Left, 12107 , 3) 											// Point B
		
		GFX_Setf(GFX_Water_Trace_Left, 12001 , 0.66) 									// Point VA
		GFX_Setf(GFX_Water_Trace_Left, 12002 , 1.0) 										// Point VB
		
		GFX_Seti(GFX_Water_Trace_Left, 12105 , 3) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace_Left, 12106 , 3) 											// Point A
		GFX_Seti(GFX_Water_Trace_Left, 12107 , 4) 											// Point B
		GFX_Setf(GFX_Water_Trace_Left, 12001 , 0.5) 											// Point VA
		GFX_Setf(GFX_Water_Trace_Left, 12002 , 0.75) 											// Point VB
		
		GFX_Seti(GFX_Water_Trace_Left, 12105 , 4) 											// Actual LINK to set
		GFX_Seti(GFX_Water_Trace_Left, 12106 , 4) 											// Point A
		GFX_Seti(GFX_Water_Trace_Left, 12107 , 5) 											// Point B
		GFX_Setf(GFX_Water_Trace_Left, 12001 , 0.75) 										// Point VA
		GFX_Setf(GFX_Water_Trace_Left, 12002 , 1.0) 											// Point VB
			
		GFX_FlagSet(GFX_Water_Trace_Left, 0 , 1)
		GFX_FlagSet(GFX_Water_Trace_Left, 2 , 1)
	}

	LColor = 0x00FFDFDF
	ti_temp = alpha_airtrace * 128
	LColor |= (ti_temp << 24)
	RColor = LColor 
		
	// POSITIONNEMENT DES POINTS
	GFX_Seti(GFX_Water_Trace_Left, 12104 , 0) 																								// Actual point to set
	GFX_Seti(GFX_Water_Trace_Left, 12109 , LColor) 																							// Color
	GFX_Setv(GFX_Water_Trace_Left, 12200, 									cvector(-Largeur_A, tf_Y_offset, 0.0)) 	// StartPos
	GFX_Setv(GFX_Water_Trace_Left, 12201, tf_coef * (1.0 - noiseprop) * 	cvector(-LForce_Jet_SIDE * 1.5, tf_Y_speed, LForce_Jet_UP)) 	// Speed
	GFX_Setv(GFX_Water_Trace_Left, 12208, tf_coef * noiseprop * 				cvector(-LForce_Jet_SIDE * 1.5, tf_Y_speed, LForce_Jet_UP)) 	// Random Speed
	GFX_Setf(GFX_Water_Trace_Left, 12003, f_last_valid_water_Z + Cf_Water_visual_offset)										// Constraint ZMin
	
	GFX_Seti(GFX_Water_Trace_Left, 12104 , 5) 																								// Actual point to set
	GFX_Seti(GFX_Water_Trace_Left, 12109 , RColor) 																							// Color
	GFX_Setv(GFX_Water_Trace_Left, 12200, 									cvector(Largeur_A, tf_Y_offset, 0.0))	// StartPos
	GFX_Setv(GFX_Water_Trace_Left, 12201, tf_coef * (1.0 - noiseprop) * 	cvector(RForce_Jet_SIDE * 1.5, tf_Y_speed, RForce_Jet_UP)) 	// Speed
	GFX_Setv(GFX_Water_Trace_Left, 12208, tf_coef * noiseprop * 				cvector(RForce_Jet_SIDE * 1.5, tf_Y_speed, RForce_Jet_UP)) 	// Random Speed
	GFX_Setf(GFX_Water_Trace_Left, 12003, f_last_valid_water_Z + Cf_Water_visual_offset)										// Constraint ZMin
	
	GFX_Seti(GFX_Water_Trace_Left, 12104 , 1) 																								// Actual point to set
	GFX_Seti(GFX_Water_Trace_Left, 12109 , LColor) 																							// Color
	GFX_Setv(GFX_Water_Trace_Left, 12200, 									cvector(-Largeur_B, tf_Y_offset, 0.0))		// StartPos
	GFX_Setv(GFX_Water_Trace_Left, 12201, (1.0 - noiseprop) * 			cvector(-LForce_Jet_SIDE, tf_Y_speed, LForce_Jet_UP * 1.5))		// Speed
	GFX_Setv(GFX_Water_Trace_Left, 12208, noiseprop * 					cvector(-LForce_Jet_SIDE, tf_Y_speed, LForce_Jet_UP * 1.5))	 	// Random Speed
	GFX_Setf(GFX_Water_Trace_Left, 12003, f_last_valid_water_Z + Cf_Water_visual_offset)										// Constraint ZMin
	
	GFX_Seti(GFX_Water_Trace_Left, 12104 , 4) 																							// Actual point to set
	GFX_Seti(GFX_Water_Trace_Left, 12109 , RColor) 																							// Color
	GFX_Setv(GFX_Water_Trace_Left, 12200, 									cvector(Largeur_B, tf_Y_offset, 0.0)) 	// StartPos
	GFX_Setv(GFX_Water_Trace_Left, 12201, (1.0 - noiseprop) * 			cvector(RForce_Jet_SIDE, tf_Y_speed, RForce_Jet_UP * 1.5)) 	// Speed
	GFX_Setv(GFX_Water_Trace_Left, 12208, noiseprop * 					cvector(RForce_Jet_SIDE, tf_Y_speed, RForce_Jet_UP * 1.5)) 	// Random Speed
	GFX_Setf(GFX_Water_Trace_Left, 12003, f_last_valid_water_Z + Cf_Water_visual_offset) 										// Constraint ZMin
	
	GFX_Seti(GFX_Water_Trace_Left, 12104 , 2) 																								// Actual point to set
	GFX_Seti(GFX_Water_Trace_Left, 12109 , LColor) 																							// Color
	GFX_Setv(GFX_Water_Trace_Left, 12200, 									cvector(-Largeur_C, tf_Y_offset, 0.0))		// StartPos
	GFX_Setv(GFX_Water_Trace_Left, 12201, (1.0 - noiseprop) *			cvector(-2.0, tf_Y_speed, 0.0)) 								// Speed
	GFX_Setv(GFX_Water_Trace_Left, 12208, noiseprop * 					cvector(-2.0, tf_Y_speed, 0.0)) 								// Random Speed
	GFX_Setv(GFX_Water_Trace_Left, 12207, 									cvector(0, 0, 0)) 											// Random POS
	GFX_Setf(GFX_Water_Trace_Left, 12003, f_last_valid_water_Z + Cf_Water_visual_offset)										// Constraint ZMin
	
	GFX_Seti(GFX_Water_Trace_Left, 12104 , 3) 																								// Actual point to set
	GFX_Seti(GFX_Water_Trace_Left, 12109 , RColor) 																							// Color
	GFX_Setv(GFX_Water_Trace_Left, 12200, 									cvector(Largeur_C, tf_Y_offset, 0.0)) 		// StartPos
	GFX_Setv(GFX_Water_Trace_Left, 12201, (1.0 - noiseprop) *			cvector(2.0, tf_Y_speed, 0.0)) 							// Speed
	GFX_Setv(GFX_Water_Trace_Left, 12208,	noiseprop * 				cvector(2.0, tf_Y_speed, 0.0)) 							// Random Speed
	GFX_Setv(GFX_Water_Trace_Left, 12207, 									cvector(0, 0, 0)) 											// Random POS
	GFX_Setf(GFX_Water_Trace_Left, 12003, f_last_valid_water_Z + Cf_Water_visual_offset)										// Constraint ZMin
	
	GFX_Setf(GFX_Water_Trace_Left, 12000 , -10.0) 									// Gravity
	
	GY = -OBJ_SightGet()
	MATH_VecSetHorzNormalize(GY)
	GZ = Cv_VerticalVector
	GX = MATH_VecCrossProduct(GY, GZ)
//	DBG_RenderVector(OBJ_PosGet(), GX * 5.0, color_rouge)
		
	GFX_Setv(GFX_Water_Trace_Left, 12203, GX) // GX
	GFX_Setv(GFX_Water_Trace_Left, 12204, GY) // GY
	GFX_Setv(GFX_Water_Trace_Left, 12205, GZ) // GZ
	GFX_Setv(GFX_Water_Trace_Left, 12206, tv_pos) // GT
	
	// SI VUE INTERIEURE
	GFX_Seti(GFX_Water_Trace_Left, 12103 , 1) // Start
}

procedure_local void PNJ_Plane_Helice()
{
	object	to_blur	

	if (o_helice == nobody)
		return
		
	if ( ! OBJ_CapaTest(Capa_Motor_Stop) && f_move_speed && o_next_wp && ! @o_next_wp OBJ_CapaTest(Capa_Stop))
		f_helice_rot_speed = MATH_FloatBlend(f_helice_rot_speed, f_move_speed, 12.0 * TIME_GetDt())
	else if (f_helice_rot_speed > 1.5)
		f_helice_rot_speed = 1.5
	else
		f_helice_rot_speed -= MATH_FloatMin(f_helice_rot_speed, 0.4 * TIME_GetDt())

	@o_helice OBJ_RotateLocalY(f_helice_rot_speed * 10.0 * TIME_GetDt())
	
	to_blur = ANI_CanalObjectGet(9)
	@to_blur MAT_MT_SetLocalAlpha(2, 0, MATH_FloatLimit((f_helice_rot_speed - 1.0) / 5.0, 0.0, 1.0) * 150)
}

procedure_local void PNJ_Plane_Ailerons()
{
	object	to_gouverne	

	float	tf_dot_product	

	to_gouverne = ANI_CanalObjectGet(6)
	if (!to_gouverne)
		return

	tf_dot_product = MATH_VecDotProduct(Cv_VerticalVector, OBJ_HorizonGet())
	tf_dot_product = MATH_FloatLimit(tf_dot_product * 2.0, -1.0, 1.0)

	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_RotateLocalZ(tf_dot_product * Cf_PiBy2)

	to_gouverne = ANI_CanalObjectGet(2)
	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_RotateLocalX(-tf_dot_product * Cf_PiBy2)

	to_gouverne = ANI_CanalObjectGet(3)
	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_RotateLocalX(tf_dot_product * Cf_PiBy2)

	to_gouverne = ANI_CanalObjectGet(4)
	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_RotateLocalX(-tf_dot_product * Cf_PiBy2)

	to_gouverne = ANI_CanalObjectGet(5)
	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_RotateLocalX(tf_dot_product * Cf_PiBy2)

	to_gouverne = ANI_CanalObjectGet(7)
	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_Rotate_FromTo(cvector(-1.0, 0.0, 0.0), @to_gouverne MATH_VecGlobalToLocal(v_spline_sight))

	to_gouverne = ANI_CanalObjectGet(8)
	@to_gouverne OBJ_RestoreInitMatrix()
	@to_gouverne OBJ_Rotate_FromTo(cvector(1.0, 0.0, 0.0), @to_gouverne MATH_VecGlobalToLocal(v_spline_sight))
}

//procedure_local void PNJ_Plane_Smoke()
//{
//	int		ti_i
//	int		ti_smoke
//	int		ti_wanted_sprite	
//
//	float		tf_dist
//
//	vector	tv_move
//	vector	tv_pos
//	vector	tv_wind
//	
////	if (f_move_speed < 4.0)
////		return
//
//	for (ti_i = 0; ti_i < 2; ti_i++)
//	{
//		tv_pos = OBJ_PosGet()
//		tv_pos += OBJ_BankingGet() * 2.5
//		if (ti_i)
//		{
//			tv_pos += OBJ_HorizonGet() * 0.8
//			tv_move = tv_pos - v_left_last_pos
//			v_left_last_pos = tv_pos
//		}
//		else
//		{
//			tv_pos -= OBJ_HorizonGet() * 0.8
//			tv_move = tv_pos - v_right_last_pos
//			v_right_last_pos = tv_pos
//		}
//	
//		if (OBJ_CapaTest(Capa_Motor_Stop))
//			continue	
//
//		tf_dist = f_move_speed * TIME_GetDt()
//		ti_wanted_sprite = 3.0 * tf_dist
//
//		ti_smoke = GFX_Add(13)																	// Create the boum
//	
//		GFX_Seti(ti_smoke, 13100, ti_wanted_sprite)										// *Buffer number of sprite
//		GFX_Seti(ti_smoke, 13106, ti_wanted_sprite)										// *number of sprite to generate
//		GFX_Setf(ti_smoke, 13008, 0.02)														// generation rate
//	
//		GFX_MaterialSet(ti_smoke , get_SFX_light_and_smoke, -1)									// met le materiau
//		GFX_Seti(ti_smoke, 13101, 8)															// Materiau 0
//		
//		GFX_Seti(ti_smoke, 13107, 0)															// Affichage des sprites non trié
//	
//		// Size
//		GFX_Setf(ti_smoke, 13005, 0.15)								// Creation size min
//		GFX_Setf(ti_smoke, 13006, 0.25)								// Creation size max
//		GFX_Setf(ti_smoke, 13000, 0.5)														// Grwing speed min
//		GFX_Setf(ti_smoke, 13001, 1.5)														// Grwing speed max
//		GFX_Setf(ti_smoke, 13002, 0.025)														// Friction Grow
//	
//		// Color
//		GFX_Seti(ti_smoke, 13103, 0x40808080)											// Color fase 0
//		GFX_Seti(ti_smoke, 13104, 0x40808080)											// Color fase 1
//		GFX_Seti(ti_smoke, 13105, 0x00808080)											// Color fase 2
//	
//		// Translation
//		GFX_Setf(ti_smoke, 13007, 3.0)               							// Gravity
//
//		GFX_Setf(ti_smoke, 13009, 6.0)										// Norm speed min
//		GFX_Setf(ti_smoke, 13010, 10.0)								// Norm speed max
//
//		tv_wind = -OBJ_SightGet() * 5.0
//	
//		GFX_Setv(ti_smoke, 13201, tv_wind + cvector(-1.0, -1.0, -1.0))		// Speed min
//		GFX_Setv(ti_smoke, 13202, tv_wind + cvector(1.0, 1.0, 1.0))			// Speed max
//		GFX_Setv(ti_smoke, 13203, cvector(0.01, 0.01, 0.01))								// friction speed
//	
//		GFX_FlagSet(ti_smoke, 0 , 1)
//		GFX_FlagSet(ti_smoke, 2 , 1)
//		GFX_Setf(ti_smoke, 13012, 0.75)														// Time random
//	
//		GFX_Setf(ti_smoke, 13003, 0.0)		// Time fase 1
//		GFX_Setf(ti_smoke, 13004, 2.0)		// Time fase 2
//	
//		tv_wind = Cv_NullVector
//		GFX_Setv(ti_smoke, 13204, tv_wind)			// wind
//
//		DBG_RenderVector(tv_pos, -tv_move, color_blanc)
//
//		tv_move *= 0.5
//		tv_pos += tv_move
//	
//		GFX_Setv(ti_smoke, 13200, tv_pos - (tv_wind * TIME_GetDt()))				// Creation Pos
//		GFX_Setv(ti_smoke, 13207, tv_move)								// CreaPosAxe X
//	}
//}

