float			tf_dist 

#include "ci_defines.var"

i_cur_mode = Ci_mode_att_jump
if (i_cur_mode != i_old_mode)
{
	// INIT
	i_old_mode = i_cur_mode
	v_target_pos = @o_attaque OBJ_PosGet() + cvector(0,0,f_hauteur_attaque)
	if ( f_attaque_saut_distancemax > 0 )
	{
		v_target_pos -= OBJ_PosGet()
		tf_dist = MATH_VecNorm( v_target_pos )
		if ( tf_dist > f_attaque_saut_distancemax )
			v_target_pos = (v_target_pos * f_attaque_saut_distancemax) / tf_dist
		v_target_pos += OBJ_PosGet()
	}
	
	f_time_ref = TIME_Get()
	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces, none)
	DYN_GravitySet(cvector(0,0,-f_attaque_saut_speed))
	DYN_Impulsion(v_target_pos,4.0)
	
	if ( COL_HasZDM() )
		COL_ColSetActivationSet(none, C_bit_zdm_pied)

	OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),DYN_SpeedGetVector(),1500.0 * TIME_GetDt()), Cv_VerticalVector)

}


AI_Execute("ci_exec_test_kill_target")

if ( !i_duplicate || i_duplicate == 2)
{
	if (DYN_SpeedGetVector().z < 0 && OBJ_PosGet().z < v_target_pos.z)
		AI_TrackCurChangeNow("ci_10_wait_after_paf")
}
else
	AI_Execute("ci_exec_timeout")

