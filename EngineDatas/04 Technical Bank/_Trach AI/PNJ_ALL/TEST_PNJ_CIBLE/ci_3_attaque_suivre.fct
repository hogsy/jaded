
#include "ci_defines.var"

vector		tv_deplacement 
float			f_dist

i_cur_mode = Ci_mode_att_suivre
if (i_cur_mode != i_old_mode)
{
	// INIT
	i_old_mode = i_cur_mode
	
	if (COL_HasZDM() && i_suit_terrain)
	{
		COL_ColSetActivationSet(C_bit_zdm_pied, none)
		DYN_On()
		DYN_FlagsSet(DYN_C_BasicForces + DYN_C_VectorFriction, none)
		DYN_GravitySet( Cv_NormalGravity )
		DYN_FrictionVectorSet( cvector( 1, 1, 1) )
		DYN_FrictionSet(1)
	}
}

AI_Execute("ci_exec_test_kill_target")

v_target_pos = @o_attaque OBJ_PosGet() + cvector(0,0,f_hauteur_attaque)
v_dir = v_target_pos - OBJ_PosGet()
f_dist = MATH_VecNorm( v_dir )
v_dir /= f_dist
tv_deplacement = v_dir * (f_attaque_suivre_speed * TIME_GetDt())

if (COL_HasZDM() && i_suit_terrain)
{
//	v_dir.z = 0
	DYN_SpeedSetVector( v_dir * (f_attaque_suivre_speed * f_paf_coef ))
}
else
	OBJ_PosSet( OBJ_PosGet() + (tv_deplacement * f_paf_coef) )
	
OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),tv_deplacement,5.0 * TIME_GetDt()), Cv_VerticalVector)

// passe en bullrush si il faut
if ( ((f_dist >= f_bullrush_distmin) && (f_dist <= f_bullrush_distmax)) && (f_paf_coef == 1.0))
{
	f_bullrush_distance = f_dist
	AI_TrackCurChangeNow("ci_3_attaque_bullrush")
}

// passe en attaque circulaire si il faut
if (i_attaque_type == Ci_attaque_cercle)
{
	if ( ((f_dist >= f_circular_radiusmin) && (f_dist <= f_circular_radiusmax)) && (f_paf_coef == 1.0))
		AI_TrackCurChangeNow("ci_3_attaque_cercle")
}