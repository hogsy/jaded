
#include "ci_defines.var"

object		to
vector		tv_deplacement, tv_goodtarget, tv_orient
float			tf_dist, tf_speedfactor

i_cur_mode = Ci_mode_att_cercle
if (i_cur_mode != i_old_mode)
{
	// INIT
	i_old_mode = i_cur_mode
	f_circular_attacktime = MATH_RandFloat( f_circular_attackperiodmin, f_circular_attackperiodmax )
	f_circular_senstimer = MATH_RandFloat(0.1,1)
	f_circular_sens = (MATH_RandInt(0, 2) * 2) - 1
	f_circular_cursens = 0
	
	if (f_circular_attackspeed <= 0)
		f_circular_attackspeed = f_attaque_suivre_speed
	
	if (COL_HasZDM() && i_suit_terrain)
	{
		COL_ColSetActivationSet(C_bit_zdm_pied, none)
		DYN_On()
		DYN_FlagsSet(DYN_C_BasicForces + DYN_C_VectorFriction, none)
		DYN_GravitySet( Cv_NormalGravity )
		DYN_FrictionVectorSet( cvector( 1, 1, 1) )
		DYN_FrictionSet(1)
	}
	
}

AI_Execute("ci_exec_test_kill_target")

if ( f_circular_attacktime != 1000 )
	f_circular_attacktime -= TIME_GetDt()

v_target_pos = @o_attaque OBJ_PosGet() + cvector(0,0,f_hauteur_attaque)
v_dir = v_target_pos - OBJ_PosGet()
tf_dist = MATH_VecNorm( v_dir )
v_dir /= tf_dist
tv_orient = v_dir

if (tf_dist > f_circular_radiusmax + 0.5) 
{
	AI_TrackCurChange( "ci_3_attaque_suivre" )
	return
}
if (f_circular_attacktime == 1000 )
{
	if (tf_dist > f_circular_radiusmin)
		f_circular_attacktime = MATH_RandFloat( f_circular_attackperiodmin, f_circular_attackperiodmax )
	tv_deplacement = -(v_dir * (f_circular_attackspeed * MATH_AbsFloat(f_paf_coef)))
}
else
{
	if (tf_dist < f_circular_radiusmin - 0.5) 
	{
		f_circular_attacktime = -1
	}	

	if ( (f_circular_attacktime < 0) && (@get_global i_ennemi_counter_new[Ci_ennemi_counter_attacking] == 0) )
	{
		tv_deplacement = v_dir * (f_circular_attackspeed * f_paf_coef)
	}
	else
	{
		@get_global i_ennemi_counter_new[Ci_ennemi_counter_attacking]++
		
		f_circular_senstimer -= TIME_GetDt()
		if (f_circular_senstimer < 0)
		{
			f_circular_senstimer = MATH_RandFloat(1,5)
			f_circular_sens = -f_circular_sens
		}
		f_circular_cursens = MATH_FloatBlend(f_circular_cursens,f_circular_sens,0.2)
		
		tv_deplacement = v_dir * ( tf_dist - ((f_circular_radiusmin + f_circular_radiusmax)/2))
		tv_deplacement += f_circular_cursens * MATH_VecCrossProduct(v_dir,Cv_VerticalVector)
		tv_deplacement *= f_paf_coef
	}
}

if (COL_HasZDM() && i_suit_terrain)
{
//	tv_deplacement.z = 0
	DYN_SpeedSetVector( tv_deplacement )
}
else
	OBJ_PosSet( OBJ_PosGet() + (tv_deplacement * TIME_GetDt()) )
	
OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),tv_orient,5.0 * TIME_GetDt()), Cv_VerticalVector)

