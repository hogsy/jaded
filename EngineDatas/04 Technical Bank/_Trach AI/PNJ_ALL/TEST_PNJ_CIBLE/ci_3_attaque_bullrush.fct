
#include "ci_defines.var"

object		to
vector		tv_deplacement, tv_goodtarget
float			tf_dist, tf_speedfactor

i_cur_mode = Ci_mode_att_bullrush
if (i_cur_mode != i_old_mode)
{
	// INIT
	i_old_mode = i_cur_mode

	v_bullrush_target = (2 * @o_attaque OBJ_PosGet()) - OBJ_PosGet()
	
	if (COL_HasZDM() && i_suit_terrain)
	{
		COL_ColSetActivationSet(C_bit_zdm_pied, none)
		DYN_On()
		DYN_FlagsSet(DYN_C_BasicForces + DYN_C_VectorFriction, none)
		DYN_GravitySet( Cv_NormalGravity )
		DYN_FrictionVectorSet( cvector( 1, 1, 1) )
		DYN_FrictionSet(1)
	}
}

AI_Execute("ci_exec_test_kill_target")

if (COL_HasZDM() && i_suit_terrain)
{
	to = nobody
	if (COL_CollideType(COL_C_Wall))
		to = COL_ObjectGet( COL_C_Wall )
		
	if ( to )
	{
		EVENT_AddEventPaf( C_EVENT_FILTER_All, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to, 1.0 * PAF_Unit, v_dir)
		AI_TrackCurChange( "ci_3_attaque_suivre" )
		return
	}
}


v_dir = v_bullrush_target - OBJ_PosGet()
tf_dist = MATH_VecNorm( v_dir )

if ( ( tf_dist < 1.0) || (f_paf_coef != 1.0) )
{
	i_bullrush_hit = 0
	COL_UnCollidableDel( o_attaque )
	AI_TrackCurChangeNow( "ci_3_attaque_suivre" )
}
v_dir /= tf_dist

if ( (tf_dist / f_bullrush_distance) > 1.5 )
{
	v_bullrush_target = @o_attaque OBJ_PosGet() - OBJ_PosGet()
	MATH_VecSetNormalize( v_bullrush_target )
	v_bullrush_target *= f_bullrush_distance
	v_bullrush_target += @o_attaque OBJ_PosGet()
}

tf_speedfactor = (1 - (MATH_AbsFloat( (tf_dist / f_bullrush_distance)) - 1))
tf_speedfactor *= tf_speedfactor
tf_speedfactor = 1 + ((f_bullrush_speedfactor - 1) * tf_speedfactor)

tv_deplacement = v_dir * (tf_speedfactor * f_attaque_suivre_speed * TIME_GetDt())
tv_deplacement *= f_paf_coef

if (COL_HasZDM() && i_suit_terrain)
	DYN_SpeedSetVector( v_dir * (tf_speedfactor * f_attaque_suivre_speed * f_paf_coef ))
else
	OBJ_PosSet( OBJ_PosGet() + tv_deplacement )
	




OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),tv_deplacement,5.0 * TIME_GetDt()), Cv_VerticalVector)