#include "ci_defines.var"

object		to_gao 
int				ti_id
int				ti_ok


i_cur_mode = Ci_mode_wait_apres_apparition
if (i_cur_mode != i_old_mode)
{
	// INIT
	i_old_mode = i_cur_mode
	f_time_ref = TIME_Get()
}

AI_Execute("ci_exec_test_attaque_suivre")

if (TIME_Elapsed(f_time_ref, f_delai_apparition))
{
	// Il y a encore de la place dans mon nbr max d'ennemi a generer
	if (i_duplicate)
	{
		if (i_duplicate == 2)
		{
			ti_ok = faux
			if (i_nbr_de_generation < i_nbr_max_a_generer)
			{
				if (EVENT_Enemy_GetNumber( C_EVENT_EnemyState_Fight ) < i_nbr_max_total_en_fight)
				{
					// On a pas atteind le nbr max d'ennemi en fight dans cette map
					ti_id = ARR_ObjSearch(&o_simultanetch[0], i_nbr_max_fight_pourmoi, nobody)
					if (ti_id >=0)
						ti_ok = vrai
				}
			}
			else
			{
				AI_TrackStop(1)	
				AI_TrackCurChangeNow("ci_9_destroy")
			}
		}
		else if (i_duplicate == 1)
			ti_ok = vrai
		else
			ti_ok = faux

		if (ti_ok)
		{	
			to_gao = OBJ_Duplicate(OBJ_PosGet())
			i_nbr_de_generation++
			
			if (i_duplicate == 2)
			{
				// Generateur
				o_simultanetch[ti_id] = to_gao
				OBJ_RegisterKill(o_simultanetch[ti_id],&o_simultanetch[ti_id])
			}
			
			if ( i_duplicate == 1)
				@"Test/TEST_PNJ_CIBLE" to_gao f_attente_apres_attaque = 0		// Si c'est un projectile il ne doit pas attendre apres un paf.
	
			AI_TrackCurChange("ci_5_wait")
		}
	}
	else
	{
		if (i_attaque_id>=0 || o_attaque_object) 
		{
			if (o_attaque_object)
				o_attaque = o_attaque_object
			else
				o_attaque = @"univ" ao_AllHumains[i_attaque_id]

			if (o_attaque)
			{
				if (i_attaque_type == Ci_attaque_jump )
					AI_TrackCurChange("ci_3_attaque_jump")
				else if ( (i_attaque_type == Ci_attaque_suivi ) || (i_attaque_type==Ci_attaque_cercle) )
					AI_TrackCurChange("ci_3_attaque_suivre")
				else
					AI_TrackCurChange("ci_3_attaque_droite")
			}
		}
		else
		{
			if (o_1st_wp)
				o_deplacement_simple = o_1st_wp
			if (o_deplacement_simple)
				AI_TrackCurChange("ci_4_move")
			else
				AI_TrackCurChange("ci_5_wait")
		}
	}
}