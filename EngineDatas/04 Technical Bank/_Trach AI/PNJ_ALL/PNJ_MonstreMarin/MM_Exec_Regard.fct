#include "MM_defines.var"


#define		Cf_angle		Cf_PiBy4

vector		tv_look
vector		tv_best_look
vector		tv_move_axis_cur
vector		tv_move_axis_init
object		to_bone
int				ti_i
float			tf_coef
vector		tv_temp
vector		tv_best_look_pos
float			tf_dot
vector		tv_cone


// ma destinatin est dans mon dos : pas de regard
tv_move_axis_init = v_move_pos_dest - v_move_pos_start
//DBG_RenderVector(v_move_pos_start, tv_move_axis_init, color_blanc)
if( MATH_VecNullEpsilon(tv_move_axis_init) )
	tv_move_axis_init = OBJ_SightGet()
else
	MATH_VecSetNormalize(tv_move_axis_init)

tv_move_axis_cur = OBJ_PosGet() - v_move_pos_start
//DBG_RenderVector(v_move_pos_start, tv_move_axis_cur, color_jaune)
if( MATH_VecNullEpsilon(tv_move_axis_cur) )
	tv_move_axis_cur = OBJ_SightGet()		// je viens juste de changer de destination et de position init
else
	MATH_VecSetNormalize(tv_move_axis_cur)

if( o_grabbed_actor )
	i_regard_flag = faux

if( i_move_mode == Ci_move_mode_idle )
	i_regard_flag = faux

if( i_en_fuite )
	i_regard_flag = faux

if( i_move_mode != Ci_move_mode_apres_attaque && i_move_mode != Ci_move_mode_attack && ! o_grabbed_actor )
{ 
	//DBG_RenderVector(v_move_pos_start, tv_move_axis, color_blanc)
	tf_dot = MATH_VecDotProduct(v_sight_avant_sinus, tv_move_axis_cur)
	if( tf_dot < 0 )
		i_regard_flag = faux
	
	
	// l'objet que je regarde est dans mon dos : pas de regard
	tv_temp = v_look_pos - @o_bone_tete OBJ_PosGet()
//	DBG_RenderVector(@o_bone_tete OBJ_PosGet(), tv_temp, color_cyan)
	tf_dot = MATH_VecDotProduct(tv_move_axis_cur, tv_temp)
	if( tf_dot < 0 )
		i_regard_flag = faux
}


//// trop proche pour activer le suivi de regard
//if( MATH_VecNorm(tv_temp) < 5.0 )
//	i_regard_flag = faux

for( ti_i = 0; ti_i < 2; ti_i++ )
{
	// choix bone
	if( ! ti_i )
	{
		to_bone = o_bone_cou
		tf_coef = 0.3
		@to_bone OBJ_RestoreInitMatrix()
	}
	else
	{
		to_bone = o_bone_tete
		tf_coef = 0.5
		@to_bone OBJ_RestoreInitMatrix()
	}
	
	// rotation
	if( i_regard_flag )
	{
		tv_best_look_pos = v_look_pos
	}
	else
	{
//		tv_best_look_pos = OBJ_PosGet() + (tv_move_axis_init * 10)
//		tv_best_look_pos = OBJ_PosGet() + (tv_move_axis_cur * 10)
		tv_best_look_pos = OBJ_PosGet() + (OBJ_SightGet() * 10)
	}
	tv_cone = tv_best_look_pos - OBJ_PosGet()
	tv_cone = MATH_VecInCone(tv_cone, OBJ_SightGet(), Cf_PiBy3, 0)
	tv_best_look_pos = OBJ_PosGet() + tv_cone
	v_look_pos_cur = MATH_VecBlend(v_look_pos_cur, tv_best_look_pos, 2.0 * TIME_GetDt())
	tv_look = v_look_pos_cur - @to_bone OBJ_PosGet()
//	DBG_RenderVector(@to_bone OBJ_PosGet(), tv_look, color_rouge)
	
	tv_look = MATH_VecBlendRotate(@to_bone OBJ_BankingGet(), tv_look, tf_coef)
//	DBG_RenderVector(@to_bone OBJ_PosGet(), tv_look, color_vert )
	@to_bone OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @to_bone MATH_VecGlobalToLocal(tv_look))

}

DBG_RenderVector(@o_bone_tete OBJ_PosGet(), v_look_pos_cur - @o_bone_tete OBJ_PosGet(), color_rouge)

