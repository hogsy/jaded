#include "MM_defines.var"


//=================================================================================
// Retourne une position intermédiaire calculée en fonction de la position et de l'orientation du wp de destination
//=================================================================================
procedure_local vector BigMonster_GetIntermediatePosition(object to_dest_wp)
{
	vector		tv_pos
	vector		tv_dest_pos
	vector		tv_normale
	vector		tv_me_to_dest
	float			tf_dist
	float			tf_dest_pos_Z
	float			tf_my_pos_Z
	
	tv_pos = OBJ_PosGet()
	tf_my_pos_Z = tv_pos.z
	
	tv_dest_pos = @to_dest_wp OBJ_PosGet()
	tf_dest_pos_Z = tv_dest_pos.z
	tv_me_to_dest = tv_dest_pos - OBJ_PosGet()
	DBG_RenderVector(OBJ_PosGet(), tv_me_to_dest, color_vert)
	tf_dist = 0.5 * MATH_VecNorm(tv_me_to_dest)
	MATH_VecSetNormalize(tv_me_to_dest)
	tv_pos = OBJ_PosGet() + (tf_dist * tv_me_to_dest)
	
	tv_normale = MATH_VecCrossProduct(tv_me_to_dest, Cv_VerticalVector)
	if( MATH_VecDotProduct(tv_normale, @to_dest_wp OBJ_SightGet()) > 0 )
		tv_normale *= -1.0		// je prend la normale qui me fait aller dans le dos du wp
//	DBG_RenderVector(tv_pos, tv_normale * tf_dist, color_rouge)
	
	tv_pos += (tf_dist * tv_normale)
	tv_pos.z = MATH_FloatBlend(tf_my_pos_Z, tf_dest_pos_Z, 0.0)
	
	DBG_RenderVector(OBJ_PosGet(), tv_pos - OBJ_PosGet(), color_jaune)
	DBG_RenderVector(tv_pos, tv_dest_pos - tv_pos, color_jaune)
	return tv_pos
}


//=================================================================================
// MAJ de la position de début de mouvement du monstre
//=================================================================================
procedure_local void BigMonster_MovePosStartUpdate()
{
	v_move_pos_start = OBJ_PosGet()
}


//=================================================================================
// MAJ de la position de fin de mouvement du monstre
//=================================================================================
procedure_local void BigMonster_MovePosDestUpdate(vector tv_pos)
{
	v_move_pos_dest = tv_pos
}


//=================================================================================
// Nouvelle vitesse max et nouveau coef d'accélération
//=================================================================================
procedure_local void BigMonster_UpdateSpeed(float tf_speed_max, float tf_speed_blend)
{
	f_speed_max = tf_speed_max
	f_speed_blend = tf_speed_blend
//	f_speed_blend_secure = 0.0
}

//=================================================================================
// Retourne vrai si le monstre est dans une phase pendant laquelle il est sensible aux pafs / susceptible de gober une dynamite
//=================================================================================
procedure_local int BigMonster_EstVulnerable()
{
	if( i_move_mode == Ci_move_mode_attack )
	{
		// une attaque est en cours
		switch( i_attack_type )
		{
			case Ci_attack_type_renverse :
			{
				switch( i_attack_phase )
				{
					case Ci_attack_phase_sortdeleau :
					case Ci_attack_phase_plonge :
//					case Ci_attack_phase_renverse :
						return vrai
					default:
						return faux
				}
			}
			case Ci_attack_type_ras_de_l_eau :
			default:
				return vrai
		}
	}
	if( i_attack_marins_flag )
	{
		if( i_attack_phase == Ci_attack_phase_orientation || ! i_attack_phase )
		{
			// attaque sur les marins : est vulnérable après avoir émergé
			return vrai
		}
	}
	return faux
}


//=================================================================================
// Retourne la position du wp temporaire pour le déplacement courant
//=================================================================================
procedure_local vector BigMonster_CalcPhaseWpPos()
{
	vector		tv_pos
	vector		tv_temp
	
	if( i_attack_phase == Ci_attack_phase_sortdeleau )
	{
		tv_pos = @o_script_move_wp OBJ_PosGet()
		tv_temp = tv_pos - OBJ_PosGet()
		tv_temp.z = 0.0
		if( ! MATH_VecNullEpsilon(tv_temp) )
			MATH_VecSetNormalize(tv_temp)
		tv_pos -= ( f_attack_sortdeleau_H * tv_temp)
		tv_pos += (f_attack_sortdeleau_V * Cv_VerticalVector)
	}
	else if( i_attack_phase == Ci_attack_phase_plonge )
	{
		tv_pos = @o_script_move_wp OBJ_PosGet()
//		tv_temp = tv_pos - OBJ_PosGet()
//		tv_temp.z = 0.0
//		if( ! MATH_VecNullEpsilon(tv_temp) )
//			MATH_VecSetNormalize(tv_temp)
		DBG_RenderVector(OBJ_PosGet(), v_attack_axis * 5, color_jaune)
		tv_temp = v_attack_axis
		tv_pos -= ( f_attack_replonge_H * tv_temp)
		tv_pos += (f_attack_replonge_V * Cv_VerticalVector)
	}
	else if( i_attack_phase == Ci_attack_phase_renverse )
	{
		tv_pos = @o_fight_move_wp OBJ_PosGet()
//		tv_temp = tv_pos - OBJ_PosGet()
//		tv_temp.z = 0.0
//		if( ! MATH_VecNullEpsilon(tv_temp) )
//			MATH_VecSetNormalize(tv_temp)
		DBG_RenderVector(OBJ_PosGet(), v_attack_axis * 5, color_jaune)
		tv_temp = v_attack_axis
		tv_pos += ( f_attack_renverse_H * tv_temp)
		tv_pos += (f_attack_renverse_V * Cv_VerticalVector)
	}
	else if( i_attack_phase == Ci_attack_phase_souleve )
	{
//		tv_pos = OBJ_PosGet()
//		tv_pos.z = @o_water_Z OBJ_PosGet().z
//		tv_temp = OBJ_SightGet()
//		tv_temp.z = 0.0
//		if( ! MATH_VecNullEpsilon(tv_temp) )
//			MATH_VecSetNormalize(tv_temp)
		DBG_RenderVector(OBJ_PosGet(), v_attack_axis * 5, color_jaune)
		tv_pos = OBJ_PosGet()
		tv_temp = v_attack_axis
		tv_pos += ( f_attack_souleve_H * tv_temp)
		tv_pos += (f_attack_souleve_V * Cv_VerticalVector)
	}
	DBG_RenderVector(OBJ_PosGet(), tv_pos - OBJ_PosGet(), color_rouge)
	return tv_pos
}


//===================================================================================
// Calcule la position à atteindre en mode idle (tourne en rond)
//===================================================================================
procedure_local void BigMonster_Occluder_Compute_Idle_Pos(vector tv_sight_ref, byref vector tv_sight_new, byref vector tv_test_occluder_dest_pos)
{
	tv_sight_new = tv_sight_ref
	tv_sight_new.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_sight_new) )
		MATH_VecSetNormalize(tv_sight_new)
	else
		tv_sight_new = MATH_VecLocalToGlobal(cvector(0,1,0))
	tv_sight_new = MATH_VecRotate(tv_sight_new, Cv_VerticalVector, - 10 * Cf_1Degre)
	tv_test_occluder_dest_pos = OBJ_PosGet() + ( 5 * tv_sight_new )		// Tourne en rond
}


//=============================================================================================
// Ajout d'un acteur vu (ou détecté)
//=============================================================================================
procedure_local int BigMonster_Perceived_Actor_Add(object to_actor, byref messageid tmid_vision_event)
{
	int					ti_index

	ti_index = ARR_ObjSearch(&ao_perceived_actor[0], i_perceived_actor_nb, to_actor)
	if (ti_index == -1)
	{
		ti_index = i_perceived_actor_nb
		i_perceived_actor_nb ++
		ao_perceived_actor[ti_index] = to_actor
		if( ! MSG_GlobalIsValid(tmid_vision_event) )
			tmid_vision_event = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_actor, nobody)
		amid_perceived_actor[ti_index] = tmid_vision_event
	}
	else
		tmid_vision_event = amid_perceived_actor[ti_index]
	return(ti_index)
}


//===================================================================================
// Création / Mise à jour d'un intérêt
//===================================================================================
procedure_local void BigMonster_Interet_Update(byref messageid pmid_interet, int pi_status, object po_interet_target)
{
	float		tf_interet
	vector	tv_pos

	tf_interet = Cf_MonstreMarin_InteretProieDefault
	tv_pos = @po_interet_target OBJ_PosGet()

	// Test event intérêt
	if( ! MSG_GlobalIsValid(pmid_interet) )
	{
		// Création event intérêt
		pmid_interet = EVENT_AddEventInteret(OBJ_Me(), Cf_MonstreMarin_InteretDuration, tf_interet, tv_pos, po_interet_target)
		EVENT_InteretVisionIDSet(pmid_interet, C_ID_MonstreMarin)
	}
	else
	{
		// Update event intérêt
		EVENT_LifeSet(pmid_interet, Cf_MonstreMarin_InteretDuration)
		EVENT_InteretTargetSet(pmid_interet, po_interet_target)
		EVENT_InteretPositionSet(pmid_interet, tv_pos)
		EVENT_InteretSet(pmid_interet, tf_interet)
	}
	EVENT_InteretSeenTimeSet(pmid_interet, TIME_Get())
	if( pi_status != -1 )
		EVENT_InteretStatusSet(pmid_interet, pi_status)
}


//=================================================================================
// Téléporte le monstre sur un wp donné
//=================================================================================
procedure_local void BigMonster_Teleport_OLD(object to_obj)
{
	OBJ_PosSet(@to_obj OBJ_PosGet())
	OBJ_BankingGeneralSet(@to_obj OBJ_SightGet(), @to_obj OBJ_BankingGet())
	COL_StartMatrixSet(OBJ_PosGet())
}


//=================================================================================
// Téléporte le monstre sur un wp donné
//=================================================================================
procedure_local void BigMonster_Teleport(object to_obj)
{
	vector		tv_pos
	int				ti_i
	float			tf_dist
	object		to_bone
	
	OBJ_PosSet(@to_obj OBJ_PosGet())
	OBJ_BankingGeneralSet(@to_obj OBJ_SightGet(), @to_obj OBJ_BankingGet())
	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
	{
		to_bone = ao_modules[ti_i]
		tf_dist = af_modules_dist_to_head[ti_i]
		tv_pos = @to_obj OBJ_PosGet() - (tf_dist * @to_obj OBJ_SightGet())
		@to_bone OBJ_PosSet(tv_pos)
		@to_bone OBJ_BankingGeneralSet(@to_obj OBJ_BankingGet(), - @to_obj OBJ_SightGet())
	}
	COL_StartMatrixSet(OBJ_PosGet())
}


//=================================================================================
// Réinit les vars du bg monster pour passer au script suivant
//=================================================================================
procedure_local void BigMonster_Script_Next()
{
	i_script_next = vrai
	BigMonster_UpdateSpeed(f_speed_idle_max, f_speed_idle_blend)
	o_script_move_wp = nobody
	i_attack_radeau_flag = faux
	i_attack_type = 0
	f_time_depl_attack_joueur = 0.0
	o_script_move_after_attack_wp = nobody
	o_script_attack_marin_wp = nobody
	i_interet_target_nb = 0
	o_fight_move_wp = nobody
	if( i_DBG_trace_script )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : script next ")
		DBG_TraceEOL()
	}
}


//=================================================================================
// Resete la pile de script
//=================================================================================
procedure_local void BigMonster_Script_Reset()
{
	i_script_nb = 0
	i_script_indice = 0
	if( i_DBG_trace_script )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : script RESET ")
		DBG_TraceEOL()
	}
}


//=================================================================================
// Retourne vrai si une des conditions d'annulation d'attaque est remplie, faux sinon
//=================================================================================
procedure_local int BigMonster_AbortAttack()
{
	if( i_move_mode != Ci_move_mode_attack && i_move_mode != Ci_move_mode_apres_attaque )
		return faux		// n'est pas en mode attaque
	
	if(i_dynamite_just_gobee || i_paf_dmg_stop_attack_flag )
 		return vrai
	
	if( i_attack_marins_flag && @o_fight_actor OBJ_HierarchyGet() )
	{
		if( i_DBG_trace_IA )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : ")
			DBG_TraceObject(o_fight_actor)
			DBG_TraceString(" est remonté sur le radeau -> fin d'attaque")
			DBG_TraceEOL()
		}
		return vrai		// le marin est remontée sur le radeau
	}
	
	return faux
}


//=================================================================================
// Retourne vrai s'il y a un occluder sur le déplacement souhaité, faux sinon. (calcule la position de contournement de l'occluder, avec le bon Z)
//=================================================================================
procedure_local int BigMonster_Test_Occluder(vector tv_start_pos, vector tv_sight, float tf_size, vector tv_dest_pos, int ti_territory, byref vector tv_next_pos, byref object to_jump_wp, byrefarr object tao_add_occ, byrefarr float taf_add_occ_size, int ti_add_occ_nb)
{
	int			ti_occluder_status
	vector 	tv_me_to_target
	vector 	tv_me_to_target_N
	vector 	tv_me_to_occluder
	vector 	tv_me_to_proj_occluder
	float		tf_dist_proj
	
	ti_occluder_status = WAY_LIB_Test_Occluder(tv_start_pos, tv_sight, tf_size, tv_dest_pos, ti_territory, tv_next_pos, to_jump_wp, &tao_add_occ[0], &taf_add_occ_size[0], ti_add_occ_nb, C_Occl_Type_All)
	if( ti_occluder_status != 0 )
	{
		// RECUP POSITION CONTOURNEMENT OCCLUDER + CONSERVATION DU Z
		tv_me_to_target = tv_dest_pos - OBJ_PosGet()
//		DBG_RenderVector(OBJ_PosGet(), tv_me_to_target, color_jaune)
		tv_me_to_occluder = tv_next_pos - OBJ_PosGet()
//		DBG_RenderVector(OBJ_PosGet(), tv_me_to_occluder, color_vert)
		if( ! MATH_VecNullEpsilon(tv_me_to_target) )
			tv_me_to_target_N = MATH_VecNormalize(tv_me_to_target)
		else
			tv_me_to_target_N = OBJ_SightGet()
		tf_dist_proj = MATH_VecDotProduct(tv_me_to_occluder, tv_me_to_target_N)
//		DBG_RenderVector(OBJ_PosGet(), tv_me_to_target_N, color_bleu)
		tv_me_to_proj_occluder = tf_dist_proj * tv_me_to_target_N
//		DBG_RenderVector(OBJ_PosGet(), tv_me_to_proj_occluder, color_rouge)
		tv_next_pos.z = (OBJ_PosGet().z + tv_me_to_proj_occluder.z)
		return vrai
	}
	return faux
}


//=================================================================================
// Initialise le point de destination pour l'immersion
//=================================================================================
procedure_local void BigMonster_Immersion_Init()
{
	vector		tv_sight_horiz
	
	i_immersion = vrai		// plonge après avoir paffé le radeau
//	tv_sight_horiz = v_sight_avant_sinus
	tv_sight_horiz = v_move_pos_dest - v_move_pos_start		// ancien axe de depl
	tv_sight_horiz.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_sight_horiz) )
		MATH_VecSetNormalize(tv_sight_horiz)
	DBG_RenderVector(OBJ_PosGet(), tv_sight_horiz * 10, color_rouge)
//	f_speed_cur = 1.0
	f_sight_coef_accel = 0.0
	@o_dup_wp_occluder OBJ_PosSet(OBJ_PosGet() + (f_plonge_dist_H * tv_sight_horiz) + (f_plonge_dist_V * Cv_VerticalVector))
	BigMonster_MovePosDestUpdate(@o_dup_wp_occluder OBJ_PosGet())
	BigMonster_MovePosStartUpdate()
	f_speed_inclinaison_coef = 1.0
	f_speed_direction_coef = 1.0
	BigMonster_UpdateSpeed(f_speed_plonge_max, f_speed_plonge_blend)
	if( i_DBG_trace_IA )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : phase d'immersion...")
		DBG_TraceEOL()
	}
}


//=================================================================================
// Initialise un mouvement de positionnement pré-attaque
//=================================================================================
procedure_local void BigMonster_Attack_Positionnement_Init(object to_wp_positionnement)
{
	vector		tv_sight
	vector		tv_new_pos
	
	i_attack_phase = Ci_attack_phase_vers_wp_temp
	tv_new_pos = BigMonster_GetIntermediatePosition(to_wp_positionnement)
	@o_dup_wp_occluder OBJ_PosSet(tv_new_pos)
	BigMonster_MovePosDestUpdate(@o_dup_wp_occluder OBJ_PosGet())
	BigMonster_MovePosStartUpdate()
}


//=================================================================================
// Initialise une attaque
//=================================================================================
procedure_local object BigMonster_Attack_Init(object to_fight_actor)
{
	object		to_wp
	vector		tv_pos
	vector		tv_temp
	
	i_move_mode = Ci_move_mode_attack
	i_en_fuite = faux
	i_grabbed_actor_killed = faux
	if( i_attack_type == Ci_attack_type_renverse )
	{
		i_attack_phase = Ci_attack_phase_sortdeleau
		if( i_DBG_trace_IA )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : attaque 'Renverse' : début de la phase sort de l'eau")
			DBG_TraceEOL()
		}
	}
	else if( i_attack_type == Ci_attack_type_ras_de_l_eau )
	{
		i_attack_phase = 0
		if( i_DBG_trace_IA )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : attaque au ras de l'eau : aucune phase")
			DBG_TraceEOL()
		}
	}
	else if( i_attack_type == Ci_attack_type_jump_horsdeleau )
	{
		i_attack_phase = 0
		if( i_DBG_trace_IA )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : attaque jump hors de l'eau : aucune phase")
			DBG_TraceEOL()
		}
	}
	else
	{
		DBG_Error("i_attack_type ????")
	}
	to_wp = @to_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
	if( to_wp )
		return to_wp		// cible depl = tete
	else
		return to_fight_actor
}


//=================================================================================
// Retourne vrai si le monstre doit se déplacer horizontalement, faux sinon
//=================================================================================
procedure_local int BigMonster_Depl_Horiz()
{
	if( i_move_mode == Ci_move_mode_idle )
		return vrai
	if( i_move_mode == Ci_move_mode_attack )
	{
		switch( i_attack_phase )
		{
			case Ci_attack_phase_renverse :
			case Ci_attack_phase_souleve :
				return faux
			default:
				return vrai
		}
	}
	if( i_attack_phase == Ci_attack_phase_orientation )
		return vrai
	if( i_attack_phase == Ci_attack_phase_vers_wp_temp )
		return vrai
//	if( i_move_mode == Ci_move_mode_in_time )
//		return vrai
	return faux
}


//=================================================================================
// Retourne vrai si le monstre est dans un état pendant lequel il se déplace vers un wp temporaire, faux sinon
//=================================================================================
procedure_local int BigMonster_Depl_Vers_WP_Temp()
{
	if( i_attack_radeau_flag )
		return vrai
	if( i_attack_marins_flag )
		return vrai
	if( i_attack_phase == Ci_attack_phase_vers_wp_temp )
			return vrai
	if( i_immersion )
		return vrai
	if( i_en_fuite )
		return vrai
	if( i_attack_phase == Ci_attack_phase_orientation )
		return vrai
	if( i_move_mode == Ci_move_mode_fuite )
		return vrai
	return faux
}


//=================================================================================
// Retourne vrai si le monstre est dans un état pendant lequel il doit raz le wp de script à la fin de son déplacement, faux sinon
//=================================================================================
procedure_local int BigMonster_NextScriptWhenReachedPos()
{
	if( i_attack_type == Ci_attack_type_jump_horsdeleau )
		return vrai
	if( i_move_mode == Ci_move_mode_attack )
		return faux
	if( i_attack_phase == Ci_attack_phase_vers_wp_temp )		// mode apres_attaque ou mode move_in_time (ou autre.... ???)
		return faux
	if( i_attack_phase == Ci_attack_phase_orientation )		// mode apres_attaque ou mode move_in_time (ou autre.... ???)
		return faux
	return vrai
}


//=================================================================================
// Retourne vrai si le monstre est dans un état dans lequel sa vitesse a été calculée et imposée
//=================================================================================
procedure_local int BigMonster_ModeVitesseImposee()
{
	if( i_move_mode == Ci_move_mode_in_time )
		return vrai
	if( f_time_depl_attack_joueur )		// faux "move in time" pour attaquer le joueur tombé à l'eau
		return vrai
	return faux
}


//=================================================================================
// Calcule la vitesse de déplacement du monstre
//=================================================================================
procedure_local float BigMonster_SpeedCompute()
{
	return MATH_FloatBlend(f_speed_cur, f_speed_inclinaison_coef * f_speed_direction_coef * f_speed_max * f_speed_blend_secure, f_speed_blend * TIME_GetDt())
}


//=================================================================================
// Retourne la distance entre la position courante et la position à atteindre (teste les occluders)
//=================================================================================
procedure_local float BigMonster_MoveDistGet(vector tv_test_occluder_dest_pos, vector tv_init_pos)
{
	float				tf_time
	vector			tv_pos_occluder
	object			ao_occluder[10]
	float				af_occluder[10]
	int					ti_occluder_status
	object			to_occluder_jump
	
	DBG_RenderVector(tv_init_pos, tv_test_occluder_dest_pos - tv_init_pos, color_jaune)
	tf_time = 0
	ti_occluder_status = WAY_LIB_Test_Occluder(OBJ_PosGet(), OBJ_SightGet(), f_occluder_largeur, tv_test_occluder_dest_pos, -1, tv_pos_occluder, to_occluder_jump, &ao_occluder[0], &af_occluder[0], 0, C_Occl_Type_All)
	if( ti_occluder_status == 0 )
	{
		// pas d'occluder
		tf_time += MATH_VecNorm(tv_test_occluder_dest_pos - tv_init_pos)
	}
	else
	{
		// occluder : calcul de moi -> occluder + occluder -> destination
		DBG_RenderVector(tv_init_pos, tv_pos_occluder - tv_init_pos, color_jaune)
		DBG_RenderVector(tv_pos_occluder, tv_test_occluder_dest_pos - tv_pos_occluder, color_jaune)
		tf_time += MATH_VecNorm(tv_pos_occluder - tv_init_pos)
		tf_time += MATH_VecNorm(tv_test_occluder_dest_pos - tv_pos_occluder)
	}
	return tf_time
}


//=================================================================================
// Retourne vrai si le big monster est dans un état où il doit etre en snake, faux sinon
//=================================================================================
procedure_local int BigMonster_SnakeOn(vector tv_paf_recul)
{
	if( ! MATH_VecNullEpsilon(tv_paf_recul) )
		return vrai
	if( i_immersion )
		return vrai
	if( i_attack_marins_flag )
	{
		if( ! i_attack_phase ) // || i_attack_phase == Ci_attack_phase_orientation )
			return faux
		else
			return vrai
	}
	if( i_attack_phase == Ci_attack_phase_plonge )
		return vrai
	if( ! f_HP_cur ) 
		return vrai
	return faux
}


//=================================================================================
// Retourne vrai si la destination a été atteinte, faux sinon
//=================================================================================
procedure_local int BigMonster_ReachedPos(vector tv_dest_pos)
{
	float			tf_dot1
	float			tf_dot2
	vector		tv_dest_to_start
	vector		tv_dest_to_current
	
	tv_dest_to_start = v_move_pos_start - tv_dest_pos
	tv_dest_to_current = OBJ_PosGet() - tv_dest_pos
	
//	DBG_RenderVector(tv_dest_pos, tv_dest_to_start, color_vert)
//	DBG_RenderVector(tv_dest_pos, tv_dest_to_current, color_rouge)
	
	if( MATH_VecNorm(tv_dest_to_current) < 1.0 )
		return vrai
	
	tf_dot1 = MATH_VecDotProduct(tv_dest_to_start, tv_dest_to_current)
	if( tf_dot1 < 0 )
		return vrai
	else
		return faux
}


//=================================================================================
// Calcule la vitesse de déplacement du monstre
//=================================================================================
procedure_local void BigMonster_SpeedCoefCompute()
{
	vector		tv_dest_pos
	vector		tv_axe_move
	vector		tv_proj_pos
	vector		tv_axe_sight_horiz
	vector		tv_sight_new
	float			tf_speed_direction_coef
		
	if( BigMonster_ModeVitesseImposee() )
	{
		f_speed_inclinaison_coef = 1.0
		f_speed_direction_coef = 1.0
		f_speed_blend = 10.0
		return
	}
	
	if( i_move_mode == Ci_move_mode_idle )
	{
		// Tourne en rond
		BigMonster_Occluder_Compute_Idle_Pos(v_sight_avant_sinus, tv_sight_new, tv_dest_pos)
	}
	else
	{
		// Va vers un wp spécifié
		if( BigMonster_Depl_Vers_WP_Temp() )
			tv_dest_pos = @o_dup_wp_occluder OBJ_PosGet()
		else
			tv_dest_pos = @o_script_move_wp OBJ_PosGet()
	}
	
	// COEF INCLINAISON ---------------------------------------------------------------------------------------------------------------------------
	tv_axe_move = tv_dest_pos - OBJ_PosGet()
	tv_axe_sight_horiz = OBJ_SightGet()
	tv_axe_sight_horiz.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_axe_sight_horiz) && ! MATH_VecNullEpsilon(tv_axe_move) )
	{
	//	MATH_VecSetNormalize(tv_axe_sight_horiz)
	//	tf_dist_inclinaison = MATH_AbsFloat(MATH_VecDotProduct(tv_axe_move, tv_axe_sight_horiz))
	//	tv_proj_pos = OBJ_PosGet() + (MATH_VecNormalize(tv_axe_sight_horiz) * tf_dist_inclinaison)
	//	DBG_RenderVector(OBJ_PosGet(), tv_axe_move, color_vert)
	//	DBG_RenderVector(OBJ_PosGet(), MATH_VecNormalize(tv_axe_sight_horiz) * tf_dist_inclinaison, color_jaune)
	//	DBG_RenderVector(tv_proj_pos, tv_dest_pos - tv_proj_pos, color_rouge)
		if( tv_dest_pos.z > OBJ_PosGet().z )
		{
			// je remonte
			f_speed_inclinaison_coef = MATH_FloatMax(0.8, (f_speed_inclinaison_coef - (0.1 * TIME_GetDt())))
		}
		else
		{
			// je descend
			f_speed_inclinaison_coef = MATH_FloatMin(1.0, (f_speed_inclinaison_coef + (0.3 * TIME_GetDt())))
		}
	}
	else
		f_speed_inclinaison_coef = MATH_FloatBlend(f_speed_inclinaison_coef, 1.0, (0.5 * TIME_GetDt()))
	
	
//	tf_speed_inclinaison_coef_old = f_speed_inclinaison_coef
//	tv_dest_pos = @o_dup_wp_next OBJ_PosGet()
//	tv_axe_move = tv_dest_pos - OBJ_PosGet()
//	tv_axe_sight_horiz = OBJ_SightGet()
//	tv_axe_sight_horiz.z = 0.0
//	f_speed_inclinaison_coef = 1.0
//	if( ! MATH_VecNullEpsilon(tv_axe_sight_horiz) && ! MATH_VecNullEpsilon(tv_axe_move) )
//	{
//		MATH_VecSetNormalize(tv_axe_sight_horiz)
//	//	MATH_VecSetNormalize(tv_axe_move)
//		tf_dist_projection = MATH_AbsFloat(MATH_VecDotProduct(tv_axe_move, tv_axe_sight_horiz))
//		tv_proj_pos = OBJ_PosGet() + (tv_axe_sight_horiz * tf_dist_projection)
//		tv_axe_move = tv_proj_pos - OBJ_PosGet()
//		DBG_RenderVector(OBJ_PosGet(), tv_axe_move, color_cyan)
//		tv_axe_move.z += (tv_dest_pos.z - OBJ_PosGet().z)
//		DBG_RenderVector(OBJ_PosGet(), tv_axe_move, color_cyan)
//		MATH_VecSetNormalize(tv_axe_move)
//		DBG_RenderVector(OBJ_PosGet(), tv_axe_move, color_cyan)
//		
//		f_speed_inclinaison_coef = MATH_VecDotProduct(tv_axe_move, tv_axe_sight_horiz)
//		DBG_RenderVector(OBJ_PosGet(), tv_axe_sight_horiz * 10.0, color_jaune)
//		DBG_RenderVector(OBJ_PosGet(), tv_axe_move * 10.0, color_rouge)
//		if( tv_dest_pos.z > OBJ_PosGet().z )
//		{
//			// sinon je monte : coef de 0.0 à 1.0
//			f_speed_inclinaison_coef = (f_speed_inclinaison_coef - 0.5) * 2.0			// 0.0 / 0.5 / 1.0 => 0.0 / 0.0 / 0.1
//		}
//		else
//		{
//			// je descend : coef de 1.0 à 2.0
//	//		f_speed_inclinaison_coef = 2.0 - f_speed_inclinaison_coef
//	
//	//		tf_temp = 1.0 - f_speed_inclinaison_coef		// en plus de 1.0 (car je plonge)
//	//		f_speed_inclinaison_coef = MATH_FloatMin(1.25, 1.0 + tf_temp)
//	
//			f_speed_inclinaison_coef += 1 - ((f_speed_inclinaison_coef - 0.5) * 2.0)		// jusqu'à 1.5
//		}
//	}
//	f_speed_inclinaison_coef = MATH_FloatBlend(tf_speed_inclinaison_coef_old, f_speed_inclinaison_coef, 2.0 * TIME_GetDt())
	
	
	// COEF ORIENTATION -------------------------------------------------------------------------------------------------------------------------------------
	tv_axe_move.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_axe_move) )
	{
		MATH_VecSetNormalize(tv_axe_move)
		tf_speed_direction_coef = MATH_VecDotProduct(tv_axe_sight_horiz, tv_axe_move)
		// coef de 0.5 à 1.0
		tf_speed_direction_coef *=0.25
		tf_speed_direction_coef += 0.75
//		tf_speed_direction_coef = MATH_FloatMax(tf_speed_direction_coef, 0.2)
	}
	else
		tf_speed_direction_coef = 1.0
	
	f_speed_direction_coef = MATH_FloatBlend(f_speed_direction_coef, tf_speed_direction_coef, 5 * TIME_GetDt())
}


//=================================================================================
// Retourne vrai si le monstre est dans un état où l'ondulation du corps est autorisée
//=================================================================================
procedure_local int BigMonster_Ondulation_Autorisee()
{
	if( i_immersion )
		return faux
	if( i_attack_marins_flag )
	{
		if( ! i_attack_phase )
			return vrai
		else
			return faux
	}
	switch( i_attack_phase )
	{
		case Ci_attack_phase_plonge :
		case Ci_attack_phase_renverse :
		case Ci_attack_phase_souleve :
			return faux
		default:
			return vrai
	}
	return vrai
}


//=================================================================================
// Retourne vrai si le monstre doit onduler suite à un paf
//=================================================================================
procedure_local int BigMonster_Ondulation_Paf()
{
	if( MATH_FloatNullToler(f_time_paf_sinus_horiz, 0.1) )
		return faux
	else
		return vrai
}


//=================================================================================
// Retourne vrai si le monstre a le droit de paffer/grabber
//=================================================================================
procedure_local int BigMonster_PhasePaffeOuGrabbe()
{
	if( i_move_mode == Ci_move_mode_attack )
	{
		switch( i_attack_phase )
		{
			case Ci_attack_phase_vers_wp_temp :
			case Ci_attack_phase_orientation :
			case Ci_attack_phase_plonge :
			case Ci_attack_phase_souleve :		// new test
				return faux
			
			case Ci_attack_phase_sortdeleau :
				if( i_attack_type == Ci_attack_type_ras_de_l_eau )
					return vrai
				else
					return faux
			
			default:
				return vrai
		}
	}
	return faux
}

