#include "PNJ_Brontosaure_defs.var"

int			ti_i
int			ti_k
int			ti_frame_num
int			ti_flag_collision
int			ti_flag_ok
int			ti_action

float		tf_angle
float		tf_offset
float		tf_bassin_offset
float		tf_bassin_offset_min
float		tf_norm
float		tf_X
float		tf_Y
float		tf_coef
float		tf_IK_coef
float		tf_size_coef
float		tf_coef_min
float		tf_coef_max
float		tf_ray_start_offset
float		tf_look_Z_coef
float		tf_target_coef
float		tf_sign
float		tf_dot_product

vector	tv_pied_pos
vector	tv_collide_pos
vector	tv_ray_start
vector	tv_ray_dir
vector	tv_last_pos
vector	tv_start_axis
vector	tv_dest_axis
vector	tv_ray_normale
vector	tv_bassin_dest_pos
vector	tv_dest_pos
vector	tv_X
vector	tv_Y
vector	tv_temp
vector	tv_rot_pivot_pos
vector	tv_look_axis
vector	tv_virtual_banking
vector	tv_virtual_sight
vector	tv_flexion_dir

object	to_target
object	to_bone

//vector	tv_queue_banking
//object	to_queue

#define Cf_offset_min						-100.0
#define Cf_offset_max						100.0
#define Cf_walk_Z_blend_speed			12.0

#define Ci_bone_pos_index				2

if ( no_IK_LEG )
	return


v_IK_ref_ground_pos = OBJ_PosGet()

tv_virtual_banking = OBJ_BankingGet() // H_Body_Speed_Rotate()
tv_ray_dir = tv_virtual_banking

if (@get_global i_IK_LEG_Off)
{
	Bronto_Reset_IK_Legs()
	return
}

if ( (OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Culled) || OBJ_CapaTest( OBJ_Capa_1 ) )
{
	Bronto_Reset_IK_Legs()
	return
}

//to_queue = ANI_CanalObjectGet(Anim_Canal_Queue)
//tv_queue_banking = @to_queue OBJ_BankingGet()

tf_size_coef = 1.0
tf_bassin_offset_min = -1.0
tf_coef_min = 0.15
tf_coef_max = 0.2
tf_ray_start_offset = 0.33

// EST-CE QU'ON S'ADAPTE AU RELIEF DU SOL ??? =============================================================
tf_bassin_offset = 0.0

ti_action = ACT_ActionGet()

for (ti_i = 0; ti_i < 4; ti_i++)
{
	if (! i_flag_leg_IK[ti_i] && ! f_IK_coef[ti_i])
		continue

	tf_coef = Bronto_Get_Move_Coef(ti_i)

	if (f_IK_coef[ti_i] == 1.0 && tf_coef != -1.0)
	{
		if (tf_coef < 1.0) 
		{
			// Le pied décole
			f_IK_snap_coef[ti_i]	= 1.0 - tf_coef
			f_IK_ground_coef[ti_i] = 1.0 - MATH_Sin(tf_coef * Cf_Pi)
		
			tv_pied_pos = v_IK_ground_pos[ti_i] 
			tv_pied_pos += MATH_VecDotProduct(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet() - tv_pied_pos, tv_ray_dir) * tv_ray_dir

			tv_pied_pos = MATH_VecBlend(tv_pied_pos, @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet(), tf_coef)

			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet() // MATH_VecBlend(v_IK_bone_last_valid_sight[ti_i], @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet(), tf_coef)
			v_IK_bone_last_valid_banking[ti_i] = MATH_VecBlend(v_IK_bone_last_valid_banking[ti_i],  @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet(), tf_coef)
		}
		else 
		{
			// Le pied est posé
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 6.0 * TIME_GetDt())
		
			if (f_IK_snap_coef[ti_i] == 1.0)
			{
				// OK, on a sauvé la position ou le pied a été posé
				v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet()
				v_IK_bone_last_valid_banking[ti_i] = MATH_VecInCone(v_IK_bone_last_valid_banking[ti_i], @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet(), Cf_PiBy6, 1)
		
				tv_pied_pos = v_IK_ground_pos[ti_i] 
				tv_pied_pos += MATH_VecDotProduct(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet() - tv_pied_pos, tv_ray_dir) * tv_ray_dir
				
				DBG_RenderVector(tv_pied_pos, Cv_VerticalVector * 100.0, color_jaune)
			}
			else
			{
				// Première trame ou le pied est posé
				f_IK_snap_coef[ti_i] = 1.0	
			
				v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet()
				v_IK_bone_last_valid_banking[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet()
	
				tv_pied_pos = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet()
			}
		}
	}
	else
	{
		f_IK_snap_coef[ti_i] -= MATH_FloatMin(f_IK_snap_coef[ti_i], 10.0 * TIME_GetDt())	

		if (f_IK_snap_coef[ti_i])
		{
//			f_feet_contact_duration[ti_i] = 0.0
		
			tf_coef = f_IK_snap_coef[ti_i]
			f_IK_ground_coef[ti_i] = 1.0 - tf_coef
		
			tv_pied_pos = v_IK_ground_pos[ti_i] 
			tv_pied_pos += MATH_VecDotProduct(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet() - tv_pied_pos, tv_ray_dir) * tv_ray_dir

			tv_pied_pos = MATH_VecBlend(tv_pied_pos, @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet(), tf_coef)

			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet() // MATH_VecBlend(v_IK_bone_last_valid_sight[ti_i], @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet(), tf_coef)
			v_IK_bone_last_valid_banking[ti_i] = MATH_VecBlend(v_IK_bone_last_valid_banking[ti_i],  @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet(), tf_coef)
		}
		else
		{
//			f_feet_contact_duration[ti_i] = 0.0
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 6.0 * TIME_GetDt())
		
			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet()
			v_IK_bone_last_valid_banking[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet()
	
			tv_pied_pos = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet()
		}
	}

	tv_ray_start = tv_pied_pos
	tv_ray_start -= MATH_VecDotProduct(tv_ray_start - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_ray_dir) * tv_ray_dir

	ti_flag_collision = faux

	@get_global i_raptor_ray_on_colmap_nb++
	if (COL_RayObject_Dist(tv_ray_start, -tv_ray_dir, f_IK_leg_length[ti_i], all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//	if (COL_RayObject_Dist(tv_ray_start, -tv_ray_dir, f_IK_leg_length[ti_i], all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel))
		ti_flag_collision = vrai
	
	if (ti_flag_collision)
	{
		// OK ON TOUCHE UN SOL, ON VA POUVOIR POSITIONNER EN IK ==============================================
		tv_collide_pos = COL_RayObject_PosGet()
		tv_ray_normale = COL_RayObject_NormalGet()

//		DBG_RenderVector(tv_ray_start, tv_collide_pos - tv_ray_start, color_vert)
		DBG_RenderVector(tv_collide_pos, tv_ray_normale * 0.25, color_jaune)
		
		tf_offset = MATH_VecDotProduct(tv_collide_pos - tv_ray_start, -tv_ray_dir)
		if (tf_offset >= tf_ray_start_offset)
			ti_flag_collision = vrai
		else
			ti_flag_collision = faux
	}
	else
	{
		DBG_RenderVector(tv_ray_start, -tv_ray_dir * f_IK_leg_length[ti_i], color_rouge)
	}
	
	if (ti_flag_collision)
	{
		v_IK_ground_pos[ti_i] = tv_collide_pos
		v_IK_ground_normale[ti_i] = MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_ray_normale, 4.0 * TIME_GetDt())
		tf_offset = MATH_VecDotProduct(tv_collide_pos - v_IK_ref_ground_pos, tv_ray_dir)
	}
	else
	{
		v_IK_ground_pos[ti_i] = tv_pied_pos
		v_IK_ground_normale[ti_i] = MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_virtual_banking, 4.0 * TIME_GetDt())
		tf_offset = 0.0	
//		DBG_RenderVector(tv_ray_start, -tv_ray_dir * f_IK_leg_length[ti_i], color_rouge)	
	}		

		
	tf_offset = MATH_FloatMin(tf_offset, f_IK_leg_length[ti_i] * 0.33)
	
	if (tf_offset && tf_offset > f_IK_Z_offset[ti_i])
		f_IK_Z_offset[ti_i] = tf_offset // MATH_FloatBlend(f_IK_Z_offset[ti_i], tf_offset, 20.0 * TIME_GetDt())
	else
		f_IK_Z_offset[ti_i] = MATH_FloatBlend(f_IK_Z_offset[ti_i], tf_offset, Cf_walk_Z_blend_speed * TIME_GetDt())

	v_IK_dest_pos[ti_i] = tv_pied_pos
	v_IK_dest_pos[ti_i] += tv_ray_dir * f_IK_Z_offset[ti_i]
	
//	DBG_RenderVector(v_IK_dest_pos[ti_i], -tv_ray_dir * f_IK_Z_offset[ti_i], color_cyan)

	f_IK_speed[ti_i] = 1.0
}

tf_IK_coef = f_IK_coef[Ci_IK_pied_gauche]
tf_IK_coef = MATH_FloatMax(tf_IK_coef, f_IK_coef[Ci_IK_pied_droit])
tf_IK_coef = MATH_FloatMax(tf_IK_coef, f_IK_coef[Ci_IK_main_gauche])
tf_IK_coef = MATH_FloatMax(tf_IK_coef, f_IK_coef[Ci_IK_main_droite])

if (tf_IK_coef)
{
	tv_rot_pivot_pos = @o_ventre OBJ_PosGet()
	tv_temp = @o_ventre MATH_VecGlobalToLocal(@o_bassin OBJ_PosGet() - tv_rot_pivot_pos)

	// ROTATION BASSIN EN FONCTION DES ACCUMULATION DE PAFS ===============================================
	for (ti_i = 0; ti_i < 10; ti_i++)
	{
		ti_k = MATH_Modulo(i_quat_index + ti_i, 10)
	
		if (af_quat_time[ti_k] == -1.0)
			continue	
	
		tf_coef = TIME_Get() - af_quat_time[ti_k]
		if (tf_coef < 1.0)	
		{
			tf_coef = MATH_FloatMin(tf_coef * 10.0, 1.0) * (1.0 - tf_coef)
			tf_coef *= tf_IK_coef
	
			tv_X = @o_bassin MATH_VecGlobalToLocal(av_quat_start[ti_k])
			tv_Y = @o_bassin MATH_VecGlobalToLocal(av_quat_end[ti_k])

			@o_bassin OBJ_Rotate_FromTo(tv_X, MATH_VecBlend(tv_X, tv_Y, tf_coef * af_quat_coef[ti_k]))
		}
		else
		{
			af_quat_time[ti_k] = -1.0
		}
	}

	// ROTATION DU BASSIN EN FONCTION DU SUIVI DE REGARD ============================================================
	tv_virtual_sight = @o_bassin MATH_VecGlobalToLocal(OBJ_SightGet())

	tv_look_axis = v_look_axis

	f_IK_bassin_look_rot_coef = 0.1
	@o_bassin OBJ_Rotate_FromTo(tv_virtual_sight, MATH_VecBlendRotate(tv_virtual_sight, @o_bassin MATH_VecGlobalToLocal(tv_look_axis), f_IK_bassin_look_rot_coef * tf_IK_coef * f_look_blend_coef))

	// ON REPOSITIONNE LE BASSIN QUI A TOURNE AUTOUR DU PIVOT ========================================================
	tv_temp = @o_ventre MATH_VecLocalToGlobal(tv_temp)
	tv_temp += tv_rot_pivot_pos

	// ON RAJOUTE UN DEPLACEMENT LIE AU PAF ======================================================================
	if (! TIME_Elapsed(f_visual_paf_time, 0.5) )
	{
		tf_coef = TIME_Get() - f_visual_paf_time
		tf_coef /= 0.5
		tf_coef = 1.0 - tf_coef
		tf_coef *= tf_coef
		tf_coef = MATH_Sin(tf_coef * Cf_Pi)

		tv_temp += v_visual_paf_dir * (tf_coef * 0.8)
		tv_temp.z -= tf_coef * 0.8
	}

	@o_bassin OBJ_PosSet(tv_temp)
}
else
{
	f_IK_bassin_look_rot_coef = 0.0
}

// DECALAGE EN Z DU BASSIN POUR QUE LES PIEDS PUISSENT TOUCHER LE SOL ============================================
tf_bassin_offset = 0.0
for (ti_i = 0; ti_i < 4; ti_i++)
{
	if (f_IK_Z_offset[ti_i] < tf_bassin_offset)
		tf_bassin_offset = f_IK_Z_offset[ti_i] * 0.75
}

for (ti_i = 0; ti_i < 4; ti_i++)
{
	if (i_flag_leg_IK[ti_i] || f_IK_coef[ti_i])
	{
		tv_X = v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet()
		tv_X -= MATH_VecDotProduct(tv_X, tv_ray_dir) * tv_virtual_banking
	
		tf_X = MATH_VecDotProduct(tv_X, tv_X)

		tf_Y = 0.0
		for (ti_k = 0; ti_k < 3; ti_k++)
			tf_Y += af_IK_bones_length[ti_i][ti_k]

		tf_Y *= 0.99
		tf_Y *= tf_Y
		
		tf_norm = tf_Y
		tf_norm -= tf_X
	
		tf_norm = MATH_FloatMax(tf_norm, 0.0)
	//		if (tf_norm < 0.0)
	//			DBG_Error("Ha ha !!!")	
	
		tf_norm = MATH_FloatSqrt(tf_norm)
	
		tf_offset = tf_norm + MATH_VecDotProduct(v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_virtual_banking)
	
		tf_bassin_offset = MATH_FloatMin(tf_bassin_offset, tf_offset)
	}
}

tf_bassin_offset = MATH_FloatMax(tf_bassin_offset, tf_bassin_offset_min)

f_bassin_Z_offset	= MATH_FloatBlend(f_bassin_Z_offset, tf_bassin_offset, 8.0 * TIME_GetDt())
//f_bassin_Z_offset	= tf_bassin_offset

tv_bassin_dest_pos = @o_bassin OBJ_PosGet()
tv_bassin_dest_pos += tv_virtual_banking * (f_bassin_Z_offset * f_IK_coef[Ci_IK_pied_gauche])

@o_bassin OBJ_PosSet(tv_bassin_dest_pos)
v_IK_bassin_pos = tv_bassin_dest_pos

// ON EXECUTE L'IK =============================================================================================================
for (ti_i = 0; ti_i < 4; ti_i++)
{
	if (i_flag_leg_IK[ti_i])
	{
		f_IK_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_coef[ti_i], TIME_GetDt() * 8.0)	
	
		f_IK_ground_coef[ti_i] *= f_IK_coef[ti_i]

		tv_pied_pos = MATH_VecBlend(MATH_VecLocalToGlobal(v_IK_local_offset[ti_i]), v_IK_dest_pos[ti_i] - OBJ_PosGet(), f_IK_speed[ti_i])
		v_IK_local_offset[ti_i] = MATH_VecGlobalToLocal(tv_pied_pos)
		tv_pied_pos += OBJ_PosGet()
	}
	else if (f_IK_coef[ti_i])
	{
		f_IK_coef[ti_i] -= MATH_FloatMin(f_IK_coef[ti_i], TIME_GetDt() * 0.5)

		f_IK_Z_offset[ti_i] *= f_IK_coef[ti_i]
		f_IK_ground_coef[ti_i] *= f_IK_coef[ti_i]
		f_IK_snap_coef[ti_i] *= f_IK_coef[ti_i]
	
		v_IK_dest_pos[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet()
		tv_pied_pos = MATH_VecBlendRotate(v_IK_dest_pos[ti_i] - OBJ_PosGet(), MATH_VecLocalToGlobal(v_IK_local_offset[ti_i]), f_IK_coef[ti_i])
		v_IK_local_offset[ti_i] = MATH_VecGlobalToLocal(tv_pied_pos)
		tv_pied_pos += OBJ_PosGet()
	}
	else
	{
		v_IK_ground_normale[ti_i] = tv_virtual_banking
		continue
	}


//	tv_flexion_dir = MATH_VecCrossProduct(@ao_IK_bones[ti_i][0] OBJ_BankingGet(), @ao_IK_bones[ti_i][2] OBJ_PosGet() - @ao_IK_bones[ti_i][0] OBJ_PosGet())
//	tv_flexion_dir = MATH_VecCrossProduct(@ao_IK_bones[ti_i][2] OBJ_PosGet() - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_flexion_dir)
//	MATH_VecSetNormalize(tv_flexion_dir)
//
//	OBJ_LIB_IK(	ao_IK_bones[ti_i][0], ao_IK_bones[ti_i][1],
//						af_IK_bones_length[ti_i][0], af_IK_bones_length[ti_i][1],
//						tv_pied_pos,
//						tv_flexion_dir,
//						f_IK_coef[ti_i] )

	OBJ_LIB_IK(	ao_IK_bones[ti_i][0], ao_IK_bones[ti_i][1],
						af_IK_bones_length[ti_i][0], af_IK_bones_length[ti_i][1],
						tv_pied_pos,
//						-@ao_IK_bones[ti_i][1] OBJ_BankingGet(),
						Cv_NullVector,
						f_IK_coef[ti_i] )

	@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGeneralSet(
		MATH_VecBlend(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet(), v_IK_bone_last_valid_sight[ti_i], f_IK_coef[ti_i]) , 
		MATH_VecBlend(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet(), v_IK_bone_last_valid_banking[ti_i], f_IK_coef[ti_i]) )

	if (f_IK_ground_coef[ti_i])
	{
		tv_start_axis = @ao_IK_bones[ti_i][Ci_bone_pos_index] MATH_VecGlobalToLocal(tv_virtual_banking)
		
		tv_dest_axis = v_IK_ground_normale[ti_i]
		tv_dest_axis = MATH_VecInCone(tv_dest_axis, - @ao_IK_bones[ti_i][1] OBJ_BankingGet(), Cf_PiBy6, 1)
		tv_dest_axis = @ao_IK_bones[ti_i][Ci_bone_pos_index] MATH_VecGlobalToLocal(tv_dest_axis)
		tv_dest_axis = MATH_VecBlend(tv_start_axis, tv_dest_axis, f_IK_ground_coef[ti_i])
		@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_Rotate_FromTo(tv_start_axis, tv_dest_axis)
	}
}

//@to_queue OBJ_BankingSet(MATH_VecBlendRotate(@to_queue OBJ_BankingGet(), tv_queue_banking, 0.5))
