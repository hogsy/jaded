#include "KR_defines.var"

int					ti_finish_test
int					ti_paf
int					EVT_rank
vector			tv_temp
vector			tv_temp2
vector			tv_lance_pos

float				tf_jump_time
float				tf_jump_amplitude
float				tf_jump_friction
float				tf_cote
float				tf_temp

object			to_lead
object			to_sender

messageid		tmid_grabAnn
messageid		tmid_vision


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{	
	i_jump_etat = Ci_Jump_notJumping 	// Paf possible pendant un saut
	
	if( i_etat_courant != ETAT_Finish_on_KONG )
		KR_ResetRide()

	i_sort_etat = faux
	return
}


i_jump_exit = faux		// avant l'init car l'init le modifie


// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_KK_ride)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_KK_ride

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KR_DBG_Trace_Gao(i_DBG_trace_finish, "passe en ride sur Kong / bone = ", LNK_GrabBoneGet(mid_bone_ride_KK_LNK_ID))
	
	// vient de sauter sur KONG
	f_pos_blend_coef_ride = 0.0
	DYN_GravitySet(Cv_NullVector)
	COL_ColSetActivationSet(none, C_bit_zdm_pied)
	o_bone_ride_KK_uncol = o_bone_ride_KK
	KR_UncollideableAdd(o_bone_ride_KK_uncol)
	AI_CBAdd(o_bone_ride_KK_uncol, CallBack_After_Blend, "KR_CALLBACK_set_pos")
	
	if( i_action_init == Ci_action_init_Spawn_Finish )
	{
		i_ride_mode = Ci_ride_wait_for_finish
		ACT_ActionSet(Action_Ride_Attente)
	}
	else
	{
		i_ride_mode = Ci_ride_paf_kong
		f_ride_attack_delay = Cf_delay_ride_attack + MATH_RandFloat(-0.5, 0.5)
		ACT_ActionSet(Action_Ride_LandingOnKong)
		
		// make kong bend a little uppon impact of having me on his back
		tv_temp = MATH_VecBlend(@o_KONG OBJ_SightGet(), -Cv_VerticalVector, 0.5)	// direction of the paf
		EVENT_AddEventPafCanal(C_EVENT_FILTER_All, C_PAF_KK_Faible, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_KONG, -1, 0.0, tv_temp, COL_ZonePosGet(C_zde_fight))
		KR_DBG_Trace(i_DBG_trace_send_paf, "paf faible (0 dmg) en rentrant en ride (etat ride)")
	}

	// Update Kong's attack message
	EVENT_Info_LastAttackSet( mid_lastKongAttack, Ci_LASTATTACK_TYPE_Grab, TIME_Get(), OBJ_Me() )
	i_ride_pafGiven = faux
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE =======================================================================================================


// PAFS ============================================================
AI_Execute("KR_exec_check_paf")
if( o_paf_actor )
{
	KR_Select_Paf_Etat(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}


// GRAB ===========================================================
o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	macro_change_etat("KR_ETAT_grabbed")



// TEST PASSAGE EN FINISH ==========================================
if( i_DBG_Finish_on_Kong_Forbidden )
	ti_finish_test = faux
else
	ti_finish_test = vrai
o_I_finish_actor = LNK_ClientGet(Ci_LNK_KKFINISH_ON_KONG, mid_I_finish_LNK_ID, ti_finish_test, nofunc, nofunc, nofunc)
if( o_I_finish_actor )
{
	KR_DBG_Trace(i_DBG_trace_finish, "obtient la prio pour faire un finish sur KONG !!")
	KR_Finish_Initialisation(vrai)
	macro_change_etat("KR_ETAT_Finish_on_KONG")
}


// PASSAGE EN FINISH FAKE =========================================
if( @get_global o_KNMI_finish_leader )
{
	// il y a un finish : passage en anim finish fake
	to_lead = @get_global o_KNMI_finish_leader
	if( to_lead)
	{
		if( @to_lead AI_IsModel(get_PNJ_KRaptor_path))
		{
			KR_DBG_Trace_Gao(i_DBG_trace_finish, "détecte qu'1 raptor est passée en finish : ", @get_global o_KNMI_finish_leader)
			KR_Finish_Initialisation(faux)		// pas leader
			macro_change_etat("KR_ETAT_Finish_on_KONG")
		}
		else
		{
			i_ride_mode = Ci_ride_grab_impulsion
			i_jump_exit = vrai				// Kong Coupe la LIAISON
			v_ride_end_jump_pos = @o_fight_actor OBJ_PosGet() 
			v_ride_end_jump_pos -= @o_fight_actor OBJ_SightGet() * MATH_RandFloat( 7.0,10.0)
			v_ride_end_jump_pos -= @o_fight_actor OBJ_HorizonGet() * MATH_RandFloat( -3.0, 3.0)
		}
	}	
}


// SORTIE DE RIDE ===================================================
o_bone_ride_KK = LNK_ClientGet(Ci_LNK_RIDE_DINO, mid_bone_ride_KK_LNK_ID, vrai, nofunc, nofunc, nofunc)
if( i_ride_mode == Ci_ride_paf_kong && ! o_bone_ride_KK && ! i_jump_etat )
{
	i_ride_mode = Ci_ride_grab_impulsion
	i_jump_exit = vrai				// Kong Coupe la LIAISON
	v_ride_end_jump_pos = @o_fight_actor OBJ_PosGet() 
	v_ride_end_jump_pos -= @o_fight_actor OBJ_SightGet() * MATH_RandFloat( 7.0,10.0)
	v_ride_end_jump_pos -= @o_fight_actor OBJ_HorizonGet() * MATH_RandFloat( -3.0, 3.0)
}


// TEST ACTIVATION SEQUENCE DE SORTIE DE RIDE =========================
switch( i_ride_mode )
{
	case Ci_ride_wait_for_finish : 
		break
		
	// CALCUL DE LA POSITION DE SAUT POUR PARTIR
	case Ci_ride_grab_descend  :
	case Ci_ride_grab_impulsion :
	case Ci_ride_grab_au_sol :
		i_jump_exit = vrai				// Maintenir / Activer la séquence de sortie
		break
		
	case Ci_ride_paf_kong :
		// s'il n'est pas blessé je mord et je redescend sinon je mors pas et j'attend pour que les autres viennent en finish
		switch( ACT_ActionGet() )
		{
			case Action_Ride_LandingOnKong : 
			case Action_Ride_Attente :
				// j'attend pour mordre kong
				f_ride_attack_delay -= MATH_FloatMin(f_ride_attack_delay, TIME_GetDt())
				if( ! f_ride_attack_delay )
					ACT_ActionSet(Action_Ride_MordKong)
				break
				
			case Action_Ride_MordKong :
				// je suis en train de mordre kong
				if( ACT_ActionFinished() )
				{
					ti_paf = 0
					if ( i_KK_blesse )
					{
						// chercher s il y a assez de raptor pour  lancer un finish
						EVT_rank = -1
						tmid_vision = MSG_GlobalScan( C_EVENT_TYPE_Visibility, &EVT_rank)
						while ( MSG_GlobalIsValid( tmid_vision ))
						{
							to_sender = MSG_GlobalGetSender(tmid_vision )
							if ( @to_sender AI_IsModel(get_PNJ_KRaptor_path))
							{
								if ( @get_PNJ_KRaptor_path to_sender  o_fight_actor == o_KONG)
									ti_paf++
							}
							tmid_vision = MSG_GlobalScan( C_EVENT_TYPE_Visibility, &EVT_rank)							
						}
						if ( ti_paf < 3)
							ti_paf = vrai
						else
							ti_paf = faux
					}
					if( ! i_KK_blesse || ti_paf )
					{
						// kong pas blessé => je paffe et je redescend
						EVENT_AddEventPafCanal(C_EVENT_FILTER_All, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_fight_actor, -1, Ci_PAF_POINTS_RIDE_EXIT, @o_fight_actor OBJ_SightGet(), COL_ZonePosGet( C_zde_fight))					SND_RequestPlay(Ci_SND_Bite)
						KR_DBG_Trace(i_DBG_trace_send_paf, "paf moyen (10 dmg) en mordant kong en ride")
						i_ride_mode = Ci_ride_grab_impulsion
						i_jump_exit = vrai				// Kong Coupe la LIAISON
						v_ride_end_jump_pos = @o_fight_actor OBJ_PosGet() 
						v_ride_end_jump_pos -= @o_fight_actor OBJ_SightGet() * MATH_RandFloat( 7.0,10.0)
						v_ride_end_jump_pos -= @o_fight_actor OBJ_HorizonGet() * MATH_RandFloat( -3.0, 3.0)		
						o_bone_ride_KK = LNK_ClientGet(Ci_LNK_RIDE_DINO, mid_bone_ride_KK_LNK_ID, faux, nofunc, nofunc, nofunc)
					}
					else
					{
						// kong blessé => j'attend pour le finish
						ACT_ActionSet(Action_Ride_Attente)
						f_ride_attack_delay = Cf_delay_ride_attack + MATH_RandFloat(-0.5, 0.5)
					}
				}
				break
		}
		break
}


// COMPORTEMENT =======================================================================================================


// SUIVI DE REGARD ================================================
i_flag_look = faux


// INTERET ========================================================
KR_Check_Fight_Actor_Interet()

if( f_time_start_etat < 1.0 )
	KR_INTERET_Update(o_fight_actor, C_EVENT_InteretStatusAttack)
else
	KR_INTERET_Update(o_fight_actor, C_EVENT_InteretStatusRide)


// EXIT DU RIDE =====================================================
if( i_ride_mode != Ci_ride_wait_for_finish )
	AI_Execute("KR_exec_ride_exit")

