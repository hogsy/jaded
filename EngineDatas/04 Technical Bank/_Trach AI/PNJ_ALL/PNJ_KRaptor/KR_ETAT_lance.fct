#include "KR_defines.var"

#define	Cf_time_lancer		1.0

int			ti_i
int			ti_action

float		tf_coef
float		tf_time

object	to_head
object	to_obj

vector	tv_temp


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	i_flag_lance_done = faux
	o_grab_actor = LNK_ClientGet(Ci_LNK_GRAB_RAPTOR, mid_grab_actor_LNK_ID, faux, nofunc, nofunc, nofunc)
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_lance)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_lance

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	ACT_ActionSet(Action_Observe)

	i_flag_lance_done = faux

	if( i_ride_attak )
		i_ride_mode = Ci_ride_grab_sur_kong_init_jump
	
	// Choix du côté ou lancer ANN
	f_lance_side = MATH_FloatSign(MATH_RandFloat(-1.0, 1.0))
	
//	tv_temp = KR_Compute_Ride_Jump_Pos( - f_lance_side)
//	to_obj = COL_RayObject_Dist( tv_temp + cvector(0,0,1), - Cv_VerticalVector, 3, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable )
//	if( ! to_obj )
//		f_lance_side *= -1		// pas de sol -> on ne lance pas de ce côté
	
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE =======================================================================================================

o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	macro_change_etat("KR_ETAT_grabbed")

if( ! KR_Check_Fight_Actor_Interet() )
	macro_change_etat("KR_ETAT_attente")

AI_Execute("KR_exec_check_paf")
if( o_paf_actor )
{
	KR_Select_Paf_Etat(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}


if ( ! o_grab_actor)
	macro_change_etat(fct_main_etat)


// COMPORTEMENT =================================================================================================

i_iam_a_kam_target = vrai

if (i_ride_attak)
	KR_SetInterestType(C_EVENT_InteretStatusRide)
else
	KR_SetInterestType(C_EVENT_InteretStatusAttack)

i_flag_look = vrai


if (i_flag_lance_done)
{
	v_look_pos = @o_grab_actor	OBJ_PosGet()
	
	if( i_ride_attak )
		macro_change_etat("KR_ETAT_ride")
	else if (f_time_start_etat > 1.2)
		macro_change_etat(fct_main_etat)
}
else
{
	tf_coef = f_time_start_etat / Cf_time_lancer
	tf_coef *= tf_coef 
	tf_coef *= tf_coef 
	
	f_look_angle_blend_speed = 4.0 + (tf_coef * 8.0)
	
	v_look_pos = OBJ_PosGet()
	v_look_pos += MATH_VecRotate(OBJ_SightGet() * 2.0, Cv_VerticalVector, f_lance_side * ((tf_coef * Cf_Pi) - Cf_PiBy2))
	v_look_pos.z += tf_coef * 5.0
	
	if( f_time_start_etat > Cf_time_lancer )
	{
		i_flag_lance_done = vrai
		
		if( i_ride_attak )
			KR_Compute_Ride_Jump_Pos( - f_lance_side, v_ride_end_jump_pos, vrai, v_lance_pos)
		else
			KR_Compute_Ground_Lance_Pos(f_lance_side, v_lance_pos)
		
		KRDBG_DRAWVECTOR(Ci_DBG_DRAW_TMP, v_lance_pos, Cv_VerticalVector * 5, color_jaune)
		KRDBG_DRAWVECTOR(Ci_DBG_DRAW_TMP, OBJ_PosGet(), v_lance_pos - OBJ_PosGet(), color_jaune)
		
		tv_temp = DYN_LIB_ImpulsionGet_Friction(@o_grab_actor OBJ_PosGet(), v_lance_pos, Cv_NormalGravity, @o_grab_actor DYN_FrictionVectorGet().x, tf_time, faux, 4.0)
		@o_grab_actor DYN_GravitySet(Cv_NormalGravity)
		@o_grab_actor DYN_SpeedSetVector(tv_temp)
		
		// Je previens mon client qu'il est lancé
		LNK_GrabStatusSet(mid_grab_actor_LNK_ID, 4)
	}
	else
	{
		f_IK_bassin_rot_angle = f_lance_side * (tf_coef * (2.2 - (tf_coef * 1.1)))
	}
}

