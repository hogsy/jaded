#include "KR_defines.var"

vector				tv_finalTarget

// for occluders
int						ti_occluderResult
vector				tv_occluderNextPos
object				to_occluderJump
object				tao_fake[1]
float					taf_fake[1]
object				to_blockingWall
int						ti_col


#define	Cf_FLEE_LOOKAHEAD						10.0		// we flee aiming at this distance in front of us
#define	Cf_REACHED_DESTINATION_DIST		5.0		// raptor has reached his destination when this close

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	o_flee_actor = nobody	
	f_flee_time = 0.0

	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if( i_etat_courant != ETAT_moving )
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_moving
	
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	fct_main_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	i_flag_rotation_requin = faux

}
else
{
	f_time_start_etat += TIME_GetDt()
}



// ANALYSE =======================================================================================================

AI_Execute("KR_exec_check_vision")

// PAFS ------------------------------------------------------------------
AI_Execute("KR_exec_check_paf")
if( o_paf_actor )
{
	KR_Select_Paf_Etat(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}

// INTIMIDATION ------------------------------------------------------
AI_Execute("KR_exec_check_fury")
if ( o_intimidator )
	macro_change_etat("KR_ETAT_intimide")
	
// GRABBED ----------------------------------------------------------
o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	macro_change_etat("KR_ETAT_grabbed")



// Comportement ===============================================

i_iam_a_kong_target = vrai

switch (i_moving_subState)
{
	case Ci_MOVING_STATE_none :
		macro_change_etat("KR_ETAT_attente")
		break
		
	case 	Ci_MOVING_STATE_flee :
	
		i_iam_a_kam_target = vrai

		f_flee_time -= TIME_GetDt()
		if (f_flee_time > 0.0)
		{
			// first, find the direction where we should go
			tv_finalTarget = OBJ_PosGet() - @o_flee_actor OBJ_PosGet()
			tv_finalTarget.z = 0
			if (MATH_VecNull(tv_finalTarget))
				tv_finalTarget = -OBJ_SightGet()
			else
				MATH_VecSetHorzNormalize(tv_finalTarget)
			tv_finalTarget *= Cf_FLEE_LOOKAHEAD
			tv_finalTarget += OBJ_PosGet()
			
			KR_SetupToLookAtHead(o_flee_actor)
			
			// quick fix to avoir running against walls
			to_blockingWall = COL_BestAngleWallGaoGet(OBJ_SightGet(),Cf_Cos20,&ti_col)	// blocking wall in front ?
			//if (to_blockingWall)
			//	f_flee_time = 0.0	// stop right here
		}
		else
		{
			// fleeing is over
			f_use_safe_orbit_timer = 5.0
			macro_change_etat("KR_ETAT_attente")
			break
		}
		break

	case Ci_MOVING_STATE_goto :
	
		if (OBJ_SqrDistHorz(o_KONG) < Cf_dist_fight_KONG)
			i_iam_a_kam_target = vrai		//TODO: right thing to do ?

		tv_finalTarget = @o_moving_target OBJ_PosGet()
		if (MATH_VecDistance(OBJ_PosGet(),tv_finalTarget) < Cf_REACHED_DESTINATION_DIST)
		{
			macro_change_etat("KR_ETAT_attente")
		}
		break
		
}


// take occluders into account
ti_occluderResult = WAY_LIB_Test_Occluder( 	OBJ_PosGet() + Cv_VerticalVector, 
																OBJ_SightGet(), 
																COL_ZoneSizeGet(C_zdm_pied) + 0.1,
																tv_finalTarget, 
																-1,	// territory not used for now
																tv_occluderNextPos,
																to_occluderJump, 
																&tao_fake[0],
																&taf_fake[0],
																0 )
																
if (ti_occluderResult)
{
	if (ti_occluderResult & Ci_OCCLUDER_JUMP)
	{
		DBG_Error("jump occluders not supported yet")
	}
	tv_finalTarget = tv_occluderNextPos
}															

// compute new orientation to target
// v_sens_orientation where he looks
// v_sens_deplacement where he goes
v_sens_orientation = tv_finalTarget - OBJ_PosGet()
v_sens_deplacement = v_sens_orientation
KRDBG_DRAWVECTOR(Ci_DBG_DRAW_TMP, OBJ_PosGet(),v_sens_orientation,color_bleu)


// choose proper animation
switch (i_moving_speedType)
{
	case Ci_MOVING_SPEED_slow : 
		ACT_ActionSet(Action_Normal_Marche)
		break

	case Ci_MOVING_SPEED_fast :
		ACT_ActionSet(Action_Normal_Course)
		break
}



// ORIENTATION ==================================================================
if( 	( i_jump_etat != Ci_Jump_landing ) && 
	( (i_jump_etat != Ci_Jump_cycle) || (i_attack_type == Ci_ATTACK_TYPE_FrontBite) ) )
	AI_Execute("KR_exec_orientation")			// ne s'oriente pas en saut cycle et saut dérape


