#include "KR_defines.var"

int			ti_i
int			ti_action

object	to_head

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

//	COL_UnCollidableDel(o_snap_actor)
	i_uncol = vrai
	o_uncol_actor = o_snap_actor
	COL_ColSetActivationSet(C_bit_zdm_pied, none)
	AI_CBDel(o_snap_actor, CallBack_After_Blend, "KR_CALLBACK_set_pos")
	DYN_GravitySet(Cv_NormalGravity)
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_KK_grabbed)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_KK_grabbed

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	if( i_ride_attak )
		KR_ResetRide()		// RAZ ride si grabbé pendant une attaque ride
	
	KR_DelInterestMsg(vrai)	// Suppr du mesage d'intéret du mode fight
	
	//ACT_ActionSet(Action_Normal_Attente)


	DYN_GravitySet(Cv_NullVector)
	
	if( o_grab_actor )		// grab interrompu
		o_grab_actor = LNK_ClientGet(Ci_LNK_GRAB_RAPTOR, mid_grab_actor_LNK_ID, faux, nofunc, nofunc, nofunc)
	
	if( EVENT_LIFE_CurLifeGet(ID_LIFE))
	{
		if( o_grabbed_actor_KK != o_KONG )
		{
			
			EVENT_LIFE_CurLifeSet(ID_LIFE, 0.0) // grabbé par un TREX => mort
			ACT_ActionSet(Action_Paf_Sol_sur_place)
			i_paf_mortel = vrai
		}
		else
			SND_RequestPlay(Ci_SND_Paf_Small)
	}
	
	o_snap_actor = o_grabbed_actor_KK
	KR_UncollideableAdd(o_snap_actor)
	COL_ColSetActivationSet(none, C_bit_zdm_pied)
	
	AI_CBAdd(o_snap_actor, CallBack_After_Blend, "KR_CALLBACK_set_pos")

	f_time_start_etat = 0.0
	f_pos_blend_coef = 0.0
	v_grabbed_pos_init_blend = OBJ_PosGet()
}
else
{
	f_time_start_etat += TIME_GetDt()
	f_pos_blend_coef = MATH_FloatMin( f_pos_blend_coef +  (4.0 * TIME_GetDt()), 1.0)
//	f_pos_blend_coef = MATH_FloatBlend(f_pos_blend_coef, 1.0, 10.0 * TIME_GetDt())
}

// ANALYSE =======================================================================================================

if ( EVENT_LIFE_CurLifeGet( ID_LIFE))
	ACT_ActionSet(Action_KKHandGrabbed)	
else
{
	if ( !MATH_FloatNullEpsilon( @o_grabbed_actor_KK DYN_SpeedGet() ))
		ACT_ActionSet( Action_KKHandGrabbedDead)
	else
		ACT_ActionSet( Action_KKHandGrabbedDeadStop)
}
		
// PAFS -----------------------------------------------------------------------------------------------------------
AI_Execute("KR_exec_check_paf")		// pour les pafs C_PAF_KK_KiTue


// TEST LIAISON GRAB ------------------------------------------------------------------------------------
o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK == nobody)
{
	// il n'y a plus personne qui grabbe le raptor
	v_paf_dir = DYN_SpeedGetVector()
	if( MATH_VecNullEpsilon(v_paf_dir) )
		v_paf_dir = - Cv_VerticalVector
	i_projectile_mode = Ci_projectile_lache
	macro_change_etat("KR_ETAT_projectile")
}

KR_INTERET_Update(o_grabbed_actor_KK, C_EVENT_InteretStatusGrabbed)


// ACTION REALISEE PAR KONG --------------------------------------------------------------------
ti_action = LNK_GrabKong_ActionGet( mid_grabbed_by_Kong_LNK_ID)
if ( ti_action == Ci_GrabKong_Lance )
{
	// Projectile (KONG lance, ennemi en vue ou pas)
	i_projectile_mode = Ci_projectile_lance_unknown
	macro_change_etat("KR_ETAT_projectile")
}

// AUTO DEGRAB
if( EVENT_LIFE_CurLifeGet(ID_LIFE) && f_time_start_etat > Cf_GrabKong_EscapeDuration && @o_grabbed_actor_KK Proc_KK_GrabbedNMICanEscape() )
{
	//---------------------------------------------------------------------
	// we've been grabbed for too long, it's time to go
	//---------------------------------------------------------------------
	
	// leave the link
	o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, faux, nofunc, nofunc)
	
	// eject eject eject !
	i_projectile_mode = Ci_projectile_lache
	macro_change_etat("KR_ETAT_projectile")
}


// COMPORTEMENT  =======================================================================================================

i_iam_a_kam_target = faux	// grabber will set himself if appropriate


object	to_canal

return
//for(  ti_i = 0; ti_i < Ci_Nb_tremble_bone; ti_i++)
for(  ti_i = 0; ti_i < 5; ti_i++)
{
	if ( TIME_Elapsed( f_tremble_time[ti_i], f_tremble_delai[ti_i]))
	{
		f_tremble_time[ti_i] = TIME_Get()
		f_tremble_delai[ti_i] = MATH_RandFloat( 0.05, 0.15)
		f_a[ti_i] = MATH_RandFloat( 1.5,4.5) * MATH_FloatSign( MATH_RandFloat( -0.1, 0.1))
		f_b[ti_i] = MATH_RandFloat( 1.5,4.5) * MATH_FloatSign( MATH_RandFloat( -0.1, 0.1))
		i_tremble_axe[ti_i] = MATH_RandInt( 0, 2)
	}
	f_a1[ti_i] = MATH_FloatBlend( f_a1[ti_i], f_a[ti_i], 8.0 * TIME_GetDt())	
	f_b1[ti_i] = MATH_FloatBlend( f_b1[ti_i], f_b[ti_i], 8.0 * TIME_GetDt())	
	switch ( ti_i)
	{
		case 0 :
			to_canal = ANI_CanalObjectGet(Anim_Canal_CuisseGauche)
//			@to_canal  OBJ_RotateLocalY(  f_a1[ti_i] * TIME_GetDt())
		break
		case 1 :
			to_canal = ANI_CanalObjectGet(Anim_Canal_AvantBrasGauche)
//			@to_canal  OBJ_RotateLocalY(  f_a1[ti_i] * TIME_GetDt())
		break
		case 2 :
			to_canal = ANI_CanalObjectGet(Anim_Canal_Tete)
//			@to_canal  OBJ_RotateLocalX(  3.0 * f_a1[ti_i] * TIME_GetDt())
		break
		case 3 :
			to_canal = ANI_CanalObjectGet(Anim_Canal_Torse)
//			@to_canal  OBJ_RotateLocalX(  f_a1[ti_i] * TIME_GetDt())
		break
		case 4 :
			to_canal = ANI_CanalObjectGet(Anim_Canal_Queue)
//			@to_canal  OBJ_RotateLocalX(  f_a1[ti_i] * TIME_GetDt())
		break
		case 5 :
			to_canal = ANI_CanalObjectGet(Anim_Canal_CuisseDroite)
//			@to_canal  OBJ_RotateLocalY(  f_a1[ti_i] * TIME_GetDt())
		break

	}
//	switch( i_tremble_axe[ti_i])
//	{
//		case 0 :
			@to_canal  OBJ_RotateLocalX(  f_a1[ti_i] * TIME_GetDt())
//		case 1 :
			@to_canal  OBJ_RotateLocalY(  f_b1[ti_i] * TIME_GetDt())
//	}
}