#include "KR_defines.var"

int			ti_i
int			ti_frame_num
		
float		tf_angle
float		tf_offset
float		tf_bassin_offset
float		tf_bassin_offset_min
float		tf_norm
float		tf_X
float		tf_Y
float		tf_coef
float		tf_IK_coef
float		tf_size_coef

vector	tv_pied_pos
vector	tv_collide_pos
vector	tv_flexion_dir
vector	tv_ray_dir
vector	tv_last_pos
vector	tv_start_axis
vector	tv_dest_axis
vector	tv_ray_normale
vector	tv_bassin_dest_pos
vector	tv_dest_pos
vector	tv_X
vector	tv_temp
vector	tv_rot_pivot_pos
vector	tv_look_axis

object	to_bassin
object	to_torse
object	to_epaule_droite
object	to_epaule_gauche
object	to_bone

#define Cf_offset_min						-4.0
#define Cf_offset_max						2.0
#define Cf_walk_Z_blend_speed			12.0

switch(raptor_type)
{
	case C_ID_Raptor :
		tf_size_coef = 1.0
		tf_bassin_offset_min = -1.0
		break

	case C_ID_Tyranosaure :
		tf_size_coef = 2.5
		tf_bassin_offset_min = -3.0
		break	

	default:
		return
}


if (OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Culled)
	return

//if (i_etat_courant != ETAT_joueur_marche && i_etat_courant < ETAT_commun_climb_0D)
//	return

to_bassin = ANI_CanalObjectGet(Anim_Canal_Bassin)
to_torse = ANI_CanalObjectGet(Anim_Canal_Torse)
to_epaule_gauche = ANI_CanalObjectGet(Anim_Canal_EpauleGauche)
to_epaule_droite = ANI_CanalObjectGet(Anim_Canal_EpauleDroite)

//if (IO_KeyPressed(VK_SPACE))
//{
//	for (ti_i = 0; ti_i < 2; ti_i++)
//	{
//		i_flag_climb_IK[ti_i] = faux
//		i_flag_walk_IK[ti_i] = faux
//	}
//}

v_IK_bone_last_valid_sight[Ci_IKRaptor_pied_gauche] = @ao_IK_bones[Ci_IKRaptor_pied_gauche][2] OBJ_SightGet()
v_IK_bone_last_valid_banking[Ci_IKRaptor_pied_gauche] = @ao_IK_bones[Ci_IKRaptor_pied_gauche][2] OBJ_BankingGet()

v_IK_bone_last_valid_sight[Ci_IKRaptor_pied_droit] = @ao_IK_bones[Ci_IKRaptor_pied_droit][2] OBJ_SightGet()
v_IK_bone_last_valid_banking[Ci_IKRaptor_pied_droit] = @ao_IK_bones[Ci_IKRaptor_pied_droit][2] OBJ_BankingGet()

// EST-CE QU'ON S'ADAPTE AU RELIEF DU SOL ??? =============================================================
tf_bassin_offset = 0.0

i_flag_IK_ground_index = MATH_Modulo(i_flag_IK_ground_index + 1, 2)

for (ti_i = 0; ti_i < 2; ti_i++)
{
	tv_ray_dir = v_virtual_banking
	if (i_flag_walk_IK[ti_i])
	{
		tv_pied_pos = @ao_IK_bones[ti_i][3] OBJ_PosGet()

		switch(raptor_type)
		{
			case C_ID_Raptor :
				if (i_flag_IK_ground_index)
					tv_pied_pos += @ao_IK_bones[ti_i][3] OBJ_BankingGet() * 0.4
				break
		
			case C_ID_Tyranosaure :
				if (i_flag_IK_ground_index)
					tv_pied_pos += @ao_IK_bones[ti_i][3] OBJ_BankingGet()
				else
					tv_pied_pos -= @ao_IK_bones[ti_i][3] OBJ_BankingGet() * 0.4
				break
				
			default:
		}
	}
	else
	{
		f_IK_ground_coef[ti_i] -= MATH_FloatMin(f_IK_ground_coef[ti_i], 6.0 * TIME_GetDt())
		continue
	}

	@get_global i_raptor_ray_on_colmap_nb++
	if (COL_RayObject_Dist(tv_pied_pos + (tv_ray_dir * (tf_size_coef * 0.5)), -tv_ray_dir, 2.0 * tf_size_coef, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
	{
		// OK ON TOUCHE UN SOL, ON VA POUVOIR POSITIONNER EN IK ==============================================
		tv_collide_pos = COL_RayObject_PosGet()

		f_IK_offset[ti_i][i_flag_IK_ground_index] = MATH_VecDotProduct(tv_collide_pos - OBJ_PosGet(), tv_ray_dir)
		
		tf_offset = MATH_FloatMax(f_IK_offset[ti_i][0], f_IK_offset[ti_i][1])

//		if (f_walk_offset[ti_i] > tf_offset)
//			f_walk_offset[ti_i] = tf_offset
//		else
			f_walk_offset[ti_i] = MATH_FloatBlend(f_walk_offset[ti_i], tf_offset, Cf_walk_Z_blend_speed * TIME_GetDt())

		// ON RECUPERE LA NORMALE	========================================================================
		tv_ray_normale = COL_RayObject_NormalGet()
//		KRDBG_DRAWVECTOR(Ci_DBG_DRAW_TMP, tv_collide_pos, tv_ray_normale, color_jaune)

		tf_norm = MATH_VecDotProduct(tv_pied_pos - OBJ_PosGet(), tv_ray_dir) 
		if (tf_norm < 0.5 * tf_size_coef)
		{
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 6.0 * TIME_GetDt())
			v_IK_ground_normale[ti_i] = MATH_VecBlend(v_IK_ground_normale[ti_i], tv_ray_normale, 6.0 * TIME_GetDt())
		}
		else
		{
			f_IK_ground_coef[ti_i] -= MATH_FloatMin(f_IK_ground_coef[ti_i], 6.0 * TIME_GetDt())
		}	

		i_flag_climb_IK[ti_i] = vrai
		f_IK_speed[ti_i] = 1.0

		v_IK_dest_pos[ti_i] = @ao_IK_bones[ti_i][2] OBJ_PosGet()
		v_IK_dest_pos[ti_i] += tv_ray_dir * f_walk_offset[ti_i]
	}
	else
	{
		f_IK_offset[ti_i][i_flag_IK_ground_index] = -Cf_Infinit
	}
}

// ROTATION DU BASSIN AUTOUR D'UN PIVOT (PAF ET SUIVI REGARD)
if (f_IK_coef[Ci_IKRaptor_pied_gauche] && f_IK_coef[Ci_IKRaptor_pied_droit])
{
	tv_bassin_dest_pos = Cv_NullVector
	
//	tv_rot_pivot_pos = @ao_IK_bones[Ci_IKRaptor_pied_gauche][0] OBJ_PosGet()
//	tv_rot_pivot_pos -= @ao_IK_bones[Ci_IKRaptor_pied_droit][0] OBJ_PosGet()
//	tv_rot_pivot_pos *= 0.5
//	tv_rot_pivot_pos += @ao_IK_bones[Ci_IKRaptor_pied_droit][0] OBJ_PosGet()

	tf_IK_coef = MATH_FloatMin(f_IK_coef[Ci_IKRaptor_pied_gauche], f_IK_coef[Ci_IKRaptor_pied_droit])
	
	tv_rot_pivot_pos = @ao_head_bones[i_head_bone_nb - 1] OBJ_PosGet()

	tv_temp = @to_bassin MATH_VecGlobalToLocal(@to_bassin OBJ_PosGet() - tv_rot_pivot_pos)

	// DEPLACEMET BASSIN EN FONCTION DES PAF =================================================================
	tf_coef = TIME_Get() - f_visual_paf_last_time
	tf_coef /= 0.5
	if (tf_coef < 1.0)	
	{
		tf_coef = 1.0 - tf_coef
		tf_coef *= tf_IK_coef

		f_visual_paf_coef	= MATH_FloatBlend(f_visual_paf_coef, tf_coef, 8.0 * TIME_GetDt())
		tf_coef = f_visual_paf_coef

		tv_bassin_dest_pos += v_IK_bassin_paf_offset * (tf_coef * 0.25)
		tv_bassin_dest_pos.z -= MATH_Sin(tf_coef * Cf_Pi) * f_visual_paf_Z_offset

		tv_dest_pos = @to_bassin MATH_VecGlobalToLocal(v_visual_paf_dir)
		@to_bassin OBJ_Rotate_FromTo(v_visual_paf_quaternion, MATH_VecBlend(v_visual_paf_quaternion, tv_dest_pos, tf_coef * f_visual_paf_rot_coef))
	}
	else
	{
		f_visual_paf_coef = 0.0
	}

	// ROTATION DU BASSIN EN FONCTION DU SUIVI DE REGARD ============================================================
	tv_flexion_dir = @to_bassin MATH_VecGlobalToLocal(OBJ_SightGet())

	tv_look_axis = v_look_axis
//	tv_look_axis.z = 0.0

	switch(raptor_type)
	{
		case C_ID_Tyranosaure :
			@to_bassin OBJ_Rotate_FromTo(tv_flexion_dir, MATH_VecBlendRotate(tv_flexion_dir, @to_bassin MATH_VecGlobalToLocal(tv_look_axis), 0.33 * tf_IK_coef))
			break

		default:
			@to_bassin OBJ_Rotate_FromTo(tv_flexion_dir, MATH_VecBlendRotate(tv_flexion_dir, @to_bassin MATH_VecGlobalToLocal(tv_look_axis), 0.2 * tf_IK_coef))
	}

	tv_temp = @to_bassin MATH_VecLocalToGlobal(tv_temp)
	tv_temp += tv_rot_pivot_pos

	@to_bassin OBJ_PosSet(tv_temp)

//	tf_X = MATH_VecAngle(OBJ_SightGet(), v_look_pos - @ao_head_bones[i_head_bone_nb - 1] OBJ_PosGet(), Cv_VerticalVector)
//	f_IK_bassin_rot_angle = MATH_FloatBlend(f_IK_bassin_rot_angle, tf_X, 2.0 * TIME_GetDt())
//
//	if (f_IK_bassin_rot_angle)
//	{
//		@to_bassin OBJ_RotateGlobalZ(f_IK_bassin_rot_angle)
//		f_IK_bassin_rot_angle -= MATH_FloatSign(f_IK_bassin_rot_angle) * MATH_FloatMin(MATH_AbsFloat(f_IK_bassin_rot_angle), Cf_Pi * TIME_GetDt())
//	}
}
else
{
	f_IK_bassin_rot_angle = 0.0
}

// DECALAGE EN Z DU BASSIN POUR QUE LES PIEDS PUISSENT TOUCHER LE SOL ============================================
for (ti_i = 0; ti_i < 2; ti_i++)
{
	if (i_flag_climb_IK[ti_i] || f_IK_coef[ti_i])
	{
		tv_X = v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet()
		tv_X.z = 0.0
	
		tf_X = MATH_VecDotProduct(tv_X, tv_X)
	
		tf_Y = af_IK_bones_length[ti_i][0]
		tf_Y += af_IK_bones_length[ti_i][1]
		tf_Y *= 0.99
		tf_Y *= tf_Y
		
		tf_norm = tf_Y
		tf_norm -= tf_X
	
		tf_norm = MATH_FloatMax(tf_norm, 0.0)
	//		if (tf_norm < 0.0)
	//			DBG_Error("Ha ha !!!")	
	
		tf_norm = MATH_FloatSqrt(tf_norm)
	
		tf_offset = tf_norm + MATH_VecDotProduct(v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_ray_dir)
	
		tf_bassin_offset = MATH_FloatMin(tf_bassin_offset, tf_offset)
	}
}

tf_bassin_offset = MATH_FloatMax(tf_bassin_offset, tf_bassin_offset_min)

//f_bassin_Z_offset	= tf_bassin_offset
f_bassin_Z_offset	= MATH_FloatBlend(f_bassin_Z_offset, tf_bassin_offset, 8.0 * TIME_GetDt())

tv_bassin_dest_pos = @to_bassin OBJ_PosGet()
tv_bassin_dest_pos += v_virtual_banking * f_bassin_Z_offset

@to_bassin OBJ_PosSet(tv_bassin_dest_pos)
v_bassin_pos = tv_bassin_dest_pos

// ON EXECUTE L'IK =============================================================================================================
for (ti_i = 0; ti_i < 2; ti_i++)
{
	if (i_flag_climb_IK[ti_i])
	{
		f_IK_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_coef[ti_i], TIME_GetDt() * 6.0)	
	
		tv_pied_pos = MATH_VecBlend(MATH_VecLocalToGlobal(v_IK_local_offset[ti_i]), v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet(), f_IK_speed[ti_i])
		v_IK_local_offset[ti_i] = MATH_VecGlobalToLocal(tv_pied_pos)
		tv_pied_pos += @ao_IK_bones[ti_i][0] OBJ_PosGet()
	}
	else
	{
//		f_feet_contact_duration[ti_i] = 0.0
	
		f_walk_offset[ti_i] = MATH_FloatBlend(f_walk_offset[ti_i], 0.0, 12.0 * TIME_GetDt())
		f_IK_coef[ti_i] -= MATH_FloatMin(f_IK_coef[ti_i], TIME_GetDt() * 12.0)
	
		tv_pied_pos = MATH_VecLocalToGlobal(v_IK_local_offset[ti_i])
		tv_pied_pos += @ao_IK_bones[ti_i][0] OBJ_PosGet()
	}
	
	switch(raptor_type)
	{
		case C_ID_Tyranosaure :
			tv_flexion_dir = - @ao_IK_bones[ti_i][0] OBJ_SightGet()
			break
			
		default:
			tv_flexion_dir = @ao_IK_bones[ti_i][0] OBJ_BankingGet()
			break
	}

	OBJ_LIB_IK(ao_IK_bones[ti_i][0] , ao_IK_bones[ti_i][1] , af_IK_bones_length[ti_i][0], af_IK_bones_length[ti_i][1], tv_pied_pos, tv_flexion_dir, f_IK_coef[ti_i])
	@ao_IK_bones[ti_i][2] OBJ_BankingGeneralSet(v_IK_bone_last_valid_sight[ti_i], v_IK_bone_last_valid_banking[ti_i])
}

