#include "KR_defines.var"

int			ti_leaveNodeThisFrame
int			ti_actionEnded
int			ti_tmp
int			ti_orientTowardsNextNode
vector	tv_bankingVector
float		tf_jump_amplitude
float		tf_jump_friction
vector	tv_jump_travel
vector	tv_temp
float		tf_jump_time
float		tf_dist
float		tf_aniDuration
float		tf_temp
int			ti_freq
int			ti_skipJumpImpulse
int			ti_action

vector	tv_new_sight
vector	tv_new_banking

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	o_net_nextNode = nobody		// avoid resuming network following

	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_FollowNetwork)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_FollowNetwork

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
		
	f_way_rot_speed 	= 4.0

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE ===========================================================

// PAFS ------------------------------------------------------------------
AI_Execute("KR_exec_check_paf")
if( o_paf_actor )
{
	KR_Select_Paf_Etat(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}

// INTIMIDATION ------------------------------------------------------
if (	i_net_doingNodeAction ||
	(	(i_net_curLinkMove == Ci_NETWORK_LINK_MOVE_Walk) ||
		(i_net_curLinkMove == Ci_NETWORK_LINK_MOVE_Run) ||
		(i_net_curLinkMove == Ci_NETWORK_LINK_MOVE_Trot)
	) )
{
	if ( o_intimidator )
		macro_change_etat("KR_ETAT_intimide")
}

// GRABBED ----------------------------------------------------------
o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	macro_change_etat("KR_ETAT_grabbed")





// COMPORTEMENT =====================================================

i_iam_a_kong_target = vrai	// by default it's safer

AI_Execute("KR_exec_net_checkNode")

//===================================================
// GOING INSIDE NEXT NODE
//===================================================
if (i_net_justEnteredNode)
{
	i_net_doingNodeAction = vrai

	switch (i_net_curNodeAction)
	{
		case Ci_NETWORK_NODE_ACT_Bypass : 
			break

		case Ci_NETWORK_NODE_ACT_Wait :
			ACT_ActionSet(Action_Normal_Attente)
			break
			
		case Ci_NETWORK_NODE_ACT_Eat : 
			ACT_ActionSet(Action_Devore)
			break

		case Ci_NETWORK_NODE_ACT_Scream : 
			ACT_ActionSet(Action_Cri)
			break

		case Ci_NETWORK_NODE_ACT_AttackKong : 
			ACT_ActionSet(Action_Normal_Attente)
			break

		case Ci_NETWORK_NODE_ACT_AttackAnn : 
			ACT_ActionSet(Action_Normal_Attente)
			break

		case Ci_NETWORK_NODE_ACT_PlayAction : 
			// plays action specified by LD
			ACT_ActionSet(KR_NetGetNodeActionToPlay(o_net_oldNode))
			break
			
		case Ci_NETWORK_NODE_ACT_Destroy : 
			OBJ_FlagInvisibleSet(vrai)
			ACT_ActionSet(0)
			TIME_Wait(0.5)
			OBJ_Destroy()	
			break
			
		case Ci_NETWORK_NODE_ACT_NextNetwork :

			if (@o_net_oldNode OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_DesignStruct)
			{
				o_net_nextNode = KR_NetGetNextNetworkHead(o_net_oldNode)
				n_net_current_navnet = @o_net_nextNode WAY_NetOfObj()
				ti_tmp = KR_NetNextNetworkLink(o_net_oldNode)
				if (ti_tmp != Ci_NETWORK_LINK_MOVE_DefaultOrLast)
					i_net_curLinkMove = ti_tmp
				KR_NetSetupLook()
				i_net_doingNodeAction = vrai
			}
			else
			{
				DBG_Warning("NextNetwork waypoint without design struct" )
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" using node ")
				DBG_TraceObject(o_net_nextNode)
				DBG_TraceEOL()
			}
			break
	}
	
	i_net_justEnteredNode = faux
}

//===================================================
// Is it time to leave the node
//===================================================
ti_leaveNodeThisFrame = faux

if (i_net_doingNodeAction && f_net_nodeActionTimer > 0)
{
	f_net_nodeActionTimer -= TIME_GetDt()	

	// time limit was setup
	if (f_net_nodeActionTimer <= 0.0)
	{
		ti_leaveNodeThisFrame = vrai	
		f_net_nodeActionTimer = 0.0
	}
}

if (!ti_leaveNodeThisFrame && i_net_doingNodeAction)
{
	//===================================================
	// CONTINUE DOING NODE ACTION
	//===================================================
	switch (i_net_curNodeAction)
	{
		case Ci_NETWORK_NODE_ACT_Bypass : 
			ti_leaveNodeThisFrame = vrai
			break

		// cyclic animations : a time needs to have been setup to leave
		// otherwise will leave with triggered event
		case Ci_NETWORK_NODE_ACT_Wait :
		case Ci_NETWORK_NODE_ACT_Eat : 

			if (f_net_nodeActionTimer == 0.0)
			{
				DBG_Warning("Zero time for time-dependent action in KRaptor network node **see info in next line**" )
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" using node ")
				DBG_TraceObject(o_net_nextNode)
				DBG_TraceEOL()
				ti_leaveNodeThisFrame = vrai
			}
			break

		// when these actions are over : wait for time to end if timer is setup otherwise leave
		case Ci_NETWORK_NODE_ACT_Scream : 
		case 	Ci_NETWORK_NODE_ACT_PlayAction :
	
			if (ACT_ActionFinished())
			{
				if (f_net_nodeActionTimer == 0.0)
					ti_leaveNodeThisFrame = vrai
				else
					ACT_ActionSet(Action_Normal_Attente)	// wait until time is up
			}
			break

		case Ci_NETWORK_NODE_ACT_AttackKong : 
			o_fight_actor = o_KONG
			KR_LeaveNetwork()
			macro_change_etat("KR_ETAT_fight_KONG")
			break

		case Ci_NETWORK_NODE_ACT_AttackAnn : 
			o_fight_actor = o_KONG
			KR_LeaveNetwork()
			macro_change_etat("KR_ETAT_fight_ANN")
			break
			
		case Ci_NETWORK_NODE_ACT_NextNetwork :
			ti_leaveNodeThisFrame = vrai
			break

		default:			
			DBG_Error("unsopported link move for KRaptor look at log for details")
			DBG_TraceString("gao: ")
			DBG_TraceObject( OBJ_Me() )
			DBG_TraceString(" link going to gao ")
			DBG_TraceObject( o_net_nextNode )
			break
	}

}


ti_skipJumpImpulse = faux

if (ti_leaveNodeThisFrame)
{
	//===================================================
	// LEAVING NODE
	//===================================================

	if (!o_net_nextNode)
	{
		//======================
		// The END of the network
		//======================
		o_fight_actor = o_KONG
		KR_LeaveNetwork()
		macro_change_etat("KR_ETAT_fight_KONG")
//		macro_change_etat("KR_ETAT_attente")
	}
	
	if (KR_NetAimRandomInBV(o_net_nextNode))
		v_net_targetedPos = @o_net_nextNode BV_RandomPosGet(1)	// 1 means keep z at the center of the bv
	else
		v_net_targetedPos = @o_net_nextNode OBJ_PosGet()

	i_net_nodeReachedReq = Ci_NETWORK_NNR_REQ_NotUsed
	DYN_GravitySet(Cv_Raptor_Gravity)

	switch (i_net_curLinkMove)
	{
		case Ci_NETWORK_LINK_MOVE_DefaultOrLast :
			ACT_ActionSet(Action_Normal_Course)
			break
	
		case Ci_NETWORK_LINK_MOVE_Run : 
			ACT_ActionSet(Action_Normal_Course)
			break
			
		case Ci_NETWORK_LINK_MOVE_Trot : 
			ACT_ActionSet(Action_Normal_Trot)
			break
			
		case Ci_NETWORK_LINK_MOVE_Walk :
			ACT_ActionSet(Action_Normal_Marche)
			break
			
		case Ci_NETWORK_LINK_MOVE_Jump : 
		
			i_net_nodeReachedReq = Ci_NETWORK_NNR_REQ_ForceNeverReach	// wait until has landed
			tv_jump_travel = v_net_targetedPos - OBJ_PosGet()
			tf_dist = MATH_VecNorm( tv_jump_travel )
			
			ti_action = KR_GetImpulseAction()
			ACT_ActionSet(ti_action)
			if (!COL_CollideType(COL_C_Ground))//(o_net_oldNode && tf_dist > Cf_Jump_DistForBigImpulse)
			{
				ti_skipJumpImpulse = vrai
			}
			break
			
		case Ci_NETWORK_LINK_MOVE_Teleport :
			OBJ_PosSet( v_net_targetedPos )
			OBJ_SightGeneralSet( @o_net_nextNode  OBJ_SightGet(), @o_net_nextNode  OBJ_BankingGet() )
			break
			
		case Ci_NETWORK_LINK_MOVE_WallRun :
			ACT_ActionSet(Action_Network_WallRun)
			DYN_GravitySet(Cv_NullVector)
			break
			
		default:
			DBG_Error("unsopported link move for KRaptor look at log for details")
			DBG_TraceString("gao: ")
			DBG_TraceObject( OBJ_Me() )
			DBG_TraceString(" link going to gao ")
			DBG_TraceObject( o_net_nextNode )
			break
		
	}
	
	i_net_doingNodeAction = faux
}


if ( !i_net_doingNodeAction )
{
	//===============================
	// on the link (moving bw two nodes)
	//===============================

	//===============================
	// Set orientation
	ti_orientTowardsNextNode = faux
	tv_bankingVector = Cv_VerticalVector

	switch (i_net_curLinkMove)
	{
		case Ci_NETWORK_LINK_MOVE_Run : 
			ACT_ActionSet(Action_Normal_Course)
			ti_orientTowardsNextNode = vrai
			break
			
		case Ci_NETWORK_LINK_MOVE_Trot : 
			ACT_ActionSet(Action_Normal_Trot)
			ti_orientTowardsNextNode = vrai
			break
			
		case Ci_NETWORK_LINK_MOVE_Walk :
			ACT_ActionSet(Action_Normal_Marche)
			ti_orientTowardsNextNode = vrai
			break
			
		case Ci_NETWORK_LINK_MOVE_Jump : 
		
			if ( (ACT_ActionGet() == Action_Jump_Impulse) || (ACT_ActionGet() == Action_Jump_Impulse_Moving) )
			{
				// IMPULSE STEP 1 : Crank it up
				ti_orientTowardsNextNode = vrai
				
				if (ACT_ActionFinished() || ti_skipJumpImpulse)// || ((ACT_ActionGet()==Action_Jump_Impulse_Moving)&&(ANI_CurrentFrameGet(0)>19)) )
				{
					// compute the actual jump to know what impulse exit animation we neet to play					
					// IMPULSE FINISHED : DO THE JUMP
					tv_jump_travel = v_net_targetedPos - OBJ_PosGet()
					tf_dist = MATH_VecNorm( tv_jump_travel )
					tf_jump_time = 0.0
					tf_jump_amplitude = tf_dist * KR_NetGetJumpHeightOverLength( o_net_nextNode )
					tf_jump_friction = Cf_Raptor_jump_friction
					DYN_GravitySet(Cv_Raptor_Gravity)
					DYN_FrictionVectorSet( cvector( tf_jump_friction, tf_jump_friction, 0.0 ) )
					tv_temp = DYN_LIB_ImpulsionGet_Friction(OBJ_PosGet(), v_net_targetedPos, Cv_Raptor_Gravity, tf_jump_friction, tf_jump_time, faux, tf_jump_amplitude)
					if (tf_jump_time < 0.5)
					{
						tf_jump_time = 0.5
						tf_jump_amplitude = 0.0
						tv_temp = DYN_LIB_ImpulsionGet_Friction(OBJ_PosGet(), v_net_targetedPos, Cv_Raptor_Gravity, tf_jump_friction, tf_jump_time, faux, tf_jump_amplitude)
					}
					v_jump_computedSpd = tv_temp
					f_jump_duration = tf_jump_time
					
					if (ti_skipJumpImpulse)
					{
						// NO IMPULSE : DO THE JUMP
						ACT_ActionSet(Action_Fight_Saut_cycl)
						DYN_SpeedSetVector(v_jump_computedSpd)
	
						// make action last the whole duration of the jump
						tf_aniDuration = ACT_DurationGet(Action_Fight_Saut_cycl,0)
						tf_temp = tf_aniDuration / f_jump_duration
						ti_freq = (tf_temp * ACT_FrequencyGet(Action_Fight_Saut_cycl,0)) - 1.0
						ANI_FrequencySet(	0, ti_freq )
					}
					else
					{
						ti_action = KR_GetImpulseExitAction(MATH_VecNormalize(tv_temp))
						ACT_ActionSet(ti_action)
					}
					
					KRDBG_DRAWVECTOR(Ci_DBG_DRAW_NETWORK, OBJ_PosGet(), tv_jump_travel, color_vert)
			
					i_net_jumpLeftGround = faux
				}
			}
			else if ( (ACT_ActionGet() >= Action_Jump_Impulse_High_tr) && (ACT_ActionGet() <= Action_Jump_Impulse_Long_tr) )
			{
				// IMPULSE STEP 2 : Let go
				ti_orientTowardsNextNode = vrai
				
//				if (ANI_CurrentFrameGet(0) > 6)	// anim was too long
				if (ACT_ActionFinished())
				{
					// IMPULSE FINISHED : DO THE JUMP
					ACT_ActionSet(Action_Fight_Saut_cycl)
					DYN_SpeedSetVector(v_jump_computedSpd)

					// make action last the whole duration of the jump
					tf_aniDuration = ACT_DurationGet(Action_Fight_Saut_cycl,0)
					tf_temp = tf_aniDuration / f_jump_duration
					ti_freq = (tf_temp * ACT_FrequencyGet(Action_Fight_Saut_cycl,0)) - 1.0
					ANI_FrequencySet(	0, ti_freq )
				}
			}
			else if (ACT_ActionGet() == Action_Fight_Saut_cycl)
			{
				// AIRBORN
				// land before reaching next node ?
				if (!i_net_jumpLeftGround)
				{
					if (!COL_CollideType(COL_C_Ground))
					{
						// just left the ground
						i_net_jumpLeftGround = vrai
					}
				}
				else
				{
					if (COL_CollideType(COL_C_Ground))
					{
						// just touched the ground
						ACT_ActionSet(Action_Fight_Saut_Landing)
						DYN_FrictionVectorSet(Cv_Raptor_friction)						
					}
					else
					{
						// still airborn
						ti_orientTowardsNextNode = faux
					}
				}
			}
			else if (ACT_ActionGet() == Action_Fight_Saut_Landing)//Action_Fight_Saut_fin_surplace)
			{
				// LANDING
				if (ACT_ActionFinished())
				{
					i_net_nodeReachedReq = Ci_NETWORK_NNR_REQ_ForceReached
					if (!@o_net_nextNode COL_BV_PointCollide(OBJ_PosGet()))
					{
						// gotta walk the rest :(
						ACT_ActionSet(Action_Normal_Marche)
						ti_orientTowardsNextNode = vrai

						DBG_TraceString("KRaptor Jump did not reach destination [")
						DBG_TraceObject(OBJ_Me())
						DBG_TraceString("] at wp [")
						DBG_TraceObject(o_net_nextNode)
						DBG_TraceString("]")
						DBG_TraceEOL()
					}
				}
			}
			else if (ACT_ActionGet() == Action_Normal_Marche)
			{
				// WALK :(
				ti_orientTowardsNextNode = vrai
			}
			else
			{
				DBG_Error("Raptor animation unknown while jumping on network")
			}
			break
			
		case Ci_NETWORK_LINK_MOVE_WallRun : 
			ACT_ActionSet(Action_Network_WallRun)
			ti_orientTowardsNextNode = faux

			v_sens_orientation = v_net_targetedPos - OBJ_PosGet()
			MATH_VecSetNormalize(v_sens_orientation)
			
			tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), v_sens_orientation, f_way_rot_speed * TIME_GetDt())
			//tv_new_banking = MATH_VecBlendRotate( OBJ_BankingGet(), Cv_VerticalVector, 6.0 * TIME_GetDt()) 
			tv_new_banking = MATH_VecBlendRotate( OBJ_BankingGet(), @o_net_nextNode OBJ_BankingGet(), 6.0 * TIME_GetDt()) 
			
			OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)
			break
	}

	if (ti_orientTowardsNextNode)
	{
		v_sens_orientation = v_net_targetedPos - OBJ_PosGet()
		MATH_VecSetNormalize(v_sens_orientation)
		
		tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), v_sens_orientation, f_way_rot_speed * TIME_GetDt())	
	
		tv_new_banking = MATH_VecBlendRotate( OBJ_BankingGet(), Cv_VerticalVector, 6.0 * TIME_GetDt()) 
	
		OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)
		
		KRDBG_DRAWVECTOR(Ci_DBG_DRAW_NETWORK, OBJ_PosGet(), v_sens_orientation*3, color_bleu)
		KRDBG_DRAWSPHERE(Ci_DBG_DRAW_NETWORK, v_net_targetedPos, 0.5, color_jaune)
	}
	
	//===============================
	// Set look at option
	//===============================
	switch (i_net_curLookOption)
	{
		case Ci_NETWORK_NODE_LOOK_DefaultOrLast :
			break
			
		case Ci_NETWORK_NODE_LOOK_Ahead :
			i_flag_look = faux
			break
	
		case Ci_NETWORK_NODE_LOOK_AtNode :
			if (o_net_lookGao)
			{
				// look at node but at the same height as our head height (otherwise looks down too much)
				tv_temp = @o_net_lookGao OBJ_PosGet()
				tv_temp = @ao_head_bones[0] OBJ_PosGet() - OBJ_PosGet()
				tv_temp.x = 0.0
				tv_temp.y = 0.0
				tv_temp += @o_net_lookGao OBJ_PosGet()
				KR_SetupToLookAtPos( tv_temp )
			}
			else
				i_flag_look = faux
			break

		case Ci_NETWORK_NODE_LOOK_AtGao :
			if (o_net_lookGao)
				KR_SetupToLookAtPos( @o_net_lookGao OBJ_PosGet() )
			else
				i_flag_look = faux
			break
			
		case Ci_NETWORK_NODE_LOOK_AtKong	:
		case Ci_NETWORK_NODE_LOOK_AtAnn :
			if (o_net_lookGao)
				KR_SetupToLookAtHead( o_net_lookGao )
			else
				i_flag_look = faux
			break
	}	
}


if (o_net_oldNode)
{
	KRDBG_DRAWSPHERE(Ci_DBG_DRAW_NETWORK, @o_net_oldNode OBJ_PosGet(), 1.0, color_rouge)
}

if (o_net_nextNode)
{
	KRDBG_DRAWSPHERE(Ci_DBG_DRAW_NETWORK, @o_net_nextNode OBJ_PosGet(), 1.0, color_vert)
}





