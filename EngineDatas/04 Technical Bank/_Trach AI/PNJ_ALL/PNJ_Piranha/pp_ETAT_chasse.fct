#include "PNJ_piranha_defines.var"

object		to_target
vector		tv_traction
float			tf_dist

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	DYN_TractionSet(Cv_NullVector)
	DYN_SpeedSetVector( Cv_NullVector)
	return
}

// INIT ETAT ======================================================================
if ( i_etat_courant != ETAT_PP_MOVE)
{
	i_etat_courant = ETAT_PP_MOVE
	
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_etat_duree = 0.0
}
else
	f_etat_duree += TIME_GetDt()

// ANALYSE =======================================================================================================
AI_Execute( "pp_exec_chec_water")

if( ! o_cadavre && ! o_target)
	AI_TrackCurChangeNow("pp_ETAT_wait")
	

//if ( o_cadavre)
//	to_target = o_cadavre
//else
//	to_target = o_target


if( f_etat_duree > MATH_RandFloat(0.75,1.0) )
//if ( OBJ_SqrDistHorz( to_target ) < 1.0)
{
	if ( o_cadavre)
		macro_change_etat("pp_ETAT_mange")
	else
		macro_change_etat("pp_ETAT_tue")
}



//// COMPORTEMENT ===============================================================
//tv_traction= @to_target OBJ_PosGet() - OBJ_PosGet()
//tv_traction.z = 0.0
//tf_dist = MATH_VecNorm(tv_traction)
//tv_traction /= tf_dist	// Normalisé
//if ( tf_dist > 2.0)
//	tf_dist = Cf_Traction
//tv_traction *= tf_dist 
//DYN_TractionSet( tv_traction)
//
//
//// Orientation
//if ( ! MATH_VecNullEpsilon( DYN_SpeedGetVector()))
//	OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), DYN_SpeedGetVector(), 5.0 * TIME_GetDt()) , Cv_VerticalVector)
