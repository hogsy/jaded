//// FACES INFORMATION	
//to_ref_gao = o_test_gao[0]
//to_ref_gao = o_test_gao[1]
//
////		//A
////		VECTOR& a, //extents
////		VECTOR& Pa, //position
////		VECTOR* A, //orthonormal basis
////		//B
////		VECTOR& b, //extents
////		VECTOR& Pb, //position
////		VECTOR* B //orthonormal basis
//
//int			ti_i
//int			ti_k
//
//vector	tv_AB
//vector	tv_inA_AB
//
//object	to_gaoA
//object	to_gaoB
//
//tv_A_to_B = @to_gaoB OBJ_PosGet() - @to_gaoA OBJ_PosGet() 		// v
//tv_inA_AB = @to_gaoA MATH_VecGlobalToLocal(tv_A_to_B)				// T
//
//
////B's basis with respect to A's local frame
//float ra, rb, t;
//long i, k;
//
//for (ti_i = 0; ti_i < 3; ti_i++)
//{
//	for (ti_k = 0; ti_k < 3; ti_k++)
//		av_matrix_R[ti_i][ti_k] = A[i].dot(B[k]); 
//
//
///*ALGORITHM: Use the separating axis test for all 15 potential 
//separating axes. If a separating axis could not be found, the two 
//boxes overlap. */
//
////A's basis vectors
//for( i=0 ; i<3 ; i++ )
//{
//
//
//ra = a[i];
//
//rb = 
//b[0]*fabs(R[i][0]) + b[1]*fabs(R[i][1]) + b[2]*fabs(R[i][2]);
//
//t = fabs( T[i] );
//
//if( t > ra + rb ) 
//return false;
//
//
//}
//
////B's basis vectors
//for( k=0 ; k<3 ; k++ )
//{
//
//
//ra = 
//a[0]*fabs(R[0][k]) + a[1]*fabs(R[1][k]) + a[2]*fabs(R[2][k]);
//
//rb = b[k];
//
//t = 
//fabs( T[0]*R[0][k] + T[1]*R[1][k] + 
//T[2]*R[2][k] );
//
//if( t > ra + rb )
//return false;
//
//
//}
//
////9 cross products
//
////L = A0 x B0
//ra = 
//a[1]*fabs(R[2][0]) + a[2]*fabs(R[1][0]);
//
//rb = 
//b[1]*fabs(R[0][2]) + b[2]*fabs(R[0][1]);
//
//t = 
//fabs( T[2]*R[1][0] - 
//T[1]*R[2][0] );
//
//if( t > ra + rb )
//return false;
//
////L = A0 x B1
//ra = 
//a[1]*fabs(R[2][1]) + a[2]*fabs(R[1][1]);
//
//rb = 
//b[0]*fabs(R[0][2]) + b[2]*fabs(R[0][0]);
//
//t = 
//fabs( T[2]*R[1][1] - 
//T[1]*R[2][1] );
//
//if( t > ra + rb )
//return false;
//
////L = A0 x B2
//ra = 
//a[1]*fabs(R[2][2]) + a[2]*fabs(R[1][2]);
//
//rb = 
//b[0]*fabs(R[0][1]) + b[1]*fabs(R[0][0]);
//
//t = 
//fabs( T[2]*R[1][2] - 
//T[1]*R[2][2] );
//
//if( t > ra + rb )
//return false;
//
////L = A1 x B0
//ra = 
//a[0]*fabs(R[2][0]) + a[2]*fabs(R[0][0]);
//
//rb = 
//b[1]*fabs(R[1][2]) + b[2]*fabs(R[1][1]);
//
//t = 
//fabs( T[0]*R[2][0] - 
//T[2]*R[0][0] );
//
//if( t > ra + rb )
//return false;
//
////L = A1 x B1
//ra = 
//a[0]*fabs(R[2][1]) + a[2]*fabs(R[0][1]);
//
//rb = 
//b[0]*fabs(R[1][2]) + b[2]*fabs(R[1][0]);
//
//t = 
//fabs( T[0]*R[2][1] - 
//T[2]*R[0][1] );
//
//if( t > ra + rb )
//return false;
//
////L = A1 x B2
//ra = 
//a[0]*fabs(R[2][2]) + a[2]*fabs(R[0][2]);
//
//rb = 
//b[0]*fabs(R[1][1]) + b[1]*fabs(R[1][0]);
//
//t = 
//fabs( T[0]*R[2][2] - 
//T[2]*R[0][2] );
//
//if( t > ra + rb )
//return false;
//
////L = A2 x B0
//ra = 
//a[0]*fabs(R[1][0]) + a[1]*fabs(R[0][0]);
//
//rb = 
//b[1]*fabs(R[2][2]) + b[2]*fabs(R[2][1]);
//
//t = 
//fabs( T[1]*R[0][0] - 
//T[0]*R[1][0] );
//
//if( t > ra + rb )
//return false;
//
////L = A2 x B1
//ra = 
//a[0]*fabs(R[1][1]) + a[1]*fabs(R[0][1]);
//
//rb = 
//b[0] *fabs(R[2][2]) + b[2]*fabs(R[2][0]);
//
//t = 
//fabs( T[1]*R[0][1] - 
//T[0]*R[1][1] );
//
//if( t > ra + rb )
//return false;
//
////L = A2 x B2
//ra = 
//a[0]*fabs(R[1][2]) + a[1]*fabs(R[0][2]);
//
//rb = 
//b[0]*fabs(R[2][1]) + b[1]*fabs(R[2][0]);
//
//t = 
//fabs( T[1]*R[0][2] - 
//T[0]*R[1][2] );
//
//if( t > ra + rb )
//return false;
//
///*no separating axis found,
//the two boxes overlap */
//
//return true;
//
//
//}
//
//