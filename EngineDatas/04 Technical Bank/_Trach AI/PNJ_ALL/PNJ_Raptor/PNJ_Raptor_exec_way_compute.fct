#include "PNJ_Raptor_defines.var"

vector		tv_way_temp 					// Vecteur Temporaire.
vector		tv_dest_pos_temp			// Vecteur temporraire pour l'erreur grille
float			tf_born
int				ti_exit
int				ti_i, ti_cpt
int				ti_flag_next_case_reached
int				ti_flag_ok

float			tf_sqr_dist
float			tf_dist

vector		tv_temp
vector		tv_grid_current_pos
vector		tv_grid_dest_pos

object		to_collide_object

#ifdef SHOW_RASTER
DBG_StopRaster(8)
DBG_StartRaster(1, "Recherche chemin")
#endif

GRID_CurrentSet(0)

v_way_currentpos = OBJ_PosGet()
tv_grid_current_pos = GRID_PosGet(v_way_currentpos)
tv_grid_dest_pos = GRID_PosGet(v_way_destpos)

// ON CLEAN LE CHEMIN GRILLE S'IL N'AMENE PAS A LA POSITION VOULUE
if (i_way_case_nbr > 1 && v_way_case[0] != tv_grid_dest_pos)
{
	while(i_way_case_nbr)
	{
		i_way_case_nbr--
		v_way_case[i_way_case_nbr] = Cv_NullVector
	}
}

// TOLERANCE ARRIVEE
switch(raptor_type)
{
	case C_ID_Tyranosaure :
		if ( ! i_flag_in_my_territory || o_cache_best_wp || o_cine_vala_wp || (o_current_wp && @o_current_wp OBJ_CapaTest(Ci_Capa_Stop)))
			f_way_tolerance_sqr_dist = 0.0
		else if (o_next_wp)
			f_way_tolerance_sqr_dist = 1.0
		else if (i_perceived_best_actor_index != -1 && ai_perceived_accessible[i_perceived_best_actor_index])
		{
			if (MATH_VecDotProduct(v_way_destpos - OBJ_PosGet(), OBJ_SightGet()) > 0.0)
				f_way_tolerance_sqr_dist = 4.0
			else
				f_way_tolerance_sqr_dist = 0.0
		}
		else
			f_way_tolerance_sqr_dist = 64.0
		break	

	case C_ID_Raptor :

		if ( ! i_flag_in_my_territory || o_cache_best_wp || o_cine_vala_wp || i_way_computation_mode == Ci_WAY_MODE_REQUIN || i_way_status & Ci_WAY_STATUS_OCCLUDER_USED || (o_current_wp && @o_current_wp OBJ_CapaTest(Ci_Capa_Stop)))
			f_way_tolerance_sqr_dist = 0.0
		else if (o_next_wp)
			f_way_tolerance_sqr_dist = 2.0
		else if (i_way_computation_mode == Ci_WAY_MODE_FIGHT && i_way_status & Ci_WAY_STATUS_NO_WALL_BETWEEN_ME_AND_POS && i_perceived_best_actor_index != -1 && ! (ai_perceived_status[i_perceived_best_actor_index] & Ci_PERCEIVED_IS_DEAD) )
		{
			if (MATH_VecDotProduct(v_way_destpos - OBJ_PosGet(), OBJ_SightGet()) > 0.0)
				f_way_tolerance_sqr_dist = 12.0
			else
				f_way_tolerance_sqr_dist = 0.0
		}
		else
			f_way_tolerance_sqr_dist = 4.0
		break
		
	case C_ID_Galiminus :

		if ( ! i_flag_in_my_territory || o_cache_best_wp || o_cine_vala_wp || i_way_computation_mode == Ci_WAY_MODE_REQUIN || i_way_status & Ci_WAY_STATUS_OCCLUDER_USED || (o_current_wp && @o_current_wp OBJ_CapaTest(Ci_Capa_Stop)))
 		{
			f_way_tolerance_sqr_dist = 0.0
		}
		else if (i_way_computation_mode == Ci_WAY_MODE_FIGHT && i_way_status & Ci_WAY_STATUS_NO_WALL_BETWEEN_ME_AND_POS && i_perceived_best_actor_index != -1 && ! (ai_perceived_status[i_perceived_best_actor_index] & Ci_PERCEIVED_IS_DEAD) )
		{
			f_way_tolerance_sqr_dist = 4.0 * OBJ_ZoomGet()
			f_way_tolerance_sqr_dist *= f_way_tolerance_sqr_dist
		}
		else
		{
			f_way_tolerance_sqr_dist = 2.0 * OBJ_ZoomGet()
			f_way_tolerance_sqr_dist *= f_way_tolerance_sqr_dist
		}

		f_way_test_born = 5.0
		break
}

// ON NE TESTE JAMAIS LES CASES ROUGES !!!! ====================
f_way_test_born = 0.1

tv_way_temp = v_way_destpos
tv_way_temp -= v_way_currentpos
tv_way_temp.z = 0.0

tf_sqr_dist = MATH_VecDotProduct(tv_way_temp, tv_way_temp) 

if (i_flag_occluder_alllowed && i_dest_pos_territory_ID == i_occluder_territory)
	i_way_status |= Ci_WAY_STATUS_OCCLUDER_ENABLE

// SI ON EST HORS GRILLE, ON NE FAIT QU'UN TESTE DE DISTANCE POUR SAVOIR SI ON EST ARRIVE
if (i_flag_dont_use_grid || i_way_status & Ci_WAY_STATUS_OCCLUDER_ENABLE)
{
	v_way_case_dest = v_way_destpos

	if (tf_sqr_dist <= f_way_tolerance_sqr_dist)
	{
		if ( ! tf_sqr_dist )
			i_way_status |= Ci_WAY_STATUS_BEZIER_NO_MOVE

		i_way_moving = faux
	}
	else
	{
		PNJ_Raptor_Test_Occluder()
		i_way_moving = vrai	
	
		if (i_way_status & Ci_WAY_STATUS_DESTROY_OCCLUDER)
			macro_change_etat("PNJ_Raptor_ETAT_COODBOOL")
	
		if (i_way_status & Ci_WAY_STATUS_OCCLUDER_JUMP)
			macro_change_etat("PNJ_Raptor_ETAT_VIRTUEL_saut")
	}

	f_grid_use_duration = 0.0

#ifdef SHOW_RASTER
	DBG_StartRaster(8, "Comportement")
	DBG_StopRaster(1)
#endif
	return
}

//// SI ON SORT DE NOTRE TERRITOIRE, PAS LA PEINE D'ALLER PLUS LOIN
//if (! i_flag_in_my_territory && ! PNJ_Raptor_Territory_ID_Allowed(i_target_territory_ID))
//{
//	DBG_TraceFloat(TIME_Get())
//	DBG_TraceString(" => ")
//	DBG_TraceObject(OBJ_Me())
//	DBG_TraceString(" est sur le territoire ")
//	DBG_TraceInt(i_my_territory_ID)
//	DBG_TraceString(" qui n'est pas son territoire et essaye d'aller sur le territoire ")
//	DBG_TraceInt(i_target_territory_ID)
//	DBG_TraceEOL()
//	
//	i_way_moving = faux
//	return
//}

tf_dist = MATH_FloatSqrt(tf_sqr_dist)

// EST-CE QU'ON PEUT ACCEDER A LA POSITION DEST EN LIGNE DROITE ?
ti_flag_ok = faux
if (i_way_status & Ci_WAY_STATUS_NO_WALL_BETWEEN_ME_AND_POS)
	ti_flag_ok = vrai
else if (i_way_status & Ci_WAY_STATUS_NO_WALL_BETWEEN_ME_AND_WP)	
	ti_flag_ok = vrai
else
	ti_flag_ok = PNJ_Raptor_Test_Grid_Line(Ci_GRID_LINE_ME_TO_NEXT_POS, tv_grid_current_pos, tv_grid_dest_pos, 0, MATH_FloatMin(tf_dist - 1.0, 10.0), faux, i_grid_width)
	
if (ti_flag_ok)
{
	ti_flag_next_case_reached = faux

	if (f_way_tolerance_sqr_dist)
	{
		if (tv_grid_current_pos == tv_grid_dest_pos)
			ti_flag_next_case_reached = vrai
		else if (tf_sqr_dist < f_way_tolerance_sqr_dist)
			ti_flag_next_case_reached = vrai
	}
	else if ( ! tf_sqr_dist )
	{
		i_way_status |= Ci_WAY_STATUS_BEZIER_NO_MOVE
		ti_flag_next_case_reached = vrai
	}

	if (ti_flag_next_case_reached)
		i_way_moving = faux
	else
		i_way_moving = vrai

	v_way_case_dest = v_way_destpos
	i_way_case_nbr = 0

#ifdef SHOW_RASTER
	DBG_StartRaster(8, "Comportement")
	DBG_StopRaster(1)
#endif

	f_grid_use_duration = 0.0

	return
}


#ifndef _FINAL_
if (DBG_Display_Way)
{
	tv_temp = tv_grid_current_pos
	tv_temp.z = OBJ_PosGet().z + 1.0
	DBG_RenderVector(tv_temp, tv_grid_dest_pos - tv_grid_current_pos, color_rouge)

	av_grid_line_start_pos[Ci_GRID_LINE_ME_TO_NEXT_POS] = Cv_NullVector
	av_grid_line_dest_pos[Ci_GRID_LINE_ME_TO_NEXT_POS] = Cv_NullVector
	PNJ_Raptor_Test_Grid_Line(Ci_GRID_LINE_ME_TO_NEXT_POS, tv_grid_current_pos, tv_grid_dest_pos, 0, MATH_FloatMin(tf_dist - 1.0, 10.0), vrai, i_grid_width)
}
#endif

// DERNIERE CHANCE AVANT DE PASSER PAR LE A* ET LA GRILLE
//if ( f_grid_use_duration )
//{
//	f_grid_use_duration += TIME_GetDt()
//}
//else
//{
//	f_grid_use_duration += TIME_GetDt()
//	PNJ_Raptor_Clean_Way()
//
//	i_way_moving = vrai
//	v_way_case_dest = v_way_destpos
//
//	return
//}

f_grid_use_duration += TIME_GetDt()

if (f_grid_use_duration < 0.5)
{
	i_way_moving = vrai
	v_way_case_dest = v_way_destpos

	return
}

#ifdef SHOW_RASTER
DBG_StopRaster(8)
DBG_StartRaster(2, "Recherche grille")
#endif

// ON NE PEUT PAS ACCEDER EN LIGNE DROITE A LA POSITION DESTINATION
i_way_status |= Ci_WAY_STATUS_GRID_USED

//if (raptor_type == C_ID_Tyranosaure)
//{
//	i_way_moving = PNJ_Raptor_Find_Way(	v_way_currentpos, v_way_destpos)
//	return
//}

PNJ_Raptor_Hyper_Tag_On()

// SI LA POSITION DESTINATION N'EST PLUS LA MEME, ON FORCE LE RECALCUL
if (tv_grid_dest_pos != v_way_last_destpos)
{
	i_way_force_recompute = vrai
	v_way_last_destpos = tv_grid_dest_pos
}

// SI ON S'EST TROP ELOIGNE DE LA DERNIERE POSITION DEPUIS LAQUELLE ON A CALCULE UN CHEMIN, ON FORCE LE RECALCUL
if (i_way_moving && (i_way_case_nbr > 0 && !i_way_force_recompute))
{
	tv_temp = v_way_case[i_way_case_nbr - 1]
	tv_temp -= v_way_currentpos
	tv_temp.z = 0.0
	
	if (MATH_VecDotProduct(tv_temp, tv_temp) > f_way_sqr_next_case_dist)
		i_way_force_recompute = vrai
}

i_way_moving = vrai
v_way_destpos.z = v_way_currentpos.z
f_way_len_big = 20.0
i_way_algo_limitdestpos = 60

if (f_way_test_born)
{
	tf_born = f_way_test_born
	f_way_test_born = 0.0
}
else
{
	tf_born = 10.0
}

ti_exit = faux
if (!GRID_IsIn(v_way_destpos))
	DBG_Error("Point destination en dehors de la grille")
if (!GRID_IsIn(v_way_currentpos))
	DBG_Error("Point de départ en dehors de la grille")

// Rien stocké
if (i_way_case_nbr < 2)
{
	i_way_force_recompute = vrai
}
else
{
	// On test le chemin enregistré
	ti_cpt = 0
	for (ti_i = i_way_case_nbr - 2; ti_i >= 0; ti_i--)
	{
		ti_cpt++
		if (ti_cpt == 6)
			break	// Pas la peine de tester tout le chemin, juste le debut

		if (PNJ_Raptor_Blocked(v_way_case[ti_i], 0b11))
		{
			i_way_force_recompute = vrai
			break
		}
	}
}

// Si on a changé de case, on vérifie le chemin stocké
if (!i_way_force_recompute)
{
	ti_flag_next_case_reached = faux

	tv_way_temp = GRID_PosGet(v_way_case_dest) 

	// ===========================================
	// TEST SI ON A ATTEINT LA CASE DEST
	// ===========================================
	if (tv_way_temp == tv_grid_current_pos)
	{
		// On est sur la case désirée
		ti_flag_next_case_reached = vrai
	}
	else if (f_way_tolerance_sqr_dist)
	{
		// Si on a une tolerance, on teste la distance à la prochaine case	
		tv_way_temp -= v_way_currentpos
		tv_way_temp.z = 0.0
		
		tf_sqr_dist = MATH_VecDotProduct(tv_way_temp, tv_way_temp) 
		if (tf_sqr_dist < f_way_tolerance_sqr_dist)
			ti_flag_next_case_reached = vrai
	}

	// ============================================
	// ON A ATTEINT LA CASE DEST
	// ============================================
	if (ti_flag_next_case_reached)
	{
		i_way_case_nbr--
		v_way_case_dest = v_way_case[i_way_case_nbr - 1]
	}
}

// ============================================
// CALCUL D'UN NOUVEAU CHEMIN
// ============================================
if (i_way_force_recompute)
{
	// RECHERCHE AUTOUR DE LA DEST_POS -----------------------------------------------------------------------------------------------------------
	if (i_way_search_around_destpos)
	{
		// Gestion d'erreur sur le point de dest (il doit etre libre d'acces)
		tv_dest_pos_temp = GRID_ComputeDest(v_way_destpos, i_way_algo_limitdestpos)
		if (MATH_VecNull(tv_dest_pos_temp))
		{
			i_way_destpos_error = vrai															// Pas de solutions (je peux pas m'en sortir)
			i_way_moving = faux																	// Donc je m'arrete
			ti_exit = vrai																				// J'arrete l'exec de cette fonction
		}
		else
			i_way_destpos_error = faux															// Cool j'ai une solution j'y go !
	}
	else
		tv_dest_pos_temp = v_way_destpos
	// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

	if (ti_exit)
	{
		// Houla, erreur, on va tout recommencer
		PNJ_Raptor_Clean_Way()
	}
	else
	{
		// ### SHORT WAY########################################################
		// Tableau des cases
		// Pos depart
		// Pos arrivé
		// ??? Nib !
		// Distance a partir de laquelle le destpos est testé occupé
		// Nbr de case max a partir dequelle la fonction de recherche de chemin abort
		// Taille de la demi longueur de la zone a ne jamais depassé (carré)
		// Nbr d'éléments max a retourner
	
		i_way_case_nbr = GRID_ShortWay(v_way_case[0], v_way_currentpos, tv_dest_pos_temp, tf_born, i_way_algo_limitdestpos, f_way_len_big, 99)	// Chemin

//		DBG_TraceFloat(TIME_Get())
//		DBG_TraceString(" = > A STAR !!! => ")
//		DBG_TraceFloat(TIME_GetDt())
//		DBG_TraceEOL()

		if (i_way_case_nbr >= 2)
		{
			// On ne recalcul pas le chemin
			i_way_force_recompute = faux
			
			v_way_case_dest = v_way_case[i_way_case_nbr -2]
			
			tv_way_temp = v_way_case_dest
			tv_way_temp -= v_way_currentpos
			tv_way_temp.z = 0.0

			f_way_sqr_next_case_dist = MATH_VecNorm(tv_way_temp)
			f_way_sqr_next_case_dist += 2.0
			
			f_way_sqr_next_case_dist *= f_way_sqr_next_case_dist
		}
		else
		{

			// ERREUR: Pas de deplacements possibles (pas assez de case pour le déplacement)
			i_way_case_nbr = 0

			// Il faut recalculer un chemin...
			i_way_force_recompute = vrai

			if (PNJ_Raptor_Blocked(OBJ_PosGet(), 0))
			{
				// On est arrété car on est sur une case jaune
				v_way_case_dest = v_way_destpos
			}
			else
			{
				// On peut pas bouger
				i_way_moving = faux
				PNJ_Raptor_Clean_Way()
			}
		}
	}
}

PNJ_Raptor_Hyper_Tag_Off()

#ifdef SHOW_RASTER
DBG_StartRaster(8, "Comportement")
DBG_StopRaster(1)
DBG_StopRaster(2)
#endif
