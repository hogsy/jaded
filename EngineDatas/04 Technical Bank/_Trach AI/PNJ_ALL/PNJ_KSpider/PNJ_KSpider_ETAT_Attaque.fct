#include "PNJ_KSpider_defines.var"

int			ti_flag_ok

float		tf_norm

vector	tv_pos

vector	tv_new_sight
vector	tv_new_banking


#define Cf_gravity							-10.0
#define Cf_impulsion_speed			6.0

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux
	return
}

if (i_etat_courant != ETAT_Attaque)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Attaque
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	i_etat_phase = 3
	f_etat_phase_duration = 0.0

	f_jump_dist = MATH_RandFloat(1.0, 2.0)
	f_jump_dist *= f_jump_dist

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}
	
// ANALYSE ===============================================================

// COMPORTEMENT =========================================================

//if( PNJ_KSpider_vs_KAnn_Mode() && ! o_father )
//if( ! o_father )
//{
//	o_interaction_target = LNK_ClientGet(Ci_LNK_INTERACTION, mid_interaction_lnk, i_flag_can_be_there, "PNJ_KSpider_exec_interaction_add_data", nofunc, "PNJ_KSpider_exec_interaction_init")
//	if( o_interaction_target )
//	{
//		if( LNK_InteractionParamGet(mid_interaction_lnk) == C_INTER_FIGHT_ANN_READY )
//		{
//			// Ann est prête à subir une attaque
//			if( ! i_interaction_death_paf_sent && @o_interaction_target KAnn_Death_Attack_Enabled() )
//			{
//				// Attaque Mortelle
//				i_interaction_death_paf_sent = vrai
//				LNK_InteractionParamSet(mid_interaction_lnk, C_INTER_FIGHT_ENNEMY_ATTACK)
//				EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, C_PAF_KK_KiTue, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_interaction_target, 1.0, - @o_interaction_target OBJ_SightGet())
//			}
//			else
//			{
//				// Attaque Fake
//				LNK_InteractionParamSet(mid_interaction_lnk, C_INTER_FIGHT_ENNEMY_FAKE_ATTACK)
//			}
//		}
//		else if( LNK_InteractionParamGet(mid_interaction_lnk) == C_INTER_FIGHT_ANN_FAKING_ATTACK )
//		{
//			// Ann se défend
//			if( i_interaction_status != C_INTER_FIGHT_ANN_FAKING_ATTACK )
//			{
//				// Elle commence juste à se défendre
//				i_flag_paf = vrai
//			}
//		}
//
//		i_interaction_status = LNK_InteractionParamGet(mid_interaction_lnk)	// backup pour la trame suivante
//	}
//}

if (i_flag_paf)
	f_delay_before_paf = 0.5
	
if (f_delay_before_paf)
{
	f_delay_before_paf -= TIME_GetDt()
	
	if (f_delay_before_paf <= 0.0)
	{
		f_delay_before_paf = 0.0

		tv_pos = OBJ_PosGet()
		tv_pos -= @o_target OBJ_PosGet()
		tv_pos.z = 0.0
		tf_norm = MATH_VecSquareNorm(tv_pos)

		if (tf_norm < 9.00 && MATH_VecDotProduct(@o_target OBJ_SightGet(), tv_pos) > 0.0)
		{
			i_etat_phase = 5
			f_etat_phase_duration = 0.0
			
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_pos /= tf_norm
	
			v_speed = MATH_VecBlendRotate(tv_pos, Cv_VerticalVector, MATH_RandFloat(0.45, 0.6))
			v_speed *= MATH_RandFloat(3.0, 5.0)
			
			f_jump_duration = Cf_Infinit
		
			tv_pos = OBJ_PosGet()
			tv_pos += v_speed * TIME_GetDt()
			OBJ_PosSet(tv_pos)
		}
	}
}

if (i_etat_phase == 0)
{
	// Calcul impulsion
	v_speed = MATH_LIB_PHY_Impulsion_Get(OBJ_PosGet(), @o_target OBJ_PosGet() + cvector(0.0, 0.0, MATH_RandFloat(0.75, 1.25)), cvector(0.0, 0.0, Cf_gravity), Cf_impulsion_speed, f_jump_duration)

	i_etat_phase++
	f_etat_phase_duration = 0.0
}
else if (i_etat_phase == 1)
{
	// En l'air
	f_etat_phase_duration += TIME_GetDt()

	v_speed.z += Cf_gravity * TIME_GetDt()

	tv_pos = OBJ_PosGet()
	tv_pos += v_speed * TIME_GetDt()
	OBJ_PosSet(tv_pos)

	OBJ_BankingGeneralSet(Cv_VerticalVector, MATH_VecBlendRotate(OBJ_BankingGet(), -v_speed, 6.0 * TIME_GetDt()))

	if (OBJ_LIB_Virtual_Collision(OBJ_Me(), o_target, faux))
	{
		v_speed.x = 0.0
		v_speed.y = 0.0
		v_speed.z = MATH_FloatMin(v_speed.z, 0.0)
	
		i_etat_phase++
		f_etat_phase_duration = 0.0
	}
	else if (tv_pos.z < @o_target OBJ_PosGet().z)
	{
		v_speed.z = 0.0
		
		tv_pos.z = @o_target OBJ_PosGet().z 
		OBJ_PosSet(tv_pos)

		f_jump_dist = MATH_RandFloat(3.0, 5.0)
		f_jump_dist *= f_jump_dist

		i_etat_phase = 3
		f_etat_phase_duration = 0.0
	}
}
else if (i_etat_phase == 2)
{
	// On retombe au sol
	v_speed.z += Cf_gravity * TIME_GetDt()

	tv_pos = OBJ_PosGet()
	tv_pos += v_speed * TIME_GetDt()

	tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), OBJ_HorizonGet(), 2.0 * TIME_GetDt())
	tv_new_banking = MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 4.0 * TIME_GetDt())
	OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)
	
	if (tv_pos.z < @o_target OBJ_PosGet().z)
	{
		v_speed.z = 0.0
		
		tv_pos.z = @o_target OBJ_PosGet().z 
		OBJ_PosSet(tv_pos)

		f_jump_dist = MATH_RandFloat(3.0, 5.0)
		f_jump_dist *= f_jump_dist

		i_etat_phase++
		f_etat_phase_duration = 0.0
	}
	else
	{
		OBJ_PosSet(tv_pos)
	}
}
else if (i_etat_phase == 3)
{
	// On s'eloigne
	tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), OBJ_PosGet() - @o_target OBJ_PosGet(), 2.0 * TIME_GetDt())
	tv_new_sight = MATH_VecRotate(tv_new_sight, OBJ_BankingGet(), MATH_Sin(f_time_start_etat * 6.0) * 0.1)
	tv_new_banking = MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 4.0 * TIME_GetDt())
	OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)

	v_speed = OBJ_SightGet() * 4.0
	v_speed.z = 0.0

	tv_pos = OBJ_PosGet()
	tv_pos += v_speed * TIME_GetDt()
	OBJ_PosSet(tv_pos)
	
	if (OBJ_SqrDistHorz(o_target) > f_jump_dist)
	{
		f_jump_dist = MATH_RandFloat(1.0, 2.0)
		f_jump_dist *= f_jump_dist

		if ( ! i_flag_can_be_there )
			macro_change_etat("PNJ_KSpider_ETAT_Disparition")
	
		i_etat_phase++
		f_etat_phase_duration = 0.0
	}
}
else if (i_etat_phase == 4)
{
	// On se rapproche
	tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_target OBJ_PosGet() - OBJ_PosGet(), 4.0 * TIME_GetDt())
	OBJ_BankingGeneralSet(tv_new_sight, Cv_VerticalVector)

	v_speed = OBJ_SightGet() * 4.0
	v_speed.z = 0.0

	tv_pos = OBJ_PosGet()
	tv_pos += v_speed * TIME_GetDt()
	OBJ_PosSet(tv_pos)
	
	if (OBJ_SqrDistHorz(o_target) < f_jump_dist)
	{
		f_delay_before_jump = 0.0 // MATH_RandFloat(0.1, 0.8)
		
		i_etat_phase = 0
		f_etat_phase_duration = 0.0
	}
}
else if (i_etat_phase == 5)
{
	// En paf
	f_etat_phase_duration += TIME_GetDt()

	v_speed.z += Cf_gravity * TIME_GetDt()

	tv_pos = OBJ_PosGet()
	tv_pos += v_speed * TIME_GetDt()
	OBJ_PosSet(tv_pos)

	OBJ_BankingGeneralSet(Cv_VerticalVector, MATH_VecBlendRotate(OBJ_BankingGet(), -v_speed, 6.0 * TIME_GetDt()))

	if (tv_pos.z < @o_target OBJ_PosGet().z)
	{
		v_speed.z = 0.0
		
		tv_pos.z = @o_target OBJ_PosGet().z 
		OBJ_PosSet(tv_pos)

		f_jump_dist = MATH_RandFloat(3.0, 5.0)
		f_jump_dist *= f_jump_dist

		i_etat_phase = 3
		f_etat_phase_duration = 0.0
	}
}

//Str_DisplayIntOnce(i_etat_phase, VIEW_3dWorldTo2d(0, OBJ_PosGet()))


