#include "PNJ_SwampCrawlerSmall_defs.var"

vector	sight, temp, newsight
float		tf_speed 
object	to_gao 

//--------( Sortie Etat )--------
if (etat_i_quitte)
{
	net_i_test = 0
	etat_i_quitte = faux

	f_time_splash = 1.0
	SND_RequestPlay(SCS_Snd_Growl)

	return
}

//--------( Entrée Etat )--------
if ( etat_i_courant != SCS_ETAT_wait )
{
	etat_i_ancien = etat_i_courant
	etat_i_courant = SCS_ETAT_wait

	//----( quitte état précédent )----
	if ( etat_fct ) 
	{
		etat_i_quitte = vrai
		AI_Execute( etat_fct )
	}
	
	//--------( init variable )------------------------------------------------------------------------------------
	etat_f_timer = MATH_RandFloat( f_DownTimeMin, f_DownTimeMax)
	etat_i_state = 0

	etat_fct = AI_TrackCurGet()
	return
}

#ifndef _FINAL_
if ((i_debug_display || @get_global i_debug_all_swamp) && !@"univ" Engine)
{
	to_gao = ANI_CanalObjectGet(Anim_Canal_Tete)
	Str_DisplayTextOnce("WAITING", VIEW_3dWorldTo2d(0, @to_gao OBJ_PosGet()))
}	
#endif

tf_speed = MATH_VecNorm( v_last_pos - OBJ_PosGet() ) / TIME_GetDt()
if (tf_speed <= 0.1)
	ACT_ActionSet( SCS_ACT_water_wait )
else
{
	ACT_ActionSet( SCS_ACT_water_swim )
	ANI_FrequencySet(0, MATH_FloatLimit(32 * tf_speed,1,255) )
}

//--------( changement de position )---------------------------------------------------------
etat_f_timer -= TIME_GetDt()
if (etat_f_timer < 0 )
{
	if (etat_i_state == 0)
	{
		etat_i_state = 1
		etat_f_timer = MATH_RandFloat( f_UpTimeMin, f_UpTimeMax)
	}
	else
	{
		etat_i_state = 0
		etat_f_timer = MATH_RandFloat( f_DownTimeMin, f_DownTimeMax)
	}
}

if ( i_Attack_HideBeforeTrigger )
	etat_i_state = 0
	
//---------( passage en mode follow network en mode attente )---------
if ( net_i_test == 2 )
{
	if (call_trigger( net_t_Start ) )
	{
		net_i_test = 0
		net_o_wp = net_o_startwp
		AI_TrackCurChange( "SCS_follownet" )
		return
	}
}

//--------( déplacement )--------
if (o_WaitInHere)
{
	move_v_dest.z = OBJ_PosGet().z
	if (!f_WaitInHere ) // || MATH_VecSquareDistance(OBJ_PosGet(), move_v_dest) < 1.0 )
	{
		f_blendblend = 0		// Blend de Blend
		move_v_dest = @o_WaitInHere BV_RandomPosGet(0)
		f_WaitInHere = MATH_RandFloat(1.2,2.5)
		SND_RequestPlay(SCS_Snd_MvtWater)
	}
	else
		f_WaitInHere -= MATH_FloatMin(f_WaitInHere, TIME_GetDt())
}
move_v_dest.z = move_f_Zsurface
if (etat_i_state == 0 )
	move_v_dest.z = move_f_Zunderwater
move_f_speed = f_Speed / 2
move_i_brakewhennear = 1
move_i_ondule = 0
move_i_remote = 0
f_SpeedZ = 0.2
AI_Execute( "SCS_exec_move" )

//-------( réoriente )--------
newsight = move_v_startsight
if (stimul_i_visu)
{
	temp = @stimul_o_target OBJ_PosGet() - OBJ_PosGet()
	temp.z = 0
	if ( !MATH_VecNull( temp ) )
		newsight = temp
}

//if ( ( (OBJ_PosGet() == move_v_dest) || move_i_ground) && (etat_i_state == 0))
//{
//	sight = OBJ_SightGet()
//	if (MATH_VecDotProduct(sight, newsight)	 )
//		sight += 0.1 * newsight
//	else
//		sight = MATH_VecBlend(sight, newsight, 0.01)
//	OBJ_SightGeneralSet( sight, Cv_VerticalVector )
//}

//---------( passage en mode follow network )---------
if ( net_i_test == 1 )
{
	if (call_trigger( net_t_Use ) )
	{
//		SND_RequestPlay( SCS_Snd_Growl )
		net_i_test = 0
		net_o_wp = net_o_startwp
		AI_TrackCurChange( "SCS_follownet" )
		return
	}
}

//--------( se prend un paf )--------
if ( stimul_i_paf )
	macro_takeapaf( SCS_PAF_one )
	
//--------( cible en vue )--------
if (stimul_i_attack && stimul_o_target && !etat_i_swimnoattack)
{
//	SND_RequestPlay( SCS_Snd_Growl )
	macro_change_etat( "SCS_attack" )
}

//--------( stimuli de dérangement )--------
if ( stimul_i_move ) 
{
//	SND_RequestPlay( SCS_Snd_Growl )
	move_v_dest = move_v_end
	move_v_dest.z = move_f_Zsurface
	macro_change_etat( "SCS_swim" )
}

//--------( PASSAGE : fin de vie si arrivé à la fin )--------
if ( (i_Type == SCS_Passage) && (OBJ_PosGet() == move_v_end))
{
	stimul_o_pafby = nobody
	macro_change_etat( "SCS_dead" )
}
	