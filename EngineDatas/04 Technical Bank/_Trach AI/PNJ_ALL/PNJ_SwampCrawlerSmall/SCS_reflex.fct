#include "PNJ_SwampCrawlerSmall_defs.var"

int					enemy_state
int					gfx_on
int					i_test_way
int					index

float				vision_visibility
float				fz
float				gfx_width 
float				tf_temp

vector			pos

messageid 		EVT_InfoSeen_ID

object			to_obj


// UPDATE WATER Z ========================

if( IsInWater(OBJ_PosGet(), tf_temp) )
{
	move_f_Zsurface = tf_temp
	SCS_Compute_All_Z()
}
// UPDATE WATER Z ========================


//vector	tv_sight, tv_newsight, tv_pos
//object	to_head
//to_head	= ANI_CanalObjectGet(Anim_Canal_Tete)
//if (to_head)
//{
//	tv_pos = @to_head OBJ_PosGet()
//	tv_pos += @to_head OBJ_BankingGet() * 0.2
//	tv_pos += @to_head OBJ_SightGet() * 0.1
//	LIBGFX_Blood( GFX_blood, tv_pos, (cvector( 0, 0, 1) + OBJ_SightGet()) * 0.5)
//}


if( EVENT_LIFE_CurLifeGet(ID_LIFE) )
{
	EVENT_LIFE_LifeDisplay( ID_LIFE, VIEW_3dWorldTo2d(0, OBJ_PosGet()) + cvector(0.0,-0.05,1.5))

	//--------( event ennemy )--------
	if ( ! i_Attack_HideBeforeTrigger  )
	{
		EVT_InfoSeen_ID = EVENT_AddEventEnemy( C_ID_SwampCrawlerSmall, OBJ_Me(), enemy_state)
		to_obj = ANI_CanalObjectGet(Anim_Canal_Tete)
		EVENT_PositionSet(EVT_InfoSeen_ID, @to_obj OBJ_PosGet())

		//--------( event vision )--------
		EVENT_AddEventVision( 
				C_ID_SwampCrawlerSmall, 
				0, 
				OBJ_Me(), 
				Cf_EVENT_Duree_1Trame, 
				OBJ_PosGet(), 
				vision_visibility, 
				@"univ" Enemy_af_Radius[ C_ID_SwampCrawler ],
				100.0, 
				C_EVENT_CONTEXT_STANDARD, 
				2,
				EVENT_LIFE_CurLifeGet(ID_LIFE) / EVENT_LIFE_MaxLifeGet(ID_LIFE) )
	}
}
else
{
	if( f_point_de_viande && ! i_fade_flag )
		EVENT_AddEventCadavre(C_ID_SwampCrawlerSmall, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet())
//	Str_DisplayTextOnce("viande = ", VIEW_3dWorldTo2d(0, OBJ_PosGet()))
//	Str_DisplayFloatOnce(f_point_de_viande, VIEW_3dWorldTo2d(0, OBJ_PosGet()) + cvector(0.1,0,0))
}



// --------( GFX )--------
if (GFX_trace != -1)
{
	pos = OBJ_PosGet()
		
	gfx_on = 1
	if (etat_i_courant == SCS_ETAT_wait)
		gfx_on = 0
	else 
	{
		gfx_width = move_f_Zsurface - move_f_Zsurfacebattement
		if (pos.z <= gfx_width)
			gfx_on = 0
		else if (pos.z >= move_f_Zsurface)
			gfx_width = 1.0
		else
			gfx_width = (pos.z - gfx_width) / gfx_width
	}

	pos += OBJ_SightGet() / 2
	pos.z = GFX_traceZ
	
	LIBGFX_WaterTrace_Update( GFX_trace, gfx_on, pos, OBJ_SightGet(), gfx_width  )
}


// CHEKS 
AI_Execute( "SCS_exec_stimulus" )


if (etat_i_courant == SCS_ETAT_dead )
{
	if ( (gfx_on == 0) && (GFX_trace != -1) )
	{
		GFX_Del( GFX_trace )
		GFX_trace = -1
	}
	return
}

etat_f_timerswimafterhit -= TIME_GetDt()
	
if ( (etat_i_courant != SCS_ETAT_swim ) && (etat_i_courant != SCS_ETAT_wait) )
{
	etat_i_swimnoattack = 0
	etat_i_swimnopaf = 0
}
else
{
	if ( etat_i_swimnoattack )
	{
		etat_f_swimnoattack_timer -= TIME_GetDt()
		if (etat_f_swimnoattack_timer < 0) 
		{	
			etat_i_swimnoattack = 0
			etat_i_swimnopaf = 0
		}
	}
}

// --------( visu )--------
fz = OBJ_PosGet().z
i_test_way = faux
switch ( etat_i_courant )
{
	case	SCS_ETAT_wait	: 
		if (fz < (move_f_Zsurface + move_f_Zunderwater) / 2)
		{
			vision_visibility = C_EVENT_Visibility_UnderWater
			enemy_state = C_EVENT_EnemyState_Quiet
		}
		else
		{
			vision_visibility = C_EVENT_Visibility_InWater
			enemy_state = C_EVENT_EnemyState_Wait
		}
		break
		
	case SCS_ETAT_paf :
		vision_visibility = C_EVENT_Visibility_InWater
		enemy_state = C_EVENT_EnemyState_Neutral
		break

	case SCS_ETAT_swim	:
		if (fz < (move_f_Zsurface + move_f_Zunderwater) / 2 )
			vision_visibility = C_EVENT_Visibility_UnderWater_Mvt
		else
			vision_visibility = C_EVENT_Visibility_InWater_Mvt
		enemy_state = C_EVENT_EnemyState_Fight
		i_test_way = vrai
		break
		
	case SCS_ETAT_follownet :
		if (fz < (move_f_Zsurface + move_f_Zunderwater) / 2 )
			vision_visibility = C_EVENT_Visibility_UnderWater_Mvt
		else
			vision_visibility = C_EVENT_Visibility_InWater_Mvt
		enemy_state = C_EVENT_EnemyState_Fight
		break
	
		
	case SCS_ETAT_fight:
	case SCS_ETAT_grab:
		i_test_way = vrai
		vision_visibility = C_EVENT_Visibility_InWater_Mvt
		enemy_state = C_EVENT_EnemyState_Fight
		break

	default:
		vision_visibility = C_EVENT_Visibility_Full
		enemy_state = C_EVENT_EnemyState_Wait
		break
}

// Force le tir au dernier moment
if(i_Attack_TirBloque &&  enemy_state == C_EVENT_EnemyState_Fight)
{
	if ( etat_i_state == 1 || etat_i_courant == SCS_ETAT_grab)
		OBJ_Me().des_int1 = Ci_DISPLAY_FIGHT
	else
		OBJ_Me().des_int1 = Ci_DISPLAY_FIGHTBLOQUE
}



if (fz > (move_f_Zsurface + move_f_Zunderwater) / 2 )
	SPG2_AddSphere(OBJ_PosGet(), 3.0)


// INTERETssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
if ( stimul_o_target )
{
	if (MSG_GlobalIsValid(EVT_Interest))
		MSG_GlobalDelete(EVT_Interest, C_EVENT_DEL)
	EVT_Interest = EVENT_AddEventInteret(OBJ_Me(), 0.1, 10.0, @stimul_o_target OBJ_PosGet(), stimul_o_target)
	if( stimul_i_charogne )
		EVENT_InteretStatusSet(EVT_Interest, C_EVENT_InteretStatusFoodchain)
	else
		EVENT_InteretStatusSet(EVT_Interest, C_EVENT_InteretStatusAttack)
	EVENT_InteretVisionIDSet(EVT_Interest, C_ID_SwampCrawlerSmall)
}
else
{
	if (MSG_GlobalIsValid(EVT_Interest))
		MSG_GlobalDelete(EVT_Interest, 0)
}
// INTERETssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss

for ( index = 0; index < 8; index++)
{
	move_af_coltemp[ index ] -= TIME_GetDt()
	if (move_af_coltemp[ index ] < 0)
		move_af_coltemp[ index ] = 0
}

if ( i_test_way  && !GRID_LIB_IsReachableFrom(OBJ_PosGet(), move_v_dest, 0b0, 4.0, faux, 0) )
	AI_Execute( "SCS_exec_addcol" )
if ( i_test_way  && !GRID_LIB_IsReachableFrom(OBJ_PosGet(), OBJ_PosGet() + (2*OBJ_SightGet()), 0b0, 2.0, faux, 0) )
	AI_Execute( "SCS_exec_addcol" )

for (index = 0; index < 8; index++)
{
	if (move_af_coltemp[ index ]  > 0)
	{
		move_av_buddypos[ move_i_buddynb ] = move_av_colpos[ index ]
		move_af_buddyradius[ move_i_buddynb ] = 10 * move_af_coltemp[ index ]
		move_i_buddynb++
	}
}



