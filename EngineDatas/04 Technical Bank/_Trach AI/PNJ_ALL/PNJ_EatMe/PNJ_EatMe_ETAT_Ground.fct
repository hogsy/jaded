#include "PNJ_EatMe_defines.var"

int				ti_i
int				ti_flag_orient

float			tf_coef
float			tf_dist
float			tf_speed
float			tf_target_speed
float			tf_norm
float			tf_rayon
float			tf_LOD

object		to_collide_object
object		to_bone
object		to_main_actor

vector		tv_new_sight
vector		tv_new_banking
vector		tv_speed 
vector		tv_traction
vector		tv_pos
vector		tv_hor_sight
vector		tv_ray_start_pos
vector		tv_collide_pos
vector		tv_ray_col_normal

// MAIN ACTOR
if( @get_global i_Player_is_Kong )
	to_main_actor = o_main_actor_Kong
else
	to_main_actor = o_main_actor_Jack


if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux

	if (i_flag_hide)
	{
		i_flag_hide = faux
	
		to_bone = ANI_CanalObjectGet(0)
		@to_bone OBJ_FlagInvisibleSet(faux)
		to_bone = ANI_CanalObjectGet(1)
		@to_bone OBJ_FlagInvisibleSet(faux)
	}
	
	return
}

if (i_etat_courant != ETAT_Ground)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Ground
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	
	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_NeverDynamicFather | DYN_C_SlipOnGroundEdge, DYN_C_NeverDynamicHierarchy)
	DYN_FrictionVectorSet(cvector(2.0, 2.0, 0.0))
	DYN_GravitySet(v_Scolo_Gravity)
	COL_ColSetActivationSet(C_bit_zdm_pied, none)

	OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)
	OBJ_CapaSet(none, CAPA_Bidoche_Snapped_SeDetacher)

	v_init_pos = OBJ_PosGet() // @BV_ZoneTerritoire OBJ_PosGet()
	v_rand_dest_pos = OBJ_PosGet() // @BV_ZoneTerritoire BV_RandomPosGet(0)

	f_angle_oscillation = 0.0
	f_on_ground_dist = 0.0
	
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
AI_Execute("PNJ_EatMe_exec_check_paf")
if (i_flag_snap)
	macro_change_etat("PNJ_EatMe_ETAT_Snap")
if (i_flag_paf || i_flag_smell_food)
	macro_change_etat("PNJ_EatMe_ETAT_Fall")

// COMPORTEMENT =========================================================
tf_LOD = OBJ_LodVisGet()

if (tf_LOD < Cf_LOD_Visibilite)
{
	if ( ! i_flag_hide )
	{
		i_flag_hide = vrai

		to_bone = ANI_CanalObjectGet(0)
		@to_bone OBJ_FlagInvisibleSet(vrai)
		to_bone = ANI_CanalObjectGet(1)
		@to_bone OBJ_FlagInvisibleSet(vrai)
	}
}
else if (i_flag_hide)
{
	i_flag_hide = faux

	to_bone = ANI_CanalObjectGet(0)
	@to_bone OBJ_FlagInvisibleSet(faux)
	to_bone = ANI_CanalObjectGet(1)
	@to_bone OBJ_FlagInvisibleSet(faux)
}

if (tf_LOD < Cf_LOD_Activation)
{
	if ( ! i_flag_secto )
	{
		i_flag_secto = vrai

		v_secto_speed = DYN_SpeedGetVector()
		v_secto_grav = DYN_GravityVectorGet()
		v_secto_friction = DYN_FrictionVectorGet()
	
		DYN_Off()
	
		COL_ColSetActivationSet(none, C_bit_zdm_pied)
		OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
	}

	returntrack
}
else if (i_flag_secto)
{
	i_flag_secto = faux

	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_NeverDynamicFather | DYN_C_SlipOnGroundEdge, DYN_C_NeverDynamicHierarchy)
	DYN_FrictionVectorSet(v_secto_friction)
	DYN_GravitySet(v_secto_grav)
	DYN_SpeedSetVector(v_secto_speed)

	COL_ColSetActivationSet(C_bit_zdm_pied, none)
	OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)
}

f_force_Z_axis_duration -= MATH_FloatMin(f_force_Z_axis_duration, TIME_GetDt())

if (COL_CollideType(COL_C_Ground))
{
	f_delay_until_last_ground_col = 0.0

	v_ground_pos = COL_CollidedPointGet(COL_C_Ground)
	v_last_collided_pos = v_ground_pos

	v_ground_normal	= COL_ZonePosGet(C_zdm_pied)
	v_ground_normal -= v_ground_pos
	MATH_VecSetNormalize(v_ground_normal)
	
	if (v_ground_normal.z > 0.0)
		f_on_ground_dist += DYN_SpeedGet() * TIME_GetDt()
	else
		f_on_ground_dist = 0.0
}
else
{
	f_delay_until_last_ground_col += TIME_GetDt()

	if (v_ground_normal.z < 0.0 || f_delay_until_last_ground_col > 0.2)
		f_on_ground_dist = 0.0
	else
		f_on_ground_dist += DYN_SpeedGet() * TIME_GetDt()
}

if (COL_CollideType(COL_C_Wall))
{
	f_delay_until_last_wall_col = 0.0
	v_last_collided_pos = COL_CollidedPointGet(COL_C_Wall)
	v_wall_normal	= COL_ZonePosGet(C_zdm_pied)
	v_wall_normal -= v_last_collided_pos
	MATH_VecSetNormalize(v_wall_normal)
}
else
{
	f_delay_until_last_wall_col += TIME_GetDt()
}

//if (i_on_ground_modules_nb < i_modules_nb - 1)
//{
//	tv_pos = @ao_modules[i_modules_nb - 1] OBJ_PosGet()
//	tv_pos.z = MATH_FloatMax(tv_pos.z, OBJ_PosGet().z)
//	
//	if (COL_RayObject_Dist(tv_pos, -Cv_VerticalVector, 10.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//	{
//		v_ray_pos = MATH_VecBlend(v_ray_pos, COL_RayObject_PosGet(), 6.0 * TIME_GetDt())
//		v_ray_normal = MATH_VecBlendRotate(v_ray_normal, COL_RayObject_NormalGet(), 4.0 * TIME_GetDt())
//	}
//}

if (f_delay_until_last_ground_col < 0.2 || f_delay_until_last_wall_col < 0.2)
{
//	if ( ! f_delay_until_last_ground_col && ! f_delay_until_last_wall_col)
//		v_dest_banking = MATH_VecBlendRotate(v_ground_normal, v_wall_normal, 0.5)
//	else if (f_delay_until_last_ground_col > f_delay_until_last_wall_col)
//		v_dest_banking = v_wall_normal
//	else 
//		v_dest_banking = v_ground_normal

	if ( ! f_delay_until_last_ground_col && ! f_delay_until_last_wall_col )
	{
		if (MATH_VecDotProduct(v_ground_normal, OBJ_SightGet()) < MATH_VecDotProduct(v_wall_normal, OBJ_SightGet()))
			v_dest_banking = v_ground_normal
		else
			v_dest_banking = v_wall_normal
//		v_dest_banking = MATH_VecBlendRotate(v_ground_normal, v_wall_normal, 0.5)
	}
	else if ( ! f_delay_until_last_wall_col ) 
		v_dest_banking = v_wall_normal
	else if ( ! f_delay_until_last_ground_col ) 
		v_dest_banking = v_ground_normal
	else
		v_dest_banking = MATH_VecNormalize(OBJ_PosGet() - v_last_collided_pos)

//	if (f_delay_until_last_ground_col && f_delay_until_last_wall_col && COL_RayObject_Dist(OBJ_PosGet(), -v_dest_banking, 1.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//	{
//		v_dest_banking = MATH_VecNormalize(OBJ_PosGet() - COL_RayObject_PosGet())
//		
//		if (MATH_AbsFloat(v_dest_banking.z) > Cf_Cos60)
//		{
//			v_ground_normal = v_dest_banking
//			f_delay_until_last_ground_col = 0.0
//		}
//		else
//		{
//			v_wall_normal = v_dest_banking
//			f_delay_until_last_wall_col = 0.0
//		}
//	}

	tv_traction = v_dest_banking * v_Scolo_Gravity.z
	
	tv_traction.x *= DYN_FrictionVectorGet().x
	tv_traction.y *= DYN_FrictionVectorGet().y

	if (tv_traction.z)
		DYN_GravitySet(cvector(0.0, 0.0, -1.0))
	else
		DYN_GravitySet(v_Scolo_Gravity)
}
else
{
	tv_traction = Cv_NullVector

	DYN_GravitySet(v_Scolo_Gravity)

	v_dest_banking = MATH_VecBlendRotate(v_dest_banking, Cv_VerticalVector, MATH_FloatMax(f_delay_until_last_ground_col, 8.0 * TIME_GetDt()))
}

if (f_delay_until_last_ground_col < 0.2 || f_delay_until_last_wall_col < 0.2)
{
	tv_new_sight = OBJ_PosGet()
	tv_new_sight -= @to_main_actor OBJ_PosGet()
	tf_norm = MATH_VecDotProduct(tv_new_sight, tv_new_sight)

	if (tf_norm < 9.0)
	{
		tf_norm = MATH_FloatSqrt(tf_norm)
		tv_new_sight /= tf_norm
		tv_new_sight *= MATH_FloatMax(tf_norm, 3.0)
		tv_new_sight += OBJ_SightGet()
		tv_new_sight += @to_main_actor OBJ_PosGet()

		tf_target_speed = move_speed * 2.0
	}
	else
	{
//		tv_new_sight = MATH_VecRotate(cvector(1.0, 0.0, 0.0), Cv_VerticalVector, f_time_start_etat)

		f_rand_pos_duration -= MATH_FloatMin(f_rand_pos_duration, TIME_GetDt())

		tv_new_sight = v_rand_dest_pos
		tv_new_sight -= OBJ_PosGet()
		tv_new_sight.z = 0.0

		if ( ! f_rand_pos_duration || MATH_VecDotProduct(tv_new_sight, tv_new_sight) < 0.25)
		{
			f_rand_pos_duration	= MATH_RandFloat(4.0, 8.0)
		
			tv_new_sight = v_init_pos
			tv_new_sight -= OBJ_PosGet()
			tf_norm = MATH_VecNorm(tv_new_sight)
			if (tf_norm > 0.001)
				tv_new_sight /= tf_norm
			else
				tv_new_sight = OBJ_SightGet()
	
			tv_new_sight = MATH_VecCrossProduct(tv_new_sight, OBJ_BankingGet())
			tf_norm = MATH_VecNorm(tv_new_sight)
			if (tf_norm > 0.001)
				tv_new_sight /= tf_norm
			else
				tv_new_sight = OBJ_SightGet()
			
			tv_new_sight *= MATH_FloatSign(MATH_RandFloat(-1.0, 1.0))
			tv_new_sight *= rayon_balade * MATH_RandFloat(0.5, 1.0)
			
			v_rand_dest_pos = v_init_pos
			v_rand_dest_pos += tv_new_sight
		}
		
//		tv_new_sight = v_rand_dest_pos
//		tv_new_sight -= OBJ_PosGet()
//		tv_new_sight.z = 0.0
//		
//		if (MATH_VecDotProduct(tv_new_sight, tv_new_sight) < 1.0)
//			@BV_ZoneTerritoire BVw_RandomPosGet(0)

		DBG_RenderVector(OBJ_PosGet(), v_rand_dest_pos - OBJ_PosGet(), color_cyan)
		tv_new_sight = v_rand_dest_pos
		
		tf_target_speed = move_speed
		tf_target_speed *= 1.0 + (MATH_Sin(TIME_Get() * 4.0) * 0.25)
	}

	// Z MOVE ??? ============================================================
	if (MATH_VecDotProduct(OBJ_SightGet(), tv_new_sight - OBJ_PosGet()) < 0.0)
	{
		if (f_delay_until_last_wall_col < 0.1)
		{
			f_force_Z_axis_duration = 0.2
	
			if (MATH_VecDotProduct(v_wall_normal, tv_new_sight - OBJ_PosGet()) < 0.0)
				tv_new_sight = OBJ_PosGet() + Cv_VerticalVector
			else
				tv_new_sight = OBJ_PosGet() - Cv_VerticalVector
		}
		else if (f_force_Z_axis_duration)
		{
			if (MATH_VecDotProduct(v_wall_normal, tv_new_sight - OBJ_PosGet()) < 0.0)
				tv_new_sight = OBJ_PosGet() + Cv_VerticalVector
			else
				tv_new_sight = OBJ_PosGet() - Cv_VerticalVector
		}
	}

	// CALCUL DE LA DIRECTION
	tv_new_sight -= OBJ_PosGet()
	tv_new_sight -= MATH_VecDotProduct(tv_new_sight, OBJ_BankingGet()) * OBJ_BankingGet()
	tf_norm = MATH_VecNorm(tv_new_sight)

	ti_flag_orient = vrai
	if (tf_norm < 0.001)
		ti_flag_orient = faux

	if (ti_flag_orient)
	{
		tv_new_sight /= tf_norm
		
		if (MATH_VecDotProduct(OBJ_SightGet(), tv_new_sight) > 0.0)
			tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 6.0 * TIME_GetDt())
		else
			tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), MATH_FloatSign(MATH_VecDotProduct(tv_new_sight, OBJ_HorizonGet())) * OBJ_HorizonGet(), 6.0 * TIME_GetDt())
	}
	else
	{
		tv_new_sight = OBJ_SightGet()
	}

	tf_speed = MATH_VecDotProduct((OBJ_PosGet() - v_head_last_pos) / TIME_GetDt(), OBJ_SightGet())
	tf_speed = MATH_FloatMax(tf_speed, 0.0)

	f_angle_oscillation += TIME_GetDt() * Cf_Pi // MATH_FloatMin(tf_speed * 0.15, 1.5 * Cf_2Pi)
	while(f_angle_oscillation > Cf_2Pi)
		f_angle_oscillation -= Cf_2Pi

	tf_coef = MATH_Sin(f_angle_oscillation)
	tf_coef *= MATH_FloatMin(tf_speed * 0.6, 0.15)

//	tf_coef = MATH_FloatMin(f_move_speed - 1.0, 1.0)
//	tf_coef *= MATH_Sin(TIME_Get() * 6.0) * 0.15

	tv_new_banking = MATH_VecBlendRotate(OBJ_BankingGet(), v_dest_banking, 8.0 * TIME_GetDt())
	tv_new_sight = MATH_VecRotate(tv_new_sight, tv_new_banking, tf_coef)

//	if (i_on_ground_modules_nb < 10)
//	{
//		tf_coef = i_on_ground_modules_nb
//		tf_coef /= i_modules_nb
//		tf_coef = 1.0 - tf_coef
//
//		tf_target_speed = MATH_FloatMax(tf_target_speed, f_size_coef * (tf_coef * 4.0))
//
//		tv_new_sight = MATH_VecInCone(tv_new_sight, OBJ_SightGet(), Cf_2Pi * TIME_GetDt(), 1)
//	}

	f_move_speed = MATH_FloatBlend(f_move_speed, tf_target_speed, 12.0 * TIME_GetDt())	

	OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)
	
	if (f_move_speed)
	{
//		f_Z_noise = MATH_RandFloat(-0.05, 0.05)
//		f_Z_noise *= f_size_coef

		tv_speed = OBJ_SightGet() * f_move_speed
		tv_speed -= MATH_FloatMax(MATH_VecDotProduct(tv_speed, v_dest_banking), 0.0) * v_dest_banking
		DYN_SpeedSetVector(tv_speed)
	}
}
else
{
	tf_speed = DYN_SpeedGet()
	if (tf_speed > 0.001)
	{
		tv_new_sight = DYN_SpeedGetVector()
		tv_new_sight /= tf_speed
		tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 4.0 * TIME_GetDt())
	}
	else
	{
		tv_new_sight = OBJ_SightGet()
	}

	tv_new_banking = v_dest_banking
	tv_new_banking = MATH_VecBlendRotate(OBJ_BankingGet(), tv_new_banking, 4.0 * TIME_GetDt())
	OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)
}

tv_traction -= MATH_FloatMin(MATH_VecDotProduct(tv_traction, OBJ_SightGet()), 0.0) * OBJ_SightGet()
DBG_RenderVector(OBJ_PosGet(), -tv_traction, color_cyan)
DYN_TractionSet(tv_traction)

DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_jaune)

PNJ_EatMe_Modules_Update(0, nobody)

v_head_last_pos = OBJ_PosGet()