#include "PNJ_EatMe_defines.var"

int				ti_i
int				ti_flag_dodge_fire
int				ti_flag_orient
int				ti_flag_in_water

float			tf_coef
float			tf_dist
float			tf_speed
float			tf_target_speed
float			tf_norm
float			tf_rayon
float			tf_Z_max
float			tf_LOD

object		to_collide_object
object		to_bone
object		to_main_actor

vector		tv_new_sight
vector		tv_speed 
vector		tv_traction
vector		tv_pos
vector		tv_hor_sight
vector		tv_ray_start_pos
vector		tv_collide_pos
vector		tv_ray_col_normal

// MAIN ACTOR
if( @get_global i_Player_is_Kong )
	to_main_actor = o_main_actor_Kong
else
	to_main_actor = o_main_actor_Jack


if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux

	if (i_flag_hide)
	{
		i_flag_hide = faux
	
		to_bone = ANI_CanalObjectGet(0)
		@to_bone OBJ_FlagInvisibleSet(faux)
		to_bone = ANI_CanalObjectGet(1)
		@to_bone OBJ_FlagInvisibleSet(faux)
	}

	return
}

if (i_etat_courant != ETAT_Water)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Water
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	
	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_NeverDynamicFather | DYN_C_SlipOnGroundEdge, DYN_C_NeverDynamicHierarchy)
//	DYN_FrictionVectorSet(cvector(2.0, 2.0, 2.0))
	DYN_FrictionVectorSet(Cv_NullVector)
	DYN_GravitySet(Cv_NullVector)
	COL_ColSetActivationSet(none, C_bit_zdm_pied)

	OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)
	OBJ_CapaSet(none, CAPA_Bidoche_Snapped_SeDetacher)

	v_rand_dest_pos = @BV_ZoneTerritoire BV_RandomPosGet(0)

	f_angle_oscillation = 0.0
	f_on_ground_dist = 0.0
	
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
AI_Execute("PNJ_EatMe_exec_check_paf")
if (i_flag_snap)
	macro_change_etat("PNJ_EatMe_ETAT_Snap")
if (i_flag_paf || i_flag_smell_food)
	macro_change_etat("PNJ_EatMe_ETAT_Fall")

// COMPORTEMENT =========================================================
tf_LOD = OBJ_LodVisGet()

if (tf_LOD < Cf_LOD_Visibilite)
{
	if ( ! i_flag_hide )
	{
		i_flag_hide = vrai

		to_bone = ANI_CanalObjectGet(0)
		@to_bone OBJ_FlagInvisibleSet(vrai)
		to_bone = ANI_CanalObjectGet(1)
		@to_bone OBJ_FlagInvisibleSet(vrai)
	}
}
else if (i_flag_hide)
{
	i_flag_hide = faux

	to_bone = ANI_CanalObjectGet(0)
	@to_bone OBJ_FlagInvisibleSet(faux)
	to_bone = ANI_CanalObjectGet(1)
	@to_bone OBJ_FlagInvisibleSet(faux)
}

if (tf_LOD < Cf_LOD_Activation)
{
	if ( ! i_flag_secto )
	{
		i_flag_secto = vrai

		v_secto_speed = DYN_SpeedGetVector()
		v_secto_grav = DYN_GravityVectorGet()
		v_secto_friction = DYN_FrictionVectorGet()
	
		DYN_Off()
	
		OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
	}

	returntrack
}
else if (i_flag_secto)
{
	i_flag_secto = faux

	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_NeverDynamicFather | DYN_C_SlipOnGroundEdge, DYN_C_NeverDynamicHierarchy)
	DYN_FrictionVectorSet(v_secto_friction)
	DYN_GravitySet(v_secto_grav)
	DYN_SpeedSetVector(v_secto_speed)

	OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)
}

tf_Z_max = @BV_ZoneTerritoire OBJ_PosGet().z
tf_Z_max += @BV_ZoneTerritoire BV_MaxGet().z

if (OBJ_PosGet().z <= tf_Z_max)
{
	ti_flag_in_water = vrai

	if (!i_flag_in_water)
	{
		tv_pos = OBJ_PosGet()
		tv_pos.z = tf_Z_max
		PNJ_EatMe_GFX_Ripple(tv_pos)
		i_flag_in_water = vrai
	}	
}
else
{
	ti_flag_in_water = faux

	if (i_flag_in_water)
	{
		tv_pos = OBJ_PosGet()
		tv_pos.z = tf_Z_max
		PNJ_EatMe_GFX_Ripple(tv_pos)
		i_flag_in_water = faux
	}	
}

if ( ti_flag_in_water && ! i_flag_in_jump )
{
	DYN_GravitySet(Cv_NullVector)	

	f_delay_until_last_ground_col = 0.0
	f_delay_until_last_wall_col = 0.0

	tv_pos = OBJ_PosGet()
	tv_pos -= @to_main_actor OBJ_PosGet()
	tv_pos.z = 0.0

	tf_norm = MATH_VecDotProduct(tv_pos, tv_pos)

	if (tf_norm > 0.001 && tf_norm < 9.0 && MATH_VecDotProduct(v_rand_dest_pos - OBJ_PosGet(), -tv_pos) > 0.0)
	{
		f_rand_pos_duration = 0.0
		f_before_jump_duration	= MATH_RandFloat(2.0, 5.0)	
	
		tf_norm = MATH_FloatSqrt(tf_norm)
		tv_pos /= tf_norm
		tv_pos *= MATH_FloatMax(tf_norm, 3.0)
		tv_pos += OBJ_SightGet()
		tv_pos += @to_main_actor OBJ_PosGet()
		tv_pos.z = v_rand_dest_pos.z

		DBG_RenderVector(OBJ_PosGet(), tv_pos - OBJ_PosGet(), color_rouge)

		tv_pos.x = MATH_FloatLimit(tv_pos.x, @BV_ZoneTerritoire OBJ_PosGet().x + @BV_ZoneTerritoire BV_MinGet().x, @BV_ZoneTerritoire OBJ_PosGet().x + @BV_ZoneTerritoire BV_MaxGet().x)
		tv_pos.y = MATH_FloatLimit(tv_pos.y, @BV_ZoneTerritoire OBJ_PosGet().y + @BV_ZoneTerritoire BV_MinGet().y, @BV_ZoneTerritoire OBJ_PosGet().y + @BV_ZoneTerritoire BV_MaxGet().y)
		tv_pos.z =  MATH_FloatLimit(tv_pos.z, @BV_ZoneTerritoire OBJ_PosGet().z + @BV_ZoneTerritoire BV_MinGet().z, @BV_ZoneTerritoire OBJ_PosGet().z + @BV_ZoneTerritoire BV_MaxGet().z)

		DBG_RenderVector(OBJ_PosGet(), tv_pos - OBJ_PosGet(), color_vert)

		tv_new_sight = tv_pos

		tf_target_speed = move_speed * 3.0
		tf_target_speed *= 1.0 + (MATH_Sin(TIME_Get() * 4.0) * 0.25)
	
		f_move_speed = MATH_FloatBlend(f_move_speed, tf_target_speed, 8.0 * TIME_GetDt())	
	}
	else
	{
		f_rand_pos_duration -= MATH_FloatMin(f_rand_pos_duration, TIME_GetDt())
	
		tv_new_sight = v_rand_dest_pos
		tv_new_sight -= OBJ_PosGet()
		tv_new_sight.z = 0.0
	
		if ( ! f_rand_pos_duration || MATH_VecDotProduct(tv_new_sight, tv_new_sight) < 0.25)
		{
			f_rand_pos_duration	= MATH_RandFloat(4.0, 8.0)
			v_rand_dest_pos = @BV_ZoneTerritoire BV_RandomPosGet(0)	
		}
	
		tv_new_sight = v_rand_dest_pos

		tf_target_speed = move_speed
		tf_target_speed *= 1.0 + (MATH_Sin(TIME_Get() * 4.0) * 0.25)
	
		f_move_speed = MATH_FloatBlend(f_move_speed, tf_target_speed, 2.0 * TIME_GetDt())	
	}

	tv_new_sight -= OBJ_PosGet()
	
	tf_norm = MATH_VecNorm(tv_new_sight)
	if (tf_norm > 0.001)
	{
		tv_new_sight /= tf_norm
		
		if (MATH_VecDotProduct(OBJ_SightGet(), tv_new_sight) > 0.0)
			tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 6.0 * TIME_GetDt())
		else
			tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), MATH_FloatSign(MATH_VecDotProduct(tv_new_sight, OBJ_HorizonGet())) * OBJ_HorizonGet(), 6.0 * TIME_GetDt())
	}
	else
	{
		tv_new_sight = OBJ_SightGet()
	}

	tf_speed = MATH_VecDotProduct((OBJ_PosGet() - v_head_last_pos) / TIME_GetDt(), OBJ_SightGet())
	tf_speed = MATH_FloatMax(tf_speed, 0.0)

	f_angle_oscillation += TIME_GetDt() * Cf_Pi // MATH_FloatMin(tf_speed * 0.15, 1.5 * Cf_2Pi)
	while(f_angle_oscillation > Cf_2Pi)
		f_angle_oscillation -= Cf_2Pi

	tf_coef = MATH_Sin(f_angle_oscillation)
	tf_coef *= MATH_FloatMin(tf_speed, 0.25)

	tv_new_sight = MATH_VecRotate(tv_new_sight, OBJ_BankingGet(), tf_coef)

	OBJ_SightGeneralSet(tv_new_sight, Cv_VerticalVector)
	
	if (f_move_speed)
	{
//		f_Z_noise = 0.0

		tv_speed = OBJ_SightGet() * f_move_speed
		DYN_SpeedSetVector(tv_speed)
	}

	f_before_jump_duration -= MATH_FloatMin(f_before_jump_duration, TIME_GetDt())	
	if (!f_before_jump_duration)
	{
		i_flag_in_jump	= vrai
	
//		i_on_ground_modules_nb = 0
//
//		f_delay_until_last_ground_col = Cf_Infinit
//		f_delay_until_last_wall_col = Cf_Infinit
//
//		PNJ_EatMe_Virtual_Net_Init(vrai, nobody)
	
		f_before_jump_duration	= MATH_RandFloat(2.0, 5.0)
	
		tv_pos = OBJ_PosGet()	
		tv_pos += OBJ_SightGet() * MATH_RandFloat(0.5, 1.0)
		
		tv_pos.x = MATH_FloatLimit(tv_pos.x, @BV_ZoneTerritoire OBJ_PosGet().x + @BV_ZoneTerritoire BV_MinGet().x, @BV_ZoneTerritoire OBJ_PosGet().x + @BV_ZoneTerritoire BV_MaxGet().x)
		tv_pos.y = MATH_FloatLimit(tv_pos.y, @BV_ZoneTerritoire OBJ_PosGet().y + @BV_ZoneTerritoire BV_MinGet().y, @BV_ZoneTerritoire OBJ_PosGet().y + @BV_ZoneTerritoire BV_MaxGet().y)
		tv_pos.z = tf_Z_max
			
		DYN_GravitySet(cvector(0.0, 0.0, -5.0))
		DYN_Impulsion(tv_pos, MATH_RandFloat(0.25, 0.5))
	}
}
else
{
	DYN_GravitySet(cvector(0.0, 0.0, -5.0))	

	if (i_flag_in_jump && ti_flag_in_water && DYN_SpeedGetVector().z <= 0.0)
		i_flag_in_jump = faux

//	f_delay_until_last_ground_col = Cf_Infinit
//	f_delay_until_last_wall_col = Cf_Infinit

	f_move_speed = DYN_SpeedGet()

	tf_speed = f_move_speed
	if (tf_speed > 0.001)
	{
		tv_new_sight = DYN_SpeedGetVector()
		tv_new_sight /= tf_speed
		tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 8.0 * TIME_GetDt())
	}
	else
	{
		tv_new_sight = OBJ_SightGet()
	}

	OBJ_SightGeneralSet(tv_new_sight, Cv_VerticalVector)
}

DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_jaune)

PNJ_EatMe_Modules_Update(0, nobody)

v_head_last_pos = OBJ_PosGet()