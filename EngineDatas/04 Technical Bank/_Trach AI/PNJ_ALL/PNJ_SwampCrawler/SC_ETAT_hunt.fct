#include "PNJ_SwampCrawler_defs.var"

vector	move_dir, move_dest, v1, v2
float		dot, factor, dist, zkilfaut
int			vulnerable, berge

//--------( Sortie Etat )--------
if (etat_i_quitte)
{
	etat_i_quitte = faux
	return
}

//--------( Entrée Etat )--------
if ( etat_i_courant != SCETAT_hunt )
{
	etat_i_ancien = etat_i_courant
	etat_i_courant = SCETAT_hunt
	move_f_speed = SCSPEED_Water
			
	//----( quitte état précédent )----
	if ( etat_fct )
	{
		etat_i_quitte = vrai
		AI_Execute( etat_fct )
	}
	etat_fct = AI_TrackCurGet()
	ACT_ActionSet( SCACT_water_swin )

	if (etat_i_ancien == SCETAT_paf)
	{
		move_v_dest = move_v_huntpos
		move_i_fightretreat = 1
	}
	else
	{
		move_i_fightretreat = 0
		move_v_huntpos = OBJ_PosGet()
	}
	move_i_fightlastcharge = 0
	move_v_attackpos = @stimul_o_target OBJ_PosGet()
}

Org_o_StateAttack = stimul_o_target

//--------( la cible n'est plus dans l'eau : repasse en nage )--------
if (!SCfct_IsInWater( @stimul_o_target OBJ_PosGet() ))
{
	v1 = OBJ_PosGet() - @stimul_o_target OBJ_PosGet()
	stimul_o_target = nobody
	move_v_dest = OBJ_PosGet() + (5 * v1 )
	move_f_withouthunt = 2
	macro_change_etat( "SC_ETAT_nage" )
}

//--------( init )--------
vulnerable = 0
zkilfaut = home_f_zmax

//--------( berge en vue )--------
berge = !SCfct_FrontIsWater()
dist = OBJ_SqrDist( stimul_o_target)
	
if ( berge || ( (berge_i_hitcounter >= 1) && ((berge_i_hitcounter < 8) || move_i_ground)) )
{
	if (berge) SCfct_BergeState( compute_v_posgrid )
	v1 = @stimul_o_target OBJ_PosGet() - OBJ_PosGet()
	if (MATH_VecDotProduct(v1,berge_v_axe) < 0)
		berge_v_axe = -berge_v_axe
	move_v_dest = OBJ_PosGet() + (2 * berge_v_axe) + ((berge_i_hitcounter * berge_v_norm) / 2)
	move_v_huntpos = move_v_dest
	move_v_attackpos = @stimul_o_target OBJ_PosGet()
	move_i_fightlastcharge = 0
	berge_i_hitcounter++
}
else 
{
	berge_i_hitcounter = 0
	if ( !move_i_fightretreat )
	{
		if ( move_i_fightlastcharge == 0)
		{
			//--------( fonce vers la cible )--------
			move_v_dest = @stimul_o_target OBJ_PosGet()
			move_v_previousattackpos = move_v_attackpos
			move_v_attackpos = move_v_dest
			
			//--------( fin approche => charge )--------
			if ( dist < 49 )
			{
				ACT_ActionSet( SCACT_water_attack )
				move_v_attackspeed = (move_v_attackpos - move_v_previousattackpos) / TIME_GetDt()
				move_i_fightlastcharge = 1
			}
		}
		else
		{
			move_v_attackpos += move_v_attackspeed * TIME_GetDt()
			move_v_dest = move_v_attackpos 
			v1 = move_v_dest - OBJ_PosGet()
			dist = MATH_VecDotProduct( v1,v1)
					
			move_i_hit = 0
			if (dist > 29)
			{
				zkilfaut += (0.01 * (49 - dist) )
			}
			else
			{
				vulnerable = 1
				zkilfaut += 0.2
				AI_Execute( "SC_exec_hit" )
			}
			if (move_i_hit || (dist  < 4) || ACT_ActionFinished())
			{
				move_v_dest = move_v_huntpos
				move_f_withouthunt = 2
				stimul_o_target = nobody
				macro_change_etat( "SC_ETAT_nage" )
			}
		}
	}
	else
	{
		zkilfaut = home_f_zmin
		//--------( special pour terminer le mode retraite )--------
		v1 = move_v_dest - OBJ_PosGet()
		v1.z = 0
		if (MATH_VecDotProduct(v1,v1) < 4)
		{
			if (dist < 36 )
				move_v_dest += v1
			else
			{
				move_v_huntpos = OBJ_PosGet()
				move_v_attackpos = @stimul_o_target OBJ_PosGet()
				move_i_fightretreat = 0
			}
		}
	}
}

DBG_RenderSphere( move_v_dest, 1, 0xFF00FF00 )

//--------( déplacement )--------
move_i_brakewhennear = 1
if ( move_i_fightretreat )
	move_i_brakewhennear = 0
move_i_groundrec = 0
move_f_destz = zkilfaut
AI_Execute( "SC_exec_move" )

//--------( hors de la bv )--------
if ( !move_i_isinbv )
{
	move_f_outbvtimer += TIME_GetDt()
	if (move_f_outbvtimer > 5)
	{
		move_v_dest = @home_zone_waterZ BV_RandomPosGet(1)
		move_v_dest.z = home_f_zmax
		move_f_withouthunt = 2
		macro_change_etat( "SC_ETAT_nage" )
	}
}
else
	move_f_outbvtimer = 0

//--------( se prend un paf )--------
if ( stimul_i_paf )
{
	if (vulnerable && (stimul_o_pafby == stimul_o_target) )
		macro_takeapaf( SCETATPARAM_PafFightMort )
	else
		macro_takeapaf( SCETATPARAM_PafFightOne )
}


