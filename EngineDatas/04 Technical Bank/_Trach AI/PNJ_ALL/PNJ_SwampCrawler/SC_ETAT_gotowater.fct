#include "PNJ_SwampCrawler_defs.var"

vector	v
object	to_obj

//--------( Sortie Etat )--------
if (etat_i_quitte)
{
	DYN_Off()
	etat_i_quitte = faux
	return
}

//--------( Entrée Etat )--------
if ( etat_i_courant != SCETAT_gotowater )
{
	etat_i_ancien = etat_i_courant
	etat_i_courant = SCETAT_gotowater
			
	//----( quitte état précédent )----
	if ( etat_fct )
	{
		etat_i_quitte = vrai
		AI_Execute( etat_fct )
	}
	etat_fct = AI_TrackCurGet()
	ACT_ActionSet( SCACT_ground_walk )
}

//--------( arrivée ? )--------
compute_i_res = SCfct_GetGridLine( OBJ_PosGet(), -OBJ_SightGet(), 2 )
if ( (compute_i_res == 1) && (compute_ai_grid[0] == Ci_sol_eau) && (compute_ai_grid[1] == Ci_sol_eau) )
{
	//--------( récupère la hauteur de l'eau ? )--------
	to_obj = COL_RayObject_Vector(OBJ_PosGet(), cvector(0,0,4 ), OBJ_C_IdentityFlag_ColMap, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_Crossable)
	if(to_obj)
	{
		home_f_zmax = COL_RayObject_PosGet().z - 0.4
		home_f_zmin = home_f_zmax - home_f_waterdepth
	}
	//--------( première destination + passage état de nage )--------
	move_v_dest = @home_zone_waterZ OBJ_PosGet()
	macro_change_etat( "SC_ETAT_nage" )
}

//--------( déplacement )--------
move_f_destz = OBJ_PosGet().z - 1
move_i_groundrec = 1
AI_Execute( "SC_exec_move" )



