#include "PNJ_SwampCrawler_defs.var"

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//	FONCTIONS TERRITOIRE (Grid, water, berge ... )
//
//		procedure_local int SCfct_GetGridLine( vector pos, vector dir, int nbr )
//		procedure_local int SCfct_FrontIsWater( )
//		procedure_local int SCfct_IsInWater( vector pos )
//		procedure_local void SCfct_BergeState( vector pos_grid )
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//--------( procedure : get content of grid in a line defined by pos, dir and numbre of case )--------
procedure_local int SCfct_GetGridLine( vector pos, vector dir, int nbr )
{
	int 		i_loop, i_res

	dir.z = 0
	i_res = 0
	if (MATH_VecNullEpsilon( dir ))
		return 0
		
	if (MATH_AbsFloat(dir.x) >= MATH_AbsFloat(dir.y) )
		dir /= MATH_AbsFloat( dir.x )
	else
		dir /= MATH_AbsFloat( dir.y )
		
	for (i_loop = 0; i_loop < nbr; i_loop++)
	{
		compute_ai_grid[ i_loop ] = GRID_CapaGet( pos ) & tag_grid_terrain
		compute_av_grid[ i_loop ] = pos
		pos += dir
	}
	return 1
}

//--------( procedure : return 1 if  line in front of perso is only water )--------
procedure_local int SCfct_FrontIsWater( )
{
	int i_loop
	
	if( !SCfct_GetGridLine( OBJ_PosGet(), OBJ_SightGet(), 3 ) )
		return 0
	
	for (i_loop  = 0; i_loop  < 3; i_loop ++)
	{
		if (compute_ai_grid[ i_loop ] != Ci_sol_eau)
			break
	}
	if (i_loop  == 3) return 1
	compute_v_posgrid = GRID_PosGet( compute_av_grid[ i_loop ] )
	return 0
}

//--------( procedure : return 1 if  given case is in water )--------
procedure_local int SCfct_IsInWater( vector pos )
{
	int grid_capa
	grid_capa = GRID_CapaGet( pos ) & tag_grid_terrain
	if (grid_capa == Ci_sol_eau)
		return 1
	return 0
}

//--------( procedure : return 1 if  given case is in water )--------
procedure_local void SCfct_BergeState( vector pos_grid )
{
	int			aai_Grid[3][3]
	int			i_grid, i_loop, j_loop
	vector	dpos, pos, norm

	pos.z = 0
	berge_v_pos = pos_grid
	norm = Cv_NullVector
	berge_i_accessible = 1 
	berge_i_occupee = 0

	for (i_loop = 0; i_loop < 3; i_loop++)
	{
		for (j_loop = 0; j_loop < 3; j_loop++)
		{
			dpos = cvector( (i_loop - 1), (j_loop - 1), 0 )
			pos = pos_grid + dpos
			i_grid = GRID_CapaGet( pos )
			
			if ( (i_grid & tag_grid_terrain) == Ci_sol_eau )
				norm += dpos
			else if ( (i_grid & tag_grid_terrain ) == Ci_sol_mur) 
				berge_i_accessible = 0
			else if ( i_grid & tag_grid_occupe_msk	)
				berge_i_occupee = 1
		}
	}

	if ( !MATH_VecNull( norm ) )
	{
		berge_v_norm = MATH_VecNormalize( norm )
		berge_v_axe = MATH_VecCrossProduct( berge_v_norm, Cv_VerticalVector)
	}
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//	FONCTIONS ORGANIZER 
//
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

//--------( procedure : return 1 if  object already attacked by another SwampCrawler )--------
procedure_local int SCfct_IsTargetted( object o_Target )
{
	int 		i_loop, i_nb
	object	o_SC
	
	i_nb = M_Org SC_Nb
	for ( i_loop =0; i_loop < i_nb; i_loop++)
	{
		o_SC = M_Org SC_Obj[ i_loop ]
		if ( M_SC(o_SC) stimul_o_target == o_Target )
			return 1
	}
	return 0
}

