//#include "PNJ_SwampCrawler_defs.var"
//
//float		tf_val
//vector 	v, w, pos
//
//AI_Execute( "SC_compute_NearestPos" )
//
//recommence:
//
//tf_val = MATH_VecDotProduct( home_link_vector[ compute_i_link], OBJ_SightGet() )
//if (tf_val > 0 )
//{
//	v = MATH_RandFloat(0.5, 1) * home_link_vector[ compute_i_link]
//	w = home_link_vector[ MATH_Modulo( compute_i_link+ 1, home_net_nb) ]
//}
//else
//{
//	v = -MATH_RandFloat( 0.5, 1) * home_link_vector[ compute_i_link]
//	w = -home_link_vector[ MATH_Modulo( compute_i_link+ home_net_nb - 1, home_net_nb) ]
//}
//
//w = -home_link_norm[ compute_i_link ]
//
//pos = (OBJ_PosGet() + v) + (MATH_RandFloat(0, 0.5) * w)
//macro_compute_intersection( OBJ_PosGet(), pos )
//
//if (compute_i_res && (compute_f_distcarre < 10) )
//{
//	pos = (OBJ_PosGet() + v) - (MATH_RandFloat(0, 0.5) * w)
//	macro_compute_intersection( OBJ_PosGet(), pos )
//	if (compute_i_res && (compute_f_distcarre < 10) )
//		pos = OBJ_PosGet() + (MATH_RandFloat(0, 0.5) * w)
//}
//
//compute_v_pos = pos
//