#include "PNJ_SwampCrawler_defs.var"

vector 	pos
float		zref

//--------( Sortie Etat )--------
if (etat_i_quitte)
{
	etat_i_quitte = faux
	return
}

//--------( Entrée Etat )--------
if ( etat_i_courant != SCETAT_mort )
{
	etat_i_ancien = etat_i_courant
	etat_i_courant = SCETAT_mort
	etat_i_param = 0
	
	//----( quitte état précédent )----
	if ( etat_fct )
	{
		etat_i_quitte = vrai
		AI_Execute( etat_fct )
	}
	etat_fct = AI_TrackCurGet()
	
	ACT_ActionSet( SCACT_paf_mort )
	
	move_zoffvalue = 3 * Cf_Pi
	COL_ColSetActivationSet(0, C_bit_zdm_pied)
}

pos = OBJ_PosGet()
zref = home_f_zmax - 0.2
// param == 0 : on rejoint la surface de l'eau
if (etat_i_param == 0)
{
	if (pos.z < zref)
		pos.z += 0.1 * TIME_GetDt()
	else
		etat_i_param = 1
}
// param == 1 : oscillation
if (etat_i_param == 1)
{
	move_zoffvalue += 3 * TIME_GetDt()
	if (move_zoffvalue > (4 * Cf_2Pi) - (3 * Cf_PiBy4) )
		etat_i_param = 2
	else
	{
		pos.z = zref + ((MATH_Sin(move_zoffvalue ) * 1) / move_zoffvalue)
		move_f_speed = (pos.z - OBJ_PosGet().z) / TIME_GetDt()
	}
}
// param == 2 : on s'enfonce + destruction
if (etat_i_param == 2)
{
	pos.z += move_f_speed * TIME_GetDt()
	move_f_speed -= 0.05 * TIME_GetDt()
	if (pos.z < home_f_zmin - 4 )
	{
		OBJ_Destroy()
		if ( SF_i_NePasRejouerSiMort )
			Super_SpecialFlag_set( SF_i_AlreadyDead)
	}
}

OBJ_PosSet(pos)



