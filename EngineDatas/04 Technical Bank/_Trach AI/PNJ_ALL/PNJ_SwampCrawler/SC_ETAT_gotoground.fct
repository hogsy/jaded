//#include "PNJ_SwampCrawler_defs.var"
//
//vector	v
//
//
////--------( Sortie Etat )--------
//if (etat_i_quitte)
//{
//	etat_i_quitte = faux
//	return
//}
//
////--------( Entrée Etat )--------
//if ( etat_i_courant != SCETAT_gotoground )
//{
//	etat_i_ancien = etat_i_courant
//	etat_i_courant = SCETAT_gotoground 
//	etat_i_param = 0	
//	move_f_speed = 2
//	
//	//----( Dynamique )----
//	DYN_On()
//	DYN_FlagsSet(DYN_C_GlobalFriction + DYN_C_BasicForces + DYN_C_VectorFriction + DYN_C_NeverDynamicFather, none)
//	DYN_FrictionVectorSet(cvector(3, 3, 0))
//	DYN_GravitySet(Cv_NormalGravity)
//	
//	//----( quitte état précédent )----
//	if ( etat_fct )
//	{
//		etat_i_quitte = vrai
//		AI_Execute( etat_fct )
//	}
//	etat_fct = AI_TrackCurGet()
//	ACT_ActionSet( SCACT_ground_walk )
//}
//
//v = OBJ_SightGet()
//
////--------( param = 0 : croco marche jusqu'à etre au sec )--------
//if ( etat_i_param == 0)
//{
//	//--------( orient )--------
//	OBJ_SightSet( MATH_VecBlendRotate( OBJ_SightGet(), -berge_v_norm, 0.1) )
//	
//	//--------( move )--------
//	OBJ_PosSet( OBJ_PosGet() + (v * (TIME_GetDt() * move_f_speed)) )
//
//	//--------( test arrivée sur le sol )--------
//	compute_i_res = SCfct_GetGridLine( OBJ_PosGet(), -v, 2 )
//	if ( (compute_i_res == 1) && (compute_ai_grid[0] != Ci_sol_eau) && (compute_ai_grid[1] != Ci_sol_eau)  )
//	{
//		if ( MATH_VecNull( berge_v_norm ) )
//			compute_v_dir = -v
//		else
//			compute_v_dir = MATH_VecNormalize( berge_v_norm )
//		etat_i_param = 1
//		ACT_ActionSet( SCACT_ground_wait )
//	}
//}
////--------( param != 0 : croco a l'arret fait demi tour pour etre face à l'eau )--------
//else
//{
//	v.z = 0
//	v = MATH_VecNormalize( v )
//	if( MATH_VecDotProduct( v, compute_v_dir) > 0.90)
//		macro_change_etat( "SC_ETAT_ground" )
//	OBJ_SightSet( MATH_VecBlendRotate( v, compute_v_dir, 0.3) )
//}
//
////--------( recalage sur le sol )--------
//AI_Execute( "SC_exec_groundrec" )
//
//