Include_UltraProcedure_Header
#include "BC_defines.var"

// FIRE ================================================
procedure_local void BC_Fill_Fire_Array()
{
	int					ti_i
	int					ti_rank
	messageid		tmid_fire
	
	if (@get_global  i_fire_flag_already_checked)
	{
		i_fire_gao_nb = @get_global i_fire_gao_nb
		for (ti_i = 0; ti_i < i_fire_gao_nb; ti_i++)
			ao_fire_gao[ti_i] = @get_global ao_fire_gao[ti_i]
	}
	else
	{
		@get_global i_fire_flag_already_checked = vrai	
		@get_global i_fire_gao_nb = 0
		i_fire_gao_nb = 0
		ti_rank = -1
		for (tmid_fire = MSG_GlobalScan(C_EVENT_TYPE_Fire, &ti_rank); 
			MSG_GlobalIsValid(tmid_fire); 
			tmid_fire = MSG_GlobalScan(C_EVENT_TYPE_Fire, &ti_rank))
		{
			ao_fire_gao[i_fire_gao_nb] = EVENT_PereGet(tmid_fire)
			@get_global ao_fire_gao[i_fire_gao_nb] = ao_fire_gao[i_fire_gao_nb]

			i_fire_gao_nb++
			@get_global i_fire_gao_nb = i_fire_gao_nb
		}
	}
}
procedure_local int BC_Pos_Is_Near_Fire(vector tv_pos)
{
	int		ti_k
	vector	tv_temp
	object	to_bone_jack
	if( i_modele == Ci_MODELE_Bat_Noire )
		return faux		// pas peur du feu
	to_bone_jack = @o_jack ANI_CanalObjectGet(Anim_Canal_Annex1)
	for (ti_k = 0; ti_k < i_fire_gao_nb; ti_k++)
	{
		if( ! to_bone_jack || ao_fire_gao[ti_k] != to_bone_jack )		// ne pas avoir peur de Jack qui a une lance enflammée
		{
			tv_temp = tv_pos - @ao_fire_gao[ti_k] OBJ_PosGet()
			if( MATH_VecNorm(tv_temp) < Cf_fire_danger_dist)
				return vrai
		}
	}
	return faux
}
procedure_local int BC_Gao_Is_Near_Fire(object to_obj)
{
	return BC_Pos_Is_Near_Fire(@to_obj OBJ_PosGet() )
}
// FIRE ================================================


// TRACE =========================================================================
procedure_local void BC_DBG_Trace_Etat_Gao(string str_txt, object to_gao)
{
	if( i_DBG_trace_etat )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : ")
		DBG_TraceString(str_txt)
		if( to_gao )
			DBG_TraceObject(to_gao)
		DBG_TraceEOL()
	}
}

procedure_local void BC_DBG_Trace_Etat(string str_txt)
{
	BC_DBG_Trace_Etat_Gao(str_txt, nobody)
}

procedure_local void BC_DBG_Trace_Etat_Paf(string str_txt)
{
	if( i_DBG_trace_etat_paf )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : ")
		DBG_TraceString(str_txt)
		DBG_TraceEOL()
	}
}

// Teste la BV et la blind zone ET DES CACHES
procedure_local int BC_Pos_in_Territory(vector pv_pos, int ti_check_fire)
{
	int		ti_type_sol
	int		ti_return
	
	ti_return = vrai
	
	if( o_blind_zone && @o_blind_zone COL_BV_PointCollide(pv_pos) )
		ti_return = faux		// dans la blind zone
	
	if( o_zone_activite && ! @o_zone_activite COL_BV_PointCollide(pv_pos) )
		ti_return = faux		// pas dans la limite
	
	GRID_CurrentSet(1)
	ti_type_sol = GRID_CapaGet(pv_pos)
	
	// Test Feu
	if( @get_global i_nbr_de_feux_en_cours && (ti_type_sol & Ci_Grid2_EnFeu) )
		ti_return = faux		// en train de brûler
	
	// Test Cache
	ti_type_sol &= tag_grid_terrain
	if( ti_type_sol == Ci_sol_cache_bats )
		ti_return = faux		// dans une cache
	GRID_CurrentSet(0)
	
	if( ti_check_fire && BC_Pos_Is_Near_Fire(pv_pos) )
		ti_return = faux		// trop proche d'un feu
	
	return ti_return
}

// Teste la BV et la blind zone
procedure_local int BC_Gao_in_Territory(object to_gao, int ti_check_fire)
{
	if( ! to_gao )
		return faux
	else
		return BC_Pos_in_Territory(@to_gao OBJ_PosGet(), ti_check_fire)
}


//==============================================================================================
// Retourne vrai si le vecteur de position situé est dans la BV de l'objet OU s'il n'y a pas d'objet à tester ; faux sinon
//==============================================================================================
procedure_local int BC_Pos_in_BV(vector pv_pos, object po_zone) 
{
	if( ! po_zone )
		return vrai
	else
		return( @po_zone COL_BV_PointCollide(pv_pos) )
}

//==============================================================================================
// Retourne vrai si la position pv_pos est dans la BV de l'objet po_zone
//==============================================================================================
procedure_local int BC_Gao_in_BV(object po_gao, object po_zone) 
{
	return BC_Pos_in_BV(@po_gao OBJ_PosGet(), po_zone)
}


// BOSS ==========================================================================
procedure_local int BC_Boss()
{
	if( i_config_boss == Ci_config_boss_Boss )
		return vrai
	else
		return faux
}

procedure_local int BC_Lieutenant()
{
	if( i_config_boss == Ci_config_boss_Lieutenant )
		return vrai
	else
		return faux
}

procedure_local int BC_Follower()
{
	if( i_config_boss == Ci_config_boss_Follower )
		return vrai
	else
		return faux
}

procedure_local void BC_Lieutenant_Add()
{	
	if( BC_Lieutenant() )
		@get_global i_bat_noire_lieutenant_nb++
}

procedure_local void BC_Lieutenant_Del()
{
	if( BC_Lieutenant() )
	{
		@get_global i_bat_noire_lieutenant_nb--
		i_config_boss = Ci_config_boss_default
	}
}

procedure_local void BC_Boss_Attack_Init()
{
	int				ti_rand
	if( o_attaque_finale_decor && f_HP == Cf_Life_Big_Bat_Last_Attack )
	{
		ti_rand = 1	// 03B dernière attaque : toujours le 2è wp
	}
	else
	{
		ti_rand = i_boss_last_wp_index
		while( ti_rand == i_boss_last_wp_index )
		{
			ti_rand = MATH_RandInt(0, Ci_boss_attack_wp_nb)
		}
	}
	i_boss_last_wp_index = ti_rand
	o_boss_attack_wp = ao_boss_attack_wp[i_boss_last_wp_index]
	o_boss_retreat_wp = ao_boss_retreat_wp[i_boss_last_wp_index]
	i_boss_attack_init = vrai
	f_rotation_angle_courant = 0.0		// pas de 1/2 tour super rapide !!!
}

procedure_local void BC_Boss_Attack_Compute_Pos()
{
	switch( i_etat_courant )
	{
		case ETAT_Fight_Network :
			if( i_boss_attack_init )
			{
				i_boss_attack_init = faux
				// en atente : va vers le point du début de l'attaque
				o_cible_depl = o_boss_attack_wp
				v_dest_pos = @o_cible_depl OBJ_PosGet()
				v_dest_sight = @o_cible_depl OBJ_SightGet()
				v_cible_pos = v_dest_pos
				@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
		 		@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
			}
			else
			{
				// wp attaque atteint : plonge vers la cible
				o_cible_depl = o_cible_attaque
				v_dest_pos = @o_cible_depl OBJ_PosGet() + cvector(0,0,1.5)
				v_dest_sight = @o_cible_depl OBJ_PosGet() - OBJ_PosGet()
				v_cible_pos = v_dest_pos
				@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
				@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
			}
			break
		
		case ETAT_Fight_Wait_Begin :
			// wp attaque atteint : plonge vers la cible
			o_cible_depl = o_cible_attaque
			v_dest_pos = @o_cible_depl OBJ_PosGet() + cvector(0,0,1.5)
			v_dest_sight = @o_cible_depl OBJ_PosGet() - OBJ_PosGet()
			v_cible_pos = v_dest_pos
			@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
			@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
			break
		
		case ETAT_Fight_Approche :
		case ETAT_Fight_Pause :
			// cible paffée ou ratée : je vais vers le wp de retraite
			o_cible_depl = o_boss_retreat_wp
			v_dest_pos = @o_cible_depl OBJ_PosGet()
			v_dest_sight = @o_cible_depl OBJ_SightGet()
			v_cible_pos = v_dest_pos
			@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
	 		@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
	 		break	
			
		case ETAT_Fight_Remonte :
			// point de retraite atteint : fin de l'attaque
			break
	}
	o_next_wp = o_tmp_obj_next
}
// BOSS ==========================================================================


// Retourne vrai si l'état demandé est un état ciné, faux sinon.
procedure_local int BC_IsEtatCine(int ti_etat)
{
	switch(ti_etat)
	{
		case ETAT_CINE_Attaque :
		case ETAT_CINE_Vala :
		case ETAT_CINE_Wait :
		case ETAT_CINE_Wait_Default :
		case ETAT_CINE_Force_Etat :
		case ETAT_CINE_temp :
			return(vrai)
		default:
			if( i_flag_cine )
				return(vrai)
			else
				return(faux)
	}
}


// Retourne vrai si la bat est dans un état Ciné, faux sinon
procedure_ultra int BC_IsEtatCourantCine()
{
	return BC_IsEtatCine(i_etat_courant)
}


// Retourne vrai si la bat doit se positionner pour attaquer Jack de face
procedure_local int BC_AttackHorsChampSurJackPositionnement()
{
	if( f_fps_contourne_duration > 4.0 )
		return faux		// 4.0 sec que je lui tourne autour = tant pis pour lui !!!!

//	return vrai
	
	if( o_cible_attaque == o_jack && f_on_screen_pourcent < 0.25 ) 
		return vrai
	else
		return faux
}

//procedure_local void BC_GetFriendlyAttackPosition(vector tv_pos_init, object to_gao_sight, byref vector tv_pos)
//{
//	vector	tv_temp
//	
//	tv_temp = @to_gao_sight OBJ_SightGet()
//	tv_temp.z = 0.0
//	if( ! MATH_VecNullEpsilon(tv_temp) )
//		MATH_VecSetNormalize(tv_temp)
//	else
//		tv_temp = @to_gao_sight OBJ_SightGet()
//	
//	switch( i_etat_courant )
//	{
//		case ETAT_Fight_Approche :
//			tv_pos = tv_pos_init + ( 3.0 * tv_temp )
//			break
//			
//		case ETAT_Fight_Contact :
//			tv_pos = tv_pos_init + ( 3.0 * tv_temp )
//			break
//			
//		default:
//			break
//	}
//}

procedure_local int BC_ForceInactive()
{
	return faux
}

//==================================================================
// Pour savoir si on a droit à l'optimisation "wp franchi en testant mon rayon de col molle"
//==================================================================
procedure_local int BC_ReseauSoftColRayonOptimEnabled(int ti_etat)
{
	switch( ti_etat )
	{
		case ETAT_Move_Ronde :
		case ETAT_Move_Network :
		case ETAT_Move_Cadavre :
			if( i_perchee_retour_flag )
			{
//				return faux		// pas d'approximation pour retourner se percher : on retourne exactement à l'endroit duquel on vient
				if( i_perchee_retour_post_rezo_flag )
					return faux		// pas d'approximation pour la phase d'accrochage
				else
					return vrai	
			}
			else
				return vrai		// sinon je considère que j'attend le wp dès que mon rayon de col molle le touche
		case ETAT_Fight_Network :
			if( i_reseau_wp_count > 1 )
				return vrai
			else
				return faux		// je n'autorise pas l'optimisation lorsque je vais au point d'attaque, sinon je vais être mal orienté
		default:
			// dans les autres états je veux atteindre le point spécfiié
			return faux
	}
}


//===========================================================
// Retourne vrai si l'état spécifié est un état d'attaque, faux sinon
//===========================================================
procedure_local int BC_IsEtatAttaque(int ti_etat)
{
	switch( ti_etat )
	{
		case ETAT_Fight_Approche :
		case ETAT_Fight_Contact :
		case ETAT_Fight_Network :
		case ETAT_Fight_Pause :
		case ETAT_Fight_Wait_Begin :
		case ETAT_Fight_Wait_Prio :
		case ETAT_Fight_Remonte :
			return vrai
		default: 
			return faux
	}
}


//===============================================================================================
// FACES DE MORT
//===============================================================================================
procedure_local int BC_Face_De_Mort()
{
	object	to_killzone
	
	if (COL_GMatReportGet(Gmat_KK_Face_de_mort) != -1)
		return vrai
	
	switch( i_modele )
	{
		case Ci_MODELE_Bat_Rouge :
		case Ci_MODELE_Bat_Mini :
			to_killzone = @get_global o_BatsKillZone
			if( to_killzone && @to_killzone COL_BV_PointCollide(OBJ_PosGet()) )
				return vrai
			break
	}
	return faux
}


//==================================================================================================
// RETOURNE VRAI SI LA BAT EST AU SOL
//==================================================================================================
procedure_local int BC_est_au_sol()
{
	switch( i_etat_courant )
	{
		case ETAT_Mange :
		case ETAT_Paf_Sol :
		case ETAT_Paf_Ecrase :
		case ETAT_Agonie :
		case ETAT_Mort :
		case ETAT_Paf_Explose :		// la bat n'émet plus de son
		case ETAT_Fade :				// la bat n'émet plus de son
			return vrai
			break
		
		case ETAT_Brule :
			switch( ACT_ActionGet() )
			{
				case ACTION_Paf_Air_Moyen :
				case ACTION_Vol_Vrille :
					return faux
					break
				default:
					return vrai
					break
			}
			break
			
		case ETAT_Move_Atterrit :
			if( ACT_ActionGet() == ACTION_Mange_Attente )
				return vrai
			else
				return faux
			break
			
		case ETAT_Chute_wp :
		default:
			return faux
			break
	}
}


//==============================================================================================
// Test bat dans l'écran ou hors-champ
//==============================================================================================
//procedure int BC_IsHorsChampCamera()
//{
//	int			ti_hors_champ
//	vector	tv_2D_pos
//	
//	ti_hors_champ = vrai
//
//	tv_2D_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())
//	if( ( tv_2D_pos.x >= 0.0 ) && ( tv_2D_pos.x <= 1.0 ) && ( tv_2D_pos.y >= 0.0 ) && ( tv_2D_pos.y <= 1.0 ) )
//	{
//		// projection 2D de la bat dans le champ de la caméra, mais elle peut etre devant ou derrière la caméra...
//		if( MATH_VecDotProduct(OBJ_PosGet() - @get_camera OBJ_PosGet(), @get_camera OBJ_SightGet()) >= 0 )
//			ti_hors_champ = faux			// bat devant la caméra
//	}
//	
//	return ti_hors_champ
//}

//==============================================================================================
// Test bat dans l'écran ou hors-champ
//==============================================================================================
procedure_local int BC_IsHorsChampCamera()
{
	if( f_on_screen_pourcent < 0.15 ) 
		return vrai
	else
		return faux
}

//==============================================================================================
// Calcule un vecteur de décalage
//==============================================================================================
procedure vector BC_decalage(vector pv_axe_decal,  float pf_decal_horiz, float pf_decal_vert)
{
	vector tv_temp
	
	tv_temp = pv_axe_decal
	tv_temp.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_temp) )
		MATH_VecSetNormalize(tv_temp)
	tv_temp *= pf_decal_horiz
	tv_temp.z = pf_decal_vert
	tv_temp *= OBJ_ZoomGet()
	return	 tv_temp
}

procedure_local void BC_Calc_Pos_Cadavre()
{
	v_cible_pos = @o_cadavre OBJ_PosGet()
	v_dest_sight = v_cible_pos - OBJ_PosGet()
	v_decalage = BC_decalage( - v_dest_sight, Cf_atterrissage_decal_H, Cf_atterrissage_decal_Z)
	v_dest_pos = v_cible_pos + v_decalage	
	DBG_RenderVector(v_cible_pos, v_dest_pos - v_cible_pos, color_bleu)
}


procedure_local void BC_Calc_Pos_Cadavre_Update()
{
	BC_Calc_Pos_Cadavre()
	// next wp
	@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
	@o_tmp_obj_next OBJ_BankingGeneralSet(v_cible_pos - v_dest_pos, Cv_VerticalVector)
	o_next_wp = o_tmp_obj_next
	o_cible_depl = o_tmp_obj_next
}


//==============================================================================================
// Teste s'il y a besoin de contourner un obstacle, retourne le nouvel axe de déplacement
//==============================================================================================
//procedure vector BC_contourne_obstacle(vector proc_axe_depl, byref int pi_contourne_droite)
//{
//	vector		tv_temp								// cross prod avec la normale d'un mur ( = le mur)
//	
//	int				ti_tab_wall[Ci_max_wall]		// tableau des murs en collision
//	int 			ti_nbr									// nombre de murs en collision
//	int				ti_i									// compteur
//	
//	vector		tv_norm_wall						// normale d'un mur de collision
//	
//	vector		tv_ref									// direction de référence calculée à partir du 1er mur de collision (pour tester si on est coincé dans un angle)
//	
//	// aff du nombre de collisions avec des murs
//	// Str_DisplayIntOnce( COL_ReportsNumberGet(COL_C_Wall) , cvector(0,0,0) )
//	
//	if( COL_CollideType( COL_C_Wall )  )
//	{
//		// s'il y a une collision avec (au moins) 1 mur
//		
//		// récup des index des murs en collision
//		ti_nbr = COL_ReportsNumberAndRanksGet( &ti_tab_wall[0], Ci_max_wall, COL_C_Wall )
//		
//		if( ti_nbr == 0 )
//			// aucune collision
//			return proc_axe_depl
//		
//		ti_i = 0
//		while ( ti_i < ti_nbr )
//		{
//			tv_norm_wall = COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[ti_i])
//			
//			if( ( MATH_VecDotProduct( proc_axe_depl, tv_norm_wall ) >= 0) || ( COL_ReportFlagGet(COL_C_ReportIndex + ti_tab_wall[ti_i] ) & COL_C_Edge ) )
//			{
//				// suppression des normales des murs "pas vraiment" en collision et des arrêtes
//				ti_tab_wall[ti_i] = ti_tab_wall[ti_nbr-1]
//				ti_nbr--
//			}
//			ti_i++
//		}
//		
//		if( ti_nbr == 0 ) 
//			// pas de véritable collision
//			return proc_axe_depl
//		
//	 	ti_i = 0
//		while ( ti_i < ti_nbr )
//		{
//		 	// Calcul nouvelle direction déplacement
//			tv_temp = MATH_VecCrossProduct( COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[ti_i] ), Cv_VerticalVector )
//			
//			// Test sens du mur à suivre (test optimisation déplacement)
//			if( MATH_VecDotProduct( MATH_VecNormalize( tv_temp ), MATH_VecNormalize(proc_axe_depl) ) <= 0 || pi_contourne_droite )
//				// Décalage pour ne jamais obtenir un vecteur de déplacement colinéaire au côté du mur
//				tv_temp = MATH_VecBlendRotate( - tv_temp, proc_axe_depl, Cf_decalage_wall )
//			else
//				// Décalage pour ne jamais obtenir un vecteur de déplacement colinéaire au côté du mur
//				tv_temp = MATH_VecBlendRotate( tv_temp, proc_axe_depl, Cf_decalage_wall )
//			
//			if( ti_i == 0 )
//			{
//				// 1er calcul : référence pour les autres
//				tv_ref = tv_temp
//				if( pi_contourne_droite )
//					break
//			}
//			else
//			{
//				// 2nd (ou + ) mur : test de bloquage
//				if( MATH_VecDotProduct( tv_ref, tv_temp ) < 0 )
//				{
//					// si j'ai 2 directions calculées qui s'opposent => bloquage
//					pi_contourne_droite = vrai
//					
//					// calcul de tv_ref : on fixe la direction à suivre en cas de bloquage
//					tv_temp = MATH_VecCrossProduct( COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[0] ), Cv_VerticalVector )
//					tv_ref  = MATH_VecBlendRotate( - tv_temp, proc_axe_depl, Cf_decalage_wall )
//					break
//				}
//			}
//			ti_i++
//		}
//		
//		if( ( ! pi_contourne_droite ) && MATH_VecDotProduct( MATH_VecNormalize(proc_axe_depl), MATH_VecNormalize(tv_temp) ) < 0.2 )
//			// le GAO repart avec un angle presque droit : on impose la direction pour éviter des zig-zag
//			pi_contourne_droite = vrai
//		
//		// Déplacement
//		if( pi_contourne_droite )
//			// on va dans la direction imposée
//			return tv_ref
//		else
//			// les normales des murs sont dans le même sens : on suit n'importe quelle direction calculée (en fait la dernière calculée)
//			return tv_temp
//	}
//	else 
//	{
//		// pas de collision
//		
//		if( pi_contourne_droite )
//			// le GAO est décoincé
//			pi_contourne_droite = faux
//		
//		return proc_axe_depl
//	}
//}


//=============================================================================================
// Inflige les points de dégats spécifiés à la bat, et si ce n'est pas suffisant pour passer dans l'état de santé spécifié, 
// force les points de vie pour passer dans cet état.
//=============================================================================================
procedure_local void BC_Degats(float tf_degats, float tf_paf_coef )
{
	float		tf_HP_init
	tf_HP_init = f_HP
	f_HP = MATH_FloatMax(0.0, f_HP - tf_degats)
	if( f_HP > f_HP_max * tf_paf_coef )
		f_HP = f_HP_max * tf_paf_coef	// les dégats étaient insuffisants pour passer dans l'état de santé demandé -> on force l'état de santé
	if( BC_Boss() && tf_HP_init > Cf_Life_Big_Bat_Last_Attack )		// strictement supérieur !!! (1 seule fois)
		f_HP = MATH_FloatMax(f_HP, Cf_Life_Big_Bat_Last_Attack)
}


//=============================================================================================
// Retourne vrai si l'objet spécifié est dans la BV d'un des nids de la bat
//=============================================================================================
procedure_local int BC_est_dans_nid( object to_object )
{
	int			pi_found
	int			ti_i

	pi_found = faux
	for( ti_i = 0; ti_i < i_tab_wp_pause_count; ti_i++)
	{
		if( BC_Pos_in_BV(@to_object OBJ_PosGet(), ao_tab_wp_pause[ti_i]) )
		{
			pi_found = vrai
			break
		}
	}
	return pi_found
}

procedure_local int BC_mort_sur_sol_correct()
{
	return vrai
}

//=============================================================================================
// Retourne vrai si la bat est tombée sur un sol correct
//=============================================================================================
//procedure_local int BC_mort_sur_sol_correct_OLDFUNC()
//{
//	int			ti_sol_ok
//	int			ti_type_sol
//	vector	tv_normale
//
//	// test du type de sol
//	ti_type_sol = GRID_CapaGet(OBJ_PosGet())
//	ti_type_sol &= tag_grid_terrain
//	
////	if( ti_type_sol == Ci_sol_eau )
////		OBJ_Destroy()			// TMP !!!!!!!!!!!!!!!
//		
//	return vrai 		// TEMP !!!!!! : on désactive cette fonction car si on passe là c qu'il n'y a pas de wp de chute, donc que la map n'est pas prévue pour la foodchain, donc on se fout de ou la bat tombe (BERTRAND)
//	
//	ti_sol_ok = vrai
//	
//	if( ti_type_sol == Ci_sol_mur )
//		ti_sol_ok = faux
//	
//	// dans la bv d'un nid
//	if( ti_sol_ok && BC_est_dans_nid(OBJ_Me()) )
//		ti_sol_ok = faux
//	
//	if( ! ti_sol_ok )
//	{
//		// sol pas ok => rebond
//		i_ecrase_rebond = vrai
//		
//		AI_Execute("BC_exec_dyn_on")
//		
//		tv_normale = COL_NormalGet(COL_C_Ground)
//		tv_normale.z = 0.0
//		if( ! MATH_VecNullEpsilon(tv_normale) )
//			MATH_VecSetNormalize(tv_normale)
//		else
//			tv_normale = Cv_VerticalVector
//		tv_normale = MATH_VecBlendRotate(tv_normale, Cv_VerticalVector, 0.5)
//		tv_normale *= 5.0
//		DBG_RenderVector(OBJ_PosGet(), tv_normale, color_rouge)
//		DYN_SpeedSetVector(tv_normale * 2.0)
//	}
//	
//	return ti_sol_ok
//}

//============================================================================
// Retourne vrai si la bat touche un sol (objet sans IA), faux sinon
//============================================================================
procedure_local int BC_Collide_Ground()
{
	int			ti_i
	int			ti_collision_nb
	int			ti_collision_report_ID[50]
	int			ti_index
	int			ti_valid_collision_nb
	object	to_collide_object
	
	return COL_CollideType(COL_C_Ground)

//	ti_valid_collision_nb = 0
//	ti_collision_nb = COL_ReportsNumberAndRanksGet(&ti_collision_report_ID[0], 50, COL_C_Ground)
//	for (ti_i = 0; ti_i < ti_collision_nb; ti_i++)
//	{
//		to_collide_object = COL_ObjectGet(COL_C_ReportIndex + ti_collision_report_ID[ti_i])
//		if( to_collide_object && @to_collide_object OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) )
//			continue
//		ti_valid_collision_nb++
//	}
//	
//	if( ti_valid_collision_nb )
//		return vrai
//	else
//		return faux
}



//==================================================================================
// Retourne vrai si la bat a trouvé une odeur de sand intéressante
//==================================================================================
//procedure_local int BC_Check_Sang()
//{
//	if( f_HP && TIME_Elapsed(f_time_check_charogne, Cf_freq_check_sang) )
//	{
//		f_time_check_charogne = TIME_Get()
//		AI_Execute("BC_exec_check_sang")
//		if( MSG_GlobalIsValid(mid_sang) )
//			return vrai
//		else
//			return faux
//	}
//	return faux
//}


//=================================================================================================
// Retourne le nb de messages d'intérêt correspondant existants
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// po_actor : gao pour le filtre (def : nobody)
// pi_status : status recherché (def : -1)
// pi_meme_IA : vrai pour indiquer qu'on recherche un interet dont le pere a la même IA que moi (def : faux)
//=================================================================================================
procedure_local int BC_Get_Interet_Status_Model_Nb(object po_actor, int pi_status, int pi_meme_IA)
{
	int					ti_rank
	message		tm_filter
	messageid		tmid_interet_ID
	object			to_pere
	int					ti_cpt
	
	ti_cpt = 0
	ti_rank = -1
	MSG_SetNull(tm_filter)
	
	if( pi_meme_IA )
		tm_filter.msg_int3 = C_ID_BatCharognard
	
	if( po_actor )
		tm_filter.msg_gao1 = po_actor
	
	for (	tmid_interet_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tm_filter);
			MSG_GlobalIsValid(tmid_interet_ID);
			tmid_interet_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tm_filter) )
		{
			to_pere = EVENT_PereGet(tmid_interet_ID)
			if( to_pere != OBJ_Me() )
			{
				if( pi_status == -1 || EVENT_InteretStatusGet(tmid_interet_ID) == pi_status )
				{
					// compteur
					if( pi_meme_IA )
						ti_cpt+= @to_pere BC_Interet_Slots_Nb_Get()
					else
						ti_cpt++
				}
			}
		}
	return ti_cpt
}



//=================================================================================================
// Retourne le nb de messages d'intérêt correspondant existants
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// po_actor : gao pour lequel on cherche s'il est la cible d'un message
// pi_modele : modele de la bat à tester
//=================================================================================================
procedure_local int BC_Gao_Has_Interet_From_Bat_Model(object po_actor, int pi_modele)
{
	int					ti_rank
	message		tm_filter
	messageid		tmid_interet_ID
	object			to_pere
	
	ti_rank = -1
	MSG_SetNull(tm_filter)
	
	// messages des bats
	tm_filter.msg_int3 = C_ID_BatCharognard
	
	// sur mon acteur
	tm_filter.msg_gao1 = po_actor
	
	for (	tmid_interet_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tm_filter);
			MSG_GlobalIsValid(tmid_interet_ID);
			tmid_interet_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tm_filter) )
		{
			to_pere = EVENT_PereGet(tmid_interet_ID)
			if( to_pere != OBJ_Me() )
			{
				if( @to_pere BC_Modele_Get() == pi_modele )
					return vrai
			}
		}
	return faux
}


//===================================================================================
// Création / Mise à jour d'un intérêt
//===================================================================================
procedure_local void BC_Interet_Update(byref messageid pmid_interet, int pi_status, object po_interet_target, messageid pmid_vision)
{
	float		tf_interet
	vector	tv_pos
	float		tf_duree
	
	if( ! po_interet_target )
		return
	
	tf_duree = 1.0
	
	// Test event vision
//	if( MSG_GlobalIsValid(pmid_vision))
//	{
//		tf_interet = EVENT_VisionInteretGet(pmid_vision)
//		tv_pos = EVENT_PositionGet(pmid_vision)
//	}
//	else
	{
		tf_interet = 100.0
		tv_pos = @po_interet_target OBJ_PosGet()
	}
	
	// Test event intérêt
	if( ! MSG_GlobalIsValid(pmid_interet) )
	{
		pmid_interet = EVENT_AddEventInteret(OBJ_Me(), tf_duree, tf_interet, tv_pos, po_interet_target)
		EVENT_InteretVisionIDSet(pmid_interet, C_ID_BatCharognard)
	}
	else
	{
		EVENT_LifeSet(pmid_interet, tf_duree)
		EVENT_InteretTargetSet(pmid_interet, po_interet_target)
		EVENT_InteretPositionSet(pmid_interet, tv_pos)
		EVENT_InteretSet(pmid_interet, tf_interet)
	}
	EVENT_InteretSeenTimeSet(pmid_interet, TIME_Get())
	if( pi_status != -1 )
		EVENT_InteretStatusSet(pmid_interet, pi_status)
}


//===================================================================================
// Ajoute un acteur dans la liste des acteurs vus cette trame
//===================================================================================
procedure_local void BC_Seen_Actor_Add(messageid tmid_visibility_ID)
{
	amid_seen_actor[i_seen_actor_nb] = tmid_visibility_ID
	i_seen_actor_nb++
}


//===================================================================================
// Test acteur vu cette trame
//===================================================================================
procedure_local int BC_Seen_Actor_Test(object po_actor, byref messageid pmid_vision)
{
	messageid			tmid_vis_ID	
	int						ti_i
	int						ti_cible_attaque_vue

	ti_cible_attaque_vue = faux
	// le bat voit des acteurs
	for( ti_i = 0; ti_i < i_seen_actor_nb; ti_i++)
	{
		// test de tous les acteurs vus
		tmid_vis_ID = amid_seen_actor[ti_i]
		if( EVENT_PereGet(tmid_vis_ID) == po_actor )
		{
			// le bat voit son agresseur => maj intérêt
			pmid_vision = tmid_vis_ID
			ti_cible_attaque_vue = vrai
			break
		}
	}
	return ti_cible_attaque_vue
}


//===================================================================================
// Retourne le wp choisit comme cible du déplacement
//===================================================================================
procedure_local object BC_Choix_Cible_Deplacement_Calme()
{
	object		to_obj_resultat
	object		to_obj1
	object		to_obj2
	
	to_obj_resultat = nobody
	
	// init du wp cible du prochain déplacement pour commencer à m'orienter vers lui
	if( MSG_GlobalIsValid( mid_grab_charogne ) )
	{
		// vers le nid pour y apporter sa proie (charogne / humain)
		to_obj_resultat = WAY_WPNearestOfPos( OBJ_PosGet(), n_attaque, CAPA_mange_charogne, none, Ci_Filter_CapaFlag)
		if( ! to_obj_resultat )
			DBG_Error("je n'ai pas de wp pour manger !!!!")
	}
	else
	{
		// décolle d'ailleurs, rejoint le réseau
		to_obj1 = nobody
		to_obj2 = nobody
		if( n_net )
			to_obj1 = WAY_WPNearestOfPos( OBJ_PosGet(), n_net, all, CAPA_pause, Ci_Filter_CapaFlag)
		if( n_attaque )
			to_obj2 = WAY_WPNearestOfPos( OBJ_PosGet(), n_attaque, CAPA_deplacement, none, Ci_Filter_CapaFlag)
		if( to_obj1 && ! to_obj2 )
			to_obj_resultat = to_obj1
		else if( to_obj2 && ! to_obj1 )
			to_obj_resultat = to_obj2
		else if( to_obj1 && to_obj2 )
		{
			if( OBJ_SqrDist(to_obj1) < OBJ_SqrDist(to_obj2) )
				to_obj_resultat = to_obj1
			else
				to_obj_resultat = to_obj2
		}
		// else il n'y a aucun réseau de configuré !!!
	}
	return to_obj_resultat
}


//==================================================================================
// Vitesse max de la bat
//==================================================================================
procedure_local void BC_ref_speed_set(float tf_speed)
{
	f_ref_speed = tf_speed * f_freq_speed_coef * f_DBG_freq_speed_coef
}


//==================================================================================
// Fréquence d'anim
//==================================================================================
procedure_local void BC_action_frequency_set(float tf_freq)
{
	float		tf_coef
	if( i_modele == Ci_MODELE_Bat_Noire && ! f_HP )
		tf_coef = 1.0
	else
		tf_coef = f_freq_action_coef
	f_anim_frequency_ref = (tf_freq * tf_coef)
}


//==========================================================================================
// La bat a perdu son agresseur : RAZ des infos d'attaque
//==========================================================================================
procedure_local void BC_reset_attaque()
{
	i_agresseur_ID = -1
	o_cible_attaque = nobody
	o_cible_attaque_contact = nobody
	i_attack_mode = Ci_attack_mode_aucun
	i_flag_reserve_interet = faux
	i_attaque_fin_desynchro_flag = faux
	o_attaque_fin_desynchro_gao = nobody
	if( MSG_GlobalIsValid(mid_interet_attaque) )
		EVENT_Delete(mid_interet_attaque, C_EVENT_EOFDEL)
	f_obstacle_duration = 0.0		// réinit durée obstacle
	i_flag_frein = faux
	f_angle_rotation_max = Cf_angle_rotation_max_default
	f_speed = 0.0
	// BOSS ATTACK
	i_boss_attack_init = faux
//	o_boss_attack_wp = nobody
//	o_boss_retreat_wp = nobody			// conserver pour paf pendant paf
	o_cadavre = nobody		// NEW CADAVRE
}


//===================================================================================
// Retourne la position calculée pour attaquer la proie
//===================================================================================
procedure_local vector BC_Attaque_Calc_Position(int pi_attaque)
{
	object		to_head
	vector		tv_temp
	vector		tv_pos
	float			tf_H
	float			tf_V

	tf_H = 0.0
	tf_V = 0.0
	if( pi_attaque == Ci_attaque_positionnement_attack_en_cours )
	{
		// position pendant l'anim d'attaque
		tf_H = f_attaque_pos_horiz_anim
		tf_V = f_attaque_pos_vert_anim
	}
	else if( pi_attaque == Ci_attaque_positionnement_paffe )
	{
		// position pour lancer l'attaque
		tf_H = f_attaque_pos_horiz
		tf_V = f_attaque_pos_vert
	}
	else if( pi_attaque == Ci_attaque_positionnement_retrait || pi_attaque == Ci_attaque_positionnement_retrait_initial )
	{
		// position d'observation en retrait (une autre bat attaque)
		tf_H = f_attaque_pos_horiz_wait
		tf_V = f_attaque_pos_vert_wait
	}
	
	to_head = @o_cible_attaque ANI_CanalObjectGet(Anim_Canal_Tete)
	if( ! to_head )
		to_head = o_cible_attaque
	tv_pos = @to_head OBJ_PosGet()
	
	if( pi_attaque == Ci_attaque_positionnement_attack_en_cours )
	{
		tv_temp = OBJ_PosGet() - @to_head OBJ_PosGet()
	}
	else if( BC_AttackHorsChampSurJackPositionnement() )
	{
		if( pi_attaque == Ci_attaque_positionnement_paffe )
		{
			// attaque hors champ sur jack pas encore lancée
			if( MATH_FloatNullToler(f_fps_contourne_duration, 0.05) )
				SND_RequestPlay(Ci_SND_Cri_Attack_Griffe)
			f_fps_contourne_duration += TIME_GetDt()
			tv_temp = @to_head OBJ_SightGet()		// sight de la caméra
		}
		else
			tv_temp = @to_head OBJ_SightGet()		// sight de la caméra
	}
	else
		tv_temp = OBJ_PosGet() - @to_head OBJ_PosGet()
	
	tv_temp.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_temp) )
		MATH_VecSetNormalize(tv_temp)

	tv_pos += (tf_H * tv_temp)
	tv_pos += (tf_V * Cv_VerticalVector)
	if( i_DBG_render_fight_position )
		DBG_RenderVector(OBJ_PosGet(), tv_pos - OBJ_PosGet(), color_bleu)
	return tv_pos
}


//================================================================================
// Initialisation du wp de départ du déplacement de la bat dans la position et l'orientation courante de la bat
//================================================================================
procedure_local void BC_beziers_init_position()
{
	vector		tv_to_dest
	
	@o_tmp_obj_last OBJ_PosSet(OBJ_PosGet())	
	@o_tmp_obj_last OBJ_BankingGeneralSet(v_beziers_sight, v_beziers_banking)
	o_last_wp = o_tmp_obj_last
	f_link_coef = 0.0
	tv_to_dest = @o_next_wp OBJ_PosGet() - OBJ_PosGet()
	f_link_length = MATH_VecNorm(tv_to_dest)
	DBG_RenderVector(OBJ_PosGet(), tv_to_dest, color_vert)
}


//==========================================================================================
// Calcule les wp pour la béziers pour se descendre devant la proie
//==========================================================================================
procedure_local void BC_Attaque_Calc_Deplacement(int pi_attaque)
{
	vector		tv_old_cible_pos
	vector		tv_sight
	
	tv_old_cible_pos = v_cible_pos
	v_cible_pos = BC_Attaque_Calc_Position(pi_attaque)
	
	v_dest_pos = v_cible_pos
	
	@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
	tv_sight = @o_cible_attaque OBJ_PosGet() - @o_tmp_obj_last OBJ_PosGet()		// garder une courbe similaire, sans que ça me fasse tourner autour
	@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
	o_next_wp = o_tmp_obj_next
}


procedure_local int BC_TargetActive(object to_target)
{
	messageid	tmid_vision
	if( ! ( @to_target OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Active ) )
		return faux
	tmid_vision = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_target, nobody)
	if( ! MSG_GlobalIsValid(tmid_vision) )
		return faux
	return vrai
}

//=========================================================================================
// Retourne vrai si l'acteur est une cible autorisée, faux sinon
//=========================================================================================
procedure_local int BC_Target_Check(object to_target, int ti_check_fire)
{
	int					ti_loop
	object			to_gao
	message 		tm_filter
	messageid		tmid_interet
	messageid		tmid_vision
	int 				ti_rank
	int 				ti_interet_on_ann
	int 				ti_visibility_context
	int 				ti_type_sol
	
	if( ! to_target )
		return faux
	
	if( ! BC_TargetActive(to_target) )
		return faux
	
	if( o_ignore_target && to_target == o_ignore_target )
		return faux

	if( ! BC_Gao_in_Territory(to_target, ti_check_fire) )		// BV et blind zone
		return faux
	
	return vrai
}


//==================================================================================
// Test d'attaque (trigger, pafs)
//==================================================================================
procedure_local int BC_Test_Attaque()
{
	message		tmsg_trigger
	messageid		tmid_vision
	float				tf_time_bat_noire
	
	o_cible_attaque = nobody
	
	if( ! i_agressive )
		return faux
	
	if( BC_Follower() )
		return faux		// j'attaquerai qd le boss sera mort
	
	// INTERDICTIONS
	if( f_charognard_delai_aucune_attaque || f_paf_delai_aucune_attaque || BC_ForceInactive() || f_boss_delai_aucune_attaque )
		return faux
	
	if( AI_TriggerIsValid(trig_stop_attaque) && call_trigger(trig_stop_attaque) )
		return faux
	
	if( i_modele == Ci_MODELE_Bat_Grise )
	{
		// temps mort entre la fuite d'une bat noire et les attaques des bats grises
		tf_time_bat_noire = @get_global f_time_bat_noire_escape
		if( tf_time_bat_noire && ! TIME_Elapsed(tf_time_bat_noire, Cf_delai_attaque_apres_bat_noire) )
			return faux	
	}
	
	// CHOIX CIBLE
	if( BC_Boss() )
	{
		if( @get_global i_bat_noire_lieutenant_nb == 0 )
		{
			if( BC_Target_Check(o_jack, faux) )
			{
				BC_Boss_Attack_Init()		// ne faire l'init que si tout est ok !!! (sinon bugs, style coef rotation remis à 0.0 à chaque trame...)
				o_cible_attaque = o_jack
				return vrai
			}
		}
	}
	else if( o_best_paf_pere )
	{
		if( BC_Target_Check(o_best_paf_pere, faux) )
		{
			BC_DBG_Trace_Etat("test attaque ok (best paf pere)")
			o_cible_attaque = o_best_paf_pere
			return vrai
		}
	}
	else if( AI_TriggerIsValid(trig_attaque) && call_trigger(trig_attaque) )
	{
		switch(i_trig_attaque_cible)
		{
			case 0 :
				tmsg_trigger = AI_TriggerGetMsg(trig_attaque)
				Check_This_Gao5(tmsg_trigger.msg_gao5)
				if( BC_Target_Check(tmsg_trigger.msg_gao5, faux) )
				{
					BC_DBG_Trace_Etat("test attaque ok (trigger gao 5)")
					o_cible_attaque = tmsg_trigger.msg_gao5
					return vrai
				}
				break
			
			case 1 :
				if( BC_Target_Check(o_attaque_gao_specifique, faux) )
				{
					BC_DBG_Trace_Etat("test attaque ok (trigger gao specifique)")
					o_cible_attaque = o_attaque_gao_specifique
					return vrai
				}
				break
		}
	}
	
	// TEST VALIDITE
	if( o_cible_attaque )
	{
		// Vision (périmètre, distances...) ---------------------------------
		if( ! BC_Seen_Actor_Test(o_cible_attaque, tmid_vision) )
		{
			o_cible_attaque = nobody
		}
		// Test présence d'une bat noire -------------------------------------------
		if( i_modele != Ci_MODELE_Bat_Noire )
		{
			if( BC_Gao_Has_Interet_From_Bat_Model(o_cible_attaque, Ci_MODELE_Bat_Noire) )
			{
				o_cible_attaque = nobody
			}
		}
	}
	
	// RESULTAT
	if( o_cible_attaque )
		return vrai
	else
		return faux
}


//================================================================================
// Sélectionne l'action à jouer; retourne si l'action a été modifiée ou non
//================================================================================
procedure_local int BC_select_action()
{
	int 		ti_action
	float		tf_freq
	
	if( MSG_GlobalIsValid(mid_grab_charogne) )
		ti_action = ACTION_Vol_Proie
	else
		ti_action = i_ACTION_Vol_Standard
	
	if( ACT_ActionGet() != ti_action )
	{
		ACT_ActionSet(ti_action)
		return vrai
	}
	return faux
}


//===================================================================================
// Ajoute un paf (pour le test de cumul des petit pafs)
//===================================================================================
procedure_local void BC_Paf_Cumul_Add(float tf_paf_puiss)
{
	float		tf_time
	if( i_paf_cumul_nb < Ci_paf_cumul_max )
	{
		// bidouille infame !!!! avec la bat noire on a le gun, avec les autres on a le tommygun...
		switch( i_modele )
		{
			case Ci_MODELE_Bat_Noire :
				tf_time = 0.8
				break
			case Ci_MODELE_Bat_Grise :
			case Ci_MODELE_Bat_Rouge :
				tf_time = 0.8
				break
			case Ci_MODELE_Bat_Mini :
				tf_time = 0.0
				break
		}
		af_paf_cumul_time[i_paf_cumul_nb] = tf_time
		af_paf_cumul_dmg[i_paf_cumul_nb] = tf_paf_puiss
		i_paf_cumul_nb++
	}
}


//===================================================================================
// Supprime un paf pour le test de cumul des petit pafs
//===================================================================================
procedure_local void BC_Paf_Cumul_Del(int ti_indice)
{
	int			ti_k
	
	for(ti_k = ti_indice; ti_k < i_paf_cumul_nb; ti_k++)
	{
		af_paf_cumul_time[ti_k] = af_paf_cumul_time[ti_k + 1]
		af_paf_cumul_dmg[ti_k] = af_paf_cumul_dmg[ti_k + 1]
	}
	i_paf_cumul_nb--
}


//===================================================================================
// Supprime un paf conservé pour le cumul
//===================================================================================
procedure_local void BC_Paf_Cumul_Check_Time()
{
	int		ti_i
	int		ti_k
	
	for( ti_i = 0; ti_i < i_paf_cumul_nb; ti_i++)
	{
		af_paf_cumul_time[ti_i] -= MATH_FloatMin(af_paf_cumul_time[ti_i], TIME_GetDt())
		if( ! af_paf_cumul_time[ti_i] )
			BC_Paf_Cumul_Del(ti_i)
	}
}


procedure_local void BC_Paf_Cumul_Clear()
{
	while( i_paf_cumul_nb )
		BC_Paf_Cumul_Del(0)
}


//===================================================================================
// Retourne vrai si la somme des petits pafs cumulés permet de faire un paf moyen, faux sinon
//===================================================================================
procedure_local int BC_Paf_Cumul_Check_Cumul()
{
	int		ti_i
	float	tf_cumul
	int		ti_k
	
	tf_cumul = 0.0
	for( ti_i = 0; ti_i < i_paf_cumul_nb; ti_i++)
	{
		tf_cumul += af_paf_cumul_dmg[ti_i]
		if( tf_cumul >= f_paf_cumul_dmg || i_paf_type & C_PAF_KK_Javelin )	// un paf lance doit forcément devenir un paf cumul
		{
			// suppr de tous les pafs cumulés
			BC_Paf_Cumul_Clear()
			return vrai
		}
	}
	return faux
}

//===================================================================================
// Ajoute un soubresaut après un paf
//-----------------------------------------------------------
// num du canal, vecteur de paf (normalisé * puissance)
//===================================================================================
//procedure_local void BC_SoubreSaut_Add(int ti_canal, vector tv_dir)
//{
//	if( ti_canal != -1 && i_soubresaut_nb < Ci_soubresaut_max )
//	{
//		ai_soubresaut_canal[i_soubresaut_nb] = ti_canal
//		av_soubresaut_dir[i_soubresaut_nb] = tv_dir
//		i_soubresaut_nb++
//	}
//}


//===================================================================================
// Checke la validité des soubresauts mémorisés
//===================================================================================
//procedure_local void BC_SoubreSaut_Check()
//{
//	int		ti_i
//	int		ti_k
//	
//	for( ti_i = 0; ti_i < i_soubresaut_nb; ti_i++)
//	{
//		av_soubresaut_dir[ti_i] = MATH_VecBlend(av_soubresaut_dir[ti_i], Cv_NullVector, 5 * TIME_GetDt())
//		if( MATH_VecNullEpsilon(av_soubresaut_dir[ti_i]) )
//		{
//			for(ti_k = ti_i; ti_k < i_soubresaut_nb; ti_k++)
//			{
//				av_soubresaut_dir[ti_k] = av_soubresaut_dir[ti_k + 1]
//				ai_soubresaut_canal[ti_k] = ai_soubresaut_canal[ti_k + 1]
//			}
//			i_soubresaut_nb--
//		}
//	}
//}


procedure_local void BC_SoftCol_Rayon_Resize()
{
	if( i_etat_courant == ETAT_Fight_Contact )
		f_softcol_rayon_perfect = Cf_softcol_rayon_contact
	else
		f_softcol_rayon_perfect = Cf_softcol_rayon_en_vol

	f_softcol_rayon_current = MATH_FloatBlend(f_softcol_rayon_current, f_softcol_rayon_perfect, 5 * TIME_GetDt())
}


//====================================================================================
// Retourne l'ID du gao à partir de son event vision, -1 si l'event vision n'est pas trouvé
//====================================================================================
procedure_local int BC_Get_ID(object to_actor)
{
	messageid 		tmid_vision
	
	tmid_vision = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_actor, nobody)
	if( MSG_GlobalIsValid(tmid_vision) )
		return EVENT_VisionIDGet(tmid_vision)
	else
		return -1
}


//=======================================================================================================
// Recherche d'une autre proie dans la zone de choix de cible. 
// Retourne vrai s'il y a une autre cible
//=======================================================================================================
procedure_local int BC_Check_New_Target(byref object to_new_target)
{
	messageid			tmid_vis_ID
	object				to_actor
	object				to_best_actor
	int						ti_i
	
	if( BC_Follower() )
		return faux		// je n'ai pas le droit d'attaquer tant que je suis follower
	
	to_new_target = nobody
	to_best_actor = nobody
	if( i_agressive )
	{
		// une bat agressive qui vient de détecter un cadavre ne va pas rechanger de cible pour un humain...
		for( ti_i = 0; ti_i < i_seen_actor_nb; ti_i++)
		{
			tmid_vis_ID = amid_seen_actor[ti_i]
			to_actor = EVENT_PereGet(tmid_vis_ID)
			if( to_actor != o_cible_attaque )
				if( IsThis_ID_Humain(BC_Get_ID(to_actor)) )
					if( BC_Pos_in_BV(@to_actor OBJ_PosGet(), o_zone_choix_target) )	// on restreint à la zone de changement de proie
						if( BC_Pos_in_Territory(@to_actor OBJ_PosGet(), faux) )	// mais il faut totu de même tenir compte des blind zone, grille, etc...
							if( ! to_best_actor || to_actor == o_jack)
								to_best_actor = to_actor				// Jack est prioritaire sur les autres
		}
	}
	to_new_target = to_best_actor
	if( to_new_target )
		return vrai
	else
		return faux
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Effectue un blend en rotation, mais avec une vitesse angulaire a ne pas depasser
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
procedure vector BC_BlendRotate(vector src, vector dst, float speed, float maxspeed)
{
	vector	tv_temp, tv_normal
	float		tf_angle
	
	maxspeed *= TIME_GetDt()
	tv_temp = MATH_VecBlendRotate(src, dst, speed * TIME_GetDt())
	
	tv_normal = MATH_VecCrossProduct(src, dst)
	if(MATH_VecNullEpsilon(tv_normal)) return tv_temp
	
	tf_angle = MATH_VecAngle(src, tv_temp, tv_normal)
	if(MATH_AbsFloat(tf_angle) > maxspeed)
	{
		tv_temp = MATH_VecRotate(src, tv_normal, maxspeed * MATH_FloatSign(tf_angle))
	}
	
	return tv_temp
}

//==========================================================================
// Calcule et retourne un délai pour désynchroniser les fins d'attaques des bats
//==========================================================================
procedure_local float BC_Attaque_Desynchro_Time_Get()
{
	float			tf_delay_random
	float			tf_delay_min
	float			tf_delay_total
	float			tf_time_delta
	
	if( TIME_Elapsed(@get_global af_time_bats_attaque_desynchro[i_modele -1], f_time_attaque_fin_desynchro_delai_min) )
		tf_delay_min = 0.0
	else
	{
		tf_time_delta = @get_global af_time_bats_attaque_desynchro[i_modele -1] - TIME_Get()
		tf_delay_min = tf_time_delta + f_time_attaque_fin_desynchro_delai_min
	}
	
	tf_delay_random = MATH_RandFloat(f_time_attaque_fin_desynchro_min, f_time_attaque_fin_desynchro_max)
	
	tf_delay_total = tf_delay_min + tf_delay_random
	@get_global af_time_bats_attaque_desynchro[i_modele -1] = ( TIME_Get() + tf_delay_total )
	
	return tf_delay_total
}


//===============================================================================
// Lance un cri de présence et remet un timer
//===============================================================================
procedure_local void BC_Sound_Cri_Presence_Play()
{
	SND_RequestPlay(Ci_SND_Cri_Presence)
	f_time_cri_presence = MATH_RandFloat(7.0, 15.0)
}


//===============================================================================
// Lance le son de vol
//===============================================================================
//procedure_local void BC_Sound_Fly_Play()
//{
//	if( ! i_sound_fly_playing )
//	{
//		SND_PlayLooped(i_sound_fly_request, -1)
//		i_sound_fly_playing = vrai
//	}
//}


//===============================================================================
// Arrête le son de vol
//===============================================================================
//procedure_local void BC_Sound_Fly_Stop()
//{
//	if( i_sound_fly_playing )
//	{
//		SND_Stop(i_sound_fly_request)
//		i_sound_fly_playing = faux
//	}
//}


//==========================================================================
// Réserve un wp d'attaque
//==========================================================================
procedure_local void BC_WP_Reservation_Add(object to_wp)
{
	if( to_wp && @to_wp OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_ExtendedObject) )
	{
		@to_wp OBJ_CapaSet(CAPA_point_reserve, none)		// réserve ce wp
		i_attak_wp_reserve = vrai
	}
}


//==========================================================================
// Supprime la réservation d'un wp d'attaque
//==========================================================================
procedure_local void BC_WP_Reservation_Del(object to_wp)
{
	if( i_attak_wp_reserve )
	{
		if( to_wp && @to_wp OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_ExtendedObject) )
		{
			@to_wp OBJ_CapaSet(none, CAPA_point_reserve)		// enlève la réservation car on quitte le wp
			i_attak_wp_reserve = faux
		}
	}
}

// =============================================================================
// POSITION DE LA BAT SUR LA BEZIERS
// =============================================================================
//procedure_local void BC_Calc_Beziers(byref vector tv_point_A, byref vector tv_point_B, float tf_coef)
procedure_local void BC_Calc_Beziers(byref vector tv_pos_new, byref vector tv_sight_new, float tf_coef)
{
	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	tv_point_A = @o_last_wp OBJ_PosGet()
	
	tv_point_B = tv_point_A
//	DBG_RenderVector(@o_last_wp OBJ_PosGet(), @o_last_wp OBJ_SightGet() * 10, color_bleu)
 	tv_point_B += @o_last_wp OBJ_SightGet() * (f_link_length * f_beziers_pourcent)
	
	tv_point_D = @o_next_wp OBJ_PosGet()
	
	tv_point_C = tv_point_D
//	DBG_RenderVector(@o_next_wp OBJ_PosGet(), @o_next_wp OBJ_SightGet() * 10, color_rouge)
	tv_point_C -= @o_next_wp OBJ_SightGet() * (f_link_length * f_beziers_pourcent)
	
	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
	tv_point_C += (tv_point_D - tv_point_C) * tf_coef
	
	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
	
	tv_sight_new = tv_point_B - tv_point_A
	
	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	
	tv_pos_new = tv_point_A
	
//	DBG_RenderVector(tv_point_A, Cv_VerticalVector * 2, color_bleu)
//	DBG_RenderVector(tv_point_B, Cv_VerticalVector * 2, color_rouge)
}


//procedure_local void BC_Calc_Beziers(byref vector tv_pos_new, byref vector tv_sight_new, vector tv_init_pos, vector tv_init_sight, vector tv_dest_pos, vector tv_dest_sight, float tf_coef)
//procedure_local void BC_Calc_Beziers(byref vector tv_pos_A, byref vector tv_pos_B, vector tv_init_pos, vector tv_init_sight, vector tv_dest_pos, vector tv_dest_sight, float tf_coef)
//{
//	vector	tv_point_A
//	vector	tv_point_B
//	vector	tv_point_C
//	vector	tv_point_D
//	
//	tv_point_A = tv_init_pos
//	
//	tv_point_B = tv_point_A
//	DBG_RenderVector(tv_init_pos, tv_init_sight * 10, color_bleu)
// 	tv_point_B += tv_init_sight * (f_link_length * f_beziers_pourcent )
//	
//	tv_point_D = tv_dest_pos
//	
//	tv_point_C = tv_point_D
//	DBG_RenderVector(tv_dest_pos, tv_dest_sight * 10, color_rouge)
//	tv_point_C -= tv_dest_sight * (f_link_length * f_beziers_pourcent )
//	
//	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
//	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
//	tv_point_C += (tv_point_D - tv_point_C) * tf_coef
//	
//	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
//	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
//	
////	tv_sight_new = tv_point_B - tv_point_A	
////	tv_point_A += (tv_point_B - tv_point_A) * tf_coef	
////	tv_pos_new = tv_point_A
//	
//	tv_pos_A = tv_point_A
//	tv_pos_B = tv_point_B
//	
//	DBG_RenderVector(tv_point_A, Cv_VerticalVector * 2, color_bleu)
//	DBG_RenderVector(tv_point_B, Cv_VerticalVector * 2, color_rouge)
//}


//=====================================================================
// Affiche la béziers
//=====================================================================
procedure_local void BC_Beziers_Display(float tf_coef, int ti_color)
{
	int			ti_i
	vector	tv_last_pos
	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	tv_last_pos = @o_last_wp OBJ_PosGet()
	
	for (ti_i = 1; ti_i < 30; ti_i++)
	{
		tf_coef = ti_i / 30.0
	
		tv_point_A = @o_last_wp OBJ_PosGet()
		
		tv_point_B = tv_point_A 
		tv_point_B += @o_last_wp OBJ_SightGet() * (f_link_length * f_beziers_pourcent )
			
		tv_point_D = @o_next_wp OBJ_PosGet()
		
		tv_point_C = tv_point_D
		tv_point_C -= @o_next_wp OBJ_SightGet() * (f_link_length * f_beziers_pourcent )

		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef
		tv_point_C += (tv_point_D - tv_point_C) * tf_coef

		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
		tv_point_B += (tv_point_C - tv_point_B) * tf_coef

		tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	
		DBG_RenderVector(tv_last_pos, tv_point_A - tv_last_pos, ti_color)
		tv_last_pos = tv_point_A
	}
}


//====================================================================================
// Force la bat a passer en mode agressive
//====================================================================================
procedure_local void BC_Charognard_Mode_Force()
{
	i_agressive = faux
//	f_charognard_forced_duration = 0.0
	if( i_DBG_mode && i_mode_agressif_ON )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : devient charognard")
		DBG_TraceEOL()
	}
}


//====================================================================================
// Reset le mode agressif courant et remet le mode agressif initial
//====================================================================================
procedure_local void BC_Charognard_Mode_Reset()
{
	if( ! i_agressive )
	{
		i_agressive = i_mode_agressif_ON
		if( i_agressive )
		{
			f_charognard_delai_aucune_attaque = MATH_RandFloat(1.0, 3.0)
			if( i_DBG_mode )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : redevient agressive (pas d'attaque pendant ")
				DBG_TraceFloat(f_charognard_delai_aucune_attaque)
				DBG_TraceString(" sec)")
				DBG_TraceEOL()
			}
		}
	}
}

//====================================================================
// Retourne vrai si le cadavre est nouveau (pas encore allé le voir), faux sinon
//====================================================================
procedure_local int BC_Cadavre_Nouveau_Test(object to_actor)
{
	int				ti_indice
	
	ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
	if( ti_indice != -1 && ai_cadavre_nouveau[ti_indice] )
		return vrai
	else
		return faux
}

procedure_local int BC_Cadavre_Libre(object to_gao)
{
	message	tmsg_filter
	messageid	tmid_ID
	int				ti_rank
	object		to_pere
	int				ti_cpt
	int				ti_max
	
	// recherche d'un message d'intérêt d'autres ennemis sur le cadavre
	ti_cpt = 0
	ti_max = @get_global i_foodchain_bats_nb
	MSG_SetNull(tmsg_filter)
	tmsg_filter.msg_gao1 = to_gao
	ti_rank = -1
	for (	tmid_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter);
			MSG_GlobalIsValid(tmid_ID);
			tmid_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter) )
	{
		to_pere = EVENT_PereGet(tmid_ID)
		if( to_pere != OBJ_Me() )
		{
			if( @to_pere AI_IsModel(get_PNJ_Bats_path) )
			{
				// une bat interdit aux autres bats de venir uniquement si elle a commencé à atterrir / manger le cadavre
				switch( EVENT_InteretStatusGet(tmid_ID) )
				{
					case C_EVENT_InteretStatusFoodchain :
						ti_cpt++
						if( ti_cpt > ( ti_max - 1) )
							return faux			// 3 bats maxi pour aller voir un cadavre
						break
					case C_EVENT_InteretStatusFoodchainLocked :
						return faux				// 1 bat qui atterrit / mange et c mort pour moi
				}
			}
			else if( ! @to_pere AI_IsModel(get_Humain_path) )
			{
				// les autres ennemis enpêchent une bat de venir (anti oscillation repart / revient des bats)
				// sauf s'il est nouveau (je viens qd même 1 fois) ou que c le cadavre que j'ai déà commencé à aller voir)
				if( ! BC_Cadavre_Nouveau_Test(to_gao) && to_gao != o_cadavre )
					return faux
			}
		}
	}
//	if( to_gao && @to_gao DBG_IsObjSel() )
//		ti_cpt = ti_cpt
	return vrai
}

procedure_local int BC_Cadavre_Safe(object to_gao)
{
	messageid		tmid_tmp
	float		tf_danger
	int			ti_i
	object	to_pere
	vector	tv_temp
	int			ti_safe
	// TEST DU NIVEAU DE DANGER
	if( ! to_gao )
		return vrai
	tf_danger = 0.0
	ti_safe = vrai
	for(ti_i = 0; ti_i < i_seen_actor_nb; ti_i++)
	{
		// analyse des persos visibles
		tmid_tmp = amid_seen_actor[ti_i]
		to_pere = EVENT_PereGet(tmid_tmp)
		if( to_pere != to_gao && to_pere != o_jack && ! @to_pere AI_IsModel(get_PNJ_Bats_path) )
		{
			// ce n'est pas l'event de visibilité de la cible ni de jack (je ne le compte pas car je peux l'attaquer s'il approche trop) ni d'une bat
			if( EVENT_VisionLifeStateGet(tmid_tmp) > Cf_Life_Dead )
			{
				// cet acteur est vivant
				tv_temp = EVENT_PositionGet(tmid_tmp) - @to_gao OBJ_PosGet()
				DBG_RenderVector(@to_gao OBJ_PosGet(), tv_temp, color_rouge)
//				tv_temp.z = 0.0
				if( MATH_VecNorm(tv_temp) <= 5.0 )
				{
					// ce perso est trop proche de la charogne
					tf_danger = MATH_FloatMax(tf_danger, @"univ" Enemy_af_Danger[EVENT_VisionIDGet(tmid_tmp)])
					ti_safe = faux
					if( i_DBG_trace_etat )
					{
						DBG_TraceObject(OBJ_Me())
						DBG_TraceString(" !!! DANGER !!! : ")
						DBG_TraceObject(to_pere)
						DBG_TraceString(" trop proche de ")
						DBG_TraceObject(to_gao)
						DBG_TraceEOL()
					}
				}
			}
		}
	}
//	// TEST FIRE
//	if( ti_safe )
//	{
//		if( BC_Gao_Is_Near_Fire(to_gao) )
//		{
//			if( i_DBG_trace_etat )
//			{
//				DBG_TraceObject(OBJ_Me())
//				DBG_TraceString(" !!! FIRE !!! : ")
//				DBG_TraceObject(to_gao)
//				DBG_TraceString(" trop proche d'une source de feu ")
//				DBG_TraceEOL()
//			}
//			ti_safe = faux
//		}
//	}
	return ti_safe
}


//====================================================================
// Retourne vrai si le cadavre recherché est déjà référencé, faux sinon
//====================================================================
procedure_local int BC_Cadavre_Find(object to_actor)
{
	int		ti_indice
	if( ! to_actor )
		return faux
	else
	{
		ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
		if( ti_indice != -1 )
			return vrai
		else
			return faux
	}
}


//====================================================================
// Est-ce qu'on force ce cadavre comme un nouveau
//====================================================================
procedure_local void BC_Cadavre_Check_New()
{
	int		ti_i	
	int		ti_index
	int		ti_flag_del_body

	for (ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
	{
		if ((@ao_cadavre[ti_i] AI_IsModel(get_PNJ_Bidoche_path)) && (@ao_cadavre[ti_i] OBJ_CapaTest(CAPA_Bidoche_Oublie_Moi)) )
			ai_cadavre_nouveau[ti_i] = vrai
	}
}


//====================================================================
// Mémorise un nouveau cadavre sur mon territoire
//====================================================================
procedure_local void BC_Cadavre_Add(object to_actor)
{
	vector		tv_pos
	int				ti_type_sol
	
	if( i_cadavre_nb < Ci_cadavre_max_nb )
	{
		// test bv territoire, blind zone et caches
		if( ! BC_Cadavre_Find(to_actor) )
		{
			if( i_DBG_mode )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : mémorise un nouveau cadavre : ")
				DBG_TraceObject(to_actor)
				DBG_TraceEOL()
			}
			ao_cadavre[i_cadavre_nb] = to_actor
			ai_cadavre_nouveau[i_cadavre_nb] = vrai
			i_cadavre_nb++
		}
	}
}


//====================================================================
// Supprime un cadavre de sa mémoire
//====================================================================
procedure_local void BC_Cadavre_Del(object to_actor)
{
	int		ti_indice
	int		ti_k
	if( to_actor )
	{
		ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
		if( ti_indice != -1 )
		{
			for(ti_k = ti_indice; ti_k < i_cadavre_nb; ti_k++)
			{
				ao_cadavre[ti_k] = ao_cadavre[ti_k + 1]
				ai_cadavre_nouveau[ti_k] = ai_cadavre_nouveau[ti_k + 1]
			}
			i_cadavre_nb--
		}
	}
}


//====================================================================
// Retourne vrai si le perso est un cadavre, faux sinon
//----------------------------------------------------------------------------------------------------------------------------------------
// Par cadavre on entend toutes les bestioles dune autre espèce, sauf les humains.
//====================================================================
procedure_local int BC_Cadavre_Test(object to_actor, messageid tmid_vision)
{
	int			ti_ID
	float		tf_life_ratio
	
	ti_ID = EVENT_VisionIDGet(tmid_vision)
	if( IsThis_ID_Humain(ti_ID) )
		return faux		// pas les humains
	else if( ti_ID == C_ID_BatCharognard )
		return faux		// pas ceux de mon espèce
	else
	{
		// tous les autres : test du niveau de santé
		tf_life_ratio = EVENT_VisionLifeStateGet(tmid_vision)
		if( tf_life_ratio <= Cf_Life_Dead && tf_life_ratio != -1)
		{
			// c'est un perso agonisant ou mort, à qui il reste des points de viande
			if( @to_actor AI_IsModel(get_PNJ_Bidoche_path) )
			{
				if( @to_actor PNJ_EatMe_GetBidocheType() == Ci_Bidoche_Bat )
					return faux
				else
					return vrai
			}
			else if( ! @to_actor AI_IsModel(get_OBJ_Cadavre_path) )
				return vrai		// ce n'est pas un cadavre fake
			else if( ! i_mode_agressif_ON )
				return vrai		// c'est un fake mais je suis une bat charognard à la base
			else
				return faux		// c'est un fake mais je suis une bat agressive à la base
		}
		else
			return faux		// vivant ou déjà tout mangé
	}
}

//====================================================================
// Retourne le cadavre le + proche
//---------------------------------------------------------------------------------------------------------------------------------------
// ti_nouveau : si vrai, teste les nouveaux cadavres uniquement, si faux teste tous les cadavres
//====================================================================
procedure_local object BC_Cadavre_Nearest(int ti_nouveau)
{
	object		to_obj
	object		to_best_obj
	int				ti_i
	float			tf_dist
	float			tf_best_dist
	
	to_best_obj = nobody
	tf_best_dist = Cf_Infinit
	if( i_cadavre_nb )
	{
		for( ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
		{
			to_obj = ao_cadavre[ti_i]
			if( BC_Cadavre_Libre(to_obj) )	// ne pas choisir un cadavre pas libre (anti oscillation repart / revient des bats)
			{
				if( BC_Cadavre_Safe(to_obj) )		// ne pas choisir un cadavre pas safe (anti oscillation repart / revient des bats)
				{
					if( BC_Gao_in_Territory(to_obj, vrai) )		// tester si la cadavre n'est pas dans du feu maintenant
					{
						if( ! ti_nouveau || ai_cadavre_nouveau[ti_i] )
						{
							tf_dist = OBJ_SqrDist(to_obj)
							if( tf_dist < tf_best_dist )
							{
								tf_best_dist = tf_dist
								to_best_obj = to_obj
							}
						}
					}
				}
			}
		}
	}
	return to_best_obj
}


//====================================================================
// Mémorise que ce nouveau cadavre a déjà été choisi
//====================================================================
procedure_local void BC_Cadavre_Nouveau_Select(object to_actor)
{
	int				ti_indice
	
	ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
	if( ti_indice != -1 )
		ai_cadavre_nouveau[ti_indice] = faux
}

//====================================================================
// Teste la validité des cadavres
//====================================================================
procedure_local void BC_Cadavre_Check()
{
	object		to_obj
	object		to_best_obj
	int				ti_i
	float			tf_dist
	float			tf_best_dist
	messageid		tmid_vision
	
	for( ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
	{
		to_obj = ao_cadavre[ti_i]
		tmid_vision = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_obj, nobody)
		if( ! MSG_GlobalIsValid(tmid_vision) )
		{
			BC_Cadavre_Del(to_obj)
			if( i_DBG_mode )
				BC_DBG_Trace_Etat_Gao("perte de l'évént vision de", to_obj)
		}
		else if( EVENT_VisionLifeStateGet(tmid_vision) == -1 )
		{
			BC_Cadavre_Del(to_obj)
			if( i_DBG_mode )
				BC_DBG_Trace_Etat_Gao("l'évént vision == -1 pour ", to_obj)
		}
		else if( ! BC_TargetActive(to_obj) )
		{
			BC_Cadavre_Del(to_obj)
			if( i_DBG_mode )
				BC_DBG_Trace_Etat_Gao("le cadavre n'est plus actif", to_obj)
		}
	}
}


procedure_local float BC_Move_Speed_Dot()
{
	vector		tv_sight_horiz
	vector		tv_move_horiz
	float			tf_dot
	
	if( i_etat_courant == ETAT_Chute_wp )
		return 1.0
		
	switch( i_modele )
	{
		case Ci_MODELE_Bat_Rouge :
		case Ci_MODELE_Bat_Mini :
		case Ci_MODELE_Bat_Noire :
			return 1.0
			break
	}
	
//	if( BC_Boss() && o_attaque_finale_decor && f_HP == Cf_Life_Big_Bat_Last_Attack )
//		return 1.0		// Big Bat noire 03B : reviens toujorus au même wp d'attaque pour la dernière attaque, donc le dot la ralenti à mort....
	
	tf_dot = 1.0
	tv_sight_horiz = OBJ_SightGet()
	tv_sight_horiz.z = 0.0
	if( ! MATH_VecNullToler(tv_sight_horiz, 0.1) )
		MATH_VecSetNormalize(tv_sight_horiz)
	else
		tv_sight_horiz = OBJ_SightGet()
	tv_move_horiz = tv_sight_horiz		// par défaut, dot = 1.0

	// MODELE_Bat_Grise 
	if( i_etat_courant == ETAT_Fight_Contact )
	{
		// vers ma position d'attaque (retrait ou coup de griffe)
		switch( i_attaque_positionnement )
		{
			case Ci_attaque_positionnement_retrait_initial :
			case Ci_attaque_positionnement_paffe :
			case Ci_attaque_positionnement_attack_en_cours :
				// avance
				tv_move_horiz = v_dest_pos - OBJ_PosGet()
				break
			case Ci_attaque_positionnement_retrait :
				// recule : pas de réduction de vitesse
				break
		}
	}
	else if( i_etat_courant == ETAT_Move_Atterrit )
	{
		tv_move_horiz = @o_next_wp OBJ_SightGet()
	}
	else if( i_speed_beziers_flag )
	{
		// vers mon next wp
		i_speed_beziers_flag = faux
		if( @o_next_wp OBJ_PosGet() != @o_last_wp OBJ_PosGet() )
			tv_move_horiz = @o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet()
	}
	else if( i_speed_vertical_flag )
	{
		// décolle
		i_speed_vertical_flag = faux
		tv_move_horiz = v_dest_pos - OBJ_PosGet()
	}
	
	if( MATH_VecNullEpsilon(tv_move_horiz) )
		return 1.0
	
	if( tv_move_horiz != tv_sight_horiz )
	{
		tv_move_horiz.z = 0.0
		if( ! MATH_VecNullToler(tv_move_horiz, 0.1) )
			MATH_VecSetNormalize(tv_move_horiz)
		else
			tv_move_horiz = tv_sight_horiz
	}
	tf_dot = MATH_VecDotProduct(tv_sight_horiz, tv_move_horiz)
	// BAT GRISE : coef de 0.5 à 1.0
	tf_dot *=0.25
	tf_dot += 0.75

	return tf_dot
}


procedure_local int BC_Javelot_Reste_Plante(int ti_canal)
{
	switch(ti_canal)
	{
		case Anim_Canal_PiedGauche :
		case Anim_Canal_PiedDroit :
		case Ci_bat_canal_aileG :
		case Ci_bat_canal_aileD :
			return faux
		default:
			return vrai
	}
}


procedure_local int BC_Balancier_Enabled()
{
	switch( i_etat_courant )
	{
		case ETAT_Agonie :
		case ETAT_Brule :
		case ETAT_Fade :
		case ETAT_Chute_Libre :
		case ETAT_TEST :
		case ETAT_Paf_Air :
		case ETAT_Paf_Ecrase :
		case ETAT_Wait_Perche :
		case ETAT_Move_Atterrit :
		case ETAT_Mange :
		case ETAT_Mort :
		case ETAT_Paf_Sol :
		case ETAT_Paf_Explose :
			return faux
		case ETAT_Fight_Approche :
			if( i_etat_ancien == ETAT_Wait_Perche )
			{
				if( f_time_start_etat < 2.0 )
					return faux
			}
			return vrai
		default:
			return vrai
	}
}



//=============================================================================================
// Calcule et positionne le prochain wp (vol béziers)
//=============================================================================================
procedure_local void BC_Next_WP_Get()
{
	float				tf_dist_to_wp_cible
	float				tf_dist
	
	object			to_final_wp						// wp final
	object			to_cible_wp						// wp proche de la cible
	object			to_1st_wp						// 1er wp
	object			to_next_wp						// prochain wp
	object			to_tmp_wp						// wp voisin du wp de déplacement destination
	object			to_best_wp						// meilleur wp pour le choix
	object			tao_wp[Ci_max_reseau_wp]						// tableau de wp pour les choix
	
	vector			tv_final_pos
	vector			tv_1st_pos
	vector			tv_axe_1er_lien		// axe lien wp 1->2
	vector			tv_axe_2eme_lien	// axe lien wp 2->3
	vector			tv_to_wp
	vector			tv_to_cible
	vector			tv_dir_tmp
	vector			tv_dir_best
	vector			tv_dir
	vector			tv_collide_pos
	vector			tv_sight
		
	int					ti_nb_links
	int					ti_i
	int					ti_cpt
	int					ti_flag_calc_net
	int					ti_flag_calc_pos_next_wp
	
	ti_flag_calc_net = faux
	to_next_wp = nobody
	to_final_wp = nobody
	
	// CHOIX DU WP ========================================================================
	
	if( i_mode_depl == Ci_mode_depl_retour_se_percher )
	{
		if( i_flag_net_1st_move )
		{
			// 1er point de départ : rejoint le réseau pour aller vers son point d'accroche
			ti_flag_calc_net = faux
			i_reseau_wp_count = 10
			
			if( o_cible_depl )
			{
				to_final_wp = o_cible_depl
			}
			else
			{
				DBG_Error("je n'ai pas de o_cible_depl alors que j'ai bien un réseau n_attaque !!!???")
			}
		}
		else
		{
			if( i_reseau_wp_count > 1 )		// il y a encore des wp à parcourir
			{
				// suivi du réseau pour repartir
				to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb, v_perchee_init_pos, CAPA_deplacement, none, tv_final_pos)
				ti_flag_calc_net = vrai
			}
			else
			{
				// suivi du réseau terminé
				if( ! i_perchee_retour_post_rezo_flag )
				{
					// next wp
					@o_tmp_obj_next OBJ_PosSet(v_perchee_init_pos + (cvector(0,0,-0.6) * OBJ_ZoomGet()))
					@o_tmp_obj_next OBJ_BankingGeneralSet(- v_perchee_init_banking,  Cv_VerticalVector)
					o_next_wp = o_tmp_obj_next
					o_cible_depl = o_tmp_obj_next
										
					to_final_wp = o_next_wp
					i_reseau_wp_count = 1		// reste 1 depl à effectuer
					ti_flag_calc_net = faux
					i_flag_frein = vrai				// doit s'arrêter à la fin
					i_perchee_retour_post_rezo_flag = vrai
				}
				else
				{
					i_reseau_wp_count = 0		// fin du déplacement
					ti_flag_calc_net = faux
				}
			}
		}
	}
	else if( i_mode_depl == Ci_mode_depl_attaque )
	{
		ti_cpt = 0
		for( ti_i=0; ti_i < i_net_move_wp_nb; ti_i++)
		{
			if( ao_net_move_wp[ti_i] != o_backup_wp_depl_utilise )
			{
				// la bat ne réattaque pas du même point (test réalisé au 1er calcul du mode dépl attaque)
				tao_wp[ti_cpt] = ao_net_move_wp[ti_i]
				ti_cpt++
			}
		}
		BC_WP_Reservation_Del(o_backup_nearest_cible_wp)
		
		to_final_wp = ARR_LIB_NearestBVWaypoint(&tao_wp[0], ti_cpt, @o_cible_depl OBJ_PosGet(), CAPA_point_d_attaque, CAPA_point_reserve, tv_final_pos)
		
		if( ! to_final_wp )
		{
			if( o_backup_nearest_cible_wp )
				to_final_wp = o_backup_nearest_cible_wp
			else
				DBG_Error("Erreur LD : il n'y a pas de wp d'attaque libre ! il y a plus de bats agressives que de wp d'attaque dans toute la map !!!")
		}
		
		to_cible_wp = to_final_wp
		
		if( i_flag_net_1st_move || i_reseau_wp_count > 1 )
			ti_flag_calc_net = vrai			// il y a encore au moins un lien à parcourir
		else
		{
			// le bat vient d'arriver au wp d'attaque
			if( to_final_wp == o_backup_nearest_cible_wp )
				i_reseau_wp_count = 0			// le joueur n'a pas bougé -> la bat attaque
			else
			{
				ti_flag_calc_net = vrai			// ================================= NEW NEW NEW DECEMBRE 2004 !!!!!!!!!!!!!!!!!!!!!! =================================
				i_flag_depl_fini = faux			// la cible a bougé depuis que le bat a atteint le point d'attaque
				i_flag_net_1st_calcul = vrai		// ne pas faire l'optimisation "je vais pas derrière"
			}
		}
		o_backup_nearest_cible_wp = to_cible_wp
		BC_WP_Reservation_Add(o_backup_nearest_cible_wp)
	}
	else if( i_mode_depl == Ci_mode_depl_attente )
	{
		// retour au réseau d'attente
		
		if( i_flag_net_1st_move )
		{
			// 1er point de départ après l'attaque : choix du wp de depl entre le nearest wp et les wp qui sont reliés avec lui
			ti_flag_calc_net = faux
			i_reseau_wp_count = 1
			
			// NEW ==============================================
			if( o_cadavre )
			{
				to_final_wp = o_cadavre
			}
			else if( o_cible_depl )
			{
				to_final_wp = o_cible_depl	
			}
			else
			{
				to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb, OBJ_PosGet(), CAPA_deplacement, none, tv_final_pos)	// nearest de la bat
			}
		}
		else
		{
			// suivi du réseau pour repartir
			to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb, @o_cible_depl OBJ_PosGet(), CAPA_deplacement, none, tv_final_pos)
			ti_flag_calc_net = vrai
		}
	}
	else if( i_mode_depl == Ci_mode_depl_charogne_transport )
	{
		// retour au nid
		if( i_flag_net_1st_move )
		{
			// 1er point de départ après l'attaque : choix du wp de depl entre le nearest wp et les wp qui sont reliés avec lui
			ti_flag_calc_net = faux
			
			to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb, OBJ_PosGet(), CAPA_deplacement, none, tv_final_pos)	// nearest de la bat
			i_reseau_wp_count = 99
		}
		else
		{
			if( i_reseau_wp_count > 1 )
			{
				// il y a encore des wp à parcourir
				to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb, @o_cible_depl OBJ_PosGet(), CAPA_deplacement, none, tv_final_pos)
				ti_flag_calc_net = vrai
			}
			else
			{
				// la bat est arrivée au wp le + proche
				if( ! i_flag_depl_wp_apres_reseau )
				{
					AI_Execute("BC_exec_calc_pos_grab_charogne")
					
					// next wp
					@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
					@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
					o_next_wp = o_tmp_obj_next
					
					to_final_wp = o_next_wp
					i_reseau_wp_count = 1		// reste 1 depl à effectuer
					ti_flag_calc_net = faux
					i_flag_frein = vrai				// doit s'arrêter à la fin
					i_flag_depl_wp_apres_reseau = vrai
				}
				else
				{
					i_reseau_wp_count = 0		// fin du déplacement
					ti_flag_calc_net = faux
					i_flag_depl_wp_apres_reseau = faux
				}
			}
		}
	}
//	else if( i_mode_depl == Ci_mode_depl_charogne_olfactif || i_mode_depl == Ci_mode_depl_charogne_visuel )
//	{
//		if( i_reseau_wp_count > 1 )		// il y a encore des wp à parcourir
//		{
//			// suivi du réseau pour atteindre la position de la charogne ou de la trace de sang
//			@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
//			@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
//			o_next_wp = o_tmp_obj_next
//			
//			o_cible_depl = o_tmp_obj_next
//		
//			to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb,  @o_cible_depl OBJ_PosGet(), CAPA_deplacement, none, tv_final_pos)
//			ti_flag_calc_net = vrai
//		}
//		else
//		{
//			// la bat est arrivée au wp le + proche
//			if( ! i_flag_depl_wp_apres_reseau )
//			{
//				if(i_mode_depl == Ci_mode_depl_charogne_olfactif)
//					AI_Execute("BC_exec_calc_pos_suivi_olfactif")
//				else if(i_mode_depl == Ci_mode_depl_charogne_visuel)
//					AI_Execute("BC_exec_calc_pos_suivi_visuel")
//				
//				// next wp
//				@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
//				@o_tmp_obj_next OBJ_BankingGeneralSet(v_cible_pos - v_dest_pos, Cv_VerticalVector)
//				o_next_wp = o_tmp_obj_next
//				o_cible_depl = o_tmp_obj_next
//				
//				to_final_wp = o_next_wp
//				i_reseau_wp_count = 1		// reste 1 depl à effectuer
//				ti_flag_calc_net = faux
//				i_flag_frein = vrai				// doit s'arrêter à la fin
//				i_flag_depl_wp_apres_reseau = vrai
//			}
//			else
//			{
//				i_reseau_wp_count = 0		// fin du déplacement
//				ti_flag_calc_net = faux
//				i_flag_depl_wp_apres_reseau = faux
//			}
//		}
//	}
	else if( i_mode_depl == Ci_mode_depl_cadavre )
	{
		if( i_reseau_wp_count > 1 )		// il y a encore des wp à parcourir
		{
			// suivi du réseau pour atteindre la position de la charogne ou de la trace de sang
			@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
			@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
			o_next_wp = o_tmp_obj_next
			
//			o_cible_depl = o_tmp_obj_next
			o_cible_depl = o_cadavre		// prendre le wp le + proche du cadavre et pas de la position pour atterrir (ça peut tout fausser, cf. 02C_02)
		
			to_final_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb,  @o_cible_depl OBJ_PosGet(), CAPA_deplacement, none, tv_final_pos)
			ti_flag_calc_net = vrai
		}
		else
		{
			// la bat est arrivée au wp le + proche
			if( ! i_flag_depl_wp_apres_reseau )
			{
				BC_Calc_Pos_Cadavre_Update()
				
				to_final_wp = o_next_wp
				i_reseau_wp_count = 1		// reste 1 depl à effectuer
				ti_flag_calc_net = faux
				i_flag_frein = vrai				// doit s'arrêter à la fin
				i_flag_depl_wp_apres_reseau = vrai
			}
			else
			{
				i_reseau_wp_count = 0		// fin du déplacement
				ti_flag_calc_net = faux
				i_flag_depl_wp_apres_reseau = faux
			}
		}
	}

	if( ! ti_flag_calc_net)
		to_next_wp = to_final_wp			// déplacement déjà calculé
	else
	{
		// calcul du réseau obligatoire
		
		// 1st_wp
		to_1st_wp = ARR_LIB_NearestBVWaypoint(&ao_net_move_wp[0], i_net_move_wp_nb,  OBJ_PosGet(), CAPA_deplacement, none, tv_1st_pos)
		
		// CALCUL DU PLUS COURT CHEMIN
		if( to_1st_wp && to_final_wp ) 
		{
			// il y a des wp
			if( to_1st_wp != to_final_wp )
				i_reseau_wp_count = WAY_ShortWay( n_reseau, &ao_reseau_wp[0], to_1st_wp, to_final_wp, all, none )
			else
			{
				// wp de début et de fin identiques -> il faut se rendre au wp (test optimisation ensuite)
				ao_reseau_wp[0] = to_1st_wp
				i_reseau_wp_count = 1
			}
			
			// OPTIMISATION "je vais pas derrière" : si le wp le + proche est derrière moi, c'est que la bv du wp devant moi est tellement grande que 
			// je suis en contact avec elle alors que je suis toujours plus proche du wp derrière -> j'oublie le wp derrière
			// REM : optimisation interdite lors du 1er calcul du réseau (il ne faut pas supprimer le 1er élément du réseau)
			tv_to_wp = @to_1st_wp OBJ_PosGet() - OBJ_PosGet()
			if( ( ! i_flag_net_1st_calcul) && (MATH_VecDotProduct(tv_to_wp, OBJ_SightGet()) < 0) )
				i_reseau_wp_count--	
			
			// OPTIMISATION "j'y suis déjà" : prochain WP déjà atteint
			if( i_reseau_wp_count && ( i_flag_depl_fini || COL_Pivot_BVCollide(ao_reseau_wp[i_reseau_wp_count -1]) ) )
				if( ! i_flag_net_1st_move )		// pour etre sur que la bat aille bien se positionner à un wp d'attaque (et qu'elle n'attaque pas direct)
					i_reseau_wp_count--
			
			// OPTIMISATION "aller-retour" : éviter un aller-retour (min 2 wp)
			if( ! i_disable_net_optim )
			{
				if( i_reseau_wp_count >= 2 )
				{
					tv_axe_1er_lien = OBJ_PosGet() - @ao_reseau_wp[i_reseau_wp_count -1] OBJ_PosGet()
					if( ! MATH_VecNullEpsilon(tv_axe_1er_lien) )
						MATH_VecSetNormalize(tv_axe_1er_lien)
			
					tv_axe_2eme_lien = @ao_reseau_wp[i_reseau_wp_count -2] OBJ_PosGet() - @ao_reseau_wp[i_reseau_wp_count -1] OBJ_PosGet()
					if( ! MATH_VecNullEpsilon(tv_axe_2eme_lien) )
						MATH_VecSetNormalize(tv_axe_2eme_lien)
					
					if( MATH_VecDotProduct(tv_axe_1er_lien, tv_axe_2eme_lien) > 0.8 )
						i_reseau_wp_count--			// on évite l'aller-retour
					// else pas de demi-tour -> pas d'optimisation possible
				}
				// else 0 ou 1 wp à franchir -> pas d'optimisation possible
			}
		}
		else
			i_reseau_wp_count = 0
		
		// next wp
		if( i_reseau_wp_count )
			to_next_wp = ao_reseau_wp[i_reseau_wp_count -1]
		else
			to_next_wp = ao_reseau_wp[0]		// backup ancien point pour le vol_courbe de la trame d'après
		
		i_flag_net_1st_calcul = faux
	}

	i_flag_net_1st_move = faux		// 1er déplacement effectué

	// POSITION ET ORIENTATION ========================================================================
	
	if( to_next_wp )
		o_next_wp = to_next_wp		// VAR GLOBALE !!!! ne pas écraser un wp par une absence de wp (abscence de réseau)
	
	if( i_reseau_wp_count )
	{
		// réseau pas terminé
		if( i_mode_depl == Ci_mode_depl_attaque )
			v_dest_pos = @o_next_wp OBJ_PosGet()			// pour la détecion d'obstacle
		
//		if( ! ( ( (i_mode_depl == Ci_mode_depl_charogne_olfactif) || (i_mode_depl == Ci_mode_depl_charogne_visuel) || (i_mode_depl == Ci_mode_depl_charogne_transport) ) && i_flag_depl_wp_apres_reseau ) && ! i_perchee_retour_post_rezo_flag )
		if( ! i_perchee_retour_post_rezo_flag 
			&& ( ! ( ( i_mode_depl == Ci_mode_depl_cadavre || i_mode_depl == Ci_mode_depl_charogne_transport ) && i_flag_depl_wp_apres_reseau ) ) )
		{
			// l'IA passe ici pour tous les déplacements, sauf lors du dernier déplacement (hors réseau) des modes de suivi visuel et olfactif (+ retour accrcohe perchee)
			
			// Position du wp
			tv_dir = @o_next_wp OBJ_PosGet() - OBJ_PosGet()
			if( ! MATH_VecNullEpsilon(tv_dir) )
				tv_dir = MATH_VecNormalize(tv_dir)
			
			if ( ! OBJ_LIB_Intersection_Dir_BV(o_next_wp, OBJ_PosGet(), tv_dir, tf_dist, tv_collide_pos))
				tv_collide_pos = OBJ_PosGet()
			
			@o_tmp_obj_next OBJ_PosSet( tv_collide_pos )
			
			if( i_reseau_wp_count == 1 )
			{
				// dernier wp -> sight en fonction du mode
				switch ( i_mode_depl )
				{
					case Ci_mode_depl_cadavre  :
					{
						tv_sight = v_cible_pos - OBJ_PosGet()
						if( MATH_VecNullEpsilon(tv_sight) )
							tv_sight = OBJ_SightGet()
						@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
						break
					}
//					case Ci_mode_depl_charogne_olfactif  :
//					{
//						tv_sight = v_cible_pos - OBJ_PosGet()
//						@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
//						break
//					}
//					case Ci_mode_depl_charogne_visuel :
//					{
//						tv_sight = @o_cible OBJ_PosGet() - OBJ_PosGet()
//						@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
//						break
//					}
					case Ci_mode_depl_attaque :
					{
						tv_sight = @o_cible_attaque OBJ_PosGet() - @o_next_wp OBJ_PosGet()
						if( MATH_VecNullEpsilon(tv_sight) )
							tv_sight = OBJ_SightGet()
						@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)		// maintenant que la bat attend, c du BGS
						break
					}
					case Ci_mode_depl_attente :
					{
						tv_sight = @o_cible_depl OBJ_PosGet() - @o_tmp_obj_next OBJ_PosGet()
						if( MATH_VecNullEpsilon(tv_sight) )
							DBG_Error("Attention, la bat a du être initialisée sur un wp du réseau !!!")
						@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
						break
					}
					case Ci_mode_depl_charogne_transport :
					{
				 		tv_sight = OBJ_SightGet()
				 		@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
				 		break
				 	}
				 	case Ci_mode_depl_retour_se_percher :
				 	{
					 	tv_sight = v_perchee_init_pos - tv_collide_pos
				 		@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
					 	break
					}
				 	default:
				 	{
					 	DBG_BreakPoint()
					 	break
					}
				}
			}
			else
			{
				tv_sight = tv_collide_pos - OBJ_PosGet()		// il reste des wp à parcourir -> sight dans le sens du déplacement
				if( MATH_VecNullEpsilon(tv_sight) )
					tv_sight = OBJ_SightGet()
				@o_tmp_obj_next OBJ_SightGeneralSet( tv_sight, Cv_VerticalVector)
			}
			
			o_next_wp = o_tmp_obj_next
		}
		else if( ! i_perchee_retour_post_rezo_flag )
		{
			// v_dest_pos et v_dest_sight précalculés
			@o_tmp_obj_next OBJ_PosSet( v_dest_pos )
	 		@o_tmp_obj_next OBJ_BankingGeneralSet( v_dest_sight, Cv_VerticalVector )
			o_next_wp = o_tmp_obj_next
		}
		// else le wp a déjà été positionné et orienté
	}
	
	if( ! o_next_wp )
		o_next_wp = o_next_wp
}

procedure_local int BC_Take_Paf()
{
	// RESTRICTION PAFS POUR LE BOSS
	if( BC_Boss() )
	{
		if( f_boss_delai_paf_perforant )
			return faux
		else if( i_mode_neuneu )
			return vrai
		else
		{
			switch( i_etat_courant )
			{
				case ETAT_Fight_Wait_Prio :
				case ETAT_Fight_Wait_Begin :
				case ETAT_Fight_Approche :
				case ETAT_Fight_Pause :
				case ETAT_Fight_Remonte :
				case ETAT_Mort : 	// paf ciné
					// je prend les pafs
					return vrai
					break
				case ETAT_Move_Decolle :
					if( i_etat_ancien == ETAT_Paf_Air )
						return faux		// pas 2 pafs successifs
					else
						return vrai
					break
				default:
					// j'ignore les pafs
					if( f_boss_ronde_delai_take_paf )
						return vrai
					else
						return faux
					break
			}
		}
	}
	
	if( ! i_take_paf )
		return faux
	
	return vrai
}

procedure_local void BC_GFX_Particules(vector tv_pos, vector tv_paf_dir) 
{
	int			pi_GFX_Blood
	color 		tc_materiau_color
	int			ti_materiau_num
	vector	tv_lat2_axis, tv_lat_axis 
	
//	tc_materiau_color = 0x002E2E41
//	tc_materiau_color = materiau_color
//	tc_materiau_color = 0x002c316c
	tc_materiau_color = 0x0048201c
//	ti_materiau_num = materiau_nb
	ti_materiau_num = 35
	tv_lat_axis = MATH_VecCrossProduct(tv_paf_dir, Cv_VerticalVector)
	tv_lat2_axis = MATH_VecCrossProduct(tv_paf_dir, tv_lat_axis)
	
	pi_GFX_Blood = GFX_Add(13)																// Create the boum
	GFX_MaterialSet(pi_GFX_Blood, get_SFX_light_and_smoke, -1)
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, ti_materiau_num)									// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13100, 100)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, 50)														// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.2)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 0.8)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.0)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.2)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.5)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.15 )													// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.3 )														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
	GFX_Seti(pi_GFX_Blood, 13103, 0x00000000 + tc_materiau_color)					// Color fase 0
	GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + tc_materiau_color)					// Color fase 1
	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + tc_materiau_color)					// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 5)															// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 10)														// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -1.0)														// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, tv_paf_dir)												// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13201, (tv_paf_dir * 5.0) + (tv_lat_axis * 5.0) + (tv_lat2_axis * 5.0) )	// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, (- tv_paf_dir * 5.0) - (tv_lat_axis * 5.0 ) - (tv_lat2_axis * 5.0 ) )	// Speed max
}


// PLONGEON ( DELAI ET SOUND ) ================================================
procedure_local void BC_Update_Global_Last_Plongeon_Time()
{
	@get_global f_time_bats_last_plongeon = TIME_Get()
}

procedure_local void BC_Update_Global_Plongeon_Delay()
{
	@get_global f_bat_plongeon_delay += f_plongeon_desynchro_time
}

procedure_local void BC_Global_Plongeon_Sound_Play()
{
	if( TIME_Elapsed(@get_global f_time_bats_last_plongeon, 1.5) )
		@get_global i_bat_perchee_plongeon_modulo = 0		// RAZ modulo
	
	if( @get_global i_bat_perchee_plongeon_modulo == 0 )
	{
		SND_RequestPlay(Ci_SND_Cri_Attack_Loin)
//		DBG_TraceString("SOUND PLAY")
//		DBG_TraceEOL()
	}
//	else
//	{
//		DBG_TraceString("sound pas played...")
//		DBG_TraceEOL()
//	}
}

//============================================================================
// Retourne vrai si l'état courant de la bat autorise la gestion des collisions molles, faux sinon
//============================================================================
procedure_ultra int BC_SoftCol_IsEnabled()
{
	if( ! f_HP )
		return faux
	
	if( BC_Follower() )
		return faux
	
	if( i_modele == Ci_MODELE_Bat_Noire )
		return faux
		
	switch( i_etat_courant )
	{
		case ETAT_Agonie :
		case ETAT_Mort :
		case ETAT_Paf_Air :
		case ETAT_Paf_Sol :
		case ETAT_Paf_Ecrase :
		case ETAT_Paf_Explose :
		case ETAT_Chute_Libre :
		case ETAT_Chute_wp :
		case ETAT_Brule :
		case ETAT_Move_Decolle :
		case ETAT_Move_Atterrit :
		case ETAT_Mange :
		case ETAT_Wait_Grotte :
		case ETAT_Wait_Perche :
//		case ETAT_Move_Olfactif :
//		case ETAT_Move_Visuel :
			return faux
		case ETAT_Fight_Contact :
//			if( i_modele == Ci_MODELE_Bat_Grise && ACT_ActionGet() == ACTION_Falaise_Attaque ) //  i_attaque_positionnement == Ci_attaque_positionnement_attack_en_cours )
//				return faux
//			else
				return vrai
		case ETAT_Move_Cadavre : 
//			if( i_cadavre_mode == Ci_cadavre_mode_deplacement )
				return vrai
//			else
//				return faux
		default:
			if( BC_IsEtatCine(i_etat_courant) )
				return faux
			else
				return vrai
	}
}

//==================================================================================================
// PRECAL DES COLLISIONS MOLLES
//==================================================================================================
procedure_local void BC_Precompute_Dist()
{
	int		ti_i
	int		ti_k	
	int		ti_iterations_nb

	float	tf_dist

	object	to_bat_i
	object	to_bat_k

	vector	tv_temp
	vector	tv_move_dir[100]

	if (@get_global i_soft_col_bat_computed)
		return
		
	@get_global i_soft_col_bat_computed = vrai
	
	for (ti_i = 0; ti_i < @get_global i_soft_col_bat_nb; ti_i++)
	{
		to_bat_i	 = @get_global ao_soft_col_bat[ti_i]
		@get_global av_soft_sol_bat_pos[ti_i] = @to_bat_i OBJ_PosGet()
	
		ti_iterations_nb = 0

		for (ti_k = ti_i + 1; ti_k < @get_global i_soft_col_bat_nb; ti_k++)
		{
			ti_iterations_nb++
			
			to_bat_k = @get_global ao_soft_col_bat[ti_k]

			if (@to_bat_i BC_SoftCol_IsEnabled() && @to_bat_k BC_SoftCol_IsEnabled())
			{
				tv_temp = @to_bat_i OBJ_PosGet() - @to_bat_k OBJ_PosGet()
				DBG_RenderVector(@to_bat_k OBJ_PosGet(), tv_temp, color_blanc)
	
				tf_dist = MATH_VecSquareNorm(tv_temp)
			}
			else
			{
				tf_dist = Cf_Infinit
			}
			
			@get_global af_soft_col_bat_dist[ti_i][ti_k] = tf_dist
			@get_global af_soft_col_bat_dist[ti_k][ti_i] = tf_dist
			
//			if (ti_iterations_nb == 10)
//				break
		}
	}

	return
}


//==================================================================================================
// DETECTION DES COLLISIONS MOLLES
//==================================================================================================
procedure_local int BC_SoftCol_Check(byref vector tv_col_move_axis)
{
	int			ti_i
	float		tf_dist_to_budy
	float		tf_intersection_dist
	float		tf_intersection_sqr_dist
	vector	tv_me_to_budy
	float		tf_dist_proj_horiz
	object	to_nearest_budy
	int			ti_decal_horiz
	float		tf_Z
	float		tf_dist_decal
	float		tf_norm
	object	to_bat			

	if (i_my_index == -1)
		return(faux)

	tv_col_move_axis = Cv_NullVector
	tf_Z = 0.0
	if( BC_est_au_sol() )
		return faux
		
	BC_Precompute_Dist()

	if( i_etat_courant == ETAT_Fight_Contact )
		ti_decal_horiz = vrai
	else
		ti_decal_horiz = faux

	for (ti_i = 0; ti_i < @get_global i_soft_col_bat_nb; ti_i++)
	{
		if( ti_i == i_my_index )
			continue
		
		to_bat = @get_global ao_soft_col_bat[ti_i]
	
		tf_intersection_dist = f_softcol_rayon_current * f_zoom
		tf_intersection_dist += @to_bat BC_SoftCol_Rayon_Get() * @to_bat OBJ_ZoomGet()

		tf_intersection_sqr_dist = tf_intersection_dist * tf_intersection_dist
		
		tv_me_to_budy = @get_global av_soft_sol_bat_pos[ti_i] - @get_global av_soft_sol_bat_pos[i_my_index]
		
//		if( ti_decal_horiz )
//			tv_me_to_budy.z = 0.0			// décalage forcé à l'horizontale
//		
//		if( f_softcol_no_down_delai )		// décalage vers le bas interdit
//			tv_me_to_budy.z = MATH_FloatMax(tv_me_to_budy.z, 0.0)
//		
		tf_dist_to_budy = @get_global af_soft_col_bat_dist[i_my_index][ti_i]
		if (tf_dist_to_budy > 0.001 && tf_dist_to_budy < tf_intersection_sqr_dist )
		{
			DBG_RenderSphere(@get_global av_soft_sol_bat_pos[i_my_index], f_softcol_rayon_current * f_zoom, 0x80000080)	
		
			tf_dist_to_budy = MATH_FloatSqrt(tf_dist_to_budy)
		
			tv_me_to_budy /= tf_dist_to_budy
			tv_me_to_budy *= tf_intersection_dist - tf_dist_to_budy

			if( ti_decal_horiz )
				tv_me_to_budy.z = 0.0			// décalage forcé à l'horizontale
			
			if( f_softcol_no_down_delai )		// décalage vers le bas interdit
				tv_me_to_budy.z = MATH_FloatMax(tv_me_to_budy.z, 0.0)
	
			tv_col_move_axis -= tv_me_to_budy
		}

//		if ( ao_budy[ti_i] && @ao_budy[ti_i] BC_SoftCol_IsEnabled() )
//		{
//			// c'est une bat toujours vivante
//			tf_intersection_dist = f_softcol_rayon_current * f_zoom
//			tf_intersection_dist += @ao_budy[ti_i] BC_SoftCol_Rayon_Get() * @ao_budy[ti_i] BC_Zoom_Get()
//			tf_intersection_sqr_dist = tf_intersection_dist * tf_intersection_dist
//			
//			tv_me_to_budy = (@ao_budy[ti_i] OBJ_PosGet() + @ao_budy[ti_i] BC_SoftCol_Decal_Get()) - (OBJ_PosGet() + v_softcol_decal_current )
//			
//			if( ti_decal_horiz )
//				tv_me_to_budy.z = 0.0			// décalage forcé à l'horizontale
//			
//			if( f_softcol_no_down_delai )		// décalage vers le bas interdit
//				tv_me_to_budy.z = MATH_FloatMax(tv_me_to_budy.z, 0.0)
//			
//			tf_dist_to_budy = MATH_VecDotProduct(tv_me_to_budy, tv_me_to_budy)
//			if( tf_dist_to_budy < tf_intersection_sqr_dist )
//			{
//				DBG_RenderVector(OBJ_PosGet(), tv_me_to_budy, color_jaune)
//				tf_dist_decal = MATH_FloatSqrt(tf_intersection_sqr_dist - tf_dist_to_budy)
//				if( ! MATH_VecNullEpsilon(tv_me_to_budy) )
//					MATH_VecSetNormalize(tv_me_to_budy)
//				tv_col_move_axis -= tf_dist_decal * tv_me_to_budy
//			}
//		}
	}
//	DBG_RenderVector(OBJ_PosGet(), tv_col_move_axis, color_vert)
	if( ! MATH_VecNullEpsilon(tv_col_move_axis) )
	{
		// il y a soft coll
		if( MATH_VecDotProduct(OBJ_SightGet(), tv_col_move_axis) < 0 )
		{
			tf_Z = tv_col_move_axis.z
			tf_dist_proj_horiz = MATH_VecDotProduct(OBJ_HorizonGet(), tv_col_move_axis)
			tv_col_move_axis = OBJ_HorizonGet() * tf_dist_proj_horiz
			if( ! ti_decal_horiz )
				tv_col_move_axis.z = tf_Z
			DBG_RenderVector(OBJ_PosGet(), tv_col_move_axis, color_cyan)
		}
		// collisions molles limitées
		tf_norm = MATH_VecSquareNorm(tv_col_move_axis)
		if (tf_norm > Cf_soft_coll_norm_max * Cf_soft_coll_norm_max)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_col_move_axis /= tf_norm * Cf_soft_coll_norm_max
		}
//		MATH_VecSetNorm(tv_col_move_axis, MATH_FloatMin(MATH_VecNorm(tv_col_move_axis), Cf_soft_coll_norm_max) )
		return vrai
	}
	else
		return faux
}

procedure_local void BC_SoftCol_ForgetMe()
{
	object to_bat
	if (i_my_index != -1)
	{
		@get_global i_soft_col_bat_nb--
		@get_global ao_soft_col_bat[i_my_index] = @get_global ao_soft_col_bat[@get_global i_soft_col_bat_nb]
		to_bat = @get_global ao_soft_col_bat[@get_global i_soft_col_bat_nb]
		@get_global ao_soft_col_bat[@get_global i_soft_col_bat_nb] = nobody
	
		if (to_bat && @to_bat AI_IsModel(get_PNJ_Bats_path))
			@get_PNJ_Bats_path to_bat i_my_index = i_my_index
	
		i_my_index	 = -1
	}
}


// WATER ================================================================================
procedure_local int BC_IsWater(vector tv_pos)
{
	int		ti_capa	
	ti_capa = GRID_CapaGet(tv_pos)
	ti_capa &= tag_grid_terrain
	switch(ti_capa)
	{
		case Ci_sol_eau :
		case Ci_sol_eau_basse :
		case Ci_sol_eau_basse_herbe :
		case Ci_sol_eau_herbe :
		case Ci_sol_eau_mouche_feu :
			return(vrai)
		default:
			return(faux)
	}
}
procedure_local void BC_Check_WaterZ()
{
	vector		tv_ray_start
	object		to_collide_object
	float			tf_ray_length
	switch( i_modele )
	{
		case Ci_MODELE_Bat_Noire :
			tf_ray_length = 10.0
			break
		default:
			tf_ray_length = 2.0
			break
	}
	if( BC_IsWater(OBJ_PosGet()) && f_water_Z < -1000.0)
	{
		tv_ray_start = OBJ_PosGet()
		tv_ray_start.z += (tf_ray_length * 0.5)		// penser à la bat noire !!!
		DBG_RenderVector(tv_ray_start,  - Cv_VerticalVector * tf_ray_length, color_blanc)
		to_collide_object = COL_RayObject_Dist(tv_ray_start, - Cv_VerticalVector, tf_ray_length, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_Crossable)
		if (to_collide_object && COL_GMAT_FlagsGet(COL_C_Ray) & Gmat_KK_Face_eau)
			f_water_Z = COL_RayObject_PosGet().z
	}
}
procedure_local float BC_Get_Water_DiffZ()
{
	switch( i_modele )
	{
		case Ci_MODELE_Bat_Grise :
			return 1.8
		case Ci_MODELE_Bat_Noire :
			return 4.5
		default:
			return 0.5
	}
}
// WATER ================================================================================


procedure_local int BC_Ready_to_be_Eaten()
{
	if( i_etat_courant == ETAT_Mort )
	{
//		if( ! i_splash_flag )
			return vrai
//		else if( i_splash_flag_posok )
//			return vrai
	}
	return faux
}


// STATS ==============================================================
procedure_local void BC_STATS_NMI_Killed(object to_enemy_killed_sender)
{
	if( ! to_enemy_killed_sender )
		to_enemy_killed_sender = o_jack
	if( ! i_stats_nmi_killed_done )
	{
		i_stats_nmi_killed_done = vrai
		switch (i_modele)
		{
			case Ci_MODELE_Bat_Noire :
				if( BC_Boss() )		// ne pas comptabiliser la bat noire ciné
					STATS_IncEnemyKilled_New(to_enemy_killed_sender, C_EnemyType_Bat_Noire, 0 )
				break
			case Ci_MODELE_Bat_Grise :
				STATS_IncEnemyKilled_New(to_enemy_killed_sender, C_EnemyType_Bat_Normale, 0 ) 
				break
			case Ci_MODELE_Bat_Rouge :
			case Ci_MODELE_Bat_Mini :
				STATS_IncEnemyKilled_New(to_enemy_killed_sender, C_EnemyType_Bat_Rouge, 0 ) 
				break
			default: 
				STATS_IncEnemyKilled_New(to_enemy_killed_sender, C_EnemyType_Unkonwn, 0 ) 
				break
		}
	}
}

// WP DE CHUTE ============================================
procedure_local int BC_Chute_WP_mode_reservation(object to_wp)
{
	if( to_wp.des_flags & DSF_Jack_Bats_Chute_Reservation )
		return vrai
	return faux
}
procedure_local int BC_Chute_WP_reservation_get(object to_wp)
{
	if( to_wp.des_flags & DSF_Jack_Bats_Chute_Reserved )
		return vrai
	return faux
}
procedure_local void BC_Chute_WP_reservation_set(object to_wp)
{
	to_wp.des_flags |= DSF_Jack_Bats_Chute_Reserved
}
procedure_local void BC_Chute_WP_reservation_free(object to_wp)
{
	to_wp.des_flags &= ~DSF_Jack_Bats_Chute_Reserved
}
procedure_local int BC_Chute_WP_Special_Bat_Noire(object to_wp)
{
	if( to_wp.des_flags & DSF_Jack_Bat_Noire_Chute )
		return vrai
	return faux
}
procedure_local object BC_Chute_WP_Select()
{
	int				ti_i
	object		to_wp
	object		to_best_wp
	object		to_best_wp_noire
	float			tf_dist
	float			tf_best_dist
	float			tf_best_dist_noire
	to_best_wp = nobody
	tf_best_dist = Cf_Infinit
	to_best_wp_noire = nobody
	tf_best_dist_noire = Cf_Infinit
	if( BC_Boss() && o_attaque_finale_wp_chute )
	{
		to_best_wp = o_attaque_finale_wp_chute
		i_points_de_chute = faux		// blindage pas de recalcul...
	}
	else if( i_points_de_chute )
	{
		// si la bat a été configurée pour checker les points de chute
		for( ti_i = 0; ti_i < @get_list_manager i_chute_bats_wp_nb; ti_i++ )
		{
			// recherche des points de chute dans la liste globale
			to_wp = @get_list_manager ao_chute_bats_wp[ti_i]
			if( @to_wp OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Active )
			{
				// s'il n'y a pas besoin de réserver ce point ou s'il est libre
				if( ! BC_Chute_WP_mode_reservation(to_wp) || ! BC_Chute_WP_reservation_get(to_wp) )
				{
					tf_dist = OBJ_SqrDist(to_wp)
					
					// calcul wp special bat noire
					if( i_modele == Ci_MODELE_Bat_Noire && BC_Chute_WP_Special_Bat_Noire(to_wp) )
					{
						if( tf_dist < tf_best_dist_noire)
						{
							to_best_wp_noire = to_wp
							tf_best_dist_noire = tf_dist
						}
					}
					
					// calcul wp standard
					if( tf_dist < tf_best_dist)
					{
						to_best_wp = to_wp
						tf_best_dist = tf_dist
					}
				}
			}
		}
		// j'ai 1 wp special bat noire, je prend celui là
		if( to_best_wp_noire )
		{
			to_best_wp = to_best_wp_noire
			tf_best_dist = tf_best_dist_noire
		}
		// j'ai 1 wp de chute
		if( to_best_wp && BC_Chute_WP_mode_reservation(to_best_wp) )
		{
			i_chute_reservation_flag = vrai
			BC_Chute_WP_reservation_set(to_best_wp)
		}
	}
	return to_best_wp
}
// WP DE CHUTE ============================================


procedure_local int BC_CanAttackMyPafActor()
{
//	if( BC_Follower() )
//		return faux
	if( f_sum_pafs_force )
		return vrai
	if( ( i_paf_type & C_PAF_KK_Repousse) && i_repousse_pendant_attaque )
		return vrai
	return faux
}


// GESTION UNCOL ==========================================
procedure_local void BC_UncollideAdd(object to_gao, float tf_duration)
{
	int		ti_index
	ti_index = ARR_ObjSearch(&ao_uncollide_gao[0], i_uncollide_gao_nb, to_gao)
	if (ti_index == -1)
	{
		ao_uncollide_gao[i_uncollide_gao_nb] = to_gao
		af_uncollide_duration[i_uncollide_gao_nb] = tf_duration
		i_uncollide_gao_nb++
		COL_UnCollidableAdd(to_gao)
		if( i_DBG_trace_etat )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : uncol ADD avec")
			DBG_TraceObject(to_gao)
			DBG_TraceEOL()
		}
	}
	else
		af_uncollide_duration[ti_index] = tf_duration
}

procedure_local void BC_UncollideDel(object to_gao)
{
	int		ti_index
	ti_index = ARR_ObjSearch(&ao_uncollide_gao[0], i_uncollide_gao_nb, to_gao)
	if (ti_index != -1)
		af_uncollide_duration[ti_index] = 0.0
}

procedure_local void BC_UncollideCheck()
{
	int		ti_i
	for (ti_i = 0; ti_i < i_uncollide_gao_nb; ti_i++)
	{
		if (af_uncollide_duration[ti_i] == -1.0)
			continue

		if (af_uncollide_duration[ti_i] <= 0.0 && ! OBJ_LIB_Virtual_Collision(OBJ_Me(), ao_uncollide_gao[ti_i], faux))
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : uncol DEL avec")
				DBG_TraceObject(ao_uncollide_gao[ti_i])
				DBG_TraceEOL()
			}
			COL_UnCollidableDel(ao_uncollide_gao[ti_i])
			i_uncollide_gao_nb--
			af_uncollide_duration[ti_i] = af_uncollide_duration[i_uncollide_gao_nb]
			ao_uncollide_gao[ti_i] = ao_uncollide_gao[i_uncollide_gao_nb]
			af_uncollide_duration[i_uncollide_gao_nb] = -1.0
			ao_uncollide_gao[i_uncollide_gao_nb] = nobody
		}

		af_uncollide_duration[ti_i] -= MATH_FloatMin(af_uncollide_duration[ti_i], TIME_GetDt())
	}
}

procedure_local void BC_Obstacle_Check(int ti_wall_ground)
{
	object		to_ray_object					// obstacle rencontré par le lancer de rayon
	object		to_col_object					// obstacle rencontré par le lancer de rayon
	
	vector		tv_obstacle_pos				// position de l'obstacle
	vector		tv_to_obstacle					// vecteur de contact avec l'obstacle
	vector		tv_sight
	vector		tv_obstacle_dir
	
	if( COL_CollideType(ti_wall_ground) )
	{
		to_col_object = COL_ObjectGet(ti_wall_ground)
		if( to_col_object && ! @to_col_object OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims) )
		{
			// je touche un mur, mais pas un perso
			tv_obstacle_pos = COL_CollidedPointGet(ti_wall_ground)
			tv_obstacle_dir = tv_obstacle_pos - OBJ_PosGet()
			if( ! MATH_VecNullEpsilon(tv_obstacle_dir) )
				MATH_VecSetNormalize(tv_obstacle_dir)
			if( MATH_VecDotProduct(OBJ_SightGet(), tv_obstacle_dir) > 0.0 ) // Cf_Cos30 )
			{
				DBG_RenderVector(tv_obstacle_pos, OBJ_PosGet() - tv_obstacle_pos, color_cyan)		// obstacle
				f_obstacle_duration += TIME_GetDt()
				if( f_obstacle_duration >= 3.0 )
				{
					// UN OBSTACLE A ETE DETECTE  : mur, ou LRAY + ( il est plus haut que mon point d'attaque OU il est trop proche de ma destination -> je vais rentrer dedans )
					i_flag_obstacle = vrai
					f_time_since_last_obstacle = 0.0
					i_force_test_inclinaison = vrai
					
					i_flag_frein = vrai
					
					i_flag_reach_attack_wp = faux		// position d'attaque annulée -> le bat devra en recalculer une nouvelle
				}
			}
		}
	}
}


//if( ! BC_IsEtatCine(i_etat_courant) && ! BC_IsEtatAttaque(i_etat_courant) && ! o_cible_attaque && f_HP && ! BC_Boss() && ! BC_Follower() && ( ! BC_est_au_sol() || i_etat_courant == ETAT_Mange ) && i_etat_courant != ETAT_Paf_Air )
procedure_local int BC_Detect_Proximity_Shoot()
{
	if( ! f_HP )
		return faux
	if( i_modele == Ci_MODELE_Bat_Noire )
		return faux
//	if( BC_Boss() )
//		return faux
	if( BC_Follower() )
		return faux
	if( o_cible_attaque )
		return faux
	if( BC_IsEtatCine(i_etat_courant) )
		return faux
	if( BC_IsEtatAttaque(i_etat_courant) )
		return faux
	if( i_etat_courant == ETAT_Paf_Air )
		return faux
	if( BC_est_au_sol() && i_etat_courant != ETAT_Mange)		// pas de détection une fois au sol (sauf si c'est pour manger)
		return faux
	return vrai
}

