#include "BC_defines.var"


#define		Cf_bone_look_blend_coef		0.2		// pourcentage de blend selon les os

int				ti_i

object		to_head

float			tf_look_cur_coef

vector 		tv_final
vector 		tv_cur
vector		tv_look_dir
vector		tv_tar
vector		tv_anim_banking[3]


if (@get_global i_IK_NECK_Off)
	return

if( i_etat_courant == ETAT_Fade || ( i_etat_courant == ETAT_Mort && f_time_start_etat > 0.5 ) )
	return

if( i_flag_neck
	&& ! MATH_VecNullEpsilon(v_softcol_decal_perfect) 
	&& MATH_VecNorm(v_softcol_decal_current) > (Cf_soft_coll_norm_max * 0.25 ) 
	&& i_etat_courant != ETAT_Fight_Approche
	&& i_etat_courant != ETAT_Fight_Contact )
{
	// regarde la bat qui la collisionne (sens opposé des collisions)
	v_look_pos = OBJ_PosGet() - ( 10.0 * MATH_VecNormalize(v_softcol_decal_perfect) )
}


tf_look_cur_coef = 0.0			// pourcentage d'application du blend (pourcentage de répartition selon les os)

// Recup des orientations des bones de la tête dans l'anim
for (ti_i = (Ci_head_bones_count -1); ti_i >= 0; ti_i--)
{
	tv_anim_banking[ti_i] = @ao_head_bones[ti_i] OBJ_BankingGet()
}

// CALCUL des positions des os de la tête
for (ti_i = (Ci_head_bones_count -1); ti_i >= 0; ti_i--)
{
	tv_cur = v_cur_look_pos - @ao_head_bones[ti_i] OBJ_PosGet()								// vecteur courant du regard	
	if( MATH_VecNullToler(tv_cur, 0.01) )
		tv_cur = (OBJ_SightGet() * 0.5)
	if( i_flag_neck )
	{
		tv_final = v_look_pos - @ao_head_bones[ti_i] OBJ_PosGet()									// vecteur final du regard
		if( MATH_VecNullToler(tv_final, 0.01) )
			tv_final = OBJ_SightGet()

		if( i_DBG_look_all )
		{
			DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_cur, color_jaune)
			DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_final, color_rose)
		}
		tv_final = MATH_VecInCone(tv_final, OBJ_SightGet(), Cf_PiBy2, 0)							// vecteur recadré dans le cone de vision
		if( i_DBG_look_all )
		{
			DBG_RenderCone( @ao_head_bones[ti_i] OBJ_PosGet(), OBJ_SightGet() * 20, Cf_PiBy3, 0x40000080)	// cône de vision
			DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_final, color_rouge)
		}
		tv_look_dir = MATH_VecBlendRotate( tv_cur, tv_final , 4 * TIME_GetDt())				// blend de l'axe du regard
	}
	else
	{
		tv_look_dir = MATH_VecBlendRotate( tv_cur, tv_anim_banking[ti_i], 10 * TIME_GetDt())				// blend de l'axe du regard
		//tv_look_dir = tv_anim_banking[ti_i]		// revient dans l'axe donné par l'anim
	}
	
	if( i_DBG_look_all )
	{
		DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_look_dir, color_vert)
	}
	
	if( ti_i )		// cou, bosse
		tf_look_cur_coef += Cf_bone_look_blend_coef
	else		// tete
		tf_look_cur_coef = 1.0
	
	tv_tar = MATH_VecBlendRotate( @ao_head_bones[ti_i] OBJ_BankingGet(), tv_look_dir, tf_look_cur_coef )
	@ao_head_bones[ti_i] OBJ_Rotate_FromTo(cvector(0,0,1), @ao_head_bones[ti_i] MATH_VecGlobalToLocal(tv_tar) )
}

// BACKUP vision générale du bat pour le exec_check_vision de la trame suivante
to_head = ANI_CanalObjectGet(Anim_Canal_Tete)
v_look_head_pos = @to_head OBJ_PosGet()
v_look_axis = @to_head OBJ_BankingGet()

// BACKUP vision générale du bat pour le exec_neck de la trame suivante
v_cur_look_pos = tv_look_dir + @to_head OBJ_PosGet()

if( i_DBG_look_pos )
{
	DBG_RenderVector( @to_head OBJ_PosGet(), tv_look_dir, color_jaune)			// vue du bat vers le point à regarder
}


