#include "BC_defines.var"

messageid		tmid_vision

object			to_new_target
object			to_actor

i_fight_exit_flag = faux

if( i_DBG_track_test )
	return

if( ! i_attaque_fin_desynchro_flag )
{
	// ATTAQUE EN COURS =============================================
	
	// VALIDITE TARGET
	if( ! BC_Target_Check(o_cible_attaque, faux) )
	{
		BC_DBG_Trace_Etat_Gao("cible non valide (ignore target ou blind zone ou territoire ou cache) : ", o_cible_attaque)
		goto FIGHT_EXIT_DESYNCHRO
	}
	
	
	// FEU --------------------------------------
	if( BC_ForceInactive() && ! BC_Boss() )
	{
		BC_DBG_Trace_Etat("il y a du feu... ")
		goto FIGHT_EXIT_DESYNCHRO
	}
	
	
	// VISION --------------------------------------------------------------------------------------------------------------
	if( ! BC_Seen_Actor_Test(o_cible_attaque, tmid_vision) )
	{
		BC_DBG_Trace_Etat("cible perdue de vue...")
		goto FIGHT_EXIT_DESYNCHRO
	}
	
	
	// Déjà Grabbé ---------------------------------------------------------------------
	if( BC_Get_Interet_Status_Model_Nb(o_cible_attaque, C_EVENT_InteretStatusGrab, vrai) )
	{
		BC_DBG_Trace_Etat("ma cible est déjà grabbée par une autre bats...")
		goto FIGHT_EXIT_DESYNCHRO
	}

	
	// Test présence d'une bat noire -------------------------------------------
	if( i_modele != Ci_MODELE_Bat_Noire )
	{
		if( BC_Gao_Has_Interet_From_Bat_Model(o_cible_attaque, Ci_MODELE_Bat_Noire) )
		{
			BC_DBG_Trace_Etat("une bat Noire m'a piqué ma cible...")
			goto FIGHT_EXIT_DESYNCHRO
		}
	}
	
	
	// Durée --------------------------------------------------------------------------------
	if( ! BC_IsEtatCine(i_etat_courant) 
		&& i_etat_courant == ETAT_Fight_Contact 
		&& f_time_start_etat >= f_attaque_duree_poursuite 
		&& ! i_attaque_infinie 
		&& ! BC_Boss() )
	{
		BC_DBG_Trace_Etat("durée de poursuite dépassée")
		goto FIGHT_EXIT_DESYNCHRO
	}
	
	
	// Distance --------------------------------------------------------------------------------
	if( ! BC_IsEtatCine(i_etat_courant)
		&& MATH_VecNorm(v_falaise_init_cible_pos - @o_cible_attaque OBJ_PosGet()) > f_attaque_dist_stoppe_poursuite 
		&& i_etat_courant == ETAT_Fight_Contact 
		&& ! i_attaque_infinie 
		&& ! BC_Boss() )
	{
		BC_DBG_Trace_Etat("distance de poursuite dépassée")
		goto FIGHT_EXIT_DESYNCHRO
	}
	
	
	// Nouveau Cadavre ----------------------------------------------------------------------
	if( ! BC_IsEtatCine(i_etat_courant) && ! BC_Boss() )
	{
		to_actor = BC_Cadavre_Nearest(vrai)
		if( to_actor )
		{
			o_cadavre = to_actor			// NEW CADAVRE
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" : détection d'un nouveau cadavre : ")
				DBG_TraceObject(to_actor)
				DBG_TraceEOL()
			}
			BC_Charognard_Mode_Force()
			goto FIGHT_EXIT_DESYNCHRO
		}
	}
	
	
	// Trigger d'interruption d'attaque--------------------------------------------------------
	if( AI_TriggerIsValid(trig_stop_attaque) && call_trigger(trig_stop_attaque) )
	{
		BC_DBG_Trace_Etat("trigger d'interruption d'attaque")
		goto FIGHT_EXIT_DESYNCHRO
	}
	
	
	// Obstacle ----------------------------------------------------------------------------------
	AI_Execute("BC_exec_check_obstacle")
	if( i_flag_obstacle 
		&& ! BC_Boss() )
	{
		BC_DBG_Trace_Etat("s'est pris un obstacle !!! ")
		goto FIGHT_EXIT_NOW
	}
}
else
{
	// DESYNCHRONISATION FIN D'ATTAQUE EN COURS =============================================
	o_cible_attaque = o_attaque_fin_desynchro_gao
	if( ! f_time_attaque_fin_desynchro )
	{
		// délai désynchro terminé
		i_attaque_fin_desynchro_flag = faux
		if( BC_Check_New_Target(to_new_target) )
		{
			i_agresseur_ID = BC_Get_ID(to_new_target)
			o_cible_attaque = to_new_target
			v_falaise_init_cible_pos = @o_cible_attaque OBJ_PosGet()
			f_time_start_etat = 0.0
			BC_Charognard_Mode_Reset()
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" -> change de cible => ")	
				DBG_TraceObject(to_new_target)
				DBG_TraceEOL()
			}
		}
		else
		{
			if( i_DBG_trace_etat )
			{
				DBG_TraceObject(OBJ_Me())
				DBG_TraceString(" -> attaque annulée (etat ")
				switch( i_etat_courant )
				{
					case ETAT_Fight_Approche :
					DBG_TraceString("fight approche")
					break
					case ETAT_Fight_Contact :
					DBG_TraceString("fight contact")
					break
					case ETAT_Fight_Network :
					DBG_TraceString("fight network")
					break
					case ETAT_Fight_Pause :
					DBG_TraceString("fight pause")
					break
					case ETAT_Fight_Wait_Begin :
					DBG_TraceString("fight wait begin")
					break
					case ETAT_Fight_Wait_Prio :
					DBG_TraceString("fight wait prio")
					break
					default:
					DBG_TraceString("???")
					break
				}
				DBG_TraceString(")")
				DBG_TraceEOL()
			}
			
			if( i_perchee_fake_attaque )
				goto FIGHT_EXIT_FAKE_WAIT
			else
				goto FIGHT_EXIT_NOW
		}
	}
}


// DEBUT DESYNCHRONISATION ================================================================
if( 0 )
{
	FIGHT_EXIT_DESYNCHRO:
	i_attaque_fin_desynchro_flag = vrai
	o_attaque_fin_desynchro_gao = o_cible_attaque
	f_time_attaque_fin_desynchro = BC_Attaque_Desynchro_Time_Get()
	if( i_perchee_fake_attaque )
	{
		f_time_attaque_fin_desynchro += 1.0
	}
	if( i_DBG_trace_etat )
	{
		DBG_TraceString(" : délai de désynchronisation : ")
		DBG_TraceFloat(f_time_attaque_fin_desynchro)
		DBG_TraceEOL()
	}
}


// WAIT DE FIN D'ATTAQUE FAKE ==============================================================
if( i_fight_fake_wait )
{
	FIGHT_EXIT_FAKE_WAIT:
	if( ! i_fight_fake_wait )
	{
		i_fight_fake_wait = vrai
		f_time_fight_fake_wait = MATH_RandFloat(1.0, 2.0)
		i_vitesse_derapage_init = vrai
	}
	else
	{
		f_time_fight_fake_wait -= MATH_FloatMin(f_time_fight_fake_wait, TIME_GetDt())
		if( ! f_time_fight_fake_wait )
		{
			i_fight_fake_wait = faux
			f_speed = 0.0		// décolle avec une vitesse nulle
			goto FIGHT_EXIT_NOW
		}
	}
}

// FIN D'ATTAQUE ==========================================================================
if( 0 )
{
	FIGHT_EXIT_NOW:
	i_fight_exit_flag = vrai
}

