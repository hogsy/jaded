#include "BC_defines.var"

float				tf_interet
float				tf_HP_max
float				tf_liferatio
float				tf_rayon_vision
float				tf_HP_avant_paf
float				tf_rotation_coef
float				tf_rotation_angle_max

vector			tv_ground_normale
vector			tv_2D_pos

int					ti_context
int					ti_ground_ID
int					ti_max_slots
int					ti_type_sol
int					ti_capa
int					ti_NMI_state
int					ti_lieutenant_count

messageid		tmid_vis_ID
messageid		tmid_vision

object			to_ray_object
object			to_obj
object			to_head

string				str_txt

if (i_my_index == -1)
{
	i_my_index = @get_global i_soft_col_bat_nb
	@get_global ao_soft_col_bat[i_my_index] = OBJ_Me()
	@get_global i_soft_col_bat_nb++
}

tv_2D_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())

//if( i_flag_frein )
//	Str_DisplayTextOnce("frein", tv_2D_pos)

//if( IO_ButtonJustPressed(JoyPSX_Button_triangle) )
//	EVENT_AddEventPaf( C_EVENT_FILTER_Enemy, C_PAF_KK_Weapon, o_jack, Cf_EVENT_Duree_1Trame, OBJ_Me(), 5, - OBJ_SightGet())

i_budy_nb = 0

// WAIT SINUS -------------------------------------------------------------------------------------------------
i_wait_sinus_flag = faux
f_wait_sinus_duration -= MATH_FloatMin(f_wait_sinus_duration, TIME_GetDt())
if( f_wait_sinus_duration )
	i_wait_sinus_flag = vrai


// TEST INIT ACTIVATION BOSS -----------------------------------------------------------------------
if( BC_Boss() )
{
	ti_lieutenant_count = @get_global i_bat_noire_lieutenant_nb
	if( i_lieutenant_count_old > 0 && ti_lieutenant_count == 0 )
	{
		f_boss_delai_aucune_attaque = 5.0
		SND_RequestPlay(Ci_SND_Cri_Attack_Loin)
	}
	#ifndef _FINAL_
	if( i_DBG_boss_display_infos )
	{
		Str_DisplayTextOnce("***** BOSS ***** ", cvector(0.37,0,0))
		Str_DisplayTextOnce("Lieutenants = ", cvector(0.35,0.05,0))
		Str_DisplayIntOnce(ti_lieutenant_count, cvector(0.5,0.05,0))
		Str_DisplayTextOnce("pas d'attaque (boss) = ", cvector(0.3,0.1,0))
		Str_DisplayFloatOnce(f_boss_delai_aucune_attaque, cvector(0.52,0.1,0))
		Str_DisplayTextOnce("pas d'attaque (pafs) = ", cvector(0.3,0.15,0))
		Str_DisplayFloatOnce(f_paf_delai_aucune_attaque, cvector(0.52,0.15,0))
		Str_DisplayTextOnce("speed coef = ", cvector(0.35,0.2,0))
		Str_DisplayFloatOnce(f_boss_attack_speed_pct, cvector(0.5,0.2,0))
	}
	#endif
}

//if( ! i_agressive && i_mode_agressif_ON && ! BC_IsEtatAttaque(i_etat_courant) )
//	f_charognard_forced_duration += TIME_GetDt()		// temps de mode charognard forcé

f_time_total += TIME_GetDt()


// SND SPLASH EN MOURANT DANS L'EAU
if( ! f_HP && ! i_splash_flag && (i_etat_courant == ETAT_Chute_Libre || i_etat_courant == ETAT_Chute_wp) && COL_GMatReportGet(Gmat_KK_Face_eau) != -1)
{
	i_splash_flag = vrai
	SND_RequestPlay(Ci_SND_Splash)
}


// COMPTEURS TEMPS A INCREMENTER
f_time_since_last_obstacle += TIME_GetDt()

// COMPTEURS TEMPS A DECREMENTER
f_softcol_no_down_delai -= MATH_FloatMin(f_softcol_no_down_delai, TIME_GetDt())
f_paf_delai_aucune_attaque -= MATH_FloatMin(f_paf_delai_aucune_attaque, TIME_GetDt())
f_charognard_delai_aucune_attaque -= MATH_FloatMin(f_charognard_delai_aucune_attaque, TIME_GetDt())
f_boss_delai_aucune_attaque -= MATH_FloatMin(f_boss_delai_aucune_attaque, TIME_GetDt())
f_time_attaque_fin_desynchro -= MATH_FloatMin(f_time_attaque_fin_desynchro, TIME_GetDt())
f_time_cri_paf -= MATH_FloatMin(f_time_cri_paf, TIME_GetDt())
f_time_cri_presence -= MATH_FloatMin(f_time_cri_presence, TIME_GetDt())
f_time_meat_bite -= MATH_FloatMin(f_time_meat_bite, TIME_GetDt())
f_boss_ronde_delai_take_paf -= MATH_FloatMin(f_boss_ronde_delai_take_paf, TIME_GetDt())
i_boss_delai_paf_perforant_init = faux
f_boss_delai_paf_perforant -= MATH_FloatMin(f_boss_delai_paf_perforant, TIME_GetDt())

// BARBEUC PARTY
if( i_flag_barbeuc && ( i_etat_courant != ETAT_Fade || f_time_start_etat < 2.0) )
{
	f_snd_barbeuc_scream_delay -= MATH_FloatMin(f_snd_barbeuc_scream_delay, TIME_GetDt())
	if( ! f_snd_barbeuc_scream_delay )
	{
		SND_RequestPlay(Ci_SND_Fire_Scream)
		f_snd_barbeuc_scream_delay = MATH_RandFloat(0.75, 1.0)
		
		// simuler paf
		f_time_meat_bite = 0.25
		af_quat_coef[i_quat_index] = 0.3
		f_quat_last_time = TIME_Get()
		af_quat_time[i_quat_index] = f_quat_last_time

		to_head = ANI_CanalObjectGet(Anim_Canal_Tete)
		av_quat_start[i_quat_index] = @to_head OBJ_PosGet()
		av_quat_start[i_quat_index] -= @o_torse OBJ_PosGet()
		MATH_VecSetNormalize(av_quat_start[i_quat_index])
		
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(- OBJ_SightGet(), av_quat_start[i_quat_index])
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(av_quat_start[i_quat_index], av_quat_end[i_quat_index])
		MATH_VecSetNormalize(av_quat_end[i_quat_index])
		
		i_quat_index = MATH_Modulo(i_quat_index + 1, 10)
	}
}

// FLAGS A RESETER A CHAQUE TRAME
i_beziers_flag_cette_trame = faux
f_beziers_speed = 0.0
i_speed_beziers_flag = faux
i_speed_vertical_flag = faux
f_beziers_pourcent = Cf_beziers_pourcent_courbe_standard
i_flag_check_sound_valide = faux
i_flag_check_shoot_done = faux
i_flag_check_vision_done = faux
i_seen_actor_nb = 0
i_calc_pos_suivi_visuel_done = faux
i_vitesse_derapage_init = faux


// CHECK VISION ==============================================================
switch( i_etat_courant )
{
	case ETAT_Mort :
	case ETAT_Fade :
	case ETAT_Agonie :
	case ETAT_Brule :
	case ETAT_Chute_wp :
	case ETAT_Chute_Libre :
	case ETAT_Grabbed :
		break
	default:
		AI_Execute("BC_exec_check_vision")
		break
}

// ANGLE DE ROTATION =========================================================
if( i_modele == Ci_MODELE_Bat_Noire || f_obstacle_duration > 0.0 )
	tf_rotation_angle_max = 20.0
else
	tf_rotation_angle_max = f_angle_rotation_max

if( ( i_modele == Ci_MODELE_Bat_Noire && f_HP == Cf_Life_Big_Bat_Last_Attack )
	|| OBJ_CapaTest(CAPA_Rotation) 
	|| f_rotation_angle_courant > tf_rotation_angle_max 
	|| f_obstacle_duration > 0.0)
{
	if( i_modele == Ci_MODELE_Bat_Noire )
	{
		if( f_paf_delai_aucune_attaque )
			tf_rotation_coef = 5.0
		else
			tf_rotation_coef = 10.0
	}
	else if( f_obstacle_duration > 0.0 )
		tf_rotation_coef = 20.0
	else
		tf_rotation_coef = 10.0
	
	f_rotation_angle_courant = MATH_FloatMin(tf_rotation_angle_max, f_rotation_angle_courant + (tf_rotation_coef * TIME_GetDt()))
}
else
	f_rotation_angle_courant = MATH_FloatMax(0.1, f_rotation_angle_courant - (7 * TIME_GetDt()))


// FACE DE MORT =================================================================
if( BC_Face_De_Mort() )
{
	DBG_TraceObject(OBJ_Me())
	DBG_TraceString(" touche une face ou une BV de mort => destroy")
	DBG_TraceEOL()
	OBJ_Destroy()
}


// CHECK AU SOL OU EN L'AIR ========================================================
if( BC_est_au_sol() )
{
	f_time_air = 0.0
	tv_ground_normale = Cv_NullVector
	if (COL_CollideType(COL_C_Ground))
	{
		tv_ground_normale = COL_ZonePosGet(C_zdm_pied)
		tv_ground_normale -= COL_CollidedPointGet(COL_C_Ground)
		
		if( ! MATH_VecNullEpsilon(tv_ground_normale) )
			MATH_VecSetNormalize(tv_ground_normale)
		
		if (tv_ground_normale.z < 0.0)
			tv_ground_normale*= -1.0
	}
	else
	{
		if( f_time_air > 0.2 )
			tv_ground_normale = Cv_VerticalVector
	}
	
	if( ! MATH_VecNullEpsilon(tv_ground_normale) )
	{
		v_ground_normale = MATH_VecBlendRotate(v_ground_normale, tv_ground_normale, 8.0 * TIME_GetDt())
		DBG_RenderVector(OBJ_PosGet(), v_ground_normale * 10.0, color_bleu)
		if( ! MATH_VecNullEpsilon(v_ground_normale) )
			MATH_VecSetNormalize(v_ground_normale)
	}
}
else
{
	f_time_air += TIME_GetDt()
}

// DYNAMIQUE ===================================================================
if( ! i_splash_flag )
{
	// archimède géré dans le tag on
	if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
	{
		DYN_TractionSet(Cv_NullVector)
		if( i_etat_courant == ETAT_Brule )
		{
			switch( ACT_ActionGet() )
			{
				case ACTION_Paf_Air_Moyen :
					DYN_GravitySet(Cv_NullVector)
					break
				default:
					DYN_GravitySet(Cv_NormalGravity)
					break
			}
		}
		else if( BC_est_au_sol()|| i_etat_courant == ETAT_Chute_Libre )
			DYN_GravitySet(Cv_NormalGravity)
		else
			DYN_GravitySet(Cv_NullVector)
	}
}


// SOUND FLY =================================================
//if( BC_est_au_sol() || i_etat_courant == ETAT_Wait_Grotte || i_etat_courant == ETAT_Wait_Perche )
//{
//	BC_Sound_Fly_Stop()
//}
//else if( OBJ_SqrDist(o_jack) < 225 && f_time_air > 0.4 )
//	BC_Sound_Fly_Play()
//else
//	BC_Sound_Fly_Stop()


// INTERET GRAB ===============================================
if( MSG_GlobalIsValid(mid_grab_charogne) )
	BC_Interet_Update(mid_interet_charogne, C_EVENT_InteretStatusGrab, o_cible, tmid_vision)


// EVENT VISION ================================================
ti_ground_ID = GRID_CapaGet(OBJ_PosGet())
ti_ground_ID &= tag_grid_terrain
ti_context = C_EVENT_CONTEXT_ALLONGE
ti_context += ti_ground_ID * 10
tf_interet = 100									// Event non prioritaire
// Ratio de vie
tf_HP_max = f_HP_max
tf_liferatio = f_HP / tf_HP_max
if( ! f_HP && f_point_de_viande <= 0.0 )
	tf_liferatio = -1.0		// life ratio utile + bas... donc pas dans le if()
MSG_GlobalSetInvalid(tmid_vis_ID)
if( ! i_flag_barbeuc && i_etat_courant != ETAT_Fade && ( f_point_de_viande > 0.0 || f_HP > 0.0 ) )
{
	// les bats noires n'envoient plus de vision qd elles sont mortes, les autres quand elles sont en fade
	ti_max_slots = 0									// ?
	tf_rayon_vision = 	Cf_rayon_corps_bat		// Envergure du perso
	tmid_vis_ID = EVENT_AddEventVision( C_ID_BatCharognard, C_EVENT_FILTER_None, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet(), C_EVENT_Visibility_Crouch, tf_rayon_vision, tf_interet, ti_context, ti_max_slots, tf_liferatio)
}
// TERRITOIRE -------------------------------------------------
if( MSG_GlobalIsValid(tmid_vis_ID) )
{
	if( i_etat_courant != ETAT_Fade && ( BC_est_au_sol() || o_chute_bats_wp || ! f_HP ) )
	{
		if( BC_est_au_sol() )
			to_obj = OBJ_Me()		// une fois tombée, donne sa vraie position
		else if( o_chute_bats_wp )
			to_obj = o_chute_bats_wp
		else
			to_obj = OBJ_Me()
		ti_type_sol = GRID_CapaGet(@to_obj OBJ_PosGet())
		ti_type_sol &= tag_grid_terrain
		if( ti_type_sol != Ci_sol_mur )
		{
			EVENT_PositionSet(tmid_vis_ID, @to_obj OBJ_PosGet())
			EVENT_VisionTerritoryUdpate(tmid_vis_ID)			// n'update pas le territoire sur une case jaune
		}
	}
}

//================== TEST BAT MORTE ====================

if( f_HP )
{
	//================= TEST HORS CHAMP ===================
	
	if( BC_IsHorsChampCamera() )
	{
		if( f_duree_dans_champ_camera )
			f_time_debut_wait_hors_champ = TIME_Get()		// la trame d'avant j'étais à l'écran
		
		f_duree_dans_champ_camera = 0.0
		if( ( i_modele == Ci_MODELE_Bat_Rouge || i_modele == Ci_MODELE_Bat_Mini ) && i_etat_courant == ETAT_Fight_Approche )
		{
			f_zde_fight_size_coef = 2.0
			if( i_batR_acceleration_flag )
			{
				// accélérer les bats rouge hors champ (pour rattrapper JACK dans son dos)
				if( f_ref_speed != Cf_speed_batR_hors_champ )
				{
					f_batR_max_speed = f_ref_speed
					f_ref_speed = Cf_speed_batR_hors_champ
				}
			}
		}
	}
	else
	{
		f_duree_dans_champ_camera += TIME_GetDt()
		if( ( i_modele == Ci_MODELE_Bat_Rouge || i_modele == Ci_MODELE_Bat_Mini ) && i_etat_courant == ETAT_Fight_Approche )
		{
			f_zde_fight_size_coef = 1.0
			if( i_batR_acceleration_flag && f_batR_max_speed )
			{
				// remettre la vitesse max autorisée par le comportement
				f_ref_speed = f_batR_max_speed
				f_speed = MATH_FloatMin(f_speed, f_ref_speed)
			}
		}
	}
	
	//================== EVENT ENEMY ======================
	
	if( ! i_agressive )
	{
		// bat charognard
		ti_NMI_state = C_EVENT_EnemyState_Quiet			// ignorée par les humains
	}
	else if( i_modele == Ci_MODELE_Bat_Noire )
	{
		if( i_etat_courant == ETAT_Paf_Ecrase || i_etat_courant == ETAT_Agonie || i_etat_courant == ETAT_Mort || i_etat_courant == ETAT_Fade )
			ti_NMI_state = C_EVENT_EnemyState_Quiet			// ignorée par les humains
		else
			ti_NMI_state = C_EVENT_EnemyState_Fight			// menaçante / agressive
	}
	else
	{
		switch( i_etat_courant )
		{
			case ETAT_Agonie :
			case ETAT_Mort :
			case ETAT_Wait_Grotte :
			case ETAT_Brule :
			case ETAT_Chute_Libre :
			case ETAT_Chute_wp :
			case ETAT_Paf_Explose :
			case ETAT_Paf_Ecrase :
			case ETAT_TEST :
				ti_NMI_state = C_EVENT_EnemyState_Quiet			// ignorée par les humains
				break
				
			case ETAT_Fight_Approche :
			case ETAT_Fight_Contact :
			case ETAT_Fight_Network :
			case ETAT_Fight_Pause :
			case ETAT_Fight_Wait_Begin :
			case ETAT_Fight_Wait_Prio :
			case ETAT_Paf_Air :
			case ETAT_Paf_Sol :
				ti_NMI_state = C_EVENT_EnemyState_Fight			// menaçante / agressive
				break
			
			default:
				ti_NMI_state = C_EVENT_EnemyState_Wait			// présente...
				break
		}
	}
	
	EVENT_AddEventEnemy(C_ID_BatCharognard, OBJ_Me(), ti_NMI_state)
	
	#ifndef _FINAL_
	if( i_DBG_music )
	{
		switch( ti_NMI_state )
		{
			case C_EVENT_EnemyState_Quiet :
				str_txt = "Quiet"
				break
			case C_EVENT_EnemyState_Fight :
				str_txt = "Fight"
				break
			case C_EVENT_EnemyState_Wait :
				str_txt = "Wait"
				break
			default:
				str_txt = "????"
				break
		}
		Str_DisplayTextOnce(str_txt, tv_2D_pos)
	}
	#endif
}


// CHECK PAFS =======================================================
tf_HP_avant_paf = f_HP
f_sum_pafs_force = 0.0
v_sum_pafs_dir = Cv_NullVector
AI_Execute("BC_exec_check_paf")			// même si mort car points de viande
if( f_sum_pafs_force )
{
	BC_Charognard_Mode_Reset()		// redevient agressive
	if( ! BC_Follower() )
	{
		if( i_agressive )
		{
			// la bat agressive mémorise qui l'a paffée
			if( o_best_paf_pere && @o_best_paf_pere AI_IsModel(get_Humain_path) )
			{
				if( ! o_cible_attaque || i_paf_change_target || TIME_Elapsed(f_last_time_paf_change_target, 4.0) )
				{
					f_last_time_paf_change_target = TIME_Get()
					o_cible_attaque = o_best_paf_pere
					if( o_cible_attaque_contact )
						o_cible_attaque_contact = o_cible_attaque		// si ct pas nobody alors j'update
				}
			}
		}
	}
}


// Diminution recul des pafs
f_paf_offset_coef = MATH_FloatBlend(f_paf_offset_coef, 1.0, 10 * TIME_GetDt())
v_paf_offset = MATH_VecBlend(v_paf_offset, Cv_NullVector, 5 * TIME_GetDt())			// 5


switch( i_etat_courant )
{
	case ETAT_Paf_Air :
	case ETAT_Paf_Sol :
	case ETAT_Agonie :
	case ETAT_Paf_Ecrase :
	case ETAT_Mort :
	case ETAT_Chute_wp :
	case ETAT_Chute_Libre :
	case ETAT_Brule :
	case ETAT_Fade :
		return		// plus d'interruption à cause d'un paf ======================================
		break
	
	default:
//		if( BC_CanAttackMyPafActor() 
//			&& ( f_sum_pafs_force || ((i_paf_type & C_EVENT_PAF_Repousse) && i_repousse_pendant_attaque) ) )
		if( f_sum_pafs_force || ((i_paf_type & C_PAF_KK_Repousse) && i_repousse_pendant_attaque) )
		{
			// j'ai pris des pafs
			if( f_sum_pafs_force )
				BC_DBG_Trace_Etat_Paf("a pris un paf dmg")
			if( (i_paf_type & C_PAF_KK_Repousse) && i_repousse_pendant_attaque )
				BC_DBG_Trace_Etat_Paf("a pris un paf repousse")
			
			i_force_test_inclinaison = vrai			// force le test de l'inclinaison de la courbe entre ma position et le point que je choisi pour partir
			
			// ===================== RECUL ========================

			v_paf_offset += v_sum_pafs_dir
			f_paf_offset_coef = 0.0

			//========= INTERRUPTION INTERET CHAROGNE =============
			
			if( ! MSG_GlobalIsValid(mid_grab_charogne) )
				if( MSG_GlobalIsValid(mid_interet_charogne) )
					EVENT_Delete(mid_interet_charogne, C_EVENT_EOFDEL )		// perte de l'intérêt pour une charogne qu'on n'a pas encore grabbée
			
			//================== CRI ====================
			
			if( ! i_flag_silent_kill )
			{
				if( ! ( i_paf_type & C_PAF_KK_FoodChain ) )
				{
					if( i_paf_explose_flag || i_flag_hurle || ( ! f_HP && tf_HP_avant_paf ) )
						SND_RequestPlay(Ci_SND_Paf_Gros)
					else if( i_paf_important_flag ) //  || i_paf_type & C_EVENT_PAF_Agonisant )
						SND_RequestPlay(Ci_SND_Paf_Gros)
					else if( f_time_cri_paf == 0.0 )
					{
						SND_RequestPlay(Ci_SND_Paf_Petit)
						f_time_cri_paf = MATH_RandFloat(0.5, 1.0)
					}
				}
			}
			
			//============== RESOLUTION ================
			
			v_pos_avant_paf = OBJ_PosGet()		// backup position du bat
			
			if( BC_est_au_sol() )
			{
				BC_DBG_Trace_Etat_Paf("est au sol -> etat paf sol")
				macro_change_etat("BC_ETAT_Paf_Sol")			// gros paf au sol => anim de paf au sol
			}
			else
			{
//				if( i_paf_type & C_EVENT_PAF_Agonisant )
//				{
//					i_flag_agonie = vrai
//					BC_DBG_Trace_Etat_Paf("reçoit un paf agonisant -> etat paf air")
//					macro_change_etat("BC_ETAT_Paf_Air")
//				}
//				else 
				if( i_paf_explose_flag )
				{
					if( i_modele == Ci_MODELE_Bat_Noire )
					{
						// pour la bat noire, un paf explose équivaut à un paf important
						i_paf_explose_flag = faux
						i_paf_important_flag = vrai
						BC_DBG_Trace_Etat_Paf("reçoit un paf explose -> etat paf air")
						macro_change_etat("BC_ETAT_Paf_Air")
					}
					else
					{
						BC_DBG_Trace_Etat_Paf("reçoit un paf explose -> etat paf explose")
						macro_change_etat("BC_ETAT_Paf_Explose")
					}
				}
				else if( i_paf_important_flag )
				{
					f_paf_pause_time = f_paf_important_pause_time
					BC_DBG_Trace_Etat_Paf("reçoit un paf important -> etat paf air")
					macro_change_etat("BC_ETAT_Paf_Air")
				}
				else if( i_paf_moyen_flag )
				{
					f_paf_pause_time = f_paf_moyen_pause_time
					BC_DBG_Trace_Etat_Paf("reçoit un paf moyen -> etat paf air")
					macro_change_etat("BC_ETAT_Paf_Air")
				}
				else if( i_paf_type & C_PAF_KK_Repousse && i_repousse_pendant_attaque && f_HP )
				{
					// j'ai été repoussé (mais toujours vivante, car un paf repousse peut tuer maintenant, et ouiiiiii....... #{@\|~||{[#
					f_paf_pause_time = 0.5
					BC_DBG_Trace_Etat_Paf("reçoit un paf repousse -> etat fight pause")
					macro_change_etat("BC_ETAT_Fight_Pause")
				}
				else if( ! f_HP )
				{
					BC_DBG_Trace_Etat_Paf("un petit paf qui me tue -> etat paf air")
					macro_change_etat("BC_ETAT_Paf_Air")
				}
//				else if( i_paf_faible_flag )
//				{
//					if( ! f_HP )
//					{
//						o_chute_bats_wp = BC_Chute_WP_Select()
//						if( o_chute_bats_wp )
//						{
//							BC_DBG_Trace_Etat_Paf("reçoit un paf faible -> etat chute wp")
//							macro_change_etat("BC_ETAT_Chute_WP")		// Chute guidée
//						}
//						else
//						{
//							BC_DBG_Trace_Etat_Paf("reçoit un paf faible -> etat chute libre")
//							macro_change_etat("BC_ETAT_Chute_Libre")		// Chute pas guidée
//						}
//					}
//				}
			}
		}
		break
}


// MESSAGES =================================================
AI_Execute("BC_exec_check_msg")


// CHEAT AFFICHAGE DES POINTS DE VIE ===========================
#ifndef _FINAL_
if( f_HP && @"univ" i_cheat_page == 3 )
	Str_DisplayFloatOnce(f_HP, tv_2D_pos)
#endif


// PAS PLUS LOIN POUR LES BOSS EN ATTAQUE ======================
if( BC_Boss() ) // && BC_IsEtatAttaque(i_etat_courant) )
	returntrack


// DETECTION DE PAFS A PROXIMITE ================================
if( BC_Detect_Proximity_Shoot() )
{
	AI_Execute("BC_exec_check_shoot")
	if( i_near_shoot_flag )
	{
		BC_Charognard_Mode_Reset()
		o_cadavre = nobody
		BC_DBG_Trace_Etat("!!! i_near_shoot_flag !!!")
		if( i_agressive )
		{
			BC_DBG_Trace_Etat("near shoot flag => init attaque")
			AI_Execute("BC_exec_init_attaque")
		}
		else
		{
			BC_DBG_Trace_Etat("near shoot flag => envol puis retour ronde")
			i_decolle_near_shoot_flag = vrai
			v_decolle_near_shoot_pos = @o_cible_attaque OBJ_PosGet()
			o_cible_attaque = nobody
			i_envol_palier = 0
			macro_change_etat("BC_ETAT_Move_Decolle")
		}
	}
}


// FEU =====================================================================
if( i_etat_courant == ETAT_Brule )
	return
if( @get_global i_nbr_de_feux_en_cours )
	i_fire = vrai
else
	i_fire = faux
GRID_CurrentSet(1)
ti_capa = GRID_CapaGet(OBJ_PosGet())
if( ti_capa & Ci_Grid2_EnFeu )
{
	// en train de brûler
	if( BC_Collide_Ground() )
		macro_change_etat("BC_ETAT_Brule")
	else
	{
		// test hauteur
		to_ray_object = COL_RayObject_Vector(OBJ_PosGet(), - Cv_VerticalVector * 3.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
		if( to_ray_object && (to_ray_object != OBJ_Me()) )
		{
			// je suis dans les flammes
			macro_change_etat("BC_ETAT_Brule")
		}
	}
}
GRID_CurrentSet(0)


//if( DBG_IsObjSel() )
//{
//	if( IO_KeyJustPressed(65) )
//		EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, C_EVENT_PAF_Tuant, o_jack, Cf_EVENT_Duree_1Trame, OBJ_Me(), 0, Cv_NullVector)
//}
