
#include 		"BC_defines.var"

//=============================================================================
// DETECTION DES OBSTACLES
//=============================================================================

object		to_ray_object					// obstacle rencontré par le lancer de rayon
object		to_col_object					// obstacle rencontré par le lancer de rayon

vector		tv_obstacle_pos				// position de l'obstacle
vector		tv_to_obstacle					// vecteur de contact avec l'obstacle
vector		tv_sight
vector		tv_lray_sight
vector		tv_obstacle_dir

float			tf_lray_dist

int				ti_col_wall
int				ti_col_lray


if( i_flag_cine )
	return

if( ! i_flag_obstacle )
{
	ti_col_wall = faux
	ti_col_lray = faux
	
	// TEST COLL
	if( COL_CollideType(COL_C_Wall) )
	{
		to_col_object = COL_ObjectGet(COL_C_Wall)
//		if( to_col_object != o_cible_attaque )
		if( ! @to_col_object OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims) )
		{
			// je touche un mur, mais pas un perso
			tv_obstacle_pos = COL_CollidedPointGet(COL_C_Wall)
			tv_obstacle_dir = tv_obstacle_pos - OBJ_PosGet()
			if( MATH_VecDotProduct(OBJ_SightGet(), MATH_VecNormalize(tv_obstacle_dir)) > Cf_Cos30 )
			{
				ti_col_wall = vrai
				DBG_RenderVector(tv_obstacle_pos, OBJ_PosGet() - tv_obstacle_pos, color_cyan)		// obstacle
			}
		}
	}
	
//	// TEST LRAY
//	if( ! ti_col_wall )
//	{
//		tv_lray_sight = OBJ_SightGet()
//		tf_lray_dist = f_check_obstacle_dist * f_zoom_ratio
////		DBG_RenderVector(OBJ_PosGet(), tv_lray_sight * tf_lray_dist, color_bleu)
//		to_ray_object = COL_RayObject_Dist(OBJ_PosGet(), tv_lray_sight, tf_lray_dist, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//		if( to_ray_object && (to_ray_object != OBJ_Me()) )
//		{
//			tv_obstacle_pos = COL_RayObject_PosGet()
//			if( o_cible_attaque && OBJ_SqrDist(o_cible_attaque) < OBJ_SqrDist(to_ray_object) 
//				&& MATH_VecDotProduct(OBJ_SightGet(), @o_cible_attaque OBJ_PosGet() - OBJ_PosGet()) > 0 )
//			{
//				// je ne tiens pas compte de l'obstacle car ma proie est devant
//			}
//			else
//			{
//				ti_col_lray = vrai
//			}
//		}
//	}
	
//	if( ti_col_wall || ( ti_col_lray && (tv_obstacle_pos.z > v_dest_pos.z || MATH_VecNorm(tv_obstacle_pos - v_dest_pos) < 1) ) )
	if( ti_col_wall )
	{
		f_obstacle_duration += TIME_GetDt()
		if( f_obstacle_duration >= 1.0 )
		{
			// UN OBSTACLE A ETE DETECTE  : mur, ou LRAY + ( il est plus haut que mon point d'attaque OU il est trop proche de ma destination -> je vais rentrer dedans )
			i_flag_obstacle = vrai
			i_flag_obstacle_memo = vrai
			f_time_since_last_obstacle = 0.0
			i_force_test_inclinaison = vrai
			
			i_flag_frein = vrai
			
			i_flag_reach_attack_wp = faux		// position d'attaque annulée -> le bat devra en recalculer une nouvelle
			
			tv_to_obstacle = tv_obstacle_pos - OBJ_PosGet()
			DBG_RenderVector(tv_obstacle_pos, OBJ_PosGet() - tv_obstacle_pos, color_cyan)		// obstacle
			
			// position next WP : devant moi 
			@o_tmp_obj_next OBJ_PosSet(OBJ_PosGet() + ( ( tv_to_obstacle * 0.75 ) + cvector(0, 0, 1) ) )
			
			// orientation next WP : normale à mon sight, vertical
			tv_sight = OBJ_SightGet()
			MATH_VecSetHorzNormalize(tv_sight)
			tv_sight = MATH_VecCrossProduct(tv_sight, Cv_VerticalVector)
			tv_sight *= - MATH_FloatSign(MATH_VecDotProduct(@o_tmp_obj_next OBJ_PosGet() - OBJ_PosGet(), OBJ_HorizonGet()))
			@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
			
			o_next_wp = o_tmp_obj_next

			BC_ref_speed_set(Cf_speed_obstacle)
			
			v_cible_pos = @o_next_wp OBJ_PosGet()
			v_dest_pos = v_cible_pos
			
			// Suivi du regard
			v_look_pos = v_cible_pos + MATH_VecLocalToGlobal( cvector(0, -3, 1) )	// regard un peu derrière le wp

			// anim obstacle
			ACT_ActionSet(i_ACTION_Vol_Standard)
			BC_action_frequency_set(Cf_freq_obstacle)
			
	//		DBG_TraceObject(OBJ_Me())
	//		DBG_TraceString(" a détecté un obstacle...")
	//		DBG_TraceEOL()
		}
	}
}
f_check_obstacle_dist = Cf_dist_obstacle_vol			// réinit dist check obstacles

