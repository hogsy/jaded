
#include "BC_defines.var"

float				tf_dist
float				tf_sign

messageid		tmid_tmp		// event odeur de sang

vector			tv_wp_pos		// position du wp intermédiaire
vector			tv_wp_sight		// sight du wp intermédiaire


// SORTIE ETAT
if (i_sort_etat)
{
	i_sort_etat = faux
	return
}


//======================================================
// Init next wp : à l'init de l'état et à chaque frame de l'état
//======================================================

// position de la trace de sang
v_cible_pos = EVENT_PositionGet(mid_sang)

// decalage horizontal + le bat observe la trace à 2 m de haut
v_decalage = decalage( v_cible_pos, 2, 2)

if( ! i_flag_use_inter_wp )
{
	// le bat se dirige vers un le wp au-dessus de la trace de sang
	@o_tmp_obj_next OBJ_PosSet(v_cible_pos + v_decalage)
	@o_tmp_obj_next OBJ_BankingGeneralSet(v_cible_pos - @o_tmp_obj_next OBJ_PosGet(),Cv_VerticalVector)
	o_next_wp = o_tmp_obj_next
}

// ENTREE ETAT
if (i_etat_courant != ETAT_Suivi_Odeur)
{
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Suivi_Odeur
	
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	
	if (MATH_VecDotProduct(OBJ_SightGet(), @o_tmp_obj_next OBJ_SightGet()) < 0.0)
	{
		// le sight du bat et le sight du next_wp sont opposés => demi-tour => point intermédaire
		i_flag_use_inter_wp	= vrai
		
		// calcul de la position du wp intermédiaire
		tv_wp_pos = OBJ_SightGet()
		MATH_VecSetHorzNormalize(tv_wp_pos)		// horizontal puis normalizé
		
		tv_wp_sight = MATH_VecCrossProduct(tv_wp_pos, Cv_VerticalVector)
		tv_wp_sight *= - MATH_FloatSign(MATH_VecDotProduct(@o_tmp_obj_next OBJ_PosGet() - OBJ_PosGet(), OBJ_HorizonGet()))
		
		tv_wp_pos *= 2.0
		tv_wp_pos += tv_wp_sight * 1.0
		tv_wp_pos += OBJ_PosGet()
		
		// position et sight du wp intermédiaire
		@o_tmp_obj_next OBJ_PosSet(tv_wp_pos)
		@o_tmp_obj_next OBJ_BankingGeneralSet(tv_wp_sight, Cv_VerticalVector)
	}
	
	// position et orientation last WP (infos courantes du bat)
	@o_tmp_obj_last OBJ_PosSet(OBJ_PosGet())
	@o_tmp_obj_last OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
	o_last_wp = o_tmp_obj_last
	
	// lien à parcourir
	f_link_coef = 0.0
	
	ACT_ActionSet(ACTION_Vol)
	
	// le bat regarde la tache de sang
	v_look_pos = v_cible_pos
}

f_link_length = MATH_VecNorm(@o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet())

DBG_RenderVector( @o_last_wp OBJ_PosGet(), @o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet(), color_vert)


// ========== STIMULUS PAF ============

// S'il est attaqué, le bat se retourne contre son agresssur
AI_Execute("BC_exec_check_paf")
if( o_paf_pere )
{
	o_cible = o_paf_pere
	macro_change_etat("BC_ETAT_Attaque")
}

// ========= STIMULUS VISION ===========

// Si le bat a un perso blessé en visuel, il le suit plutôt que de pister l'odeur de sang
AI_Execute("BC_exec_check_vision_blesses")


// ========= STIMULUS SANG ============

// Sinon le bat suit la piste de sang
tmid_tmp = mid_sang
AI_Execute("BC_exec_check_sang")
if( MSG_GlobalIsValid(mid_sang) && (mid_sang != tmid_tmp) )
	i_etat_courant--			// tache de sang + fraiche => on recommence l'état Suivi Odeur
else
	mid_sang = tmid_tmp		// récup ancienne trace de sang


// ======== DEPLACEMENT ==========

AI_Execute("BC_exec_vol_courbe")
if( i_flag_lien_fini )
	macro_change_etat("BC_ETAT_Observe_Trace")		// le bat est arrivé jusqu'à la tache de sang et il n'a rien repéré

AI_Execute("BC_exec_inclinaison")

