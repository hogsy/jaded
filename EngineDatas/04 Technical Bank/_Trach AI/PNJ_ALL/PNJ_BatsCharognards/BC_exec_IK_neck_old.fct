#include "BC_defines.var"

//=============================================================================
// SUIVI DU REGARD
//=============================================================================


#define		Cf_bone_look_blend_coef		0.2		// pourcentage de blend selon les os

int				ti_i
object		to_head
float			tf_look_cur_coef

vector 		tv_final
vector 		tv_cur
vector		tv_look_dir
vector		tv_tar


if( i_etat_courant == ETAT_TEST )
	return

tf_look_cur_coef = 0.0			// pourcentage d'application du blend (pourcentage de répartition selon les os)

if( ! MATH_VecNullEpsilon(v_softcol_decal_perfect) 
	&& MATH_VecNorm(v_softcol_decal_current) > (Cf_soft_coll_norm_max * 0.25 ) 
	&& i_etat_courant != ETAT_Fight_Approche )
{
	// regarde la bat qui la collisionne (sens opposé des collisions)
	v_look_pos = OBJ_PosGet() - ( 10.0 * MATH_VecNormalize(v_softcol_decal_perfect) )
}


// CALCUL des positions des os de la tête
for (ti_i = (Ci_head_bones_count -1); ti_i >= 0; ti_i--)
{
	tv_final = v_look_pos - @ao_head_bones[ti_i] OBJ_PosGet()									// vecteur final du regard
	if( i_DBG_look_all )
		DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_final, color_rose)
	
	tv_final = MATH_VecInCone(tv_final, OBJ_SightGet(), Cf_PiBy2, 0)							// vecteur recadré dans le cone de vision
	if( i_DBG_look_all )
	{
		DBG_RenderCone( @ao_head_bones[ti_i] OBJ_PosGet(), OBJ_SightGet() * 20, Cf_PiBy3, 0x40000080)	// cône de vision
		DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_final, color_rouge)
	}
	
	if( i_DBG_look_all )
		DBG_RenderVector(@ao_head_bones[ti_i] OBJ_PosGet(), v_cur_look_pos - @ao_head_bones[ti_i] OBJ_PosGet(), color_vert)
	
	tv_cur = v_cur_look_pos - @ao_head_bones[ti_i] OBJ_PosGet()								// vecteur courant du regard	
	
	if( i_flag_neck )
		tv_look_dir = MATH_VecBlendRotate( tv_cur, tv_final , 2 * TIME_GetDt())				// blend de l'axe du regard
	else if( i_etat_courant == ETAT_Paf_Air )
		tv_look_dir = MATH_VecBlendRotate( tv_cur, - OBJ_SightGet() * 5, 2 * TIME_GetDt())				// blend de l'axe du regard
	else
//		tv_look_dir = MATH_VecBlendRotate( tv_cur, OBJ_SightGet() * 5, 2 * TIME_GetDt())				// blend de l'axe du regard
		tv_look_dir = MATH_VecBlendRotate( tv_cur, @ao_head_bones[ti_i] OBJ_BankingGet(), 2 * TIME_GetDt() )		// revient dans l'axe donné par l'anim
		
	if( i_DBG_look_all )
	{
		DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_cur, color_jaune)
		DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_final, color_bleu)
		DBG_RenderVector( @ao_head_bones[ti_i] OBJ_PosGet(), tv_look_dir, color_vert)
	}
	
	if( ti_i )
		tf_look_cur_coef += Cf_bone_look_blend_coef
	else
		tf_look_cur_coef = 1.0
	
	tv_tar = MATH_VecBlendRotate( @ao_head_bones[ti_i] OBJ_BankingGet(), tv_look_dir, tf_look_cur_coef )
	@ao_head_bones[ti_i] OBJ_Rotate_FromTo(cvector(0,0,1), @ao_head_bones[ti_i] MATH_VecGlobalToLocal(tv_tar) )
}

// BACKUP vision générale du bat pour le exec_check_vision de la trame suivante
to_head = ANI_CanalObjectGet(Anim_Canal_Tete)
v_look_head_pos = @to_head OBJ_PosGet()
v_look_axis = @to_head OBJ_BankingGet()

// BACKUP vision générale du bat pour le exec_neck de la trame suivante
v_cur_look_pos = tv_look_dir + @to_head OBJ_PosGet()

if( i_DBG_look_pos )
	DBG_RenderVector( @to_head OBJ_PosGet(), tv_look_dir, color_jaune)			// vue du bat vers le point à regarder

