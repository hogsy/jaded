#include "BC_defines.var"

float			tf_coef
float			tf_archimede
float			tf_Z_offset

int				ti_soft_collision_flag_old
int				ti_zdm_active
int				ti_col_report

vector		tv_new_soft_collision
vector 		tv_zdm_perfect_size
vector		tv_zdm_offset
vector		tv_zde_fight_size
vector		tv_pivot_tete
vector		tv_temp
vector		tv_pos
vector		tv_traction
vector		tv_collide_pos
vector		tv_sinus

object		to_tete
object		to_piedD
object		to_piedG
object		to_collide_object


AI_Execute("BC_cb_tag_on")


// ZDE FIGHT =====================================================================
if( BC_Boss() && BC_IsEtatAttaque(i_etat_courant) )
{
	to_tete = ANI_CanalObjectGet(Anim_Canal_Machoire)
	tv_pivot_tete = @to_tete OBJ_PosGet() - OBJ_PosGet()
}
else if( BC_est_au_sol() )
{
	// attaque au sol
	to_tete = ANI_CanalObjectGet(Anim_Canal_Tete)
	tv_pivot_tete = @to_tete OBJ_PosGet() - OBJ_PosGet()
}
else
{
	// attaque en vol
	to_piedD = ANI_CanalObjectGet(Anim_Canal_OrteilDroit)
	to_piedG = ANI_CanalObjectGet(Anim_Canal_OrteilGauche)
	tv_temp = @to_piedD OBJ_PosGet() - @to_piedG OBJ_PosGet()
	tv_pos = @to_piedG OBJ_PosGet() + (0.5 * tv_temp)
	tv_pivot_tete = tv_pos - OBJ_PosGet()
}
switch( i_modele )
{
	case Ci_MODELE_Bat_Noire :
		tv_zde_fight_size = Cv_zde_fight_size_noire
		break
	case Ci_MODELE_Bat_Grise :
		tv_zde_fight_size = Cv_zde_fight_size_grise
		break
	case Ci_MODELE_Bat_Rouge :
	case Ci_MODELE_Bat_Mini :
		tv_zde_fight_size = Cv_zde_fight_size_rouge
		break
}
COL_ZoneSizeSet(C_zde_fight, tv_zde_fight_size)
COL_ZonePosSet(C_zde_fight, MATH_VecGlobalToLocal(tv_pivot_tete) / f_zoom)


// RECUL DU AUX PAFS ==========================================================
OBJ_PosSet(OBJ_PosGet() + (f_paf_offset_coef * v_paf_offset * (TIME_GetDt() * 15.0)) )					// recul paf


// CUMUL DE PAFS  ============================================================
BC_Paf_Cumul_Check_Time()


// WAIT SINUS =================================================================
tv_pos = OBJ_PosGet()
tv_pos -= v_wait_sinus
if( i_wait_sinus_flag && i_modele != Ci_MODELE_Bat_Noire )
{
	tv_sinus = cvector(MATH_Sin(f_wait_sinus_frequence * 1.4 * f_zoom * TIME_Get()), MATH_Sin(f_wait_sinus_frequence * 0.65 * f_zoom * TIME_Get()), MATH_Sin(f_wait_sinus_frequence * 1.4 * f_zoom * TIME_Get()))
	v_wait_sinus = MATH_VecBlend(v_wait_sinus, tv_sinus, 5 * TIME_GetDt())
}
else
{
	v_wait_sinus = MATH_VecBlend(v_wait_sinus, Cv_NullVector, 3 * TIME_GetDt())
}
tv_pos += v_wait_sinus
OBJ_PosSet(tv_pos)

// COLLISION MOLLES ============================================================
ti_soft_collision_flag_old = i_softcol_flag
BC_SoftCol_Rayon_Resize()
//DBG_RenderCircle(OBJ_PosGet(), f_softcol_rayon_current * f_zoom, Cv_NullVector, color_rouge)		
if( ! BC_SoftCol_IsEnabled() || MSG_GlobalIsValid(mid_grab_charogne) )
{
	// états col molles interdites
	i_softcol_flag = faux
	v_softcol_decal_perfect = Cv_NullVector
	tf_coef = 5.0
}
else
{
	// test des col molles
	i_softcol_flag = BC_SoftCol_Check(tv_new_soft_collision)
	if( ! i_softcol_flag )
	{
		// pas de col molles
		v_softcol_decal_perfect = Cv_NullVector
		tf_coef = 3.0
	}
	else
	{
		// col molles...
		if( ! ti_soft_collision_flag_old )
		{
			// je passe en coll molle maintenant et je n'avais pas de résidus de col molles (franchissement de wp)
			if( MATH_VecNullEpsilon(v_softcol_decal_current) )
			{
				f_softcol_link_speed = f_beziers_speed
			}
		}
		v_softcol_decal_perfect = tv_new_soft_collision
		tf_coef = 1.0
	}
}
v_softcol_decal_current = MATH_VecBlend(v_softcol_decal_current, v_softcol_decal_perfect, tf_coef * TIME_GetDt())
DBG_RenderVector(OBJ_PosGet(), v_softcol_decal_current, color_bleu)
OBJ_PosSet(OBJ_PosGet() + ( v_softcol_decal_current * 20.0 * TIME_GetDt() ) )


// POSITION DU BALANCIER ====================================================
AI_Execute("BC_exec_balancier")


// TEST BEZIERS ??? =========================================================
if( i_beziers_flag_cette_trame )
	i_beziers_flag_last_trame = vrai
else
	i_beziers_flag_last_trame = faux


// VITESSE =================================================================
if( i_modele == Ci_MODELE_Bat_Noire )
	tf_coef = 0.9
else
	tf_coef = 0.95
v_vitesse_derapage *= Amorti_Coef_Dt(tf_coef)
if( i_vitesse_derapage_init )
{
	v_vitesse_derapage = v_vitesse_last_move
	DBG_RenderVector(OBJ_PosGet(), v_vitesse_derapage, color_cyan)
}
if( i_etat_courant == ETAT_Fight_Approche )
	v_vitesse_derapage = Cv_NullVector
DBG_RenderVector(OBJ_PosGet(), v_vitesse_derapage, color_bleu)
OBJ_PosSet(OBJ_PosGet() + (v_vitesse_derapage * TIME_GetDt()))

v_vitesse_last_move = (OBJ_PosGet() - v_vitesse_last_pos) / TIME_GetDt()
v_vitesse_last_pos = OBJ_PosGet()


// ZDM ==========================================================================
if( i_etat_courant == ETAT_Brule )
{
	switch( ACT_ActionGet() )
	{
		case ACTION_Vol_Vrille :
		case ACTION_Paf_Air_Moyen :
			tv_zdm_perfect_size = Cv_ZDM_Chute_Libre
			tv_zdm_offset = cvector(0.0, 0.0, 0.8)
			break
		default:
			tv_zdm_perfect_size = Cv_ZDM_Sol
			tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Sol.x)
			break
	}
}
else if( i_etat_courant == ETAT_Chute_Libre )
{
	tv_zdm_perfect_size = Cv_ZDM_Chute_Libre
	tv_zdm_offset = cvector(0.0, 0.0, 0.8)
}
else if( i_etat_courant == ETAT_Fight_Contact )
{
	tv_zdm_perfect_size = Cv_ZDM_Contact
	tv_zdm_offset = Cv_NullVector
}
else if( i_etat_courant == ETAT_Move_Atterrit || i_etat_courant == ETAT_Move_Decolle )
{
	tv_zdm_perfect_size = Cv_ZDM_Trans_Sol_Air		// diminuée pour les transitions air / sol...
	tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Trans_Sol_Air.x)
}
else if( BC_est_au_sol() )
{
	tv_zdm_perfect_size = Cv_ZDM_Sol
	tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Sol.x)
}
else
{
	tv_zdm_perfect_size = Cv_ZDM_Air
	tv_zdm_offset = cvector(0.0, 0.0, 0.2)
}

if( ! MATH_VecNullToler(v_zdm_cur_size - tv_zdm_perfect_size, 0.05) )
{
	v_zdm_cur_size = MATH_VecBlend(v_zdm_cur_size, tv_zdm_perfect_size, 5 * TIME_GetDt())
	if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
		DYN_FlagsSet(DYN_C_OptimizeColDisable, none)
}
else
	v_zdm_cur_size = tv_zdm_perfect_size
COL_ZoneSizeSet(C_zdm_pied, v_zdm_cur_size)

if( ! MATH_VecNullToler( tv_zdm_offset - v_zdm_cur_offset, 0.05) )
	v_zdm_cur_offset = MATH_VecBlend(v_zdm_cur_offset, tv_zdm_offset, 10 * TIME_GetDt())
else
	v_zdm_cur_offset = tv_zdm_offset
COL_ZonePosSet(C_zdm_pied, v_zdm_cur_offset ) // / f_zoom)

//if( BC_Boss() )
//	ti_zdm_active = faux
//else 
if( i_splash_flag)
	ti_zdm_active = faux
else if( i_etat_courant == ETAT_Fight_Contact )
	ti_zdm_active = vrai
else if( BC_IsEtatCine(i_etat_courant ) )
	ti_zdm_active = faux
else if( BC_IsEtatAttaque(i_etat_courant) )
{
	if( BC_Boss() )
	{
		if( i_etat_courant == ETAT_Fight_Network )
			ti_zdm_active = vrai
		else
			ti_zdm_active = faux		// combat 03B et 07B
	}
	else
		ti_zdm_active = vrai
}
else if( i_etat_courant == ETAT_Chute_wp )
	ti_zdm_active = faux
else if( MSG_GlobalIsValid(mid_grab_charogne) && ! BC_est_au_sol() )
	ti_zdm_active = faux
else
	ti_zdm_active = vrai

if( ti_zdm_active )
	COL_ColSetActivationSet(C_bit_zdm_pied, none)			// active zdm pied
else
	COL_ColSetActivationSet(none, C_bit_zdm_pied)			// désactive zdm pied


// RAZ Capa Rotation
OBJ_CapaSet(none, CAPA_Rotation)


// ACTION FREQUENCY ===================================================================
f_anim_frequency_cur = MATH_FloatBlend(f_anim_frequency_cur, f_anim_frequency_ref, 3.0 * TIME_GetDt())
ACT_LIB_ActionFrequencyMultiply(f_anim_frequency_cur)


// BOSS ET LIEUTENANTS =================================================================
if( BC_Boss() )
	i_lieutenant_count_old = @get_global i_bat_noire_lieutenant_nb


// GESTION DES UNCOLS ==================================================================
if( o_cible && o_cible != o_jack )
	BC_UncollideAdd(o_cible, Cf_EVENT_Duree_1Trame)
if( o_cadavre )		// ne pas cumuler pour le même acteur
	BC_UncollideAdd(o_cadavre, Cf_EVENT_Duree_1Trame)
if( o_cible_attaque && o_cible_attaque != o_jack && ( i_etat_courant == ETAT_Fight_Approche || i_etat_courant == ETAT_Fight_Contact) )
	BC_UncollideAdd(o_cible_attaque, Cf_EVENT_Duree_1Trame)
BC_UncollideCheck()


// CADAVRES ============================================================================
BC_Cadavre_Check()
BC_Cadavre_Check_New()
if( ! o_cadavre )
{
	BC_Charognard_Mode_Reset()
	EVENT_Delete(mid_interet_charogne, C_EVENT_EOFDEL)		// pour les bats qui comptent les interets
}


// ARCHIMEDE ============================================================================
if( i_splash_flag )
{
	AI_Execute("BC_exec_dyn_on")
	DYN_GravitySet(Cv_NormalGravity)
	tv_traction = Cv_NullVector
	DYN_FrictionVectorSet(cvector(6.0, 6.0, 0.0))
	if( i_splash_flag )
	{
		ti_col_report =COL_GMatReportGet(Gmat_KK_Face_eau)
		if (ti_col_report != -1)
		{
			to_collide_object = COL_ObjectGet(COL_C_ReportIndex + ti_col_report)
			tv_collide_pos = COL_CollidedPointGet(COL_C_ReportIndex + ti_col_report) 
			f_water_Z = tv_collide_pos.z
		}
		tf_Z_offset = BC_Get_Water_DiffZ()
		tf_archimede = f_water_Z - OBJ_PosGet().z + tf_Z_offset
		tf_archimede /= tf_Z_offset
		tf_archimede = MATH_FloatLimit(tf_archimede, 0.0, 2.0)
		if (tf_archimede)
		{
			tv_traction.z -= tf_archimede * DYN_GravityVectorGet().z * 0.85
			DYN_FrictionVectorSet(cvector(6.0, 6.0, 4.0))
		}
	}
	else
	{
		tf_archimede = 0.0
		f_water_Z = -Cf_Infinit
	}
	DYN_TractionSet(tv_traction)
}


// PAF VIANDE ===============================================================================
if (f_time_meat_bite)
{
	AI_Execute("BC_exec_dyn_on")
	DYN_GravitySet(Cv_NormalGravity)
	if( i_splash_flag )
		DYN_SpeedSetVector(cvector(MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(-0.5, -0.2)) * f_zoom)
	else
		DYN_SpeedSetVector(cvector(MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(0.0, 1.0)) * f_zoom)
}


// ANTI JAVELIN MITRAILLETTE
if( i_boss_delai_paf_perforant_init )
	f_boss_delai_paf_perforant = 2.0


// DEBUG ===============================================================================
AI_Execute("BC_exec_DEBUG")
