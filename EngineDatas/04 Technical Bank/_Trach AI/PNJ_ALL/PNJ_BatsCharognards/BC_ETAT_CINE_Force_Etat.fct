#include "BC_defines.var"

int		ti_data


// SORTIE ETAT =================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	return
}


// ENTREE ETAT ================================================================
if (i_etat_courant != ETAT_CINE_Force_Etat )
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_CINE_Force_Etat
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	if( i_DBG_trace_etat )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : etat cine force etat")
	}
	
	// TEST MODIF A EFFECTUER
	ti_data = am_CineStack[0].msg_int2
	
	switch(am_CineStack[0].msg_int1)
	{
		case 0 :
			// Rend (in)sensible aux pafs
			ti_data &= 0b1
			i_take_paf = 1 - ti_data
			if( i_DBG_trace_etat )
			{
				DBG_TraceString(" : Rend insensible aux pafs : ")
				DBG_TraceInt(ti_data)
			}
			break
		
		case 1 :
			// les pafs coupent les scripts (activé par défaut)
			ti_data &= 0b1
			i_paf_cut_cine = 1 - ti_data
			if( i_DBG_trace_etat )
			{
				DBG_TraceString(" : les pafs coupent les scripts : ")
				DBG_TraceInt(ti_data)
			}
			break
		
		case 2 :
			// nb d'attaques fakes
			i_cine_attaque_fake_nb = ti_data
			if( i_DBG_trace_etat )
			{
				DBG_TraceString(" : nb d'attaques fakes : ")
				DBG_TraceInt(ti_data)
			}
			break
			
		default:
			break
	}
	
	if( i_DBG_trace_etat )
		DBG_TraceEOL()
}
else
{
	f_time_start_etat += TIME_GetDt()
}


if( i_cine_close )
{
	// action terminée et pas de nouvelle commande ciné
	AI_Execute("BC_exec_init_attente")
}

i_cine_close = vrai
i_etat_courant = ETAT_CINE_temp

