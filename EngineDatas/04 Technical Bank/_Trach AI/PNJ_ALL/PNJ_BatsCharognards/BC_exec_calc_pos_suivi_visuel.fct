#include "BC_defines.var"

object			to_charogne_head		// tête de la charogne (pour positionner la bat)

vector			tv_decal_head				// vecteur de décalage entre le pivot et la tête de la cible
vector			tv_old_cible_pos			// blend progressif de la position de la charogne
vector			tv_old_dest_pos

if( i_calc_pos_suivi_visuel_done )
	return

i_calc_pos_suivi_visuel_done = vrai

tv_old_dest_pos = v_dest_pos
tv_old_cible_pos = v_cible_pos
v_cible_pos = @o_cible OBJ_PosGet()

//if( MATH_VecNorm( v_cible_pos - tv_old_cible_pos) >= 3.0 )
//{
//	// la cible s'est déplacée => init de la courbe
//	i_force_reinit = vrai
//}

v_dest_sight = v_cible_pos - OBJ_PosGet()


v_decalage = BC_decalage( - v_dest_sight, Cf_atterrissage_decal_H, Cf_atterrissage_decal_Z)
//v_decalage = cvector(0.0, 0.0, 4.0)
v_dest_pos = v_cible_pos + v_decalage


DBG_RenderVector(OBJ_PosGet(), v_dest_pos - OBJ_PosGet(), color_cyan)


// CALCUL DU RESEAU et du next_wp
i_mode_depl = Ci_mode_depl_charogne_visuel
if( ! MATH_VecNullToler(tv_old_dest_pos - v_dest_pos, 0.5) )
{
	i_flag_depl_wp_apres_reseau = faux		// la bidoche a bougé
}

if( ! n_attaque )
{
	i_reseau_wp_count = 0		// pas de réseau
	i_flag_reseau_array = faux
	i_flag_reseau_oneway = faux
	o_next_wp = o_tmp_obj_next
}
else
{
	n_reseau = n_attaque
	i_reseau_wp_count = 10				// pour bien spécifier qu'on a pas terminé de parcourir le réseau (mais qu'on veut commencer)
}
BC_Next_WP_Get()
if( ! o_next_wp )
{
	o_next_wp = o_tmp_obj_next
}

