#include "BC_defines.var"

object		to_piedD
object		to_piedG
object		to_bone

vector 		tv_temp
vector		tv_X
vector		tv_Y
vector		tv_pivot

float			tf_coef

int				ti_i
int				ti_k


// SUIVI DU REGARD =================
AI_Execute("BC_exec_IK_neck")

// ZDE CORPS =======================
to_bone = ANI_CanalObjectGet(BAT_canal_torse)	
tv_temp = @to_bone OBJ_PosGet() - OBJ_PosGet()
tv_temp = MATH_VecGlobalToLocal(tv_temp)
COL_ZonePosSet(C_zde_corps, tv_temp / f_zoom)

// GRAB ================================================================
to_piedD = ANI_CanalObjectGet(Anim_Canal_OrteilDroit)
to_piedG = ANI_CanalObjectGet(Anim_Canal_OrteilGauche)
tv_temp = @to_piedG OBJ_PosGet() - @to_piedD OBJ_PosGet()
v_grab_object_pos = @to_piedD OBJ_PosGet() + ( tv_temp / 2 )


// ROTATION QUATERNION EN FONCTION DES ACCUMULATION DE PAFS ---------------------------------
tv_pivot = @o_torse OBJ_PosGet()
tv_temp = @o_torse MATH_VecGlobalToLocal(@o_bassin OBJ_PosGet() - tv_pivot)

for (ti_i = 0; ti_i < 10; ti_i++)
{
	ti_k = MATH_Modulo(i_quat_index + ti_i, 10)

	if (af_quat_time[ti_k] == -1.0)
		continue	

	tf_coef = TIME_Get() - af_quat_time[ti_k]
	if (tf_coef < 1.0)
	{
		tf_coef = MATH_FloatMin(tf_coef * 10.0, 1.0) * (1.0 - tf_coef)

		tv_X = @o_bassin MATH_VecGlobalToLocal(av_quat_start[ti_k])
		tv_Y = @o_bassin MATH_VecGlobalToLocal(av_quat_end[ti_k])
		if( ! f_HP )
			tf_coef = MATH_FloatMin(tf_coef, 0.25)
		@o_bassin OBJ_Rotate_FromTo(tv_X, MATH_VecBlend(tv_X, tv_Y, tf_coef * af_quat_coef[ti_k]))
	}
	else
	{
		af_quat_time[ti_k] = -1.0
	}
}

// ON REPOSITIONNE LE BASSIN QUI A TOURNE AUTOUR DU PIVOT ========================================================
tv_temp = @o_torse MATH_VecLocalToGlobal(tv_temp)
tv_temp += tv_pivot
@o_bassin OBJ_PosSet(tv_temp)	
tv_temp = tv_temp

