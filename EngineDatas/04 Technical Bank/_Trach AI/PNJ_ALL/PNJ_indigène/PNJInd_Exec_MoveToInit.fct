vector	v_target
vector	tv_temp, tv_temp1, tv_temp2
object	to_nearest_me, to_nearest_me1
object	to_nearest_cible
object	ao_obj[100]
int			ti_num
object	to_obj
float		tf_dot

v_target = pop
tv_temp = v_target - OBJ_PosGet()
tv_temp.z = 0
if(MATH_VecNorm(tv_temp) < 1) 
{
	push( 1 )
	return
}

if(m_net_traque)
{
	to_nearest_cible = WAY_WPNearestOfPos(v_target, m_net_traque, -1, 0, 0)
	to_nearest_me = WAY_WPNearestOfPos(OBJ_PosGet(), m_net_traque, -1, 0, 0)
	ti_num = WAY_ShortWay(m_net_traque, &ao_obj[0], to_nearest_me, to_nearest_cible, -1, 0)
	if(ti_num > 2) 
	{
		to_obj = ao_obj[ti_num - 1]
		tv_temp1 = v_target - OBJ_PosGet()
		tv_temp2 = v_target - @to_obj OBJ_PosGet()
		if(MATH_VecDotProduct(tv_temp1, tv_temp1) < MATH_VecDotProduct(tv_temp2, tv_temp2))
			ao_obj[ti_num-1] = ao_obj[ti_num-2]
		else if(OBJ_SqrDist(ao_obj[ti_num-1]) < 2)
			ao_obj[ti_num-1] = ao_obj[ti_num-2]
			
		to_obj = ao_obj[ti_num - 1]
		tv_temp1 = v_target - OBJ_PosGet()
		tv_temp2 = v_target - @to_obj OBJ_PosGet()
		tf_dot = MATH_VecDotProduct(tv_temp1, tv_temp1)
		if(tf_dot > 9 || (tf_dot  > MATH_VecDotProduct(tv_temp2, tv_temp2)))
		{
			v_target = @to_obj OBJ_PosGet()
			tv_temp = v_target - OBJ_PosGet()
			tv_temp.z = 0
		}
	}
}

MATH_VecSetHorzNormalize(tv_temp)

if(COL_CollideType(COL_C_Wall))
{
	tv_temp = MATH_VecCrossProduct(Cv_VerticalVector, COL_NormalGet(COL_C_Wall))
	MATH_VecSetHorzNormalize(tv_temp)
}

tv_temp = MATH_VecBlendRotate(OBJ_SightGet(), tv_temp, 10 * TIME_GetDt())
OBJ_SightGeneralSet(tv_temp, Cv_VerticalVector)
ACT_ActionSet( 2 )
push( 0 )
