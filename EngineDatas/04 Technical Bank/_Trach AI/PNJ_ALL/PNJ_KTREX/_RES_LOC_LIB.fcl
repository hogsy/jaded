
#define			Ci_max_wall				20
#define			Cf_decalage_wall			0.1


//==============================================================================================
// Regroupe dans un tableau les infos des tests d'obstacle réalisés par Collision puis par LRay
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (BYREF) pi_cumul_nb : nombre de normales et flags de GMat cumulés
// (BYREFARR) pav_cumul_normales_tab : tableau de cumul des normales
// (BYREFARR) pai_cumul_gmat_flags_tab : tableau de cumul des flags de GMat
// pi_coll_nb : nombre d'obstacles détectés par Collision
// pav_coll_normales_tab : tableau des normales des obstacles détectés par Collision
// pai_coll_gmat_flags_tab : tableau des flags de GMat des obstacles détectés par Collision
// pi_lray_nb : nombre d'obstacles détectés par LRay
// pav_lray_normales_tab : tableau des normales des obstacles détectés par LRay
// pai_lray_gmat_flags_tab : tableau des flags de GMat des obstacles détectés par LRay
//==============================================================================================
procedure void RES_LOC_LIB_Cumul_Coll_LRay( byref int pi_cumul_nb, byrefarr vector pav_cumul_normales_tab, byrefarr int pai_cumul_gmat_flags_tab, int pi_coll_nb, byrefarr vector pav_coll_normales_tab, byrefarr int pai_coll_gmat_flags_tab, int pi_lray_nb, byrefarr vector pav_lray_normales_tab, byrefarr int pai_lray_gmat_flags_tab)
{
	int		ti_i
	
	pi_cumul_nb = 0
	// Collisions
	for( ti_i = 0; ti_i < pi_coll_nb; ti_i++)
	{
		pav_cumul_normales_tab[pi_cumul_nb] = pav_coll_normales_tab[ti_i]
		pai_cumul_gmat_flags_tab[pi_cumul_nb] = pai_coll_gmat_flags_tab[ti_i]
		pi_cumul_nb++
	}
	// LRay
	for( ti_i = 0; ti_i < pi_lray_nb; ti_i++)
	{
		pav_cumul_normales_tab[pi_cumul_nb] = pav_lray_normales_tab[ti_i]
		pai_cumul_gmat_flags_tab[pi_cumul_nb] = pai_lray_gmat_flags_tab[ti_i]
		pi_cumul_nb++
	}
}


//==============================================================================================
// Détecte les obstacles grâce à 2 lancers de rayon (D et G). Indique le nb de collisions détectées et remplit le tableau de vecteurs avec les normales.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Remarque : pas besoin de normaliser les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// pf_ray_side_decalage : distance de décalage sur les côtés pour les lancers de rayons
// pf_ray_add_size : distance supplémentaire pour le lancer de rayon (au-delà de la tête de l'acteur)
// pf_avance_recule : le gao avance (1.0) ou recule (-1.0) (pour la suppression des normales pas génantes)
// pv_orientation_parfaite : vecteur gao_dest - obj_me
// (BYREF) pi_normales_nb  : nombre de collisions détectées
// (BYREFARR) pav_normales : tableau des normales des collisions détectées
// (BYREFARR) pai_gmat_flags : tableau des flags des matériaux des collisions détectées
// ti_dbg : si vrai, affiche les vecteurs
//==============================================================================================
procedure void RES_LOC_LIB_LRay(float pf_ray_side_decalage, float pf_ray_add_size, float pf_avance_recule, vector pv_orientation_parfaite, byref int pi_normales_nb, byrefarr vector pav_normales, byrefarr int pai_gmat_flags, int ti_dbg)
{
	vector		tv_pos
	vector		tv_temp
	vector		tv_decal_cote
	vector		tv_normale
	float			tf_dist_check
	object		to_bone
	object		to_obj
	vector		tv_axis
	
	pi_normales_nb = 0
	tv_decal_cote = MATH_VecLocalToGlobal(cvector(pf_ray_side_decalage, 0, 0))
	
	// Calcul du rayon ------------------------------------------------------------------------------
	to_bone = ANI_CanalObjectGet(Anim_Canal_Tete)
	tv_temp = @to_bone OBJ_PosGet() - OBJ_PosGet()
	tv_temp.z = 0.0
	tv_temp += pf_ray_add_size * MATH_VecNormalize(tv_temp)			// longueur du lancer de raton
	tf_dist_check = MATH_VecDotProduct(OBJ_SightGet(), tv_temp)	// projection pour calculer la distance 
	
	// Sens des lancers de rayon -------------------------------------------------------------
	if( ! MATH_VecNullEpsilon(pv_orientation_parfaite) )
		tv_axis = pf_avance_recule * pv_orientation_parfaite
	else
		tv_axis = pf_avance_recule * OBJ_SightGet()
	MATH_VecSetNormalize(tv_axis)
	
	// Lancer de rayon à droite -----------------------------------------------------------------
	tv_pos = OBJ_PosGet() + Cv_VerticalVector - tv_decal_cote
	if( ti_dbg )
		DBG_RenderVector(tv_pos, tv_axis * tf_dist_check, color_bleu )
 	to_obj = COL_RayObject_Dist( tv_pos, tv_axis, tf_dist_check, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable )
	if( to_obj )
	{
		tv_normale = COL_RayObject_NormalGet()
		if( MATH_VecDotProduct(tv_normale, OBJ_SightGet()) < 0 )
		{
			if( ti_dbg )
				DBG_RenderVector(COL_RayObject_PosGet(), COL_RayObject_NormalGet(), color_rouge )
			if( ! MATH_VecNullEpsilon(tv_normale) )
			{
				pai_gmat_flags[pi_normales_nb] = COL_GMAT_FlagsGet(COL_C_Ray)
				pav_normales[pi_normales_nb] = tv_normale
				pi_normales_nb++
			}
			else
				ti_dbg = ti_dbg
		}
	}
	
	// Lancer de rayon à gauche -----------------------------------------------------------------
	tv_pos = OBJ_PosGet() + Cv_VerticalVector + tv_decal_cote
	if( ti_dbg )
		DBG_RenderVector(tv_pos, tv_axis * tf_dist_check, color_bleu )
	to_obj = COL_RayObject_Dist( tv_pos, tv_axis, tf_dist_check, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable )
	if( to_obj )
	{	
		tv_normale = COL_RayObject_NormalGet()
		if( MATH_VecDotProduct(tv_normale, OBJ_SightGet()) < 0 )
		{
			if( ti_dbg )
				DBG_RenderVector(COL_RayObject_PosGet(), COL_RayObject_NormalGet(), color_rouge )
			if( ! MATH_VecNullEpsilon(tv_normale) )
			{
				pai_gmat_flags[pi_normales_nb] = COL_GMAT_FlagsGet(COL_C_Ray)
				pav_normales[pi_normales_nb] = tv_normale
				pi_normales_nb++
			}
			else
				ti_dbg = ti_dbg
		}
	}
}


//==============================================================================================
// Détecte les obstacles par collision. Indique le nb de collisions détectées et remplit le tableau de vecteurs avec les normales.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Remarque : pas besoin de normaliser les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// pf_avance_recule : le gao avance (1.0) ou recule (-1.0) (pour la suppression des normales pas génantes)
// pv_orientation_parfaite : vecteur gao_dest - obj_me
// (BYREF) pi_normales_nb : nombre de collisions détectées
// (BYREFARR) pav_normales : tableau des normales des collisions détectées
// (BYREFARR) pai_gmat_flags : tableau des flags des matériaux des collisions détectées
// ti_dbg : si vrai, affiche les vecteurs
//==============================================================================================
procedure void RES_LOC_LIB_Collision(float pf_avance_recule, vector pv_orientation_parfaite, byref int pi_normales_nb, byrefarr vector pav_normales, byrefarr int pai_gmat_flags, int ti_dbg)
{
	int				ti_nbr_col
	int				ti_i
	vector		tv_normale
	vector		tv_pos
	vector		tv_edge_normale
	vector		tv_edge_pos
	int				ti_edge_gmat_flags
	int				ti_tab_wall[Ci_max_wall]
	int				ti_report_flag
	vector		tv_axis
	int				ti_gmat
	object		to_obj
	
	pi_normales_nb = 0
	tv_edge_normale = Cv_NullVector
	tv_edge_pos = Cv_NullVector
	ti_edge_gmat_flags = 0
	ti_report_flag = 0
	
	if( COL_CollideType(COL_C_Wall) )
	{
		ti_nbr_col = COL_ReportsNumberAndRanksGet( &ti_tab_wall[0], Ci_max_wall, COL_C_Wall )
		if( ti_nbr_col )
		{
			if( ! MATH_VecNullEpsilon(pv_orientation_parfaite) )
				tv_axis = pf_avance_recule * pv_orientation_parfaite
			else
				tv_axis = pf_avance_recule * OBJ_SightGet()
			
			for(ti_i=0; ti_i < ti_nbr_col; ti_i++ )
			{
				// suppression des normales des murs "pas vraiment" en collision et des arrêtes
				tv_normale = COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[ti_i])
				tv_pos = COL_CollidedPointGet(COL_C_ReportIndex + ti_tab_wall[ti_i])
				ti_report_flag = COL_ReportFlagGet(COL_C_ReportIndex + ti_tab_wall[ti_i])
				ti_gmat = COL_GMAT_FlagsGet(COL_C_ReportIndex + ti_tab_wall[ti_i])
				to_obj = COL_ObjectGet(COL_C_ReportIndex + ti_tab_wall[ti_i])
				
				if( ti_report_flag & ( COL_C_Extra_SlipperyEdge | COL_C_Extra_Corner ) )
				{
					// rapport de collision "bidon" : on zappe
				}
				else if( ti_report_flag & COL_C_Edge )
				{
					if( MATH_VecNullEpsilon(tv_edge_normale))		// mémo 1er edge
					{
						if( ti_dbg )
							DBG_RenderVector(tv_pos, tv_normale, color_vert)
						if( ! MATH_VecNullEpsilon(tv_normale) )
						{			
							tv_edge_pos = tv_pos		// backup pos pour rendervector ensuite
							tv_edge_normale = tv_normale
							ti_edge_gmat_flags = ti_gmat
						}
						else
							ti_dbg = ti_dbg
					}
				}
				else if( MATH_VecDotProduct( tv_axis, tv_normale ) >= 0)
				{
					// dans mon sens de déplacement : on zappe
				}
				else
				{
					// collision mur
					if( ti_dbg )
						DBG_RenderVector(tv_pos, tv_normale, color_rouge)
					if( ! MATH_VecNullEpsilon(tv_normale) )
					{
						pav_normales[pi_normales_nb] = tv_normale
						pai_gmat_flags[pi_normales_nb] = ti_gmat
						pi_normales_nb++
					}
					else
						ti_dbg = ti_dbg
				}
			}
			
			if( ! pi_normales_nb && ! MATH_VecNullEpsilon(tv_edge_normale) )
			{
				// je n'ai pas eu de rapport de mur mais j'ai mémorisé un rapport d'edge : je le récupère
				if( ti_dbg )
					DBG_RenderVector(tv_edge_pos, tv_edge_normale * 5, color_rouge)
				pav_normales[pi_normales_nb] = tv_edge_normale
				pai_gmat_flags[pi_normales_nb] = ti_edge_gmat_flags
				pi_normales_nb++
			}
		}
	}
}

//==============================================================================================
// Choix du sens de contournement : D ou G
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Remarque : pas besoin de normaliser les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// pv_normale : normale du rapport de collision
// pv_direction : direction de déplacement calculée pour cette normale
// (BYREF) pf_contourne_sens : sens de contournement choisi (G = 1.0 ; D = -1.0)
// ti_dbg : si vrai, affiche les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Retourne le vecteur de déplacement sélectionné
//==============================================================================================
procedure vector RES_LOC_LIB_Choix_Sens_Contournement( vector pv_normale, vector pv_direction, byref float pf_contourne_sens, int ti_dbg)
{
	vector		tv_ref						// vecteur de déplacement après choix de direction
	vector		tv_ref_gauche			// vecteur de référence pour contourner l'obstacle par la gauche
	float			tf_dot
	
	if( ti_dbg )
	{
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, pv_normale * 3, color_rouge)
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, pv_direction * 3, color_jaune)
	}
	tv_ref_gauche = MATH_VecCrossProduct(pv_normale, Cv_VerticalVector )	// vecteur de référence pour aller à gauche
	tf_dot = MATH_VecDotProduct(pv_direction, tv_ref_gauche)
	pf_contourne_sens = MATH_FloatSign(tf_dot)			// G = 1.0 | D = -1.0
	tv_ref = MATH_VecBlendRotate(pv_direction, - pv_normale, Cf_decalage_wall )
	if( ti_dbg )
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_ref * 3, color_cyan)
	return tv_ref
}


//==============================================================================================
// Procède à la résolution locale de déplacement en fonction des normales et gmats spécifiés en paramètre.
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Remarque : pas besoin de normaliser les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// pv_orientation_avant_resolution : axe de déplacement courant (s'il n'y avait pas de résolution locale)
// pv_orientation_parfaite : vecteur gao_dest - obj_me
// pi_coll_nb : nombre de rapports de collision à tester
// pav_coll_tab : tableau des normales des collisions détectées
// pai_gmat_flags : tableau des flags des matériaux des collisions détectées
// (BYREF) pf_contourne_sens : sens de contournement forcé (G = 1.0 ; D = -1.0 ; aucun = 0.0)
// (BYREF) pv_normale_choisie : renseigne la normale choisie pour le calcul du nouveau déplacement
// ti_dbg : si vrai, affiche les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Retourne le vecteur d'orientation calculé après la resolution locale
//==============================================================================================
procedure vector RES_LOC_LIB_Resolution_Locale_Normales(vector pv_orientation_avant_resolution, vector pv_orientation_parfaite, int pi_coll_nb, byrefarr vector pav_coll_tab, byrefarr int pai_gmat_flags, byref float pf_contourne_sens, byref vector pv_normale_choisie, int ti_dbg)
{
	vector	tv_normale					// normale du rapport de collision
	vector	tv_result						// vecteur de déplacement (résultat de la fonction)
	vector	tv_temp						// cross prod normale / verticale, en fct du côté choisi
	vector	tv_temp_decal				// décalage vers le mur pour rester dans le mur
	vector	tv_ref_gauche				// vecteur de référence pour longer le mur vers la gauche
	vector	tv_ref							// vecteur de déplacement référence pour les autres calculs pour tester si on a des calculs contradictoires
	int			ti_i
	int			ti_gmat_flags
	float		tf_dot
	
	if( MATH_VecNullEpsilon(pv_orientation_avant_resolution) || MATH_VecNullEpsilon(pv_orientation_parfaite) )
		return OBJ_SightGet()
	
	if( ti_dbg )
	{
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, pv_orientation_parfaite * 10, color_cyan)
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, pv_orientation_avant_resolution * 10, color_jaune)
	}
	if( ! pi_coll_nb )
	{
		// PAS D'OBSTACLE ===========================================
		pf_contourne_sens = 0.0
		tv_result = pv_orientation_avant_resolution
	}
	else
	{
		// PRESENCE D'OBSTACLE =====================================
	 	for( ti_i=0; ti_i < pi_coll_nb; ti_i++ )
		{
			tv_normale = pav_coll_tab[ti_i]
			pv_normale_choisie = tv_normale
 			ti_gmat_flags = pai_gmat_flags[ti_i]
			tv_ref_gauche = MATH_VecCrossProduct(tv_normale, Cv_VerticalVector )		// vecteur de référence pour aller à gauche
			tv_temp = MATH_VecCrossProduct( tv_normale, Cv_VerticalVector)
 			if( MATH_VecNullEpsilon(tv_temp) )
 				continue		// erreur : j'ai une normale verticale, donc un tv_temp null
 			
			if( ti_dbg )
			{
				DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_normale, color_rouge)
				DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp, color_bleu)
				DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_ref_gauche * 3, color_noire)
			}
			if( ti_gmat_flags & Gmat_KK_Force_Left )
			{
				pf_contourne_sens = 1.0
 				if( MATH_VecDotProduct(tv_temp, tv_ref_gauche) < 0 )
					tv_temp *= -1
			}
			else if( ti_gmat_flags & Gmat_KK_Force_Right )
			{
				pf_contourne_sens = -1.0
 				if( MATH_VecDotProduct(tv_temp, tv_ref_gauche) > 0 )
					tv_temp *= -1
			}
			else
			{
				if( pf_contourne_sens )		// sens de contournement forcé
				{
					tf_dot = MATH_VecDotProduct(tv_temp, tv_ref_gauche)
					if( MATH_FloatSign(tf_dot) != pf_contourne_sens )
						tv_temp *= -1				// si le vecteur n'est pas dans le sens dans lequel je souhaite aller, je prend le vecteur opposé
				}
				else			// sens de contournement libre
				{
					if( MATH_VecDotProduct(tv_temp, pv_orientation_parfaite) < 0 )
						tv_temp *= -1
				}
			}
			
			tv_temp_decal = MATH_VecBlendRotate( tv_temp, - tv_normale, Cf_decalage_wall )	// pour rester dans le mur	
			if( ti_dbg )
			{
				DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp, color_bleu)
				DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp_decal, color_cyan)
			}
			
 			if( ! ti_i )
			{
				tv_ref = tv_temp_decal							// 1er calcul : sert de référence
				if( pf_contourne_sens )
					break
			}
			else
			{
				if( MATH_VecDotProduct( MATH_VecNormalize(tv_ref), MATH_VecNormalize(tv_temp_decal) ) <= 0.1 )
				{
					// si j'ai 2 directions calculées qui s'opposent => je choisis un côté pour contourner l'obstacle
 					tv_ref = RES_LOC_LIB_Choix_Sens_Contournement( tv_normale, tv_temp, pf_contourne_sens, ti_dbg )
					break
				}
			}
		}
		if( ti_dbg )
		{
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp, color_rouge)
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_ref, color_bleu)
		}
		// TEST ZIG ZAG ==================================================
		if( ( ! pf_contourne_sens ) && MATH_VecDotProduct( MATH_VecNormalize(pv_orientation_avant_resolution), MATH_VecNormalize(tv_temp_decal) ) < 0.2 )
		{
			// on impose la direction pour éviter des zig-zag lorsqu'on est derrière un mur, face à l'acteur
			tv_ref = RES_LOC_LIB_Choix_Sens_Contournement( tv_normale, tv_temp, pf_contourne_sens, ti_dbg )
		}
		
		// SENS DE DEPLACEMENT APRES LES CALCULS =======================
		if( pf_contourne_sens )
			tv_result = tv_ref
		else
			tv_result = tv_temp
	}
	
	return tv_result
}


//==============================================================================================
// Procède à la détection d'obstacles par LRay et/ou Collision puis procède à la résolution locale de déplacement
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Remarque : pas besoin de normaliser les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// pi_coll_on : si vrai, les collisions sont testées 
// pi_ray_on : si vrai, les lancers de rayon sont utilisés
// pf_ray_side_decal : décalage sur les côtés pour les lancers de rayon
// pf_ray_add_size : longueur additionnelle au lancer de rayon (par défaut c'est pivot->tête)
// pf_avance_recule : le gao avance (1.0) ou recule (-1.0) (pour la suppression des normales pas génantes)
// pv_orientation_parfaite : vecteur gao_dest - obj_me
// pv_orientation_avant_resolution : orientation précalculée sans resolution locale
// (BYREF) pv_orientation_apres_resolution : orientation calculée après resolution locale
// (BYREF) pf_force_contourne_sens : sens de contournement forcé (G = 1.0 ; D = -1.0 ; aucun = 0.0)
// (BYREF) pv_normale_choisie : renseigne la normale choisie pour le calcul du nouveau déplacement
// ti_dbg : si vrai, affiche les vecteurs
//--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Retourne vrai si la résolution locale a été activée, faux sinon
//==============================================================================================
procedure int RES_LOC_LIB_Resolution_Locale_Collision_LRay(int pi_coll_on, int pi_ray_on, float pf_ray_side_decal, float pf_ray_add_size, float pf_avance_recule, vector pv_orientation_parfaite, vector pv_orientation_avant_resolution, byref vector pv_orientation_apres_resolution, byref float pf_force_contourne_sens, byref vector pv_normale_choisie, int ti_dbg)
{
	int				ti_i
	// Détection LRay
	int				ti_lray
	vector		tav_lray_normales[2]
	int				tai_lray_gmat_flags[2]
	// Détection Coll
	int				ti_coll
	vector		tav_coll_normales[Ci_max_wall]
	int				tai_coll_gmat_flags[Ci_max_wall]
	// Cumul LRay+Coll
	int				ti_cumul
	vector		tav_cumul_normales[Ci_max_wall]
	int				tai_cumul_gmat_flags[Ci_max_wall]
	
	// DETECTION DES OBSTACLES PAR COLLISION
	ti_coll = 0
	if( pi_coll_on )
		RES_LOC_LIB_Collision(pf_avance_recule, pv_orientation_parfaite, ti_coll, &tav_coll_normales[0], &tai_coll_gmat_flags[0], ti_dbg)
	
	// DETECTION DES OBSTACLES PAR LANCER DE RAYON
	ti_lray = 0
	if( pi_ray_on )
		RES_LOC_LIB_LRay( pf_ray_side_decal, pf_ray_add_size, pf_avance_recule, pv_orientation_parfaite, ti_lray, &tav_lray_normales[0], &tai_lray_gmat_flags[0], ti_dbg)

	// FUSION DES RESULTATS DES DEUX TYPES DE DETECTION DES OBSTACLES
	RES_LOC_LIB_Cumul_Coll_LRay( ti_cumul, &tav_cumul_normales[0], &tai_cumul_gmat_flags[0], ti_coll, &tav_coll_normales[0], &tai_coll_gmat_flags[0], ti_lray, &tav_lray_normales[0], &tai_lray_gmat_flags[0])
	
	// RESOLUTION LOCALE
	pv_orientation_apres_resolution = RES_LOC_LIB_Resolution_Locale_Normales(pv_orientation_avant_resolution, pv_orientation_parfaite, ti_cumul, &tav_cumul_normales[0], &tai_cumul_gmat_flags[0], pf_force_contourne_sens, pv_normale_choisie, ti_dbg)
	if( pv_orientation_apres_resolution != pv_orientation_avant_resolution || pf_force_contourne_sens )
		return vrai
	else
		return faux
}
