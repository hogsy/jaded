#include "KT_defines.var"

int			ti_i
int			ti_k
int			ti_flag_quaternion

float		tf_borne_inf
float		tf_borne_sup
float		tf_coef
float		tf_totale_norm
float		tf_pourcentage
float		tf_step
float		tf_angle
float		tf_anim_angle
float		tf_X
float		tf_Z	
float		tf_length_coef
float		tf_dot_product
float		tf_dist
float		tf_AB_and_CD_dist
float		tf_IK_coef
float		tf_Z_balayage_range
float		tf_head_length
float		tf_bone_sqr_length
float		tf_dt

vector	tv_ref_sight
vector	tv_pseudo_bone
vector	tv_temp
vector	tv_hor_half_plan
vector	tv_hor_look_dir

vector	tv_point_A
vector	tv_point_B
vector	tv_point_C
vector	tv_point_D

vector	tv_head_pos
vector	tv_head_sight
vector	tv_col_head_pos

vector	tv_start_pos
vector	tv_dest_pos

vector	tv_new_head_sight
vector	tv_new_head_banking

object	to_collision_object
object	to_target


if (@get_global i_IK_NECK_Off)
	return

if ( i_frame_nb < 10)
	tf_dt = 1000.0
else
	tf_dt = TIME_GetDt()

ti_flag_quaternion = vrai
tf_AB_and_CD_dist = f_neck_length * 0.75

tf_step = 1.0
tf_step /= i_head_bone_nb

tv_point_A = @ao_head_bones[0] OBJ_PosGet()
tv_point_B = @ao_head_bones[i_head_bone_nb - 1] OBJ_PosGet()

tf_Z_balayage_range = 1.2
tf_head_length = 3.0

tv_ref_sight = @ao_head_bones[i_head_bone_nb] OBJ_BankingGet()
tv_ref_sight -= MATH_VecDotProduct(tv_ref_sight, OBJ_BankingGet()) * OBJ_BankingGet()
MATH_VecSetNormalize(tv_ref_sight)

v_neck_head_anti_col_pos = @ao_head_bones[i_head_bone_nb] OBJ_PosGet() + @ao_head_bones[i_head_bone_nb] MATH_VecLocalToGlobal(v_neck_head_anti_col_pos)

if (o_DBG_pilotage_tete)
{
	tv_head_pos = @o_DBG_pilotage_tete OBJ_PosGet()
	tv_head_sight = @o_DBG_pilotage_tete OBJ_SightGet()
}
else
{
	// SI ON PILOTE LA TETE, ON VA DETERMINER LA POSITION DE LA TETE
	// EN FONCTION DE L'ANIM ET DE LA POSITION QU'ON VEUT REGARDER
	if (f_look_blend_coef)
	{
		tv_point_A -= tv_point_B
		
		tv_hor_look_dir = v_look_axis
		tv_hor_look_dir -= MATH_VecDotProduct(tv_hor_look_dir, v_IK_bassin_banking) * v_IK_bassin_banking
		MATH_VecSetNormalize(tv_hor_look_dir)

		tf_dot_product = MATH_VecDotProduct(tv_ref_sight, tv_hor_look_dir)
		tv_temp = MATH_VecCrossProduct(tv_ref_sight, tv_hor_look_dir)

		tf_angle = MATH_VecNorm(tv_temp)
		if (tf_angle)
		{
			tv_temp /= tf_angle
			tf_angle = MATH_FloatMin(tf_angle, 1.0)
		
			tf_angle = MATH_ASin(tf_angle)
			if (tf_dot_product < 0.0)	
				tf_angle = Cf_Pi - tf_angle
				
			tf_angle *= 0.5
			tf_angle *= f_look_blend_coef
		
			tf_length_coef = MATH_AbsFloat(tf_angle)
			tf_length_coef /= Cf_PiBy2
			tf_length_coef *= 0.2
			tf_length_coef = 1.0 - tf_length_coef
		
			tv_point_A = MATH_VecRotate(tv_point_A, tv_temp, tf_angle)
			tv_point_A *= tf_length_coef
		}
		
		tv_point_A += tv_point_B
		tv_point_C = v_bezier_head_look_pos

		// (begin) align head Z -------------------------------------------------------
		to_target = nobody
		if( o_fight_actor )
		{
			to_target = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete)
			if( ! to_target )
				to_target = o_fight_actor
		}
		else if( o_Kong )
		{
			to_target = @o_Kong ANI_CanalObjectGet(Anim_Canal_Tete)
			if( ! to_target )
				to_target = o_Kong
		}
		else if( o_Jack )
		{
			to_target = @o_Jack ANI_CanalObjectGet(Anim_Canal_Tete)
			if( ! to_target )
				to_target = o_Jack
		}
		if( to_target )
		{
			tv_point_A.z = MATH_FloatBlend(tv_point_A.z, @to_target OBJ_PosGet() .z + 1.0, f_machoire_rot_coef)
			tv_point_C.z = MATH_FloatBlend(tv_point_C.z, @to_target OBJ_PosGet().z + 4.0, f_machoire_rot_coef)
		}
		// (end) align head Z -------------------------------------------------------
		
		tv_head_sight = MATH_VecNormalize(tv_point_C - tv_point_A)
	}
	else
	{
		tv_head_sight = @ao_head_bones[0] OBJ_BankingGet()
	}
	
	// On ne veut pas que la tete passe sous le sol
	COL_SpecificCrossableSet(all)
	if (COL_RayObject_Dist(tv_point_A + (5.0 * Cv_VerticalVector), -Cv_VerticalVector, 15.0, all, OBJ_C_IdentityFlag_Dyna | OBJ_C_IdentityFlag_Anims | OBJ_C_IdentityFlag_ODE, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable | COL_C_Ray_use_SpecificCrossableSet))
	{
		tv_point_C = COL_RayObject_PosGet()
//		DBG_RenderVector(tv_point_A, tv_point_C - tv_point_A, color_jaune)
		f_head_Z_min = MATH_FloatBlend(f_head_Z_min, tv_point_C.z + 2.0, 8.0 * tf_dt)
	}
	else
	{
		f_head_Z_min = MATH_FloatBlend(f_head_Z_min, OBJ_PosGet().z, 2.0 * tf_dt)
	}

	tv_point_A.z = MATH_FloatMax(tv_point_A.z, f_head_Z_min)
	
	tv_head_pos = tv_point_A
	
	tv_point_C = tv_head_pos
	tv_point_D = OBJ_PosGet()
	tv_point_D.z = @ao_head_bones[i_head_bone_nb - 1] OBJ_PosGet().z
	
	switch(i_etat_courant)
	{
		case ETAT_KO_au_sol :
		case ETAT_mort :
			f_neck_vert_coef	-= MATH_FloatMin(f_neck_vert_coef, 4.0 * tf_dt)
			tv_point_C += OBJ_BankingGet() * 0.25
			tv_point_D -= MATH_VecDotProduct(tv_point_D - tv_point_C, OBJ_BankingGet()) * OBJ_BankingGet()
			break	

		default:
			f_neck_vert_coef	+= MATH_FloatMin(1.0 - f_neck_vert_coef, 4.0 * tf_dt)

			tv_temp = MATH_VecRotate(OBJ_BankingGet(), tv_point_C - tv_point_D, f_head_col_ray_Z_offset* Cf_Pi) * tf_Z_balayage_range
//			DBG_RenderVector(tv_point_C, tv_temp, color_rose)
//			DBG_RenderVector(tv_point_D, tv_temp, color_rose)
			tv_point_C += tv_temp
			tv_point_D += tv_temp
			break
	}
}


f_neck_B_weight = MATH_FloatBlend(f_neck_length, 0.5 * f_neck_length, f_time_head_col)
f_neck_C_weight = MATH_FloatBlend(0.5, 1.9, f_time_head_col)

if (f_time_head_col)
{
	tv_head_pos = MATH_VecBlendRotate(tv_head_pos - tv_point_B, v_neck_head_anti_col_pos - tv_point_B, f_time_head_col)
	tf_dist = MATH_VecNorm(tv_head_pos)
	tv_head_pos /= tf_dist
	tv_head_pos *= MATH_FloatLimit(tf_dist, f_neck_length * 0.8, f_neck_length * 0.95)
	tv_head_pos += tv_point_B

//	DBG_RenderVector(tv_point_B, tv_head_pos - tv_point_B, color_blanc)

	if (f_look_blend_coef == 1.0)
	{
		tv_start_pos = MATH_VecNormalize(tv_head_pos - tv_point_B)
		tv_dest_pos = MATH_VecNormalize(v_bezier_head_look_pos - tv_head_pos)
		tf_dot_product = MATH_VecDotProduct(tv_start_pos, tv_dest_pos)
		tv_dest_pos = MATH_VecBlendRotate(tv_start_pos, tv_dest_pos, tf_dot_product)
	}
	else if ( ! f_look_blend_coef )
	{
		tv_start_pos = tv_head_pos - tv_point_B
		tv_start_pos -= MATH_FloatMin(MATH_VecDotProduct(tv_start_pos, v_neck_col_normale), 0.0) * v_neck_col_normale
		MATH_VecSetNormalize(tv_start_pos)

		tv_dest_pos = tv_head_sight
	}
	else
	{
		tv_start_pos = MATH_VecNormalize(tv_head_pos - tv_point_B)
		tv_dest_pos = MATH_VecNormalize(v_bezier_head_look_pos - tv_head_pos)
		tf_dot_product = MATH_VecDotProduct(tv_start_pos, tv_dest_pos)
		tv_dest_pos = MATH_VecBlendRotate(tv_start_pos, tv_dest_pos, tf_dot_product)

		tv_start_pos = tv_head_pos - tv_point_B
		tv_start_pos -= MATH_FloatMin(MATH_VecDotProduct(tv_start_pos, v_neck_col_normale), 0.0) * v_neck_col_normale
		MATH_VecSetNormalize(tv_start_pos)
		
		tv_dest_pos = MATH_VecBlendRotate(tv_start_pos, tv_dest_pos, f_look_blend_coef)
	}

	tv_head_sight = MATH_VecBlendRotate(tv_head_sight, tv_dest_pos, f_time_head_col)

//	if (!f_neck_col_duration)
		f_time_head_col -= MATH_FloatMin(f_time_head_col, 4.0 * tf_dt)
}

f_neck_col_duration -= MATH_FloatMin(f_neck_col_duration, tf_dt)

if (!f_time_head_col)
	v_neck_head_anti_col_pos = tv_head_pos

v_neck_head_anti_col_pos = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(v_neck_head_anti_col_pos - @ao_head_bones[i_head_bone_nb] OBJ_PosGet())

tf_IK_coef = MATH_FloatMax(f_look_blend_coef, f_time_head_col)

// PAS DU TOUT DE PILOTAGE !!!!
if (!tf_IK_coef)
{
	f_neck_bezier_coef					= 1.0
	af_neck_bone_bezier_coef[0]		= 1.0
	af_neck_bone_bezier_coef[1]		= 0.8
	af_neck_bone_bezier_coef[2]		= 0.6
	af_neck_bone_bezier_coef[3]		= 0.4
	af_neck_bone_bezier_coef[4]		= 0.2

	return
}

tv_head_sight = MATH_VecBlendRotate(@ao_head_bones[0] OBJ_BankingGet(), tv_head_sight, tf_IK_coef)

#ifndef _FINAL_
if (i_DBG_Display_Pilotage)
	DBG_RenderVector(tv_head_pos, tv_head_sight, color_blanc)
#endif

// C'EST PARTI POUR TROUVER UNE BONNE BEZIER ============================================
tv_point_A = @ao_head_bones[i_head_bone_nb - 1] OBJ_PosGet()
tv_point_D = tv_head_pos

// =============================================================================
// On fait une première dichotomie pour trouver en gros une courbe de la même longueur que celle du cou
// =============================================================================
tf_borne_inf = 0.0
tf_borne_sup = 2.0
ti_k = 0
tf_totale_norm = 0.0
while(ti_k < 10)
{
	ti_k++

	tf_totale_norm	= 0.0

	tf_pourcentage = tf_borne_inf
	tf_pourcentage += (tf_borne_sup - tf_borne_inf) * 0.5

	tv_point_B = tv_point_A
	tv_point_B += @ao_head_bones[i_head_bone_nb - 1]  OBJ_BankingGet() * (f_neck_B_weight * tf_pourcentage)

	tv_point_C = tv_point_D	
	tv_point_C -= tv_head_sight * f_neck_C_weight

	tv_start_pos = @ao_head_bones[i_head_bone_nb - 1] OBJ_PosGet()
	tv_dest_pos = tv_start_pos

	for (ti_i = 1; ti_i < i_head_bone_nb - 1; ti_i++)
	{
		tf_coef = ti_i * tf_step
		tv_start_pos = tv_dest_pos
		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_temp)
		tf_totale_norm += MATH_VecNorm(tv_dest_pos - tv_start_pos)
	}

	tf_totale_norm += MATH_VecNorm(tv_point_D - tv_dest_pos)

	if (MATH_AbsFloat(tf_totale_norm - f_neck_length) < 0.2)
	{
		// OK, C'est bon
		ti_k = ti_k
		break
	}
	else if (tf_totale_norm > f_neck_length)
	{
		tf_borne_sup -= tf_borne_inf
		tf_borne_sup *= 0.5
		tf_borne_sup += tf_borne_inf 
	}
	else
	{
		tf_borne_inf -= tf_borne_sup
		tf_borne_inf *= 0.5
		tf_borne_inf += tf_borne_sup
	}
}

f_neck_bezier_coef = MATH_FloatBlend(f_neck_bezier_coef, tf_pourcentage, 6.0 * tf_dt)
tf_pourcentage = f_neck_bezier_coef

// ON A ENFIN NOS 4 POINTS QUI DETERMINENT LA COURBE ==============================================
tv_point_B = tv_point_A
tv_point_B += @ao_head_bones[i_head_bone_nb - 1] OBJ_BankingGet() * (f_neck_B_weight * tf_pourcentage)

tv_point_C = tv_point_D	
tv_point_C -= tv_head_sight * f_neck_C_weight

#ifndef _FINAL_
if (i_DBG_Display_Pilotage)
	MATH_LIB_Bezier_Display(30, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
#endif

// =========================================================================
// Pour les bones, on va rechercher une position sur la courbe telle que la longueur de l'os soit correcte
// =========================================================================

tf_borne_inf = 0.0
tv_start_pos = tv_point_A

for (ti_i = i_head_bone_nb - 1; ti_i > 1; ti_i--)
{
	tf_borne_sup = 1.0

	ti_k = 0

	tf_bone_sqr_length = af_neck_bone_length[ti_i - 1]
	tf_bone_sqr_length *= tf_bone_sqr_length

	while (ti_k < 10)
	{
		ti_k++

		tf_coef = tf_borne_inf 
		tf_coef += (tf_borne_sup - tf_borne_inf) * 0.5
	
		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_temp)

		tv_pseudo_bone = tv_dest_pos - tv_start_pos
		tf_totale_norm = MATH_VecDotProduct(tv_pseudo_bone, tv_pseudo_bone)

		if (MATH_AbsFloat(tf_totale_norm - tf_bone_sqr_length) < 0.1)
		{
			// OK, C'est bon
			break
		}
		else if (tf_totale_norm > tf_bone_sqr_length)
		{
			tf_borne_sup -= tf_borne_inf
			tf_borne_sup *= 0.5
			tf_borne_sup += tf_borne_inf 
		}
		else
		{
			tf_borne_inf -= tf_borne_sup
			tf_borne_inf *= 0.5
			tf_borne_inf += tf_borne_sup
		}
	}

	af_neck_bone_bezier_coef[ti_i] = MATH_FloatBlend(af_neck_bone_bezier_coef[ti_i], tf_coef, 6.0 * tf_dt)
	tf_coef = af_neck_bone_bezier_coef[ti_i]

	// On récupère la position une dernière fois après le blend
	tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_temp)

	if (ti_i < i_head_bone_nb - 1)
		tv_temp = @ao_head_bones[ti_i + 1] OBJ_SightGet()
	else
		tv_temp = MATH_VecBlend(@ao_head_bones[ti_i] OBJ_SightGet(), -Cv_VerticalVector, f_neck_vert_coef)

	if (ti_flag_quaternion)
	{
		@ao_head_bones[ti_i] OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), MATH_VecBlendRotate(cvector(0.0, 0.0, 1.0),  @ao_head_bones[ti_i]  MATH_VecGlobalToLocal(tv_dest_pos - tv_start_pos), tf_IK_coef))

		tv_new_head_sight = @ao_head_bones[ti_i] OBJ_HorizonGet() 
		tv_new_head_sight.z = 0.0
		tv_new_head_sight = MATH_VecBlend(@ao_head_bones[ti_i] OBJ_HorizonGet() , tv_new_head_sight, tf_IK_coef * 0.5)
		@ao_head_bones[0] OBJ_Rotate_FromTo(cvector(1.0, 0.0, 0.0), @ao_head_bones[ti_i]  MATH_VecGlobalToLocal(tv_new_head_sight))
	}
	else
	{
		@ao_head_bones[ti_i] OBJ_BankingGeneralSet(	MATH_VecBlend(@ao_head_bones[ti_i] OBJ_SightGet(), tv_temp, tf_IK_coef),
																			MATH_VecBlend(@ao_head_bones[ti_i] OBJ_BankingGet(), tv_dest_pos - tv_start_pos, tf_IK_coef)	)
	}

	tv_start_pos = @ao_head_bones[ti_i - 1] OBJ_PosGet()
}

if (ti_flag_quaternion)
{
	@ao_head_bones[1] OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), MATH_VecBlendRotate(cvector(0.0, 0.0, 1.0),  @ao_head_bones[1]  MATH_VecGlobalToLocal(tv_head_pos - @ao_head_bones[1] OBJ_PosGet()), tf_IK_coef))

	tv_new_head_sight = @ao_head_bones[1] OBJ_HorizonGet() 
	tv_new_head_sight.z = 0.0
	tv_new_head_sight = MATH_VecBlend(@ao_head_bones[1] OBJ_HorizonGet() , tv_new_head_sight, tf_IK_coef * 0.5)
	@ao_head_bones[1] OBJ_Rotate_FromTo(cvector(1.0, 0.0, 0.0), @ao_head_bones[1]  MATH_VecGlobalToLocal(tv_new_head_sight))
}
else
{
	@ao_head_bones[1] OBJ_BankingGeneralSet(		MATH_VecBlend(@ao_head_bones[1] OBJ_SightGet(), @ao_head_bones[2] OBJ_SightGet(), tf_IK_coef),
																		MATH_VecBlend(@ao_head_bones[1] OBJ_BankingGet(), tv_head_pos - @ao_head_bones[1] OBJ_PosGet(), tf_IK_coef)	)
}

if (i_flag_head_search)
	f_look_head_coef = MATH_FloatBlend(f_look_head_coef, 0.5 + (MATH_Sin(TIME_Get() * 3.0) * 0.1), 6.0 * tf_dt)
else
	f_look_head_coef = MATH_FloatBlend(f_look_head_coef, 0.85, 6.0 * tf_dt)

if (ti_flag_quaternion)
{
	tv_new_head_banking = MATH_VecBlendRotate(@ao_head_bones[0] OBJ_BankingGet(), tv_head_sight, tf_IK_coef * f_look_head_coef)
	@ao_head_bones[0] OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), @ao_head_bones[0]  MATH_VecGlobalToLocal(tv_new_head_banking))

	tv_new_head_sight = @ao_head_bones[0] OBJ_HorizonGet() 
	tv_new_head_sight.z = 0.0
	tv_new_head_sight = MATH_VecBlend(@ao_head_bones[0] OBJ_HorizonGet() , tv_new_head_sight, tf_IK_coef *  0.5)
	@ao_head_bones[0] OBJ_Rotate_FromTo(cvector(1.0, 0.0, 0.0), @ao_head_bones[0]  MATH_VecGlobalToLocal(tv_new_head_sight))
	@ao_head_bones[0] OBJ_RotateLocalX(- tf_IK_coef * 0.3)
}
else
{
	tv_new_head_sight = MATH_VecBlend(-Cv_VerticalVector, @ao_head_bones[1] OBJ_SightGet(), f_time_head_col * 0.75)
	tv_new_head_sight = MATH_VecBlendRotate(@ao_head_bones[0] OBJ_SightGet(), tv_new_head_sight, tf_IK_coef)

	tv_new_head_banking = MATH_VecBlendRotate(@ao_head_bones[0] OBJ_BankingGet(), tv_head_sight, tf_IK_coef * f_look_head_coef)

	@ao_head_bones[0] OBJ_BankingGeneralSet	(tv_new_head_sight, tv_new_head_banking)
}

