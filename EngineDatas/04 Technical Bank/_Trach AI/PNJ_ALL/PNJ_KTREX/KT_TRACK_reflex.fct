#include "KT_defines.var"

int				ti_ind
int				ti_rank

float			tf_dist

object		to_canal
object		to_actor

vector		tv_pos_2D
vector		tv_speed
vector		tv_new_ground_normale

messageid		EVT_ID

message		tm_msg_filter

AI_Execute("KT_exec_check_main_actors")


i_frame_nb++
i_flag_cadavres_check_done = faux


//ADDED SURESH
f_global_time = TIME_Get()

// TEST ETAT KONG --------------------------------------------------------------------------------------------------------------------------------------------------------
i_Kong_Mashing = faux
i_Kong_Gladiator = faux
i_Kong_Paf = faux
i_Kong_Swing = faux
if( o_Kong )
{
	if( @o_Kong Proc_KK_Test_Mode(ETAT_Kong_grab_mashing) )
		i_Kong_Mashing = vrai
	if( @o_Kong Proc_KK_ModeGladiator() )
		i_Kong_Gladiator = vrai
	if( @o_Kong Proc_KK_Test_Mode(ETAT_Kong_desequilibre_paf_fort) )
		i_Kong_Paf = vrai
	if( @o_Kong Proc_KK_Test_Mode(ETAT_Kong_swing_arch) )
		i_Kong_Swing = vrai
}
// TEST ETAT KONG --------------------------------------------------------------------------------------------------------------------------------------------------------


//i_force_change_anim = faux
i_occluder_cette_trame = faux
i_fight_just_paf = faux
i_charge_interdite = faux

f_time_KONG -= MATH_FloatMin(f_time_KONG, TIME_GetDt())

// TIMER D EX CROUTAGE : SERT A LANCER LE RECUL
f_jauge_croutage = MATH_FloatMax( f_jauge_croutage - TIME_GetDt(), 0.0)

f_Jack_paf_jauge -= MATH_FloatMin(f_Jack_paf_jauge, 2.0 * TIME_GetDt())


// FURY ========================================
AI_Execute("KT_exec_check_fury")
if( o_fury_check_actor )
{
	// INTERRUPTION DES ETATS FIGHT ============================================================
	if( KT_IsEtatFightMove() || i_etat_courant == ETAT_attente || i_etat_courant == ETAT_attaque )	// TEST FURY CANCEL (CHARGE + ATTAQUE)
	{
		o_fury_actor = o_fury_check_actor
		i_cri_filtre |= Ci_CRI_PAS_D_ATTENTE_BLESSE
		macro_change_etat("KT_ETAT_cri")
	}
}


// TRIGGER CIBLE EN HAUTEUR ===============================================================
if( i_etat_courant == ETAT_attente || i_etat_courant == ETAT_fight_KONG )
{
	switch( KT_CibleEnHauteur() )
	{
		case Ci_Cible_Pas_En_Hauteur :
			i_cible_haut_cancel_mur = faux			//  Var qui empeche Kong de marcher vers un mur k il a détecté
			break
			
		case Ci_Cible_En_Hauteur_Mode_Walling :
		case Ci_Cible_En_Hauteur_Mode_Pas_Walling :
			macro_change_etat("KT_ETAT_fight_cible_hauteur")
			break
	}
}


// ANALYSE =====================================
i_flag_paf_check_done			= faux
i_fight_actor_init_done 			= faux
i_fight_actor_select_done		= faux

i_flag_look = faux

// IK LEGS ======================================
i_flag_leg_IK[0] = vrai
i_flag_leg_IK[1] = vrai

// IK COU =======================================
v_look_head_pos = OBJ_PosGet() + MATH_VecLocalToGlobal(v_look_head_pos)
v_look_banking = MATH_VecLocalToGlobal(v_look_banking)

v_look_virtual_sight = v_look_banking
v_look_virtual_sight.z = 0.0
if( ! MATH_VecNullEpsilon(v_look_virtual_sight) )
	MATH_VecSetNormalize(v_look_virtual_sight)
else
	v_look_virtual_sight = OBJ_SightGet()

f_look_angle_blend_speed = 4.0

// IK ==========================================
f_IK_speed[Ci_IK_pied_gauche]		= TIME_GetDt() * 6.0
f_IK_speed[Ci_IK_pied_droit]			= f_IK_speed[Ci_IK_pied_gauche]

i_flag_climb_IK[Ci_IK_pied_gauche]	= faux
i_flag_climb_IK[Ci_IK_pied_droit]		= faux

i_flag_walk_IK[Ci_IK_pied_gauche]		= faux
i_flag_walk_IK[Ci_IK_pied_droit]			= faux

i_flag_walk_IK[Ci_IK_pied_gauche]		= vrai
i_flag_walk_IK[Ci_IK_pied_droit]			= vrai


// FACE DE MORT ==================================
if( COL_CollideType( COL_C_Ground) )
	if( COL_GMAT_FlagsGet(COL_C_Ground) & (Gmat_KK_Face_de_mort | Gmat_KK_Face_de_lave ) )
		OBJ_Destroy()

// LECTURES DES MESSAGES ========================
AI_Execute("KT_exec_check_msg")
if( o_jumpattak_actor_msg && i_etat_courant != ETAT_JumpAttak )
{
 	macro_change_etat( "KT_ETAT_JumpAttak")
}
// Détection d'un envoi de projectile de Kong
if( o_msg_projectile && KT_ChoppeProjectileAllowed() )
{
	o_KK_projectile = o_msg_projectile
	macro_change_etat("KT_ETAT_choppe")
}
if ( o_charge_actor)
{
	macro_change_etat("KT_ETAT_charge")
}

// TEST PAF ZONE ==================================
//EVENT_AddEventPafZone( C_EVENT_FILTER_Object, C_EVENT_PAF_Moyen , OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet(), 6.0,Cf_DMG_Zone_Presence)
//for (ti_i = 0; ti_i < 5; ti_i ++)
//{
//	to_canal = ANI_CanalObjectGet( Anim_Canal_Queue + ti_i)
//	EVENT_AddEventPafZone( C_EVENT_FILTER_Object, C_EVENT_PAF_Moyen , OBJ_Me(), Cf_EVENT_Duree_1Trame, @to_canal OBJ_PosGet(), 1.0,Cf_DMG_Zone_Presence)
//}


// TEST COLLISION KONG ========================
i_KONG_virtual_collision = faux
i_paf_exit_colmap_mode = faux
if( o_Kong )
{
	i_KONG_virtual_collision = OBJ_LIB_Virtual_Collision(OBJ_Me(), o_Kong, faux)
	
	tf_dist = OBJ_SqrDist(o_Kong)
	if( tf_dist < 26.0 && KT_AntiBug_Col_KONG_Autorise() && i_KONG_virtual_collision )
	{
		// KONG dans REX : repousser KONG
		i_paf_exit_colmap_mode = vrai		// mode paf exit colmap allumé
		if( ARR_ObjSearch(&ao_uncol_old[0] , i_uncol_old_nb, o_Kong) == -1 )
		{
			KT_Uncol_Add(o_Kong)
		}
	}
}

// GESTION DES UNCOLLIDES =======================================================================
// 1 - les RAPTORS
ti_rank = -1

// ON RECUPERE LE CONTEXT VISUEL DU MAIN ACTOR
MSG_SetNull(tm_msg_filter)
tm_msg_filter.msg_int1 = C_EVENT_FILTER_Raptor
ti_rank = -1
for(	EVT_ID = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Visibility, &ti_rank, tm_msg_filter);
		MSG_GlobalIsValid(EVT_ID);
		EVT_ID = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Visibility, &ti_rank, tm_msg_filter) )
{
	to_actor = MSG_GlobalGetSender(EVT_ID)
	ti_ind = ARR_ObjSearch( &ao_uncol_list[0], i_nb_uncol, to_actor) 
	if ( ti_ind == -1 )
	{
		// ajout d un raptor uncollide
//		ai_uncol_done[i_nb_uncol] = 1 // l acteur est la on le rentre
		ao_uncol_list[ i_nb_uncol] = to_actor
		i_nb_uncol ++
		@to_actor COL_UnCollidableAdd( OBJ_Me())
	}
//	else
//		ai_uncol_done[ti_ind] = 1 // l acteur est encore la
}


// VISION NMI & CADAVRE ===============================================
if( i_etat_courant != ETAT_mort )
{
	EVENT_AddEventVision(C_ID_Tyranosaure, C_EVENT_FILTER_Tyranosaure, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet(), C_EVENT_Visibility_Full_Mvt, Cf_Rayon_De_Vision, Cf_Degre_Interet_TREX, C_EVENT_CONTEXT_STANDARD, 0, EVENT_LIFE_CurLifeGet(ID_LIFE) / EVENT_LIFE_MaxLifeGet(ID_LIFE))
	EVENT_AddEventEnemy( C_ID_Tyranosaure, OBJ_Me(), C_EVENT_EnemyState_Fight)
	
	// display --------------------
	to_canal = ANI_CanalObjectGet(Anim_Canal_Tete)
	tv_pos_2D = VIEW_3dWorldTo2d( 0, @to_canal OBJ_PosGet() + cvector(0.0,0.0,1.5))
	EVENT_LIFE_StateDisplay( ID_LIFE, tv_pos_2D)
	tv_pos_2D -= cvector( 0.0, 0.05,0.0)
	EVENT_LIFE_LifeDisplay( ID_LIFE, tv_pos_2D)
}

if( ! EVENT_LIFE_CurLifeGet(ID_LIFE) )
{
	// même ko au sol, les bats commencent à venir vers moi !!!
	EVENT_AddEventCadavre(C_ID_Tyranosaure, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet())
}


// GRABBED =================================================
i_grabbed_special = faux		// Par défaut on a un grab classique
ANI_Pause(faux)
if ( o_grabbed_actor_KK_ref  )
	@o_grabbed_actor_KK_ref  ANI_Pause(faux)
if ( o_I_finish_actor_ref )
	@o_I_finish_actor_ref ANI_Pause(faux)

// LIFE
if ( EVENT_LIFE_Est_Blesse(ID_LIFE))
{
	i_blesse_on = vrai
	i_Anim_attente = Action_Blesse_Attente
	i_Anim_marche = Action_Blesse_Marche
}
else
{
	i_blesse_on = faux
	i_Anim_attente = Action_Normal_Attente
	i_Anim_marche = Action_Normal_Marche_Rapide
}

if ( EVENT_LIFE_CurLifeGet( ID_LIFE) <= 0.0 && ( KT_IsEtatFightMove() || i_etat_courant == ETAT_attente) )
{
	f_fatigue_time = 5.0
	v_paf_sens = - OBJ_SightGet()
	macro_change_etat("KT_ETAT_KO_au_sol")
}


// Maintenir le TREX au SOL
tv_speed = DYN_SpeedGetVector()
if ( tv_speed.z > 0.0)
{
	tv_speed.z = 0.0
	DYN_SpeedSetVector( tv_speed)
}


// JAUGES DE CONTRE ATTAQUE =============================
// contre les pafs
f_time_contre_attaque += TIME_GetDt()
if( f_jauge_contre_attaque > 0.0 && f_time_contre_attaque > 2.0 )
{
	f_jauge_contre_attaque = 0.0
}

// contre les repousse
f_time_contre_repousse += TIME_GetDt()
if( f_jauge_contre_repousse > 0.0 && f_time_contre_repousse > 2.5 )
{
	f_jauge_contre_repousse = 0.0
}

// contre les grabs
f_grabbed_jauge_last_time += TIME_GetDt()
f_grabbed_jauge_refuse_delay -= MATH_FloatMin(f_grabbed_jauge_refuse_delay, TIME_GetDt())

// contre les charges
f_time_contre_dash_attack += TIME_GetDt()
if( f_jauge_contre_dash_attack > 0.0 && f_time_contre_dash_attack > 2.0 )
{
	f_jauge_contre_dash_attack = 0.0
}

if ( i_etat_courant != ETAT_mort && i_etat_courant != ETAT_charge && i_etat_courant != ETAT_KO_au_sol)
{
	if ( o_Kong && o_fight_actor == o_Kong && @o_fight_actor Proc_KK_Test_Mode( C_Mode_Dash_Attack) 
	&& @o_fight_actor Proc_KK_FightActorGet() == OBJ_Me()
	&& f_time_contre_dash_attack >= f_jauge_contre_dash_attack
	&& ! @o_fight_actor Proc_KK_RAGE_Test())
	{
		// Kong dash sur moi
		if ( !MATH_FloatNullEpsilon( f_jauge_contre_dash_attack) 
		&& MATH_VecDotProduct( @o_fight_actor OBJ_SightGet(), OBJ_PosGet() - @o_fight_actor OBJ_PosGet()) > 0 )
		{
			i_fight_must_dodge = vrai	// Trop tot : ESQUIVE
			f_time_contre_dash_attack = 0.0
		}
		else
		{
			f_jauge_contre_dash_attack = 1.0
			f_time_contre_dash_attack = 0.0
		}
	}
}


// DODGE
if( i_fight_must_dodge )
{
	if( o_Kong )
	{
		o_fight_actor = o_Kong
		macro_change_etat("KT_ETAT_fight_KONG")
	}
}


// rage
f_rage_jauge -= MATH_FloatMin(f_rage_jauge, TIME_GetDt())
f_fight_delai_attak -= MATH_FloatMin(f_fight_delai_attak, TIME_GetDt())
f_interaction_delay_dont_ask -= MATH_FloatMin(f_interaction_delay_dont_ask, TIME_GetDt())
f_delay_last_paf_mur += TIME_GetDt()
f_stunned_last_delay += TIME_GetDt()

//if( o_fight_actor == o_ANN )
if( o_fight_actor == o_Jack )
	f_time_on_Jack += TIME_GetDt()


// DEBUG TRIGGER ===========================================================
//if( AI_TriggerIsValid(trig_DBG) && call_trigger(trig_DBG) )
//{
//	Str_DisplayTextOnce("Trigger valide !!!", cvector(0.4,0.0,0.0))
//}



OBJ_CapaSet( none, Capa_Fall_On_Ground_PAF)	// LE TREX n'est plus en impact sur le sol


// GROUND NORMALE
//if( COL_ColSetActivationGet() & C_bit_zdm_pied )
//{
//	if( COL_CollideType(COL_C_Ground) )
//		tv_new_ground_normale = COL_NormalGet(COL_C_Ground)
//	else
//		tv_new_ground_normale = Cv_VerticalVector
//}
//else
//	tv_new_ground_normale = Cv_VerticalVector
//v_ground_normale = MATH_VecBlend(v_ground_normale, tv_new_ground_normale, 2.0 * TIME_GetDt())
//DBG_RenderVector(OBJ_PosGet(), v_ground_normale * 10, color_bleu)
//