#include "KT_defines.var"

int				ti_i
int				ti_releve

vector		tv_new_sight

object		to_bone
object		to_head

float			tf_freq


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_ko_face_mur = faux							// Par defaut on ne s explose pas sur un mur
	i_grabbed_finish = faux							// posible que pendant une certaine partie du KO au SOL
	f_ko_delay = 0
//	f_fatigue_time += Cf_fatigue_add_paf_wall	// chaque croutage fatigue
	f_jauge_croutage = 0.0
	DYN_GravitySet(Cv_NormalGravity)

//	if( i_etat_courant != ETAT_KK_grabbedTT && EVENT_LIFE_CurLifeGet(ID_LIFE) < Cf_PAF_seuil_recuperation )
//		KT_LifeRecupere()
	
	// KONG ATTIRE LE TREX
	KT_Timer_KONG_Init()
	o_fury_actor = nobody		// interdit de crier en se relevant !!!
	
	i_paf_mur_align = faux
	OBJ_CapaSet(none, Capa_KO_au_Sol)
	
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_KO_au_sol)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_KO_au_sol
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0

	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux
//	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai		// NEW NEW TEST GRAB ACTIF MÊME AU SOL

	if( MATH_VecNullToler(v_paf_sens, 0.1) )
		v_paf_sens = -OBJ_SightGet()		// BLINDAGE !!!! A CORRIGER...

	// METTRe UN BIT DE CHOIX D ANIM !!!!!!!!!!!!!!
	if ( ACT_ActionGet() == Action_Croutage_Face && ANI_CurrentFrameGet(0) > 35)
			ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai		
	else if ( i_dernier_etat == ETAT_JumpAttak)
		ACT_ActionSet(Action_Agonie)
	else if ( i_ko_face_mur)
		ACT_ActionSet(Action_Paf_Mur_Tombe)
	else if ( ACT_ActionGet() == Action_KO_au_sol)
		ACT_ActionSet(Action_Agonie)
	else if( i_dernier_etat == ETAT_charge )
		ACT_ActionSet(Action_Paf_Tombe)
	else if( i_dernier_etat == ETAT_chute )
		ACT_ActionSet(Action_Paf_au_sol_chute)
	else if( ACT_ActionGet() == Action_FlancG_Crash
	||  ACT_ActionGet() == (Action_FlancG_Crash + 20))
		ACT_ActionSet(Action_Agonie)
	else if( i_paf_va_se_vautrer )
	{
		// choix de l'anim en fonction du sens du paf
		i_paf_va_se_vautrer = faux
		f_coef_recul = 1.0			// pas de translation et de rotation ajoutée, on se cale sur l'anim
		if( MATH_VecDotProduct(OBJ_HorizonGet(), v_paf_sens ) < 0 )
			ACT_ActionSet(Action_Paf_Rapide_Agonie_D)
		else 
			ACT_ActionSet(Action_Paf_Rapide_Agonie_G)
	}
	else if( i_dernier_etat == ETAT_KK_grabbedTT )
		ACT_ActionSet(Action_Paf_SeReleve ) // Action_Agonie)		// cancel souleve
	else if (ACT_ActionGet() != 142)
		ACT_ActionSet(Action_Paf_Tombe)
	else
	{
		v_add_speed = OBJ_SightGet() * 7.0 
		f_coef_recul = 0.0
	}
	f_time_o_sol = 0.0
	
	if( i_stunned_paf_ecrase_flag )
	{
		f_ko_delay = 2.0
		// tomber les hp après un paf stunned ecrase
		EVENT_LIFE_CurLifeSet(ID_LIFE, Cf_PAF_seuil_recuperation)
	}
	else
	{
		f_ko_delay = f_fatigue_time - Cf_fatigue_add_paf_wall
		i_grabbed_finish = vrai
	}

	
	// projeté au sol par KONG ou par un REX balancé par KONG => on fixe l'interet sur KONG
	o_paf_actor_memo = o_Kong
	o_fight_actor = o_Kong
	i_stunned_paf_ecrase_flag = faux
	
	to_head = ANI_CanalObjectGet(Anim_Canal_Tete)
	v_collision_point = @to_head OBJ_PosGet()
//	DBG_RenderVector(v_collision_point, Cv_VerticalVector, color_bleu)
//	DBG_RenderVector(v_collision_point, OBJ_SightGet(), color_vert)
//	DBG_RenderVector(v_collision_point, - OBJ_SightGet(), color_rouge)
//	DBG_RenderVector(v_collision_point, - Cv_VerticalVector, color_jaune)
	KT_GFX_Impact(v_collision_point)
	OBJ_CapaSet( Capa_Fall_On_Ground_PAF, none)
	if( ! i_already_finished_flag )
		OBJ_CapaSet(Capa_KO_au_Sol, none)
}
else
{
	f_time_start_etat += TIME_GetDt()
	f_time_o_sol += TIME_GetDt()
}

// ANALYSE =======================================================================================================


// Detection du vide
macro_checkchute

KT_Interet_Update(o_fight_actor, C_EVENT_InteretStatusLock)

// Detection du Grab pour le Finish
if ( ! MATH_FloatNullEpsilon( f_time_start_etat))
	o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
{
	if ( LNK_GrabKong_TypeGet( mid_grabbed_by_Kong_LNK_ID) == Ci_GrabKong_Type_Finish)
		macro_change_etat("KT_ETAT_Finish")
	else
		macro_change_etat("KT_ETAT_Grabbed_by_Kong")			// dans ce mode REX n'accepte que les finish et les gros (cf. dans exec propose grab)
}


// Detection de PAF Cas non générique
AI_Execute("KT_exec_check_paf")
if( o_paf_actor )
{
	if ( i_paf_type & C_PAF_KK_KiTue )
	{
		KT_STATS_NMI_Killed(o_paf_actor)
		macro_change_etat("KT_ETAT_mort")
	}
	if( ACT_ActionGet() == Action_Paf_SeReleve )
		macro_change_etat("KT_ETAT_paf")		// en train de se relever -> debout
	else
	{
		// couché -> paf au sol
		ACT_ActionSet(Action_Paf_au_sol)
		f_time_start_etat = 0.0
	}
}

// COMPORTEMENT =================================================================================================

ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai
switch ( ACT_ActionGet())
{
	case Action_Paf_Mur_Tombe :
		if ( f_time_start_etat < 0.5)
			ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux
		if ( ACT_ActionFinished())
			ACT_ActionSet(Action_Agonie)
		break
	case 142 :
		if ( f_time_start_etat < 0.5)
			ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux
		if( ACT_ActionFinished())
			ACT_ActionSet(Action_Agonie)
	case Action_Paf_au_sol : 
		// Paf au sol : fin de l"action de soubresaut
//		if ( f_time_start_etat < 1.0)
//			ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux
		if( ACT_ActionFinished())
			ACT_ActionSet(Action_Agonie)		
		break
	case Action_Paf_SeReleve  :
	case Action_Paf_SeRelevePAF :
		if( i_uncol && f_time_start_etat > 0.55 ) 	// 0.15 )		// && f_time_start_etat < 0.45 )
		{
			// REX PAFFE EN SE RELEVANT (pour dégager KONG et réactiver les collisions)
			i_paf_exit_colmap_mode = vrai
//			COL_ColSetActivationSet(C_bit_zde_fight, none)
//			i_flag_zde_fight_type = Ci_zde_fight_type_se_releve
//			AI_Execute("KT_exec_zdf_zdc")
//			COL_ColSetActivationSet(none, C_bit_zde_fight)
		}
		
		// GRAB KONG NEW NEW NEW
		if ( i_grabbed_finish && ANI_CurrentFrameGet(0) > 40)
		{
			i_grabbed_finish = faux
			ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai			// Le TREX est trop debout pour refuser le grab
		}
		o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
		if (o_grabbed_actor_KK)
			macro_change_etat("KT_ETAT_Grabbed_by_Kong")		
		// GRAB KONG NEW NEW NEW

		if ( ACT_ActionFinished())
//			macro_change_etat(fct_main_etat)		// Fin du temps
			macro_change_etat("KT_ETAT_attente")
		break
	case Action_Agonie :
		// Gestion du temps KO
		ti_releve = faux
		f_ko_delay -= TIME_GetDt()
		if( o_Kong && @o_Kong Proc_KK_Test_Mode(ETAT_Kong_grab_mashing) )
		{
			ti_releve = vrai
			tf_freq = 2.0		// se relève + vite !!!!	
		}
		else if (f_ko_delay <= 0 )
		{
			ti_releve = vrai
			tf_freq = 1.0
		}
		if( ti_releve )
		{
			i_grabbed_finish = faux							// Pas possible de gtrabber au sol pendant le se relève il y aura ptre des attak plus tard
			f_time_start_etat = 0.0
			ACT_ActionSet( Action_Paf_SeReleve)
			tf_freq *= ANI_FrequencyGet(0)
			ANI_FrequencySet(0, tf_freq)
			KT_LifeRecupere()
		}
		break
	default:
		if ( ACT_ActionFinished())
		{
			ACT_ActionSet(Action_Agonie)
			ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai
		}			
		break
}

//if ( ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] && i_grabbed_finish)
//{
//	// As t on le temps de lancer le Finish
//	if ( f_ko_delay <= 1.0 || f_fatigue_time < 1.0)
//		ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux
//}

// ORIENTATION APRES UN PAF TRONC D'ARBRE
//if( i_paf_va_se_vautrer )
if( i_paf_mur_align )
{
	if( ANI_CurrentFrameGet(0) > 15 )
		OBJ_BankingGeneralSet(
			MATH_VecBlendRotate(OBJ_SightGet(), v_paf_mur_align, 5 * TIME_GetDt()),
			MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 10 * TIME_GetDt()))
}
else if( ACT_ActionGet() == Action_Paf_Rapide_Agonie_D || ACT_ActionGet() == Action_Paf_Rapide_Agonie_G )
{
	// REX a besoin de s'orienter à l'opposé du sens du paf pour partir à la renverse (sinon s'il est paffé de dos alors il tombe de dos vers KONG...)
	if( f_time_o_sol < 0.25 )
		OBJ_BankingGeneralSet(
			MATH_VecBlendRotate(OBJ_SightGet(), - v_paf_sens, 20 * TIME_GetDt()),
			MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 10 * TIME_GetDt()))
//	else
//		i_paf_va_se_vautrer = faux
}


//if( (ACT_ActionGet() == Action_Agonie_finish_Deb) && ( f_time_start_etat > 0.40 ) )
//{
//	// Paf au sol : fin de l"action de soubresaut
//	ACT_ActionSet(Action_Agonie)
//}

//if( ( ti_action == Action_Paf_SeReleve ) && ACT_ActionFinished() )
//{
//	macro_change_etat(fct_main_etat)		// Fin du temps on remonte
//}

//if( ( ACT_ActionGet() != Action_Agonie ) && ACT_ActionFinished() )
//{
//	ACT_ActionSet(Action_Agonie)
//	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai
//}

//if( ACT_ActionGet() == Action_Agonie )
//{
//	// Gestion du temps KO
//	f_ko_delay -= TIME_GetDt()
//	if (f_ko_delay <= 0)
//		ACT_ActionSet( Action_Paf_SeReleve)
//		macro_change_etat(fct_main_etat)		// Fin du temps on remonte
//}

