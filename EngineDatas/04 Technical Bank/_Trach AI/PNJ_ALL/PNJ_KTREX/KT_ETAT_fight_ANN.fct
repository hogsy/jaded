//#include "KT_defines.var"
//
//
//// RENDRE LE TREX COMPLETEMENT INACTIF MAIS VIVANT
//// #define  MODE_DUMMY
//// RENDRE LE TREX COMPLETEMENT INACTIF MAIS VIVANT
//
//float		tf_dot_avec_occluder
//float		tf_dot_sans_occluder
//float		tf_dist_trop_loin
//float		tf_dist_trop_proche
//
//int			ti_flag_trop_loin
//int			ti_flag_trop_pres
//int			ti_interaction_param
//int			ti_ask
//int			ti_pos_pour_crier
//int			ti_pos_pour_attendre
//
//object	to_old_interaction_target
//object	to_ANN_serveur
//
//
//// SORTIE ETAT ===================================================================
//if (i_sort_etat)
//{
////	if( i_etat_courant != ETAT_cri && i_etat_courant != ETAT_attaque )
////	{
////		o_interaction_target = LNK_ThisClientGet(o_ANN, Ci_LNK_INTERACTION, mid_interaction, faux, nofunc, nofunc, nofunc)
////		KT_Last_Time_ANN_Attack_Update()
////		i_interaction_cpt = 0		// RAZ cpt attack sur Ann
////	}
//	i_degagement_flag = faux
//	
//	i_sort_etat = faux
//	return
//}
//
//// INITIALISATION ETAT ==============================================================
//if( i_etat_courant != ETAT_fight_ANN )
//{
//	i_dernier_etat = i_etat_courant
//	i_etat_courant = ETAT_fight_ANN
//	
//	if (fct_last_etat)
//	{
//		i_sort_etat = vrai
//		AI_Execute(fct_last_etat)
//	}
//
//	fct_last_etat = AI_TrackCurGet()
//	fct_main_etat = AI_TrackCurGet()
//	
//	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai	
//	
//	f_non_collide_ground_time = 0.0		// sinon bug cycle "chute -> KO sol -> chute -> KO sol..."
//	
//	i_paf_nb = 0
//
//	// Considerer pour l hysteresis des anims de deplacement qu'on pard a l arret a l init du mode
//	i_fight_action_old = -1
//	f_fight_delai_anim = 10.0	
//	f_orientation_coef = 0.0						// BLEND DE BLEND	
//	
//	f_time_start_etat = 0.0
//	i_flag_zde_fight_type = 0
//	
////	i_interaction_cpt = (Ci_script_KAnn_cycle_max -1)		// TMP !!!!!
//	KT_ReAttackDelay()
//}
//else
//{
//	f_time_start_etat += TIME_GetDt()
//}
//
//
//// flags temp
//i_fight_action = i_Anim_attente		// action par défaut
//ti_flag_trop_pres = faux
//ti_flag_trop_loin = faux
//ti_pos_pour_crier = faux
//ti_pos_pour_attendre = faux
//
//i_interaction_well_positionned = faux
//
//// ANALYSE ========================================================================
//
//// Detection de GRAB
//o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
//if (o_grabbed_actor_KK)
//{
//	macro_change_etat("KT_ETAT_grabbed")		
//}
//
//// Detection de PAF
//AI_Execute("KT_exec_check_paf")
//if (o_paf_actor)
//{
//	macro_change_etat("KT_ETAT_paf")					// ko delay nul -> simple paf
//}
//
//// Detection du vide
//macro_checkchute
//
//// Détection CINE
//Macro_Check_Capa_CINE_Crier
//
//// CHOIX FIGHT ACTOR
//AI_Execute("KT_exec_fight_actor_select")
//if( ! o_fight_actor )
//{
//	macro_change_etat("KT_ETAT_attente")
//}
//else if( o_fight_actor == o_KONG )
//{
//	macro_change_etat("KT_ETAT_fight_KONG")
//}
//
//// CYCLE TERMINE -> CRI FINAL (LAISSER LE TEMPS A ANN DE REMETTRE A ANN_READY)
////if( i_interaction_fin_cri )
//if( i_cri_filtre & Ci_CRI_INTERACTION_FIN )
//{
//	if( @o_ANN OBJ_CapaTest(Capa_ANN_Morte) )
//		o_fight_actor = o_KONG
//	Macro_Crie_Vers_Fight_Actor		// avant de couper la liaison !!!!
//}
//
//// COMPORTEMENT ============================================================================
//
//// INTERET
//KT_Interet_Update(o_fight_actor, C_EVENT_InteretStatusLock)
//
//// REGARD
//i_flag_look = vrai
//v_look_pos = KT_GetActorPosToLook(o_fight_actor)
//
//// TEST EMBOUTEILLAGES
//if( ! i_degagement_flag && o_degagement_wp && f_time_on_ANN > 10.0 && ! o_interaction_target && OBJ_SqrDist(o_ANN) < 144 )
//{
//	if( KT_CheckTargetIsInteractionFightClient(o_ANN, to_ANN_serveur) )
//	{
//		// ANN est cliente d'un autre acteur
//		if( @to_ANN_serveur AI_IsModel(get_KTREX_Path) && ! @to_ANN_serveur KT_Proc_FightAnnWellPositionned() )
//		{
//			// l'autre REX n'est pas bien positionné, je dois le géner
//			KT_Degagement_Init()
//			f_time_on_ANN = 0.0
//		}
//	}
//}
//
//// ORIENTATION
//KT_OrientationInitGet()
//
//// TEST D'OCCLUDER
//KT_OccluderTest()
//
//i_fight_action = i_Anim_attente
//
//#ifndef MODE_DUMMY
//
//
//// TEST ORIENTATION
//tf_dot_avec_occluder = MATH_VecDotProduct(OBJ_SightGet(), v_sight_avec_occluder)
//tf_dot_sans_occluder = MATH_VecDotProduct(OBJ_SightGet(), v_sight_sans_occluder)
//
//if( i_DBG_interaction_off )
//	ti_ask = faux
//else if( f_interaction_delay_dont_ask )
//	ti_ask = faux
//else
//	ti_ask = vrai
//to_old_interaction_target = o_interaction_target
//o_interaction_target = LNK_ThisClientGet(o_ANN, Ci_LNK_INTERACTION, mid_interaction, ti_ask, "KT_exec_interaction_add_data", nofunc, "KT_exec_interaction_init")	
//
//
//if( ! o_interaction_target )
//{
//	// PAS D'INTERACTION ETABLIE : CRIER
//	if( f_fight_delai_attak )
//		ti_pos_pour_attendre = vrai
//	else
//		ti_pos_pour_crier = vrai
//}
//else
//{
//	// INTERACTION ETABLIE
//	if( ! to_old_interaction_target ) //  || i_interaction_cpt == Ci_script_KAnn_cycle_max )
//	{
//		// liaion établie cette trame : raz compteur d'action
//		i_interaction_cpt = 0
//	}
//	
//	// TEST ETAT DE LA LIAISON
//	if( f_fight_delai_attak )
//	{
//		ti_pos_pour_attendre = vrai
//	}
//	else
//	{
//		ti_interaction_param = LNK_InteractionParamGet(mid_interaction)
//
//		if( ti_interaction_param != C_INTER_FIGHT_ANN_READY )
//			ti_pos_pour_crier = vrai
//
//		if( ti_interaction_param == C_INTER_FIGHT_WAIT_FOR_ANN )
//			i_interaction_cpt = 0
//	}
//}
//
//// DEPLACEMENT
//if( @o_ANN KAnn_Interaction_Pos_Safe() )
//{
//	tf_dist_trop_loin = 10.0
//	tf_dist_trop_proche = 7.0
//}
//else if( o_interaction_target && @o_ANN KAnn_Death_Attack_Enabled() )
//{
//	// dist pour attaquer
//	tf_dist_trop_loin = 7.0
//	tf_dist_trop_proche = 5.0
//}
//else if( ti_pos_pour_crier || ti_pos_pour_attendre )
//{
//	// dist pour crier
//	tf_dist_trop_loin = 9.0
//	tf_dist_trop_proche = 7.0
//}
//else
//{
//	// dist pour attaquer
//	tf_dist_trop_loin = 7.0
//	tf_dist_trop_proche = 5.0
//}
//
//if( i_degagement_flag )
//{
//	if( ! o_interaction_target )
//		f_time_on_ANN = 0.0		// embouteillages
//		
//	if( f_move_dist < 3.0 )
//		i_degagement_flag = faux		// on a atteint un point éloigné, on fait demi-tour
//	else
//		ti_flag_trop_loin = vrai
//}
//else if( f_move_dist > tf_dist_trop_loin )
//{
//	ti_flag_trop_loin = vrai
//}
//else if( f_move_dist < tf_dist_trop_proche )
//{
//	ti_flag_trop_pres = vrai
//}
//else if( tf_dot_sans_occluder < Cf_Cos15 )
//{
//	ti_flag_trop_loin = vrai		// mal orienté
//}
//else
//{
//	// LE TREX QUI EST BIEN POSITIONNE DEMANDE UNE LIAISON D'INTERACTION
//	i_interaction_well_positionned = vrai
//	
//	if( o_interaction_target && @o_ANN KAnn_Death_Attack_Enabled() )
//	{
//		i_interaction_cpt = 3		// position gueule REX
//		goto ATTAQUE_TUE_ANN		// ne pas crier si compteur temps Ann == 0.0
//	}
//	else if( ti_pos_pour_crier )
//	{
//		f_fight_delai_attak = MATH_RandFloat(5.0, 7.0)		// attendre au retour dans le mode fight ann
//		Macro_Crie_Vers_Fight_Actor
//	}
//	else if( ! ti_pos_pour_attendre )
//	{
//		i_interaction_cpt++
//		if( i_interaction_cpt > 3 )
//			i_interaction_cpt = 3
//		
//		// REX attaque
//		if( i_interaction_cpt == Ci_script_KAnn_cycle_max )
//		{
//			ATTAQUE_TUE_ANN:
////			f_interaction_delay_dont_ask = 10.0
////			i_interaction_fin_cri = vrai
// 			i_cri_filtre |= Ci_CRI_INTERACTION_FIN
//			LNK_InteractionParamSet(mid_interaction, C_INTER_FIGHT_ENNEMY_ATTACK)
//		}
//		else
//			LNK_InteractionParamSet(mid_interaction, C_INTER_FIGHT_ENEMY_FAKE_ATTACK)
//		i_KK_attaque_action = KT_SelectActionAttackFace()
//		i_flag_zde_fight_type = Ci_zde_fight_type_machoire
//		macro_change_etat("KT_ETAT_attaque")		
//	}
//}
//
//
//// DEPLACEMENT
//if( ti_flag_trop_loin )
//	i_fight_action = i_Anim_marche
//else if( ti_flag_trop_pres )
//	i_fight_action = Action_Normal_Recul
//else if( no_occluder_duration <= Cf_no_occluder_duration_min )
//	i_fight_action = i_Anim_marche		// occluder -> forcer à avancer
//
//#endif		// DUMMY...
//
//
//// ACTION
//KT_SelectActionMove()
//
//// ORIENTATION
//v_orientation_sens = v_sight_avec_occluder
//KT_OrientationFinaleSet()
//
//