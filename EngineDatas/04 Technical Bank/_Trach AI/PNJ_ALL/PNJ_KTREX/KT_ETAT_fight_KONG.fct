#include "KT_defines.var"

// RENDRE LE TREX COMPLETEMENT INACTIF MAIS VIVANT
// #define  MODE_DUMMY
// RENDRE LE TREX COMPLETEMENT INACTIF MAIS VIVANT

float		tf_dot_avec_occluder
float		tf_dot_sans_occluder
float		tf_dot_FA_to_me
float		tf_contourne_angle
float		tf_speed_norm
float		tf_charge_distance
float		tf_charge_delay

int			ti_flag_trop_loin
int			ti_flag_trop_pres
int			ti_attak_hurlement
int			ti_can_attack 
int			ti_zero_orientation
int			ti_Kong_colonne
int			ti_col

vector	tv_FA_sight
vector	tv_FA_to_me
vector	tv_speed_vector
vector	tv_temp1
vector	tv_temp2
vector	tv_test

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_fight_must_dodge = faux

	i_sort_etat = faux
	return
}


// INITIALISATION ETAT ==============================================================
if( i_etat_courant != ETAT_fight_KONG )
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_fight_KONG

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	fct_main_etat = AI_TrackCurGet()
	
	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai	
	
	f_non_collide_ground_time = 0.0		// sinon bug cycle "chute -> KO sol -> chute -> KO sol..."

	i_paf_nb = 0

	// Considerer pour l hysteresis des anims de deplacement qu'on pard a l arret a l init du mode
	i_fight_action_old = -1
	f_fight_delai_anim = 10.0	
	f_orientation_coef = 0.0						// BLEND DE BLEND	
	
	f_time_start_etat = 0.0
	i_flag_zde_fight_type = 0
	f_contact_kong_delay = 0.3
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// contact avec Kong
if( i_KONG_virtual_collision )
	f_contact_kong_delay -= MATH_FloatMin(f_contact_kong_delay, TIME_GetDt())


// flags temp
i_fight_action = i_Anim_attente		// action par défaut
ti_flag_trop_loin = faux
ti_flag_trop_pres = faux
ti_attak_hurlement = faux
ti_can_attack = vrai
ti_zero_orientation = faux
ti_Kong_colonne = @o_Kong Proc_KK_Test_Mode(ETAT_Kong_colonne)

// ANALYSE =======================================================================================================

// Detection de GRAB
o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
{
	macro_change_etat("KT_ETAT_Grabbed_by_Kong")		
}

// Detection de PAF
AI_Execute("KT_exec_check_paf")
if (o_paf_actor)
{
	macro_change_etat("KT_ETAT_paf")					// ko delay nul -> simple paf
}

// Jack fait diversion
Macro_Check_Paf_Jauge_Crier

// Detection du vide
macro_checkchute

// Détection CINE
Macro_Check_Capa_CINE_Crier

// CHOIX FIGHT ACTOR 
AI_Execute("KT_exec_fight_actor_select")
if( ! o_fight_actor )
{
	macro_change_etat("KT_ETAT_attente")
}
//else if( o_fight_actor == o_ANN )
//{
//	macro_change_etat("KT_ETAT_fight_ANN")
//}
else if( o_fight_actor == o_Jack )
{
	macro_change_etat("KT_ETAT_fight_JACK")
}

// COMPORTEMENT =========================================================================================

// INTERET
KT_Interet_Update(o_fight_actor, C_EVENT_InteretStatusLock)

// REGARD
i_flag_look = vrai	
v_look_pos = KT_GetActorPosToLook(o_fight_actor)

// ORIENTATION
KT_OrientationInitGet(o_fight_actor, faux)

// TEST D'OCCLUDER
KT_OccluderTest()

	
// TEST KONG EN MAUVAISE POSTURE ===========================================================
if( @o_fight_actor Proc_KK_IsInBadSituation(C_ID_Tyranosaure) )
{
	ti_attak_hurlement = vrai
	if( f_move_dist <= 10.0 )
	{
		if ( ! COL_BestWallGaoGet( -v_sight_sans_occluder, &ti_col))
			i_fight_must_dodge = vrai		// trop proche de KONG : m'éloigner de lui en dodgeant
		else
		{ 
			v_sight_sans_occluder = MATH_VecRotate(v_sight_sans_occluder, Cv_VerticalVector,Cf_PiBy2)
			if ( ! COL_BestWallGaoGet( -v_sight_sans_occluder, &ti_col))
				i_fight_must_dodge = vrai		// trop proche de KONG : m'éloigner de lui en dodgeant
			else
			{
				v_sight_sans_occluder =  -v_sight_sans_occluder
				if ( ! COL_BestWallGaoGet( -v_sight_sans_occluder, &ti_col))
					i_fight_must_dodge = vrai		// trop proche de KONG : m'éloigner de lui en dodgeant
			}
		 }
	}
}

// TEST ORIENTATION =========================================================================
tf_dot_avec_occluder = MATH_VecDotProduct(OBJ_SightGet(), v_sight_avec_occluder)
tf_dot_sans_occluder = MATH_VecDotProduct(OBJ_SightGet(), v_sight_sans_occluder)

//DBG_RenderVector(OBJ_PosGet() - (10 * OBJ_SightGet()) + Cv_VerticalVector, 20 * OBJ_SightGet(), color_vert)
//tv_temp = MATH_VecRotate( - OBJ_SightGet(), Cv_VerticalVector, MATH_ACos(f_dot_tete_ou_queue) )
//DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp * 10.0, color_rouge)
//tv_temp = MATH_VecRotate( - OBJ_SightGet(), Cv_VerticalVector, - MATH_ACos(f_dot_tete_ou_queue) )
//DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp * 10.0, color_rouge)


#ifndef MODE_DUMMY

if( i_fight_must_dodge )
{
	ti_can_attack = faux
	switch( i_fight_action_old )
	{
		case Action_Esquive_D :
		case Action_Esquive_G :
			if( ACT_ActionFinished() )
			{
				i_fight_must_dodge = faux
				ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai					
				i_force_change_anim = vrai
			}
			else
			{
				if ( @o_fight_actor Proc_KK_Test_Mode( C_Mode_Dash_Attack))
					ti_zero_orientation = faux
				else
					ti_zero_orientation = vrai
					
 				i_fight_action = i_fight_action_old		// Finir l'esquive coute que coute
				ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux	// J'esquive un grab je vais donc les refuser pendant ce temps.
			}
			break
			
		case Action_DemiTourRapideG :
		case Action_DemiTourRapideD :
			if( ANI_CurrentFrameGet(0) > 55 )
			{
				// ne pas jouer la fin du demi-tour dans le cas d'une esquive
				i_fight_must_dodge = faux
				ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai
				i_force_change_anim = vrai
			}
			else
			{
				ti_zero_orientation = vrai
				ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux	// J'esquive un grab je vais donc les refuser pendant ce temps.
				tv_speed_vector = DYN_SpeedGetVector()
				if( ! MATH_VecNullEpsilon(tv_speed_vector) )
				{
					MATH_VecSetNormalize(tv_speed_vector)
					tf_speed_norm = DYN_SpeedGet()
					DYN_SpeedSetVector(tv_speed_vector * tf_speed_norm * 2.5)
				}
			}
			break
			
		default:
			if ( @o_fight_actor Proc_KK_Test_Mode( C_Mode_Dash_Attack))
				ti_zero_orientation = faux
			else
				ti_zero_orientation = vrai
			i_force_change_anim = vrai
			if( MATH_VecDotProduct(v_sight_sans_occluder, OBJ_SightGet()) < - Cf_Cos45)
			{
				// kong derrière
				if ( MATH_VecDotProduct(v_sight_sans_occluder, OBJ_HorizonGet()) > 0 )
					i_fight_action = Action_DemiTourRapideG
				else
					i_fight_action = Action_DemiTourRapideD
			}
			else
			{
				// kong devant
				if ( MATH_VecDotProduct(v_sight_sans_occluder, OBJ_HorizonGet()) > 0 )
					i_fight_action = Action_Esquive_D
				else
					i_fight_action = Action_Esquive_G
			}
	}
}


// ATTAQUES AUTORISEES ? --------------------------------------------------------------------------------------------------------------------------------------------------
if ( i_fight_must_dodge)
	ti_can_attack = faux
else if( i_Kong_Mashing )
	ti_can_attack = vrai
else if( i_Kong_Gladiator && i_Kong_Paf )
	ti_can_attack = faux		 // pas de nouvelle attaque sur kong gladiator qui prend déjà un paf fort
else if( no_occluder_duration < Cf_no_occluder_duration_min )
	ti_can_attack = faux
else
	ti_can_attack = vrai


// COUP DE TETE / QUEUE ===========================================================================
// i_DBG_charge = enum( "default" 0 "toujours" 1 "jamais" 2 )
if( ti_can_attack && i_DBG_charge != 1 && ! ti_Kong_colonne && ! i_Kong_Mashing )
{
	if( f_move_dist > 8.0 )
	{
		ti_flag_trop_loin = vrai
	}
	else if( ti_attak_hurlement )
	{
		// REX ne peut pas attaquer l'acteur
		i_cri_filtre |= Ci_CRI_PAS_D_ATTENTE_BLESSE
		Macro_Crie_Vers_Fight_Actor
	}
	else if( ! f_fight_delai_attak || ! f_contact_kong_delay )
	{
		KT_Rage_Decrement()
		if( tf_dot_sans_occluder > Cf_Cos45 ) // - f_dot_tete_ou_queue )
		{
			KT_Lance_Attaque(v_sight_sans_occluder, Action_Attak_CpTeteD, Action_Attak_CpTeteG, Ci_zde_fight_type_coup_de_tete)
			macro_change_etat("KT_ETAT_attaque")
		}
		else
		{
			KT_Lance_Attaque(v_sight_sans_occluder, Action_Attak_CpQueueD, Action_Attak_CpQueueG, Ci_zde_fight_type_coup_de_queue)
			macro_change_etat("KT_ETAT_attaque")
		}
	}
}


// ATTAQUE DE FACE ===========================================================================
// i_DBG_charge = enum( "default" 0 "toujours" 1 "jamais" 2 )
if( ti_can_attack && i_DBG_charge != 1 && ! ti_Kong_colonne && ! i_Kong_Mashing )
{
	if( f_move_dist > 14.0 )
	{
		ti_flag_trop_loin = vrai
	}
	else if( f_move_dist < 5.5 )
	{
		// else : trop près, mais ne recule pas face à KONG : coup de tete / queue
	}
	else
	{
		// Ennemi devant : coup de dents
		if( ti_attak_hurlement )
		{
			// REX en peut pas attaquer l'acteur
			i_cri_filtre |= Ci_CRI_PAS_D_ATTENTE_BLESSE
			Macro_Crie_Vers_Fight_Actor
		}
		else
		{
			// REX peut attaquer l'acteur
			if( ! f_fight_delai_attak || ! f_contact_kong_delay )
			{
				KT_Rage_Decrement()
				i_KK_attaque_action = Action_Attak_CpdeFace
				i_flag_zde_fight_type = Ci_zde_fight_type_machoire
				macro_change_etat("KT_ETAT_attaque")
			}
		}
	}
}


// CHARGE =================================================================================
// i_DBG_charge = enum( "default" 0 "toujours" 1 "jamais" 2 )
if( ti_can_attack && ( i_Kong_Mashing || ! i_charge_interdite || ti_Kong_colonne ) && ! i_Kong_Swing && i_DBG_charge != 2 )
{
	// TEST DANS LE DOS DE KONG
	tv_temp1 = @o_Kong OBJ_SightGet()		// je teste si KONG me tourne le dos alors je ne regarde pas sa rotation tête mais son sight
	MATH_VecSetHorzNormalize(tv_temp1)
	tv_temp2 = @o_Kong OBJ_PosGet() - OBJ_PosGet()
	MATH_VecSetHorzNormalize(tv_temp2)
	
	if( ti_Kong_colonne )
	{
		tf_charge_distance = 0.0 // charge sans contrainte
		tf_charge_delay = 6.0
	}
	else if( i_Kong_Mashing )
	{
		tf_charge_distance = 0.0 // charge sans contrainte
		tf_charge_delay = 6.0
	}
	else if( MATH_VecDotProduct(tv_temp1, tv_temp2) > 0 )
	{
		tf_charge_distance = Cf_charge_distance_de_dos
		tf_charge_delay = Cf_charge_delai_recup_de_dos
	}
	else
	{
		tf_charge_distance = Cf_charge_distance
		tf_charge_delay = Cf_charge_delai_recup
	}
	
	// CRITERES DE CHARGE
	if( f_move_dist >= tf_charge_distance && tf_dot_avec_occluder > Cf_Cos30 )
	{
		if( KT_Trigger_Charge(tf_charge_delay))
		{
			if( ! KT_Check_Presence_Interet_Statut(o_fight_actor, C_EVENT_InteretStatusCharge) && ! ti_attak_hurlement  )
			{
				KT_Rage_Decrement()
				if ( !ti_Kong_colonne)
					o_charge_actor = o_fight_actor
				else
					o_charge_actor = @o_Kong Proc_KK_Colonne_Get()
				macro_change_etat("KT_ETAT_charge")
			}
			else
			{
				// un autre TREX charge déjà mon fight_actor : j'attend ici (reste à distance de charge)
				i_flag_crie_au_lieu_de_charger = vrai		// anti-bug AI loop !!!!
				f_time_last_charge = TIME_Get() - tf_charge_delay
				i_cri_filtre |= Ci_CRI_PAS_D_ATTENTE_BLESSE
				Macro_Crie_Vers_Fight_Actor
			}
		}
		// else reste à distance de charge
	}
	else if ( ti_Kong_colonne)
		ti_flag_trop_pres = vrai
	else
		ti_flag_trop_loin = vrai				// Trop loin ou mal orienté : avance pour s'orienter
}

// SENS DE CONTOURNEMENT =====================================================================
if( @o_fight_actor Proc_KK_FightActorGet() == OBJ_Me() )
{
	f_fight_sens_contourne = 0.0		// KONG me locke : je vais droit vers lui
	tf_dot_FA_to_me = 0.0
}
else
{
	// sinon je le contourne tant que je ne suis pas dans son dos
	tv_FA_sight = @o_fight_actor Proc_KK_LookDirectionGet()
	tv_FA_sight.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_FA_sight) )
		MATH_VecSetNormalize(tv_FA_sight)
	
	tv_FA_to_me = OBJ_PosGet() - @o_fight_actor OBJ_PosGet()
	tv_FA_to_me.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_FA_to_me) )
		MATH_VecSetNormalize(tv_FA_to_me)
	
	tf_dot_FA_to_me = MATH_VecDotProduct(tv_FA_sight, tv_FA_to_me)
	
	if( f_move_dist < 30.0 && MATH_FloatNullEpsilon( f_fight_sens_contourne) )		
		f_fight_sens_contourne = - MATH_FloatSign(MATH_VecDotProduct(MATH_VecCrossProduct(Cv_VerticalVector, tv_FA_sight),tv_FA_to_me))
		
	// ET LES COLMAPS BORDEL
	if ( ! MATH_FloatNullEpsilon( f_fight_sens_contourne))
	{
		tf_contourne_angle = f_fight_sens_contourne * MATH_AbsFloat(tf_dot_FA_to_me) * 90.0
		tf_contourne_angle *= Cf_1Degre
		tv_test = MATH_VecRotate(v_sight_avec_occluder, Cv_VerticalVector, tf_contourne_angle)
		DBG_RenderVector( OBJ_PosGet() + cvector(0.0,0.0,3.0), tv_test * 6.0, color_bleu)
		if (  COL_RayObject_Dist( OBJ_PosGet() + cvector(0.0,0.0,3.0), tv_test, 6.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
			f_fight_sens_contourne = 0.0
	}
}

if( ! i_fight_must_dodge && (ti_flag_trop_loin || no_occluder_duration <= Cf_no_occluder_duration_min) )
{
	i_fight_action = i_Anim_marche
}
else if( ti_flag_trop_pres )
	i_fight_action = Action_Normal_Recul
#endif		// DUMMY...


// ACTION 
KT_Action_Move_Select()

// ORIENTATION 
if( ! ti_zero_orientation && i_fight_action != i_Anim_attente )
{
	// Orientation avec résolution locale
	tf_contourne_angle = f_fight_sens_contourne * MATH_AbsFloat(tf_dot_FA_to_me) * 90.0
	tf_contourne_angle *= Cf_1Degre
	v_sight_avec_occluder = MATH_VecRotate(v_sight_avec_occluder, Cv_VerticalVector, tf_contourne_angle)
	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_sight_avec_occluder * 10, color_jaune)
	
	v_orientation_sens = v_sight_avec_occluder
	KT_OrientationFinaleSet()
}

