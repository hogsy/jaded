#include "KT_defines.var"
Include_UltraProcedure_Header

// Retourne vrai si REX est dans une phase de l'anim pendant laquelle il refusera d'interrompre son attaque pour lancer une esquive de grab
procedure_local int KT_AttaqueFenetreGrabEsquiveInterdite()
{
	int			ti_action_item
	int			ti_frame
	
	ti_action_item = ACT_ActionItemGet()
	ti_frame = ANI_CurrentFrameGet(0)
	switch( ACT_ActionGet() )
	{
		case Action_Fight_Attak_FPS :
			return vrai
			break
		case Action_Fight_Attak_Humain :
			if( ti_action_item == 0 && ti_frame > 30 )
				return vrai
			if( ti_action_item == 1 && ti_frame < 15 )
				return vrai
			break
		case Action_Attak_Mord_Haut :
			if( ti_frame > 30 && ti_frame < 60 )
				return vrai
			break
		case Action_Attak_CpdeFace :
			if( ti_frame > 30 && ti_frame < 60 )
				return vrai
			break
		case Action_Attak_CpTeteD :
		case Action_Attak_CpTeteG :
			if( ti_frame > 25 && ti_frame < 65 )
				return vrai
			break
		case Action_Attak_CpQueueD :
		case Action_Attak_CpQueueG :
			if( ti_frame > 25 && ti_frame < 65 )
				return vrai
			break
	}
	return faux
}

procedure_local void KT_Grabbed_Jauge_Update()
{
//	if( f_grabbed_jauge_last_time <= Cf_grabbed_delai_chain )
	{
		f_grabbed_jauge_refuse_delay = Cf_grabbed_delai_refuse
	}
	f_grabbed_jauge_last_time = 0.0
}

procedure_local void KT_Grabbed_Jauge_Reset()
{
	f_grabbed_jauge_refuse_delay = 0.0
}

// retourne vrai si REX doit refuser le prochain grab
procedure_local int KT_Proc_AntiChain()
{
	if( i_etat_courant == ETAT_KO_au_sol )
		return faux		// ne peut pas refuser un grab quand il est au sol
	
	if( KT_AttaqueFenetreGrabEsquiveInterdite() )
		return faux
	
//	i_DBG_refuse_grab = enum( "default" 0 "toujours" 1 "jamais" 2 )
	if( i_DBG_refuse_grab == 1 )
		return vrai
	
	if( i_DBG_refuse_grab == 2 )
		return faux
	
	if( f_grabbed_jauge_refuse_delay > 0.0 )
	{
		f_grabbed_jauge_refuse_delay = 0.0
		f_grabbed_jauge_last_time = Cf_grabbed_delai_chain		// ne pas compter le grab qui a déclenché l'anti-grab dans les délais...
		return vrai
	}
	else
		return faux
}

// retourne vrai si REX doit refuser le prochain grab
//procedure_local int KT_Proc_AntiChain()
//{
//	if( i_DBG_always_refuse_grab )
//		return vrai
//	if ( i_grabbed_nb >= 1 && !TIME_Elapsed( f_grabbed_last_time, Cf_grabbed_delai_chain))
//	{
//		i_grabbed_nb = 0
//		return vrai
//	}
//	else
//		return faux
//}

//procedure_local void KT_Add_Time_KONG( float tf_add )
//{
//	f_time_KONG = MATH_FloatMin( f_time_KONG + tf_add, Cf_max_time_KONG )
//}


////=============================================================================================
//// Détection de la chute : retourne 1 si en chute, 0 sinon
////=============================================================================================
//procedure_local int KT_KT_CheckChute()
//{
//	int			ti_contact_nb, ti_i
//	vector	tav_ground_pos[3]
//	vector	tv_decal
//	object	to_bone
//	
//	ti_contact_nb = 0
//
//	for (ti_i = 0; ti_i < 3; ti_i++)
//	{	
//		tav_ground_pos[ti_i] = OBJ_PosGet()
//		tav_ground_pos[ti_i].z += 4.0
//	
//		switch(ti_i)
//		{
//			case 0 :
//				tav_ground_pos[ti_i] -= OBJ_SightGet() * 2.5
//				break
//			case 1 :
//				tav_ground_pos[ti_i] += OBJ_SightGet() * 1.80
//				tav_ground_pos[ti_i] -= OBJ_HorizonGet() * 1.80
//				break
//			case 2 :
//				tav_ground_pos[ti_i] += OBJ_SightGet() * 1.80
//				tav_ground_pos[ti_i] += OBJ_HorizonGet() * 1.80
//				break
//		}
//		
//		DBG_RenderVector( tav_ground_pos[ti_i], -Cv_VerticalVector * 7.0, color_rouge)
//		if (COL_RayObject_Dist(tav_ground_pos[ti_i], -Cv_VerticalVector, 7.0, all, OBJ_C_IdentityFlag_Dyna | OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//			ti_contact_nb++
//	}
//	
//	if ( !COL_CollideType(COL_C_Ground) && !ti_contact_nb)
//	{																				
//		f_non_collide_ground_time += TIME_GetDt()				
//	}																				
//	else																			
//	{			
//		if ( !ti_contact_nb)																	
//		{
//			// Ici on a juste la collison sol : imprimer un glissement pour sormtir de la collision
//			tv_decal = COL_CollidedPointGet( COL_C_Wall) - OBJ_PosGet()
//			tv_decal.z = 0.0
//			MATH_VecSetNorm( tv_decal, 3.0)
//			DYN_SpeedSetVector( DYN_SpeedGetVector() - tv_decal)
//		}
//		f_non_collide_ground_time = 0.0									
//	}																				
//	if ( f_non_collide_ground_time > 0.1)								
//	{	
//		return 1
//	}	
//	else
//		return 0
//}


//=============================================================================================
// Détection de la chute : retourne 1 si en chute, 0 sinon
//=============================================================================================
procedure_local int KT_CheckChute()
{
	int			ti_contact_nb
	int			ti_i
	vector	tav_ground_pos[2]
	vector	tv_decal
	object	to_bone
	vector 	tv_pos
	
	ti_contact_nb = 0	
	if( i_etat_courant == ETAT_chute )
	{
		// En train de chuter : un LRAY sous la tête
		to_bone = ANI_CanalObjectGet(Anim_Canal_Torse)
		tv_pos = @to_bone OBJ_PosGet()
		if (COL_RayObject_Dist(tv_pos, -Cv_VerticalVector, 10.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
//			DBG_RenderVector(tv_pos, -Cv_VerticalVector * 10.0, color_vert)
			ti_contact_nb++
		}
//		else
//			DBG_RenderVector( tv_pos, -Cv_VerticalVector * 10.0, color_rouge)
	}
	else
	{
		// Pas en train de chuter : deux LRAY sous les pieds
		for (ti_i = 0; ti_i < 2; ti_i++)
		{
			switch(ti_i)
			{
				case 0 :
					to_bone = ANI_CanalObjectGet(Anim_Canal_OrteilDroit)
					tav_ground_pos[ti_i] = @to_bone OBJ_PosGet()
					tav_ground_pos[ti_i] += 0.5 * OBJ_SightGet()
					tav_ground_pos[ti_i].z += 1.0
					break
				case 1 :
					to_bone = ANI_CanalObjectGet(Anim_Canal_OrteilGauche)
					tav_ground_pos[ti_i] = @to_bone OBJ_PosGet()
					tav_ground_pos[ti_i] += 0.5 * OBJ_SightGet()
					tav_ground_pos[ti_i].z += 1.0
					break
			}
			
			if (COL_RayObject_Dist(tav_ground_pos[ti_i], -Cv_VerticalVector, 10.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
			{
//				DBG_RenderVector( tav_ground_pos[ti_i], -Cv_VerticalVector * 10.0, color_vert)
				ti_contact_nb++
			}
//			else
//				DBG_RenderVector( tav_ground_pos[ti_i], -Cv_VerticalVector * 10.0, color_rouge)
		}
	}
	
	if( ! ti_contact_nb)
	{
		// les rayons ne touchent rien -> on désactive la ZDM pour que REX tombe
		COL_ColSetActivationSet(none, C_bit_zdm_pied)
		f_non_collide_ground_time += TIME_GetDt()
	}
	else
	{
		// les rayons touchent -> on réactive la ZDM
		COL_ColSetActivationSet(C_bit_zdm_pied, none)
		if( i_etat_courant == ETAT_chute )
		{
			// REX est en train de chuter : on attend que la ZDM touche le sol pour couper la chute
			if( COL_CollideType(COL_C_Ground) )
				f_non_collide_ground_time = 0.0				// la ZDM touche : fin de la chute
			else
				f_non_collide_ground_time += TIME_GetDt()			// la ZDM ne touche pas : la chute continue
		}
		else
		{
			// autre : on considère qu'on touche le sol (les rayons suffisent, pas besoin que la ZDM touche)
			f_non_collide_ground_time = 0.0
		}
	}
	
	if ( f_non_collide_ground_time > Cf_tolerence_time_chute)
		return 1
	else
		return 0
}


//==============================================================================================
// Teste s'il y a une collision qui gènerait le deplacement
//==============================================================================================
procedure_local object KT_Test_collision_Mur_LRAY_COL( int i_test_ray, int i_test_col, vector v_deplacement, byref vector v_sens_collision, byref vector tv_collision_point)
{
	int			ti_col
	object	to_col_ray_object
	object	to_col_wall_object 
	object	to_tete
	vector	tv_pos_collision
	vector	tv_lray_vector
	vector	tv_speed
	float		tf_dot, tf_dist
	
	v_sens_collision = Cv_NullVector
	
	// 1 LRAY
	to_col_ray_object = nobody
	if ( i_test_ray)
	{
		to_tete = ANI_CanalObjectGet( Anim_Canal_Ventre ) // Anim_Canal_Tete)
		tv_speed = DYN_SpeedGetVector()
		tv_speed.z = 0.0
		if( ! MATH_VecNullEpsilon(tv_speed) )
			tv_lray_vector = MATH_VecNormalize(tv_speed)
		else
			tv_lray_vector = OBJ_SightGet()

		if (i_etat_courant != ETAT_charge)
			tf_dist = 3.0
		else
			tf_dist = 4.0		
		DBG_RenderVector(@to_tete OBJ_PosGet(), tv_lray_vector * tf_dist, color_bleu )
		@o_Kong OBJ_FlagsControlSet( OBJ_C_ControlFlag_RayInsensitive, none)
		to_col_ray_object = COL_RayObject_Dist( @to_tete OBJ_PosGet(), tv_lray_vector, tf_dist, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable  )
		@o_Kong OBJ_FlagsControlSet( none, OBJ_C_ControlFlag_RayInsensitive)
		if( to_col_ray_object )
		{
			v_sens_collision = COL_RayObject_NormalGet()
			tv_collision_point = COL_RayObject_PosGet()
			DBG_RenderVector(tv_collision_point, v_sens_collision * 5.0, color_rouge)
//			DBG_TraceObject(to_col_ray_object)
//			DBG_TraceEOL()
			if ( to_col_ray_object == o_Kong)
			{
				// Detection Paf sur Kong
				i_charge_paf_KONG = vrai	
			}
		}
	}
	
	// 2 Collision Mur	
	to_col_wall_object = nobody
	if ( i_test_col)
	{
		if( COL_BestAngleWallGaoGet( v_deplacement, Cf_Cos30, &ti_col) )
		{
			// Mur de face
			if ( !COL_CollideType(COL_C_Extra_ODE))
			{
				to_col_wall_object = COL_ObjectGet(COL_C_ReportIndex + ti_col)
				v_sens_collision = COL_NormalGet(COL_C_ReportIndex  + ti_col)
				tv_pos_collision = COL_CollidedPointGet(COL_C_ReportIndex  + ti_col)
				tv_collision_point = tv_pos_collision
				v_sens_collision = tv_pos_collision - OBJ_PosGet()
				v_sens_collision.z = 0.0
				if( ! MATH_VecNullEpsilon(v_sens_collision) )
					MATH_VecSetNormalize(v_sens_collision)
				else
					v_sens_collision = OBJ_SightGet()
				DBG_RenderVector( tv_pos_collision, -v_sens_collision * 5.0, color_rouge)
				if ( MATH_VecDotProduct( v_sens_collision, MATH_VecNormalize(v_deplacement)) < Cf_Cos30)
				{
					to_col_wall_object = nobody			// La collision est trop sur le coté de la ZDM on annule
				}
				else 
				{
//					DBG_TraceObject(to_col_wall_object)
//					DBG_TraceEOL()
					if ( to_col_wall_object == o_Kong)
					{
						// Detection Paf sur Kong
						i_charge_paf_KONG = vrai	
					}
				}
				v_sens_collision *= -1		// remis dans le bon sens
			}
		}
	}
	
	// Alignement le long du mur
	if( ! MATH_VecNullEpsilon(v_sens_collision) )
	{
		v_paf_mur_align = MATH_VecCrossProduct(v_sens_collision, Cv_VerticalVector)
		tf_dot = MATH_VecDotProduct(OBJ_SightGet(), v_paf_mur_align)
		if( tf_dot < 0.0 )
			v_paf_mur_align *= -1.0
//		DBG_TraceString("dot = ")
//		DBG_TraceFloat(tf_dot)
//		DBG_TraceEOL()
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_paf_mur_align * 5.0, color_cyan)
	}
	
	// Test collision 3 - Résultat 
	if( to_col_ray_object && to_col_ray_object != OBJ_Me())
		return to_col_ray_object
	else if ( to_col_wall_object && to_col_wall_object != OBJ_Me())
		return to_col_wall_object 
	else
		return nobody
}


//=============================================================================================
// Retourne vrai si REX doit se prendre un paf en paffant lui-même cet acteur, faux sinon
//=============================================================================================
procedure int KT_Test_collision_Mur_Prend_Paf(object to_col_actor)
{
	// REX doit se paffer sur l'objet : test du type d'objet pour valider la prise de paf
	if( @to_col_actor OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) )
	{
		if( @to_col_actor AI_IsModel(get_KI_Decor_Path) )
		{
			if( ! @get_KI_Decor_Path to_col_actor i_type_decor )
				return faux			// REX paffe un pieux -> il ne prend pas de paf en retour
		}
		else if( @to_col_actor AI_IsModel(get_KIntGrabObj_Path) )
			return faux			// REX paffe un tronc -> il ne prend pas de paf en retour
	}
	return vrai
}


//=================================================================================================
// Calculs pour un paf en charge
//=================================================================================================
procedure_local void KT_Init_Paf_Charge( byref vector pv_paf_sens, byref int pi_type_paf, byref float pf_puissance, int pi_je_paffe_kong, byref vector pv_charge_stop_vector )
{
	int			ti_calc_paf_analogique
	float		tf_angle
	float		tf_dot
	float		tf_sign
	vector	tv_temp
	
	ti_calc_paf_analogique = vrai
	
	// Type du paf
	pi_type_paf = C_PAF_KK_Fort + C_PAF_KK_Projection
	pf_puissance = Cf_DMG_Attack_Charge
	
	if( pi_je_paffe_kong )
	{
		// déplacement du TREX
		if( ! ti_calc_paf_analogique )
			tf_angle = Cf_Charge_Paf_Kong_Angle_Move
		else
		{					
			tf_dot = MATH_VecDotProduct(OBJ_SightGet(), MATH_VecNormalize(@o_Kong OBJ_PosGet() - OBJ_PosGet()))
			tf_dot *= Cf_PiBy4
			tf_angle = MATH_ACos(tf_dot)
		}
		
		// signe de l'angle
		tf_sign = 1
		tv_temp = MATH_VecCrossProduct(OBJ_SightGet(), Cv_VerticalVector)
		if( MATH_VecDotProduct(tv_temp, @o_Kong OBJ_SightGet()) < 0 )
			tf_sign *= -1
		
		pv_charge_stop_vector = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, tf_sign * tf_angle)
		DBG_RenderVector(OBJ_PosGet(), pv_charge_stop_vector * 5 , color_jaune)
		
		// sens du paf
		if( ! ti_calc_paf_analogique )
			tf_angle = Cf_Charge_Paf_Kong_Angle_Paf
		// ELSE : tf_angle conservé
		
		// signe de l'angle
		tf_sign *= -1
		
		pv_paf_sens = MATH_VecRotate(OBJ_SightGet(), Cv_VerticalVector, tf_sign * tf_angle)
	}
	else
		pv_paf_sens = OBJ_SightGet()
	
	MATH_VecSetNormalize(pv_paf_sens)
}


//=================================================================================================
// Mise à jour de l'intérêt de REX
//=================================================================================================
procedure_local void KT_Interet_Update(object po_actor, int pi_status)
{
	messageid			tmid_vision
	float					tf_interet
	vector				tv_pos
	
	// INFOS ACTEUR ====================================================
	tmid_vision = EVENT_FindEventPereTarget( C_EVENT_TYPE_Visibility, po_actor, nobody)
	if( MSG_GlobalIsValid(tmid_vision) )
	{
		tf_interet = EVENT_VisionInteretGet(tmid_vision)
		tv_pos = EVENT_PositionGet(tmid_vision)
	}
	else
	{
		tf_interet = Cf_interet_standard
		tv_pos = @po_actor OBJ_PosGet()
	}
	
	// UPDATE INTERET ===================================================
	if( MSG_GlobalIsValid(mid_best_interet) )
	{
		EVENT_InteretTargetSet(mid_best_interet, po_actor)
		EVENT_InteretSeenTimeSet(mid_best_interet, TIME_Get())
	}
	else
	{
		mid_best_interet = EVENT_AddEventInteret(OBJ_Me(), 5.0, tf_interet, tv_pos, po_actor)
	}
	EVENT_InteretStatusSet(mid_best_interet, pi_status)
}


//=================================================================================================
// Retourne vrai s'il existe déjà un message d'intérêt d'un autre acteur sur l'acteur spacifié et avec le statut spécifié, faux sinon
//=================================================================================================
procedure_local int KT_Check_Presence_Interet_Statut( object po_actor, int pi_statut)
{
	int					ti_rank
	message		tm_filter
	messageid		tmid_interet_ID
	
	ti_rank = -1
	MSG_SetNull(tm_filter)
	tm_filter.msg_gao1 = po_actor
	
	for (	tmid_interet_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tm_filter);
			MSG_GlobalIsValid(tmid_interet_ID);
			tmid_interet_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tm_filter) )
		if( EVENT_PereGet(tmid_interet_ID) != OBJ_Me() && EVENT_InteretStatusGet(tmid_interet_ID) == pi_statut)
				return vrai
	
	return faux
}


//
//procedure_local int	KT_Check_Attack( object po_actor)
//{
//	vector	pv_sens
//	if ( !o_fight_actor)
//		return (faux)	// Pas d adversaire
//	if ( !@o_fight_actor OBJ_CapaTest( OBJ_Capa_3))
//		return (faux)	// Pas d attaque
//	pv_sens = OBJ_PosGet() - @o_fight_actor OBJ_PosGet()
//	pv_sens.z = 0.0
//	if ( MATH_VecNorm( pv_sens) > 11.0)
//		return (faux)	//Trop Loin
//	pv_sens = MATH_VecNormalize( pv_sens)
//	if ( MATH_VecDotProduct( @o_fight_actor  OBJ_SightGet(), pv_sens) < 0.0)
//		return (faux)	//Pas dans l axe
//	return ( vrai)
//}
//

// retourne vrai uniquement si toutes les conditions sont remplies pour faire un finish à kong
procedure_local int FINISH_Kong_Allowed( object po_actor)
{
	messageid		tmid_kong
	int		ti_test
	if( ! o_Kong || po_actor != o_Kong )
		return faux
	ti_test = faux
	if( i_dernier_etat == ETAT_fight_cible_hauteur )
		ti_test = faux		// pas de demande de finish sur une attaque cible en hauteur (sinon bug finish Z décalé)
	else if( i_Kong_Gladiator )
		ti_test = vrai
	else if( ! @get_global i_Player_is_Kong )
		ti_test = vrai		// TEMP pour tester la protection de Kong en mode dual
	else
	{
		tmid_kong = EVENT_LIFE_MSGID_Get(po_actor)
		if( EVENT_LIFE_Est_Blesse(tmid_kong) && ! @po_actor Proc_KK_RAGE_Test() )
		{
			// Detection du Grab pour le Finish
			i_I_finish_try_cycle++
			if( i_I_finish_try_cycle == 2 )
			{
				ti_test = vrai
				i_I_finish_try_cycle = 0
			}
		}
	}
	if( ti_test )
	{
		o_I_finish_actor = LNK_ClientGet(Ci_LNK_KKFINISH_ON_KONG, mid_I_finish_LNK_ID, vrai, nofunc, nofunc, nofunc)
		if( o_I_finish_actor )
			return vrai
	}
	return faux
}


// Retourne vrai si l'action en cours est un cri
procedure_local int KT_Action_Cri_EnCours()
{
	switch( ACT_ActionGet() )
	{
		case Action_Fight_Cri_Haut :
		case Action_Fight_Cri_Bas :
			return vrai
		default:
			return faux
	}
}


procedure void KT_ActionSetForceFrame0(int ti_action)
{
	ACT_ActionSet(ti_action | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero )
}

// Choix de l'action de cri à lancer en fonction d'un test de hauteur
procedure_local void KT_Action_Cri_Select_by_Z(object to_actor, float tf_Z)
{
	object	to_head
	vector	tv_actor_pos
	vector	tv_my_pos
	
	tv_actor_pos = @to_actor OBJ_PosGet()
	tv_my_pos = OBJ_PosGet()
	if( tv_actor_pos.z > (tv_my_pos.z + tf_Z) )
		KT_ActionSetForceFrame0(Action_Fight_Cri_Haut)
	else
		KT_ActionSetForceFrame0(Action_Fight_Cri_Bas)
}


// Choix de l'action de cri à lancer en fonction des filtres
procedure_local void KT_Action_Cri_Select(object to_actor)
{
	float		tf_freq
	int			ti_freq
	if( i_stunned_flag )
	{
		KT_ActionSetForceFrame0(Action_Blesse_Attente)		// blessé : attend au lieu de crier
	}
	else if( i_cri_filtre & Ci_CRI_A_PAFFE_KONG )
	{
		// toujours cri haut après avoir paffé
		if( i_cri_filtre & Ci_CRI_FORCE_HAUT_SI_PAF )
			KT_ActionSetForceFrame0(Action_Fight_Cri_Haut)
		else if( i_cri_filtre & Ci_CRI_FORCE_BAS_SI_PAF )
			KT_ActionSetForceFrame0(Action_Fight_Cri_Bas)
		else
			KT_Action_Cri_Select_by_Z(to_actor, 2.0)
	}
	else if( i_cri_filtre & Ci_CRI_INTERACTION_FIN )
	{
		// cri en haut à la fin du script de fight avec AN
		KT_ActionSetForceFrame0(Action_Fight_Cri_Haut)
	}
	else if( i_cri_filtre & Ci_CRI_CAPA_CINE )
	{
		// cri de ciné
		KT_Action_Cri_Select_by_Z(to_actor, 0.0)
	}
	else if( to_actor == o_Jack )
	{
//		if( @get_global i_Player_on_KK_Shoulder )
//			KT_ActionSetForceFrame0(Action_Fight_Cri_Haut)
//		else
			KT_ActionSetForceFrame0(Action_Fight_Cri_Bas)
	}
	else
	{
		if( EVENT_LIFE_Est_Blesse(ID_LIFE) && ! (i_cri_filtre & Ci_CRI_PAS_D_ATTENTE_BLESSE) )
			KT_ActionSetForceFrame0(Action_Blesse_Attente)		// blessé : attend au lieu de crier
		else
		{
			// sinon test Z par rapport à la tete
			KT_Action_Cri_Select_by_Z(to_actor, 2.0)
		}
	}
	i_cri_filtre = 0
	if( KT_Action_Cri_EnCours() )
	{
		tf_freq = ACT_FrequencyGet(ACT_ActionGet(), 0)
		tf_freq *= MATH_RandFloat(0.7,1.5)
		tf_freq = MATH_FloatLimit(tf_freq, 20.0, 240.0)
		ti_freq = tf_freq			// caster en entier !!!!
		ANI_FrequencySet(0, ti_freq)
	}
}



//// Choix de l'action de cri à lancer
//procedure_local void KT_Action_Cri_Select(object to_actor)
//{
//	object	to_head
//	vector	tv_actor_pos
//	vector	tv_head_pos
//	
//	if( i_stunned_flag  )
//	{
//		ACT_ActionSet(Action_Blesse_Attente)		// blessé : attend au lieu de crier
//	}
//	else if( i_cri_apres_un_paf )
//	{
//		// toujours cri haut après avoir paffé
//		if( i_cri_apres_un_paf_type )	// type du cri forcé (0 = bas / 1 = haut)
//			ACT_ActionSet(Action_Fight_Cri_Haut)
//		else
//			ACT_ActionSet(Action_Fight_Cri_Bas)
//	}
//	else if( i_interaction_fin_cri )
//	{
//		// cri en haut à la fin du script de fight avec ANN
//		ACT_ActionSet(Action_Fight_Cri_Haut)
//	}
//	else if( o_fury_actor == o_ANN )
//	{
//		if( o_interaction_target )
//		{
//			// SCRIPT FACE A ANN
//			ACT_ActionSet(Action_Fight_Cri_Haut)
//		}
//		else
//		{
//			tv_actor_pos = @to_actor OBJ_PosGet()
//			tv_head_pos = OBJ_PosGet()
////			if( tv_actor_pos.z > (tv_head_pos.z + 1.0) )		// sur la branche
//			if( tv_actor_pos.z > tv_head_pos.z )		// sur la branche
//				ACT_ActionSet(Action_Fight_Cri_Haut)
//			else
//				ACT_ActionSet(Action_Fight_Cri_Bas)
//		}
//	}
//	else
//	{
//		if( EVENT_TL_Is_Bleeding(ID_LIFE) )
//			ACT_ActionSet(Action_Blesse_Attente)		// blessé : attend au lieu de crier
//		else
//		{
//			// sinon test Z par rapport à la tete
//			tv_actor_pos = @to_actor OBJ_PosGet()
////			to_head = ANI_CanalObjectGet(Anim_Canal_Tete)
////			tv_head_pos = @to_head OBJ_PosGet()
////			if( tv_actor_pos.z > (tv_head_pos.z + 1.0) )
//			tv_head_pos = OBJ_PosGet()
//			if( tv_actor_pos.z > (tv_head_pos.z + 2.0) )
//				ACT_ActionSet(Action_Fight_Cri_Haut)
//			else
//				ACT_ActionSet(Action_Fight_Cri_Bas)
//		}
//	}
//	i_cri_apres_un_paf = faux
//	i_interaction_fin_cri = faux
//	
//	if( ACT_ActionGet() != Action_Blesse_Attente )
//		ANI_FrequencySet(0, ANI_FrequencyGet(0) * MATH_RandFloat(0.7,1.5))
//}


// Retourne vrai si la cible est en train de réaliser un finish
procedure_local int KT_CheckTargetFinishing(object to_actor)
{
	messageid		tmid_temp
	if( to_actor == o_Kong )
	{
		tmid_temp = EVENT_FindEventPereTarget(Ci_LNK_EVENT_OFFSET + Ci_LNK_GRAB_KONG, nobody, to_actor)
		if( MSG_GlobalIsValid(tmid_temp) )
		{
			if ( LNK_GrabKong_TypeGet(tmid_temp) == Ci_GrabKong_Type_Finish)
			{
//				Str_DisplayTextOnce("KONG FINISH UN REX", cvector(0.5, 0.5, 0.0))
				return vrai
			}
		}
	}
	return faux
}


// Retourne vrai si la cible est la proie d'un finish
procedure_local int KT_CheckTargetFinished(object to_actor)
{
	messageid		tmid_temp
	object			to_gao
	
	if( to_actor == o_Kong )
	{
		tmid_temp = EVENT_FindEventPereTarget(Ci_LNK_EVENT_OFFSET + Ci_LNK_KKFINISH_ON_KONG, to_actor, nobody)
		if( MSG_GlobalIsValid(tmid_temp) )
		{
//			to_gao = EVENT_PereGet(tmid_temp)
			to_gao = EVENT_TargetGet(tmid_temp)		// il y a bien un serveur (ce n'est pas une liaison vide d'une demande d'un client)
			if( to_gao )
			{
//				Str_DisplayTextOnce("UN REX FINISH KONG", cvector(0.5, 0.5, 0.0))
				return vrai
			}
		}
	}
	return faux
}


// init le freinage ABS d'urgence de REX qd il est en charge et qu'il y a un mur ou du vide
procedure_local void KT_Charge_Freine_Mur()
{
////	i_charge_mode = Ci_charge_mode_coll_wall_stop	
	i_charge_mode = Ci_charge_stoppee
//	ACT_ActionSet(Action_Normal_ChargeDerap)
////	ACT_ActionSet(Action_Normal_Marche_Rapide)
////	f_time_start_etat = 0.0
}


// Retourne vrai si REX est dans une fenêtre de Grab autorisé pendant une anim d'attaque
procedure_local int KT_AttaqueFenetreGrabAutorise()
{
	int			ti_frame
	int			ti_action_item
	
	if( i_contre_attaque_mode )
		return faux
	
	ti_action_item = ACT_ActionItemGet()
	ti_frame = ANI_CurrentFrameGet(0)
	switch( ACT_ActionGet() )
	{
		case Action_Fight_Attak_FPS :
			return faux
			break
		case Action_Fight_Attak_Humain :
			if( ti_action_item == 0 && ti_frame < 35 )
				return vrai
			break
		case Action_Attak_Mord_Haut :
			if( ti_frame < 30 )
				return vrai
			break
		case Action_Attak_CpdeFace :
			if( ti_frame < 25 )
				return vrai
			break
		case Action_Attak_CpTeteD :
		case Action_Attak_CpTeteG :
			if( ti_frame < 22 )
				return vrai
			break
		case Action_Attak_CpQueueD :
		case Action_Attak_CpQueueG :
			if( ti_frame < 30 )
				return vrai
			break
	}
	return faux
}

// Retourne vrai si REX a le droit de racaler KONG
procedure_local int KT_AntiBug_Col_KONG_Autorise()
{
	if( ! @o_Kong Proc_KK_IsMoveable() )
		return faux
	
	switch( i_etat_courant )
	{
		case ETAT_KK_grabbedTT :				// en grab je recalle pas KONG
		case ETAT_KK_grabbedFinish :			// en finish je recalle pas KONG
		case ETAT_Finish_sur_Kong :		// en finish je recalle pas KONG
		case ETAT_mort :							// je suis mort, je vais pas recaller kong !!! :)
			return faux
		
		case ETAT_attaque :
			if( i_fight_paf )
				return faux			// tant que je n'ai pas paffé KONG, je peux le recaler...
			else
				return vrai			// une fois KONG paffé, on ne va pas le recaler dans le sens contraire du paf...
	}
	
	return vrai
}


// Retourne vrai si la cible est en hauteur
procedure_local int KT_CibleEnHauteur()
{
	object		to_gao
	message	tmsg_trigger
	
	if( o_fight_actor == o_Kong && @get_global i_kong_camera_status == Ci_Kcamera_walling )
		return Ci_Cible_En_Hauteur_Mode_Walling

//	if ( o_fight_actor == o_Kong && @o_Kong Proc_KK_Test_Mode( ETAT_Kong_colonne))
//		return Ci_Cible_En_Hauteur_Mode_Pas_Walling
		
	if( AI_TriggerIsValid(trig_cible_hauteur) && call_trigger(trig_cible_hauteur) )
	{
		tmsg_trigger = AI_TriggerGetMsg(trig_cible_hauteur)
		to_gao = tmsg_trigger.msg_gao5
		Check_This_Gao5(to_gao)
		o_fight_actor = to_gao
		return Ci_Cible_En_Hauteur_Mode_Pas_Walling
	}
	return Ci_Cible_Pas_En_Hauteur		// 0
}



//=============================================================================================
// Choix de l'anim d'attaque D/G
//=============================================================================================
procedure_local void KT_Lance_Attaque(vector tv_sight, int ti_actionD, int ti_actionG, int ti_zde_fight_type)
{
	vector	tv_temp
	float		tf_dot
	
	tv_temp = tv_sight
	tv_temp.z = OBJ_HorizonGet().z
	MATH_VecSetNormalize(tv_temp)
	tf_dot = MATH_VecDotProduct(tv_temp, OBJ_HorizonGet())
	if( tf_dot > 0 )
		i_KK_attaque_action = ti_actionG
	else
		i_KK_attaque_action = ti_actionD
	i_flag_zde_fight_type = ti_zde_fight_type
}


// Récupère de la vie après un finish raté ou après être resté KO au sol trop longtemps
procedure_local void KT_LifeRecupere()
{
	EVENT_LIFE_CurLifeSet(ID_LIFE, MATH_FloatMax(EVENT_LIFE_CurLifeGet(ID_LIFE),Cf_PAF_seuil_recuperation))
}


procedure_local void KT_Derap_Mode_Select()
{
	vector		tv_axis
	vector		tv_sight
	vector		tv_horizon
	float			tf_dotS
	float			tf_dotH

	// sight
	tv_sight = OBJ_SightGet()
	tv_sight.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_sight) )
		MATH_VecSetNormalize(tv_sight)
	else
		tv_sight = OBJ_SightGet()
	
	// fight actor / sens projection
	tv_axis = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
	tv_axis.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_axis) )
		MATH_VecSetNormalize(tv_axis)
	else
		tv_axis = OBJ_SightGet()
	
	// horizon
	tv_horizon = - MATH_VecCrossProduct(tv_sight, Cv_VerticalVector)
	
	// dot
	tf_dotS = MATH_VecDotProduct(tv_sight, tv_axis)
	tf_dotH = MATH_VecDotProduct(tv_horizon, tv_axis)
	
	if( tf_dotS < - Cf_Cos85 ) // - Cf_Cos30 )
	{
		// kong dans mon dos
		i_derap_mode = Ci_derap_demi_tour
		v_derap_tout_droit_axis = OBJ_SightGet()
 	}
 	else
	{
		if( tf_dotS < Cf_Cos75 )
			i_derap_mode = Ci_derap_stop_rapide_deb_only	// kong sur les côtés
		else
			i_derap_mode = Ci_derap_stop_rapide_deb_fin		// kong devant moi
	}
	
	if( tf_dotH > 0.0 )
		ACT_ActionSet(Action_StopRapideGdeb)
	else
		ACT_ActionSet(Action_StopRapideDdeb)
	if( i_derap_detect_fury )
		ANI_FrequencySet(0, MATH_FloatLimit(ANI_FrequencyGet(0) * MATH_RandFloat(1.5, 2.0), 48, 200))
}

procedure_local void KT_Timer_KONG_Init()
{
	if( o_fight_actor == o_Jack )
	{
		// Kong me paffe alors que ma cible était Jack -> je reviens un moment sur Kong
		f_time_KONG = MATH_RandFloat(Cf_delay_on_KONG - 5.0, Cf_delay_on_KONG + 5.0)
		f_time_KONG_not_on_me = 0.0
	}
}


procedure_local int KT_Action_Attack_EnCours()
{
	switch( ACT_ActionGet() )
	{
		case Action_Attak_Mord_Haut :
		case Action_Attak_CpdeFace :
		case Action_Attak_CpTeteD :
		case Action_Attak_CpTeteG :
		case Action_Attak_CpQueueD :
		case Action_Attak_CpQueueG :
		case Action_Fight_Attak_Humain :
		case Action_Fight_Attak_FPS :
//		case Action_Fight_AttacJack_fin :
//		case Action_Fight_AttacJack_tr_att :
			return vrai
		default:
			return faux
	}
}

procedure_local int KT_ChoppeProjectileAllowed()
{
	switch( i_etat_courant )
	{
		case ETAT_attente :
		case ETAT_fight_KONG :
//		case ETAT_fight_ANN :
		case ETAT_fight_JACK :
		case ETAT_fight_cible_hauteur :
		case ETAT_cri :
			return vrai
		case ETAT_attaque :
			if( i_cible_en_hauteur_flag )
				return vrai
			else
				return faux
		default:
			return faux
	}
}

procedure_local int KT_IsEtatFightMove()
{
	switch( i_etat_courant )
	{
		case ETAT_fight_KONG :
//		case ETAT_fight_ANN :
		case ETAT_fight_JACK :
		case ETAT_fight_cible_hauteur :
			return vrai
		default:
			return faux
	}
}


// Retourne la postion où regarder l'acteur en paramètre
procedure_local vector KT_GetActorPosToLook(object to_target)
{
	object		to_head
	vector		tv_offset
	vector		tv_pos
	
	if( to_target == o_Jack )
	{
		tv_pos = @to_target OBJ_PosGet()
	}
//	if( to_target == o_ANN )
//	{
//		// Pour baisser REX pour paffer ANN : il regarde le pivot de ANN et pas sa tête
//		if( ! o_interaction_target )
//			tv_pos = @to_target OBJ_PosGet()
//		else
//		{
//			if( i_etat_courant == ETAT_attaque )
//			{
//				if( i_paf_try_to_paf && ! OBJ_CapaTest(Capa_Paffe) )
//				{
//					// fenetre d'attaque terminée : regarde ANN
//					tv_offset = Cv_NullVector
//				}
//				else
//				{
//					switch( i_interaction_cpt )
//					{
//						case 0 :
//							tv_offset = Cv_NullVector
//							break
//						case 1 :
//							tv_offset = - 2.0 * @to_target OBJ_SightGet()
//							break
//						case 2 :
//							tv_offset = 2.0 * @to_target OBJ_SightGet()
//							break
//						case Ci_script_KAnn_cycle_max :
//							tv_offset = Cv_NullVector
//							break
//					}
//				}
//			}
//			else
//			{
//				tv_offset = Cv_NullVector
//			}
//			tv_pos = @to_target OBJ_PosGet() + tv_offset
//		}
//	}
	else
	{
		to_head = @to_target ANI_CanalObjectGet(Anim_Canal_Tete)
		if( ! to_head )
			to_head = to_target
		tv_pos = @to_head OBJ_PosGet()
	}
	return tv_pos
}


procedure_local void KT_Degagement_Init()
{
	if( o_degagement_wp )
	{
		v_degagement_pos = @o_degagement_wp OBJ_PosGet()
		i_degagement_flag = vrai
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_degagement_pos - OBJ_PosGet(), color_bleu)
	}
}


procedure_local void KT_OrientationInitGet(object to_actor, int ti_cadavre)
{
	messageid		tmid_vision
	vector			tv_dest
	vector			tv_sight_sans_occluder
	int					ti_type
	
	if ( i_fight_must_dodge )
	{
		tv_dest = @o_Kong OBJ_PosGet()
	}
	else if( i_degagement_flag )
	{
		tv_dest = v_degagement_pos
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_degagement_pos - OBJ_PosGet(), color_cyan)
	}
	else 
	{
		if( ti_cadavre )
			ti_type = C_EVENT_TYPE_Cadavre
		else
			ti_type = C_EVENT_TYPE_Visibility
		
		tmid_vision = EVENT_FindEventPereTarget(ti_type, to_actor, nobody)
		if( MSG_GlobalIsValid(tmid_vision) )
			tv_dest = EVENT_PositionGet(tmid_vision)
		else
			tv_dest = @to_actor OBJ_PosGet()
	}
	
	f_degagement_needed = 0.0
	tv_sight_sans_occluder =  tv_dest - OBJ_PosGet()
	tv_sight_sans_occluder.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_sight_sans_occluder) )
	{
		f_move_dist = MATH_VecNorm(tv_sight_sans_occluder)
		MATH_VecSetNormalize(tv_sight_sans_occluder)
	}
	else
	{
		f_move_dist = 0.0
		tv_sight_sans_occluder = OBJ_SightGet()
	}
	
	// VARS GLOBALES
	v_sight_sans_occluder = tv_sight_sans_occluder
	v_dest_pos_sans_occluder = tv_dest
}


////////////////// PENSER A INITIALISER v_orientation_sens AVANT D'EXECUTER CETTE FONCTION !!!! /////////////////////////
procedure_local void KT_OrientationFinaleSet()
{
	vector		tv_new_sight
	float			tf_best_coef
	
	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_orientation_sens * 10, color_jaune)
	
	if( MATH_VecNullEpsilon(v_orientation_sens) )
		v_orientation_sens = OBJ_SightGet()
	
	// ORIENTATION SOUHAITEE
	if( i_Kong_Mashing )
		tf_best_coef = 5.0		// charger !!!!!
	else
		tf_best_coef = 2.0
	f_orientation_coef = MATH_FloatBlend(f_orientation_coef, 2.0, TIME_GetDt())
	tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), v_orientation_sens, f_orientation_coef * TIME_GetDt())
	
	// ORIENTATION DEFINITIVE	
	OBJ_BankingGeneralSet(tv_new_sight, Cv_VerticalVector)
}


procedure_local void KT_OccluderTest()
{
	float		tf_occluders[4]
	float		tf_largeur
	object	to_occluder_jump
	object	to_occluders[4]
	int			ti_occluder_cette_trame
	vector	tv_dest_temp
	int			ti_occluders_nb
	
	// DEST POS PAR DEFAUT
	v_dest_pos_avec_occluder = v_dest_pos_sans_occluder
	
	// TEST D'OCCLUDERS
	ti_occluders_nb = 0
	if( o_Kong && o_fight_actor != o_Kong )
	{
		to_occluders[ti_occluders_nb] = o_Kong
		tf_occluders[ti_occluders_nb] = 4.0
		ti_occluders_nb++
	}
	
//	tf_largeur = 2.0
//	tf_largeur = COL_ZoneSizeGet(C_zdm_pied) + 0.1
	tf_largeur = COL_ZoneSizeGet(C_zdm_pied) - 0.5
	ti_occluder_cette_trame = WAY_LIB_Test_Occluder(OBJ_PosGet() + Cv_VerticalVector, v_sight_sans_occluder, tf_largeur, v_dest_pos_sans_occluder, -1, tv_dest_temp, to_occluder_jump, &to_occluders[0], &tf_occluders[0], ti_occluders_nb, C_Occl_Type_All)
	if( ti_occluder_cette_trame & Ci_OCCLUDER_DEST_POS_IS_IN_OCCLUDER )
	{
		// ma cible est dans un occluder : j'ignore l'occluder et j'attaque quand même
		i_occluder_cette_trame = faux
		no_occluder_duration = Cf_no_occluder_duration_min		// permettre de paffer si ma cible est dans un occluder
		i_charge_interdite = vrai		// ne pas charger même si la cible est dans un occluder
	}
	else if( ti_occluder_cette_trame & Ci_OCCLUDER_START_POS_IS_IN_OCCLUDER )
	{
		// pouvoir paffer ma cible qui est au contact alors que moi je suis dans un occluder
		i_occluder_cette_trame = vrai
		no_occluder_duration = Cf_no_occluder_duration_min		// permettre de paffer si ma cible est dans un occluder
		i_charge_interdite = vrai		// ne pas charger même si la cible est dans un occluder
	}
	else if( ti_occluder_cette_trame != 0 )
	{
		// il y a un occluder entre ma cible et moi : je contourne
		i_occluder_cette_trame = vrai
		no_occluder_duration = 0.0
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_sight_sans_occluder * 10, color_rouge)
		v_dest_pos_avec_occluder = tv_dest_temp
	}
	else
	{
		// pas d'occluder : tout droit
		i_occluder_cette_trame = faux
		no_occluder_duration += TIME_GetDt()
	}
	
	// ORIENTATION APRES LE TEST D'OCCLUDERS
	v_sight_avec_occluder =  v_dest_pos_avec_occluder - OBJ_PosGet()
	v_sight_avec_occluder.z = 0.0
	if( ! MATH_VecNullEpsilon(v_sight_avec_occluder) )
	{
//		f_move_dist = MATH_VecNorm(v_sight_avec_occluder)
		MATH_VecSetNormalize(v_sight_avec_occluder)
	}
	else
	{
		v_sight_avec_occluder = OBJ_SightGet()
//		f_move_dist = 0.0
	}
	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_sight_avec_occluder * 10, color_vert)
}


procedure_local void KT_Action_Move_Select()
{
	float		tf_delai_anim
	
//	if( i_etat_courant == ETAT_fight_ANN )
//		tf_delai_anim = 0.1			// REX avance pour laisser passer l'autre REX qui se dégage, mais il ne faut pas non plus rentrer dans la branche où est cachée ANN...
//	else
		tf_delai_anim = 1.0
	
	if( i_force_change_anim || ( i_fight_action != i_fight_action_old && f_fight_delai_anim > tf_delai_anim ) )
	{
		ACT_ActionSet(i_fight_action)
	
		if( i_fight_action == i_Anim_marche ) // && i_blesse_on )
		{
			ANI_FrequencySet(0, MATH_FloatLimit(ANI_FrequencyGet(0) * MATH_RandFloat(0.9,1.3), 1, 255))
		}
		
		i_fight_action_old = i_fight_action
		f_fight_delai_anim = 0.0
	}
	else
		f_fight_delai_anim += TIME_GetDt()
	i_force_change_anim = faux
}


procedure_local int KT_Paf_Mur_Allowed()
{
	if( f_delay_last_paf_mur >= Cf_paf_mur_delay)
		return vrai
	else
		return faux
}


procedure_local vector KT_Proj_Vector_Get()
{
	if( o_proj_target )
	{
		// Mise à jour du point de projection
		v_proj_target_pos = @get_global v_KongFight_TargetAddPos[i_proj_target_index]                    // Position de la target a cette trame.
		v_grab_grav_speed = v_proj_target_pos - OBJ_PosGet()
		v_grab_grav_speed.z = 0.0
		if ( MATH_VecNullEpsilon( v_grab_grav_speed))
			v_grab_grav_speed = OBJ_SightGet()
		else
			MATH_VecSetNormalize(v_grab_grav_speed)

		DBG_RenderSphere(v_proj_target_pos, 3.0, 0x200000FF)
	}
//	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_grab_grav_speed, color_jaune)
	return v_grab_grav_speed
}


//procedure_local void KT_Add_GFX_Blood(int ti_type, object to_paf_actor)
//{
//	int			ti_i
//	
//	// VISUAL PAF =========
//	for( ti_i = 0; ti_i < 10; ti_i++ )
//	{
//		if( ! af_blood_delay[ti_i] )
//		{
//			switch( ti_type )
//			{
//				case Ci_GFX_Blood_Paf_Mur :
//					ai_blood_bone_index[ti_i] = Anim_Canal_Tete
//					af_blood_delay[ti_i] = 1.0
//					av_blood_bone_offset[ti_i] = Cv_NullVector
//					av_blood_bone_normale[ti_i] = Cv_NullVector
//					ai_blood_finish[ti_i] = 0
//					break
//				
//				case Ci_GFX_Blood_Finish_Bras_de_Fer :
//					ai_blood_bone_index[ti_i] = Anim_Canal_Machoire
//					af_blood_delay[ti_i] = 3.0
//					av_blood_bone_offset[ti_i] = cvector(-1.0, 0.0, 1.0)
//					av_blood_bone_normale[ti_i] = Cv_NullVector
//					ai_blood_finish[ti_i] = 1
//					break
//				
//				case Ci_GFX_Blood_Finish_Pieux :
//					ai_blood_bone_index[ti_i] = Anim_Canal_Ventre
//					af_blood_delay[ti_i] = 3.0
//					av_blood_bone_offset[ti_i] = cvector(-1.0, 0.0, 1.0)
//					av_blood_bone_normale[ti_i] = Cv_NullVector
//					ai_blood_finish[ti_i] = 1
//					break
//
//				default: 
//				case Ci_GFX_Blood_Petit_Paf :
//					if( to_paf_actor && MATH_VecDotProduct(OBJ_SightGet(), @to_paf_actor OBJ_PosGet() - OBJ_PosGet()) < 0 )
//					{
//						// paf actor de dos
//						ai_blood_bone_index[ti_i] = Anim_Canal_Bassin
//						if( i_etat_courant == ETAT_mort || i_etat_courant == ETAT_KO_au_sol )
//							av_blood_bone_offset[ti_i] = cvector(-2,0,0)
//						else
//							av_blood_bone_offset[ti_i] = Cv_NullVector
//					}
//					else
//					{
//						// pas de paf actor spécifié ou paf actor de face
//						ai_blood_bone_index[ti_i] = Anim_Canal_Tete
//						av_blood_bone_offset[ti_i] = Cv_NullVector
//					}
//					af_blood_delay[ti_i] = 1.0
//					av_blood_bone_offset[ti_i] = Cv_NullVector
//					av_blood_bone_normale[ti_i] = Cv_NullVector
//					ai_blood_finish[ti_i] = 0
//					break
//			}
//			break
//		}
//	}
//}

// Retourne vrai si la cible est en train de réaliser un finish
procedure_local int KT_CheckTargetIsInteractionFightServer(object to_actor)
{
	messageid		tmid_temp
	if( to_actor )
	{
		tmid_temp = EVENT_FindEventPereTarget(Ci_LNK_EVENT_OFFSET + Ci_LNK_INTERACTION, nobody, to_actor)
		if( MSG_GlobalIsValid(tmid_temp) )
		{
			return vrai
		}
	}
	return faux
}



// Retourne vrai si la cible est la proie d'un finish
procedure_local int KT_CheckTargetIsInteractionFightClient(object to_actor, byref object to_serveur)
{
	messageid		tmid_temp
	object			to_gao
	
	if( to_actor )
	{
		tmid_temp = EVENT_FindEventPereTarget(Ci_LNK_EVENT_OFFSET + Ci_LNK_INTERACTION, to_actor, nobody)
		if( MSG_GlobalIsValid(tmid_temp) )
		{
//			to_gao = EVENT_PereGet(tmid_temp)
			to_serveur = EVENT_TargetGet(tmid_temp)		// il y a bien un serveur (ce n'est pas une liaison vide d'une demande d'un client)
			if( to_serveur )
			{
//				Str_DisplayTextOnce("UN REX FINISH KONG", cvector(0.5, 0.5, 0.0))
				return vrai
			}
		}
	}
	return faux
}


procedure_local int KT_Bave_Enabled()
{
	if( EVENT_LIFE_Est_Blesse(ID_LIFE) )
	{
		switch( i_etat_courant )
		{
			case ETAT_KK_grabbedTT :
				if( 1 )		// certains grabs uniquement !!! STEF ???
					return vrai
				break
			
			// deplacement
			case ETAT_fight_KONG :
//			case ETAT_fight_ANN :
			case ETAT_fight_JACK :
			case ETAT_fight_cible_hauteur :
			// attente
			case ETAT_cri :
			case ETAT_attente :
			case ETAT_KK_choppe_projectile :
				return vrai
		}
	}
	return faux
}


// RAGE ===============================================================
procedure_local int KT_Rage_Enabled()
{
	if( i_Rage_enabled )
	{
//		if( @o_Kong Proc_KK_Get_KTREX_Count(OBJ_Me()) == 0 )
			return vrai
	}
	return faux
}
procedure_local void KT_Rage_Increase()
{
	if( i_Kong_Gladiator )
		f_rage_jauge = 0.0		// reset rage en gladiator
	else
		f_rage_jauge += 2.0
}
procedure_local int KT_Rage_Ready()
{
	if( f_rage_jauge > 2.5 )
		return vrai
	else
		return faux
}
procedure_local void KT_Rage_Launch()
{
	f_rage_jauge = 0.0
	i_rage_cpt = 4
}
procedure_local void KT_Rage_Decrement()
{
	if( i_Kong_Gladiator )
		i_rage_cpt = 0		// reset rage en gladiator
	if( i_rage_cpt )
		i_rage_cpt--
}
procedure_local int KT_Rage_en_cours()
{
	if( i_rage_cpt )
		return vrai
	else
		return faux
}
// RAGE ===============================================================


// CYCLE DELAI POUR RE-ATTAQUER
procedure_local void KT_ReAttackDelay()
{
	float		tf_delay
	if( o_fight_actor == o_Kong )
	{
		if( KT_Rage_en_cours() )
		{
			tf_delay = 0.2
			f_fight_delai_attak = tf_delay
		}
		else
		{
			tf_delay = @get_global f_KTREX_reattack_delay
			if( tf_delay == 0.0 || tf_delay == Ci_reattack_delay_cycl1 )
			{
				f_fight_delai_attak = Ci_reattack_delay_cycl1
				tf_delay = Ci_reattack_delay_cycl2
			}
			else if( tf_delay == Ci_reattack_delay_cycl2 )
			{
				f_fight_delai_attak = tf_delay
				tf_delay = Ci_reattack_delay_cycl3
			}
			else if( tf_delay == Ci_reattack_delay_cycl3 )
			{
				f_fight_delai_attak = tf_delay
				tf_delay = Ci_reattack_delay_cycl1
			}
			@get_global f_KTREX_reattack_delay = tf_delay
		}
	}
	else
		f_fight_delai_attak = MATH_RandFloat(2.0, 3.0)
}

//procedure_local void KT_GFX_Particules000(messageid tmid_paf, float tf_SizeFactor)
//{
//	int			ti_GFX_Impact
//	vector	tv_pos
//	vector	tv_direction
//	
//	tv_pos = EVENT_PafPositionGet(tmid_paf)
//	tv_direction = EVENT_PafDirGet(tmid_paf)
//	DBG_RenderVector(tv_pos, tv_direction, color_cyan)
//	
//	// ETINCELLES
//	ti_GFX_Impact = GFX_Add(9)
//	GFX_FlagSet(ti_GFX_Impact , 0, 1)
//	GFX_FlagSet(ti_GFX_Impact , 2, 1)
//	GFX_MaterialSet(ti_GFX_Impact , get_SFX_light_and_smoke, 5)
//	GFX_Setf(ti_GFX_Impact, 9000, Cf_PiBy2 * 0.75)												// angle d'ouverture
//	GFX_Setf(ti_GFX_Impact, 9001, 20.0)														// vitesse initiale minimum
//	GFX_Setf(ti_GFX_Impact, 9002, 50.0)														// vitesse initiale maximum
//	GFX_Setf(ti_GFX_Impact, 9003, 0.95 )														// friction
//	GFX_Setf(ti_GFX_Impact, 9004, 0.018 * tf_SizeFactor)													// épaisseur
//	GFX_Setf(ti_GFX_Impact, 9005, 0.02)														// durée de vie minimum
//	GFX_Setf(ti_GFX_Impact, 9006, 0.05)														// durée de vie maximum
//	GFX_Setf(ti_GFX_Impact, 9007, 2 )														// multiplicateur de longueur
//	GFX_Setf(ti_GFX_Impact, 9008, 0.005 )													// generation périod
//	GFX_Setf(ti_GFX_Impact, 9009, 0.05)														// durée de mort minimun
//	GFX_Setf(ti_GFX_Impact, 9010, 0.1)														// durée de mort maximun
//	GFX_Seti(ti_GFX_Impact, 9100, 25)															// Nombre
//	GFX_Seti(ti_GFX_Impact, 9102, 0b11000)												// Flags (1 => agrandissement centré)
//	GFX_Setv(ti_GFX_Impact, 9200, tv_pos)													// Origine des étincelles
//	GFX_Setv(ti_GFX_Impact, 9201, tv_direction)											// Direction
//	GFX_Setv(ti_GFX_Impact, 9202, cvector(0.0, 0.0, -2.0) )								// gravity
//	GFX_Seti(ti_GFX_Impact, 9101, 0xf080c0ff) 												// couleur}
////	GFX_Seti(ti_GFX_Impact, 9101, 0xf06666ff)
//}



//procedure_local void KT_GFX_ParticulesOLD(vector tv_pos, vector tv_direction)
//{
//	int			ti_GFX_Impact
//	
//	ti_GFX_Impact = GFX_Add(9)
//	GFX_FlagSet(ti_GFX_Impact , 0, 1)
//	GFX_FlagSet(ti_GFX_Impact , 2, 1)
//	GFX_MaterialSet(ti_GFX_Impact, get_SFX_light_and_smoke, 8)
//	GFX_Setf(ti_GFX_Impact, 9000, Cf_PiBy2 * 0.25)										// angle d'ouverture
//	GFX_Setf(ti_GFX_Impact, 9001, 8.0)														// vitesse initiale minimum
//	GFX_Setf(ti_GFX_Impact, 9002, 15.0)														// vitesse initiale maximum
//	GFX_Setf(ti_GFX_Impact, 9003, 0.96 )														// friction
//	GFX_Setf(ti_GFX_Impact, 9004, 0.04 )														// épaisseur
//	GFX_Setf(ti_GFX_Impact, 9005, 0.15)														// durée de vie minimum
//	GFX_Setf(ti_GFX_Impact, 9006, 0.5)														// durée de vie maximum
//	GFX_Setf(ti_GFX_Impact, 9007, 2.0 ) 														// multiplicateur de longueur
//	GFX_Setf(ti_GFX_Impact, 9008, 0.00 )														// generation périod
//	GFX_Setf(ti_GFX_Impact, 9009, 0.1)														// durée de mort minimun
//	GFX_Setf(ti_GFX_Impact, 9010, 0.4)														// durée de mort maximun
//	GFX_Seti(ti_GFX_Impact, 9100, 15 ) 														// Nombre
//	GFX_Seti(ti_GFX_Impact, 9102, 0b11000)												// Flags (1 => agrandissement centré)
//	GFX_Setv(ti_GFX_Impact, 9200, tv_pos)													// Origine des étincelles
//	GFX_Setv(ti_GFX_Impact, 9201, tv_direction)											// Direction
//	GFX_Setv(ti_GFX_Impact, 9202, cvector(0.0, 0.0, -6.0) )								// gravity
////	GFX_Seti(ti_GFX_Impact, 9101, 0x552E3743) 										// couleur}
//	GFX_Seti(ti_GFX_Impact, 9101, 0xFF100F23) 											// couleur}
//}
//
//
//procedure_local void KT_GFX_ParticulesTEMP(vector tv_pos, vector tv_direction)
//{
//	int			ti_GFX_Impact
//	
//	ti_GFX_Impact = GFX_Add(9)
//	GFX_FlagSet(ti_GFX_Impact , 0, 1)
//	GFX_FlagSet(ti_GFX_Impact , 2, 1)
////	GFX_MaterialSet(ti_GFX_Impact, get_SFX_light_and_smoke, 8)
//	GFX_MaterialSet(ti_GFX_Impact, get_SFX_light_and_smoke_Kanada, 2)
//	GFX_Setf(ti_GFX_Impact, 9000, Cf_PiBy2 * 0.25)										// angle d'ouverture
//	GFX_Setf(ti_GFX_Impact, 9001, 8.0)														// vitesse initiale minimum
//	GFX_Setf(ti_GFX_Impact, 9002, 15.0)														// vitesse initiale maximum
//	GFX_Setf(ti_GFX_Impact, 9003, 0.96 )														// friction
//	GFX_Setf(ti_GFX_Impact, 9004, 0.1 ) //0.04 )														// épaisseur
//	GFX_Setf(ti_GFX_Impact, 9005, 0.15)														// durée de vie minimum
//	GFX_Setf(ti_GFX_Impact, 9006, 0.75 ) //0.5)														// durée de vie maximum
//	GFX_Setf(ti_GFX_Impact, 9007, 4.0 ) 														// multiplicateur de longueur
//	GFX_Setf(ti_GFX_Impact, 9008, 0.00 )														// generation périod
//	GFX_Setf(ti_GFX_Impact, 9009, 0.1)														// durée de mort minimun
//	GFX_Setf(ti_GFX_Impact, 9010, 0.4)														// durée de mort maximun
//	GFX_Seti(ti_GFX_Impact, 9100, 15 ) 														// Nombre
//	GFX_Seti(ti_GFX_Impact, 9102, 0b11000)												// Flags (1 => agrandissement centré)
//	GFX_Setv(ti_GFX_Impact, 9200, tv_pos)													// Origine des étincelles
//	GFX_Setv(ti_GFX_Impact, 9201, tv_direction)											// Direction
//	GFX_Setv(ti_GFX_Impact, 9202, cvector(0.0, 0.0, -6.0) )								// gravity
//	GFX_Seti(ti_GFX_Impact, 9101, 0xFF2E3743) 										// couleur}
////	GFX_Seti(ti_GFX_Impact, 9101, 0xFF100F23) 											// couleur}
//}

//procedure_local void KT_Last_Time_ANN_Attack_Update()
//{
//	@get_global f_KTREX_attack_ANN_last_time = TIME_Get()
//}


//procedure_local int KT_Last_Time_ANN_Attack_Ready()
//{
//	if( TIME_Elapsed(@get_global f_KTREX_attack_ANN_last_time, 10.0) )
//		return vrai
//	else
//		return faux
//}


procedure_local	int	ARR_RemoveGao( byrefarr object pao_uncol, byref int pi_nb, object po_uncol)
{
	int		pi_i
	int		pi_pos
	pi_pos = ARR_ObjSearch(&pao_uncol[0] , pi_nb, po_uncol)	
	if ( pi_pos != -1)
	{
		for ( pi_i = pi_pos ; pi_i < pi_nb - 1; pi_i--)
		{
			pao_uncol[ pi_i] = pao_uncol[ pi_i +1] 
		}
		pao_uncol[ pi_nb -1] = nobody
		pi_nb -- 
		return pi_nb
	}
	else
		return 0
}

procedure_local	void KT_Uncol_Add( object po_uncol)
{
	int		pi_pos
	pi_pos = ARR_ObjSearch(&ao_uncol[0] , i_uncol_nb, po_uncol)
	if ( pi_pos == -1)
	{
		ao_uncol[i_uncol_nb ] = po_uncol
		i_uncol_nb++
	}
}

procedure_local	void 	KT_Uncol_Check( )
{
	int		pi_i
	int		pi_pos
	// Clean des acteur qui ne serontplus UNCOL
	for ( pi_i = 0; pi_i < i_uncol_old_nb; pi_i++)
	{
		pi_pos = ARR_ObjSearch(&ao_uncol[0] , i_uncol_old_nb, ao_uncol_old[pi_i])	
		if ( pi_pos == -1)
		{
			// on ne demande plus de uncol avec cet acteur : demander a le rétablir
			if ( !OBJ_LIB_Virtual_Collision(OBJ_Me(), ao_uncol_old[pi_i], faux))
			{
				// Pas de collision virtuelle, on réactive
				COL_UnCollidableDel( ao_uncol_old[pi_i])
				ARR_RemoveGao( &ao_uncol_old[0], i_uncol_old_nb, ao_uncol_old[pi_i])
			}
		}
	}	
	
	// Ajout des nouveaux acteurs UNCOL
	for ( pi_i = 0; pi_i < i_uncol_nb; pi_i++)
	{
		pi_pos = ARR_ObjSearch(&ao_uncol_old[0] , i_uncol_old_nb, ao_uncol[pi_i])	
		if ( pi_pos == -1)
		{
			COL_UnCollidableAdd( ao_uncol[pi_i])
			ao_uncol_old[i_uncol_old_nb] = ao_uncol[pi_i]
			i_uncol_old_nb++
		}		
		ao_uncol[pi_i] = nobody
	}
	i_uncol_nb = 0
}


//ADDED SURESH
//Parameter must be the point of collision of the TREX and the ground/wall.  At this point, a GFX is launched.
procedure_local void KT_GFX_Impact(vector v_collidedPoint) 
{
	
	message m_Msg_GFX
	object to_tete
	int 		mi_GFX_Key
	vector	pv_temp, pv_pos, pv_normal
	object	to_light_n_smoke_K
	
	if(f_global_time - f_throwTime >= f_throw_delay)
	{
		to_tete = ANI_CanalObjectGet(Anim_Canal_Tete)
		m_Msg_GFX.msg_int1 = SFX_ID_TrexImpactOnGround 
		m_Msg_GFX.msg_vec1 =  @to_tete OBJ_PosGet() 
		m_Msg_GFX.msg_vec2 =  v_collidedPoint //COL_CollidedPointGet(COL_C_Wall)
//		Dispatch_Interaction(o_Wall_Effect, m_Msg_GFX)
		f_throwTime = TIME_Get()
		
	

//procedure_local void Proc_KK_SFX_Ring( vector pv_pos, vector pv_normal)
//{

	pv_pos = v_collidedPoint
	pv_normal = -OBJ_SightGet()
	if (WOR_GetKey() == 0xc101fedb || WOR_GetKey() == 0x28000105)
		return
	
	to_light_n_smoke_K = @get_global o_global_light_and_smoke_kanada

	if( ! to_light_n_smoke_K )
		return
	
	mi_GFX_Key = GFX_Add( 13)
		
	GFX_FlagSet( mi_GFX_Key, 0 , 1)
	GFX_FlagSet( mi_GFX_Key, 2 , 1)
		
	GFX_MaterialSet( mi_GFX_Key, to_light_n_smoke_K, -1 )
	GFX_Seti( mi_GFX_Key, 13101, 1)
	
	GFX_Seti( mi_GFX_Key, 13102, 1)
	
	GFX_Seti( mi_GFX_Key, 13100, 50)
	GFX_Seti( mi_GFX_Key, 13106,  35)

	GFX_Setf( mi_GFX_Key, 13003, 0.7)
	GFX_Setf( mi_GFX_Key, 13004, 1.4)
	
	GFX_Setf( mi_GFX_Key, 13012, 0.7)
	
	GFX_Seti( mi_GFX_Key, 13107, 0)
	GFX_Setf( mi_GFX_Key, 13000, 1.0)
	GFX_Setf( mi_GFX_Key, 13001, 3.0)
	GFX_Setf( mi_GFX_Key, 13002, 0.01)	
		
	GFX_Setf( mi_GFX_Key, 13005, 0.1)
	GFX_Setf( mi_GFX_Key, 13006, 0.6)
	GFX_Setf( mi_GFX_Key, 13007, -3.0)
	
	GFX_Setv( mi_GFX_Key, 13203, cvector( 0.012,0.012,0.025))
	
	if ( @get_global SFX_Fumee_Impact_Sol)
	{
		GFX_Seti( mi_GFX_Key, 13103, 0x9D000000 + @get_global SFX_Fumee_Impact_Sol)
		GFX_Seti( mi_GFX_Key, 13104, 0x67000000 + @get_global SFX_Fumee_Impact_Sol)
		GFX_Seti( mi_GFX_Key, 13105, 0x00 + @get_global SFX_Fumee_Impact_Sol)
	}
	else
	{
		GFX_Seti( mi_GFX_Key, 13103, 0x9D93A99F)
		GFX_Seti( mi_GFX_Key, 13104, 0x6782A196)
		GFX_Seti( mi_GFX_Key, 13105, 0x00768D87)
	}
	GFX_Setf( mi_GFX_Key, 13009, -7.0)
	GFX_Setf( mi_GFX_Key, 13010, -9.0)
	
	GFX_Setf( mi_GFX_Key,  13011, -1000.0)
	
	GFX_Setv( mi_GFX_Key, 13200, pv_pos)
								
	GFX_Setv( mi_GFX_Key, 13201, Cv_NullVector )
	GFX_Setv( mi_GFX_Key, 13202, cvector(0.0,0.0, 0.1) )
	
	GFX_Setv( mi_GFX_Key, 13204, Cv_NullVector )
	
	GFX_Setv( mi_GFX_Key, 13205, Cv_NullVector )
	
	GFX_Setv( mi_GFX_Key, 13206, Cv_NullVector)
	
	if ( MATH_VecNull(pv_normal)
	||MATH_VecDotProduct( pv_normal, OBJ_BankingGet()) > Cf_Cos5)
	{
		GFX_Setv( mi_GFX_Key, 13207, OBJ_HorizonGet() )
		GFX_Setv( mi_GFX_Key, 13208, OBJ_SightGet() )
		GFX_Setv( mi_GFX_Key, 13209, 0.1* OBJ_BankingGet() )
	}
	else
	{
		pv_temp = MATH_VecCrossProduct( pv_normal, OBJ_HorizonGet()) 
		GFX_Setv( mi_GFX_Key, 13207, pv_temp)
		GFX_Setv( mi_GFX_Key, 13208, MATH_VecCrossProduct( pv_normal, pv_temp ))
		GFX_Setv( mi_GFX_Key, 13209, 0.1* pv_normal )		
	}
	
	// material rotation and scaling mods
	GFX_Seti( mi_GFX_Key, 13114, 0.0)
	
	GFX_Setf( mi_GFX_Key, 13013, 0.0)
	GFX_Setf( mi_GFX_Key, 13014, 0.0)
	GFX_Setf( mi_GFX_Key, 13015, 0.0)
	GFX_Setf( mi_GFX_Key, 13016, 0.0)
	
	GFX_Setf( mi_GFX_Key, 13008, 0.0)
//}



			
	}
}

procedure_local int KT_Trigger_Charge( float pf_charge_delay)
{
	int		pi_test
	if( i_Kong_Mashing )
		pi_test = vrai
	else if( @o_Kong Proc_KK_Test_Mode(ETAT_Kong_colonne) )
		pi_test = vrai
	else if ( i_Trig_Exec_Charge_Forced)
	{
		o_fight_actor = o_Trig_Exec_Charge_Target
		pi_test = vrai
	}
	else
		pi_test = TIME_Elapsed(f_time_last_charge, pf_charge_delay)
	return	 pi_test
}

procedure_local int KT_PosDansMonTerritoire(vector tv_pos)
{
	int			ti_i
	object	to_zone
	
	for( ti_i = 0; ti_i < Ci_blind_zone_max_nb ; ti_i++ )
	{
		to_zone = ao_blind_zone[ti_i]
		if( to_zone && @to_zone COL_BV_PointCollide(tv_pos) )
			return faux
	}
	
	if( o_perimetre && ! @o_perimetre COL_BV_PointCollide(tv_pos) )
		return faux
	
	return vrai
}

procedure_local int KT_GaoDansMonTerritoire(object to_gao)
{
	return KT_PosDansMonTerritoire(@to_gao OBJ_PosGet())
}


//procedure_local void KT_AFX_Eclairs()
//{
//	i_afx_eclair_phase = 1
//}
//
//procedure_local void KT_SlowMotion(int ti_force)
//{
//	if( ti_force || f_afx_slow_motion_speed == 1.0 )
//	{
//		// force les FX ou teste si le FX n'est pas déjà en cours
//		f_afx_slow_motion_time = 0.0
//		f_afx_slow_motion_speed = 0.05
//	}
//}

//procedure_local void KT_Paf_Effects(int ti_paf_type)
//{
//	if( i_etat_courant != ETAT_JumpAttak )
//	{
//		if( ti_paf_type & C_PAF_KK_Fort )
//		{
//			KT_AFX_Eclairs()
//			KT_SlowMotion(vrai)
//		}
//	}
//}

procedure_local int KT_Pafs_Effects_Check(int ti_paf_type)
{
	if( KT_Proc_RefusePaf() )
		return faux
	if( ! EVENT_LIFE_CurLifeGet(ID_LIFE) )
		return faux
	if( ti_paf_type & C_PAF_KK_Repousse )
		return faux
	if( @o_Kong Proc_KK_RAGE_Test() )
		return vrai
	if( i_etat_courant == ETAT_JumpAttak )
		return faux		// si furie alors FX même en jump attack
	if( ti_paf_type & C_PAF_KK_Fort )
		return vrai		// sauf pour le jump attack
	return faux
}



// STATS ==============================================================
procedure_local void KT_STATS_NMI_Killed(object to_enemy_killed_sender)
{
	if( ! i_stats_nmi_killed_done )
	{
		i_stats_nmi_killed_done = vrai
		STATS_IncEnemyKilled_New(o_Kong, C_EnemyType_Trex, 0 ) 
	}
}

//procedure_local void KT_GFX_Particules(vector tv_pos, vector tv_pos_min, vector tv_pos_max, vector tv_wind)
//{
//	int			pi_GFX_Blood
//	object	to_light_n_smoke
//	
//	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
//	if( ! to_light_n_smoke )
//		return
//	
//	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
//	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
//	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
//	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
//	GFX_Seti(pi_GFX_Blood, 13101, materiau_id)											// Materiau N°
//	GFX_Seti(pi_GFX_Blood, 13100, 100)														// *Buffer number of sprite
//	GFX_Seti(pi_GFX_Blood, 13106, 15)														// *number of sprite to generate
//	GFX_Setf(pi_GFX_Blood, 13003, 0.05)														// Time fase 1
//	GFX_Setf(pi_GFX_Blood, 13004, 0.)														// Time fase 2
//	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
//	GFX_Setf(pi_GFX_Blood, 13012, 0.0)														// Time random
//	GFX_Setf(pi_GFX_Blood, 13000, 0.2)														// Growing speed min
//	GFX_Setf(pi_GFX_Blood, 13001, 0.5)														// Growing speed max
//	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
//	GFX_Setf(pi_GFX_Blood, 13005, 0.1 )														// Creation size min
//	GFX_Setf(pi_GFX_Blood, 13006, 0.2 )														// Creation size max
//	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
//	GFX_Seti(pi_GFX_Blood, 13103, 0x00000000 + materiau_color)					// Color fase 0
//	GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)					// Color fase 1
//	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
//	GFX_Setf(pi_GFX_Blood, 13009, 5)															// Norm speed min
//	GFX_Setf(pi_GFX_Blood, 13010, 10)														// Norm speed max
//	GFX_Setf(pi_GFX_Blood, 13007, -5.0)														// Gravity
//	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
//	GFX_Setv(pi_GFX_Blood, 13204, tv_wind)												// wind
//	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
//	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
//	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
//	GFX_Setv(pi_GFX_Blood, 13201, tv_pos_min)											// Speed min
//	GFX_Setv(pi_GFX_Blood, 13202, tv_pos_max)											// Speed max
//}


procedure_local int KT_Action_Paf_EnCours(int ti_action)
{
	switch( ti_action )
	{
		case Action_Paf_Mur_Petit : 
		case Action_Paf_Mur_Tombe :
		case Action_PAF_Repousse : 
		case Action_Fight_GrabTT_Paf : 
		case Action_PAF_Fort_Dos : 
		case Action_PAF_Fort_Face : 
		case Action_PAF_Fort_Gauche : 
		case Action_PAF_Fort_Droite : 
		case Action_PAF_Moy_Dos : 
		case Action_PAF_Moy_Face : 
		case Action_PAF_Moy_Gauche : 
		case Action_PAF_Moy_Droite : 
		case Action_Paf_au_sol :
		case Action_Paf_au_sol_chute :
		case Action_Paf_au_sol_mort :
		case Action_Paf_Rapide_Agonie_D :
		case Action_Paf_Rapide_Agonie_G :
		case Action_Paf_SeReleve :
		case Action_Paf_SeRelevePAF :
		case Action_Paf_Tombe :
		case Action_PafD :
		case Action_PafG :
			return vrai
		default:
			return faux
	}
}

//=============================================================================================
// Choix de l'action à jouer quand REX se prend un paf
//=============================================================================================
procedure_local void KT_Action_Paf_Select()
{
	int 		ti_paf_action
	float		tf_paf_freq
	
	ti_paf_action = faux
	
	// Translation et rotation
//	f_coef_recul = 0.0
//	GST_PAF_Trans_Rotate( OBJ_PosGet(), OBJ_SightGet(), v_paf_position, v_paf_sens, 8.0, v_add_speed, f_add_rotation)
	
	f_jauge_croutage += Cf_jauge_croutage_palier
	i_contre_attaque_action = Action_Fight_Paf_D_Defense		// anim contre attaque par défaut (il n'y a que 2 cas ou le contre va etre un coup à Droite)
	if ( EVENT_LIFE_CurLifeGet( ID_LIFE) <= 0.0 )
	{
		f_fatigue_time = 5.0
		i_paf_va_se_vautrer = vrai
		SND_RequestPlay(Ci_SND_Paf_Fort)
	}
//	else if( i_finish_repousse_flag )
//	{
//		KT_ActionSetForceFrame0(Action_Fight_GrabTT_Paf)
//	}
	else if( i_paf_type & C_PAF_KK_Projection )
	{
		// REX a pris un paf d'un autre REX qui a été balancé sur lui
		f_fatigue_time = 0.0
		i_paf_va_se_vautrer = vrai
	}
	else if( i_paf_mur_leger )
	{
		i_paf_mur_leger = faux
		KT_ActionSetForceFrame0(Action_Paf_Mur_Petit)
	}
	else if ( i_paf_type & C_PAF_KK_Repousse)
	{
		// Combo ou paf moyen non Kong -> gros recul
		KT_ActionSetForceFrame0(Action_PAF_Repousse)
		ti_paf_action = vrai
		f_jauge_croutage = 0.0
		f_coef_recul = 0.0
//		v_add_speed = v_paf_sens * 15.0
//		f_add_rotation *= 2.0
		i_contre_attaque_action = Action_PAF_Repousse
		SND_RequestPlay(Ci_SND_Paf_Moyen)
	}
	else if( ( i_paf_type & C_PAF_KK_Ecrasement ) || i_finish_repousse_flag )
	{
		i_finish_repousse_flag = faux
		// Combo ou paf moyen non Kong -> gros recul
		KT_ActionSetForceFrame0(Action_Fight_GrabTT_Paf)
		ti_paf_action = vrai
		SND_RequestPlay(Ci_SND_Paf_Fort)
		ANI_CurrentFrameSet(0, 16)
		f_jauge_croutage = 0.0
		f_coef_recul = 0.0
		v_paf_sens = OBJ_PosGet() - @o_paf_actor_memo OBJ_PosGet()
		v_paf_sens.z = 0.0
		if( ! MATH_VecNullEpsilon(v_paf_sens) )
			MATH_VecSetNormalize(v_paf_sens)
		else
			v_paf_sens = OBJ_SightGet()
//		v_add_speed = v_paf_sens * 8.0		//20.0
		i_contre_attaque_action = 0		// pas de contre attaque !!!!
		if( f_stunned_last_delay < 3.0 )
		{
			i_paf_va_se_vautrer = vrai
			i_stunned_paf_ecrase_flag = vrai
		}
	}
	else if( i_paf_type & C_PAF_KK_Fort )
	{
		if( MATH_VecDotProduct(OBJ_SightGet(), v_paf_sens) > Cf_Cos30 )
			KT_ActionSetForceFrame0(Action_PAF_Fort_Dos)
		else if( MATH_VecDotProduct(OBJ_SightGet(), v_paf_sens) < -Cf_Cos45 )
			KT_ActionSetForceFrame0(Action_PAF_Fort_Face)
		else	if( MATH_VecDotProduct(OBJ_HorizonGet(), v_paf_sens) > 0 )
		{
			KT_ActionSetForceFrame0(Action_PAF_Fort_Gauche)
			i_contre_attaque_action = Action_Fight_Paf_G_Defense
		}
		else
			KT_ActionSetForceFrame0(Action_PAF_Fort_Droite)
		ti_paf_action = vrai
		SND_RequestPlay(Ci_SND_Paf_Fort)
	}
	else if( i_paf_type & ( C_PAF_KK_Moyen | C_PAF_KK_Javelin ) )
	{
		if( MATH_VecDotProduct(OBJ_SightGet(), v_paf_sens) > Cf_Cos30 )
			KT_ActionSetForceFrame0(Action_PAF_Moy_Dos)
		else if( MATH_VecDotProduct(OBJ_SightGet(), v_paf_sens) < -Cf_Cos45 )
			KT_ActionSetForceFrame0(Action_PAF_Moy_Face)
		else	if( MATH_VecDotProduct(OBJ_HorizonGet(), v_paf_sens) > 0 )
		{
			KT_ActionSetForceFrame0(Action_PAF_Moy_Gauche)
			i_contre_attaque_action = Action_Fight_Paf_G_Defense
		}
		else
			KT_ActionSetForceFrame0(Action_PAF_Moy_Droite)
		ti_paf_action = vrai
		SND_RequestPlay(Ci_SND_Paf_Moyen)
	}

	// RANDOM FREQ -----------------------------------------------------
	if( ti_paf_action )
	{
		tf_paf_freq = ANI_FrequencyGet(0)
		tf_paf_freq *= MATH_RandFloat(0.9,1.9)		// MIN 0.9 sinon pas le temps de contre-attaquer !!!
		ANI_FrequencySet(0, tf_paf_freq)
//		DBG_TraceFloat(tf_paf_freq)
//		DBG_TraceEOL()
	}
	
	// GFX PARTICULES ----------------------------------------------------
	switch( ACT_ActionGet() )
	{
		case Action_Fight_GrabTT_Paf :
			f_time_gfx_particules = 0.475
			break
		case Action_Paf_Mur_Petit :
		case Action_Paf_Mur_Tombe :
			f_time_gfx_particules = 0.3
			break
		case Action_PAF_Repousse :
			f_time_gfx_particules = 0.0		// pas de FX sang sur le paf repousse
			break
		case Action_PAF_Fort_Dos :
		case Action_PAF_Fort_Droite :
		case Action_PAF_Fort_Face :
		case Action_PAF_Fort_Gauche :
			f_time_gfx_particules = 0.06		// moins de FX sang car y'a les AFX éclairs + slow motion
			break
		default:
//			if( o_ANN && o_paf_actor_memo == o_ANN )
//				f_time_gfx_particules = 0.1
//			else
				f_time_gfx_particules = 0.2
			break
	}
	f_time_gfx_particules_init = f_time_gfx_particules
	v_gfx_particules_pos = Cv_NullVector	// raz pos à chaque paf
}

procedure_local void KT_GFX_Particules_Salive(vector tv_pos, vector tv_pos_min, vector tv_pos_max, vector tv_wind)
{
	int			pi_GFX_Blood
	object	to_light_n_smoke
	color 		materiau_color
	materiau_color = 0x00CCDCFE		// 0x002E2E41
	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
	if( ! to_light_n_smoke )
		return
	
	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 22)														// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13100, 100)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, 8)															// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.07)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 0.25)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.0)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.2)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.5)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.05)														// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.1)														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
	GFX_Seti(pi_GFX_Blood, 13103, 0x00000000 + materiau_color)					// Color fase 0
	if( f_time_gfx_particules > 0.1 )
		GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)				// Color fase 1
	else
		GFX_Seti(pi_GFX_Blood, 13104, 0xAA000000 + materiau_color)				// Color fase 1
//	if( f_time_gfx_particules > (f_time_gfx_particules_init * 0.66) )
//		GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)				// Color fase 1
//	else if( f_time_gfx_particules > (f_time_gfx_particules_init * 0.33) )
//		GFX_Seti(pi_GFX_Blood, 13104, 0xCC000000 + materiau_color)				// Color fase 1
//	else
//		GFX_Seti(pi_GFX_Blood, 13104, 0x88000000 + materiau_color)				// Color fase 1
	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 3)															// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 6)															// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -5.0)														// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, tv_wind)												// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13201, tv_pos_min)											// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, tv_pos_max)											// Speed max
}

procedure_local void KT_GFX_Particules(vector tv_pos, vector tv_paf_dir) 
{
	int			pi_GFX_Blood
	vector	tv_lat2_axis, tv_lat_axis 
	object	to_light_n_smoke
	color		materiau_color
	
	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
	if( ! to_light_n_smoke )
		return

// 	materiau_color = 0x0071837D		// OLD
//	materiau_color = 0x00474A5E		// RAPTOR
//	materiau_color = 0x009CAAB6		// BIDE TREX
	materiau_color = 0x00565652		// PEAU TREX
	tv_lat_axis = MATH_VecCrossProduct(tv_paf_dir, Cv_VerticalVector)
	tv_lat2_axis = MATH_VecCrossProduct(tv_paf_dir, tv_lat_axis)
	
	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 22)															// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13110, 10)															// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13100, 20)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, 20)														// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.08)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 0.4)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.0)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.1)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.5)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.2 )						 								// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.4 )														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
	GFX_Seti(pi_GFX_Blood, 13103, 0xF0000000 + materiau_color)					// Color fase 0
	GFX_Seti(pi_GFX_Blood, 13104, 0xF0000000 + materiau_color)					// Color fase 1
	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 5)															// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 15)														// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -10.0)														// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, tv_paf_dir)												// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13201, tv_paf_dir + (tv_lat_axis * 0.2) + (tv_lat2_axis * 0.2) )					// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, (tv_paf_dir * 5.0) - (tv_lat_axis * 1.2 ) - (tv_lat2_axis * 1.2 ) )											// Speed max
}

procedure_local int KT_Action_Depl_EnCours()
{
	switch( ACT_ActionGet() )
	{
		case Action_Blesse_Marche :
		case Action_Normal_Marche_Rapide :
			return vrai
		default:
			return faux
	}
}



//======================================================================
// CADAVRES & FOOD-CHAIN
//======================================================================
procedure_local int KT_Cadavre_Nouveau_Test(object to_actor)
{
	int				ti_indice
	ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
	if( ti_indice != -1 && ai_cadavre_nouveau[ti_indice] )
		return vrai
	else
		return faux
}
procedure_local int KT_Cadavre_Find(object to_actor)
{
	int		ti_indice
	ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
	if( ti_indice != -1 )
		return vrai
	else
		return faux
}
procedure_local void KT_Cadavre_Add(object to_actor)
{
	if( i_cadavre_nb < Ci_cadavre_max_nb )
	{
		if( ! KT_Cadavre_Find(to_actor) )
		{
			ao_cadavre[i_cadavre_nb] = to_actor
			ai_cadavre_nouveau[i_cadavre_nb] = vrai
			i_cadavre_nb++
		}
	}
}
procedure_local void KT_Cadavre_Del(object to_actor)
{
	int		ti_indice
	int		ti_k	
	if( to_actor )
	{
		ti_indice = ARR_ObjSearch(&ao_cadavre[0], i_cadavre_nb, to_actor)
		if( ti_indice != -1 )
		{
			for(ti_k = ti_indice; ti_k < i_cadavre_nb; ti_k++)
			{
				ao_cadavre[ti_k] = ao_cadavre[ti_k + 1]
				ai_cadavre_nouveau[ti_k] = ai_cadavre_nouveau[ti_k + 1]
			}
			i_cadavre_nb--
		}
	}
}
procedure_local int KT_Cadavre_Test(object to_actor, messageid tmid_cadavre)
{
	int			ti_ID
	ti_ID = EVENT_CadavreIDGet(tmid_cadavre)
	if( IsThis_ID_Humain(ti_ID) )
		return faux		// pas les humains
	else if( ti_ID == C_ID_Tyranosaure )
		return faux		// pas ceux de mon espèce
	else if( @to_actor AI_IsModel(get_PNJ_Bidoche_path) )
		return faux
	else if( @to_actor AI_IsModel(get_OBJ_Cadavre_path) )
		return faux		// c'est un cadavre fake
	else if( @to_actor AI_IsModel(get_KCadavre_path) )
		return faux		// c'est un cadavre fake
	else
		return vrai		// ce n'est pas un cadavre fake
}
procedure_local object KT_Cadavre_Nearest(int ti_nouveau)
{
	object		to_obj
	object		to_best_obj
	int				ti_i
	float			tf_dist
	float			tf_best_dist
	to_best_obj = nobody
	tf_best_dist = Cf_Infinit
	if( i_cadavre_nb )
	{
		for( ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
		{
			if( ! ti_nouveau || ai_cadavre_nouveau[ti_i] )
			{
				to_obj = ao_cadavre[ti_i]
				if( to_obj && KT_GaoDansMonTerritoire(to_obj) )		// sécurité : peut avoir été déplacé hors de mon territoire depuis l'ajout
				{
					tf_dist = OBJ_SqrDist(to_obj)
					if( tf_dist < tf_best_dist )
					{
						tf_best_dist = tf_dist
						to_best_obj = to_obj
					}
				}
			}
		}
	}
	return to_best_obj
}
procedure_local void KT_Cadavre_Memory_Display()
{
	int		ti_i
	vector	tv_pos
	tv_pos = Cv_NullVector
	for (ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
	{
		Str_DisplayGaoOnce(ao_cadavre[ti_i], tv_pos + (ti_i * cvector(0,0.05,0)))
	}
}
procedure_local void KT_Cadavre_Check()
{
	object		to_obj
	object		to_best_obj
	int				ti_i
	float			tf_dist
	float			tf_best_dist
	messageid		tmid_cadavre
	for( ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
	{
		to_obj = ao_cadavre[ti_i]
		tmid_cadavre = EVENT_FindEventPereTarget(C_EVENT_TYPE_Cadavre, to_obj, nobody)
		if( ! MSG_GlobalIsValid(tmid_cadavre) )
		{
			KT_Cadavre_Del(to_obj)
		}
	}
}
procedure_local void KT_Cadavre_Check_New()
{
	int		ti_i	
	int		ti_index
	int		ti_flag_del_body
	for (ti_i = 0; ti_i < i_cadavre_nb; ti_i++)
	{
		if ((@ao_cadavre[ti_i] AI_IsModel(get_PNJ_Bidoche_path)) && (@ao_cadavre[ti_i] OBJ_CapaTest(CAPA_Bidoche_Oublie_Moi)) )
			ai_cadavre_nouveau[ti_i] = vrai
	}
}



//======================================================================
// IK (import from Jack's TREX)
//======================================================================
procedure_local vector KT_Body_Speed_Rotate()
{
	vector		tv_start_axis
	vector		tv_dest_axis

	v_IK_bassin_banking = OBJ_BankingGet()
	
	f_body_rot_coef -= MATH_FloatSign(f_body_rot_coef) * MATH_FloatMin(MATH_AbsFloat(f_body_rot_coef), 2.0 * TIME_GetDt())
	
	v_IK_ref_ground_pos = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(OBJ_PosGet() - @ao_head_bones[i_head_bone_nb] OBJ_PosGet())
	
	tv_start_axis = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(OBJ_BankingGet())
	tv_dest_axis = MATH_VecBlendRotate(tv_start_axis, @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(MATH_FloatSign(f_body_rot_coef) * OBJ_HorizonGet()), MATH_AbsFloat(f_body_rot_coef) * 0.3)
	@ao_head_bones[i_head_bone_nb] OBJ_Rotate_FromTo(tv_start_axis, tv_dest_axis)

	v_IK_ref_ground_pos = @ao_head_bones[i_head_bone_nb] MATH_VecLocalToGlobal(v_IK_ref_ground_pos)
	v_IK_ref_ground_pos += @ao_head_bones[i_head_bone_nb] OBJ_PosGet()
	
	return(@ao_head_bones[i_head_bone_nb] MATH_VecLocalToGlobal(tv_dest_axis))
}
procedure_local void KT_Reset_IK_Legs()
{
	int			ti_i	

	// IK LEG
//	v_grav_last_speed = Cv_NullVector	
//
//	v_grav_last_pos = OBJ_PosGet()
//	v_grav_last_pos.z -= Cf_pendule_length
	
	f_bassin_rotation_angle = 0.0
	f_bassin_Z_offset = 0.0

	v_IK_bassin_pos = @ao_head_bones[i_head_bone_nb] OBJ_PosGet()

	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		i_flag_leg_IK[ti_i] = faux

		f_IK_Z_offset[ti_i] = 0.0
		f_IK_coef[ti_i] = 0.0
		f_IK_tenseur[ti_i] = 0.5

		f_IK_bassin_look_rot_coef = 0.0

		v_IK_ref_ground_pos = OBJ_PosGet()

		v_IK_dest_pos[ti_i] = @ao_IK_bones[ti_i][3] OBJ_PosGet()
		v_IK_local_offset[ti_i] = MATH_VecGlobalToLocal(v_IK_dest_pos[ti_i] - OBJ_PosGet())
	}
}
procedure_local void KT_Reset_IK_Neck()
{
	// PILOTAGE ET IK TETE
	i_flag_look = faux
//	i_flag_look_best_interet = faux

	f_look_blend_coef = 0.0
	f_look_angle_blend_speed = 0.0
	f_look_head_coef = 0.0

	v_look_axis = OBJ_SightGet() * f_look_axis_length
}
procedure_local void KT_Reset_IK()
{
	KT_Reset_IK_Legs()
	KT_Reset_IK_Neck()
}
procedure_local float KT_Get_Move_Coef(int ti_leg)
{
	return 0.75		// en mouvement
}




procedure_local int KT_Target_Check(object to_target)
{
	messageid		tmid_vision_ID
	
	if( ! to_target )
		return faux
	
	if( o_ignore_target && to_target == o_ignore_target )
		return faux
	
	if( ! KT_GaoDansMonTerritoire(to_target) )
		return faux
	
	tmid_vision_ID = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_target, nobody)
	if( ! MSG_GlobalIsValid(tmid_vision_ID) )
		return faux
	
	return vrai
}


procedure_local void KT_Add_Paf_Feedback(messageid tmid_paf_event)
{
	switch(i_etat_courant)
	{
		case ETAT_KO_au_sol :
		case ETAT_mort :
			if (TIME_Elapsed(f_visual_paf_time, 0.5))
			{
				f_visual_paf_time = TIME_Get()
				v_visual_paf_dir = MATH_VecBlendRotate(EVENT_PafDirGet(tmid_paf_event), Cv_VerticalVector, 0.5) * 2.0
			}
			break

		default:
			if( TIME_Elapsed(f_visual_paf_time, 0.5) )
			{
				f_visual_paf_time = TIME_Get()
				v_visual_paf_dir = EVENT_PafDirGet(tmid_paf_event)
			}
			break
	}
	
	if( TIME_Elapsed(f_quat_last_time, 0.15) )
	{
		if (TIME_Elapsed(f_quat_last_time, 0.5))
			af_quat_coef[i_quat_index] = 0.2
		else
			af_quat_coef[i_quat_index] = 0.1
			
		f_quat_last_time = TIME_Get()
		af_quat_time[i_quat_index] = f_quat_last_time

		av_quat_start[i_quat_index] = EVENT_PafPositionGet(tmid_paf_event)
		av_quat_start[i_quat_index] -= @ao_head_bones[i_head_bone_nb] OBJ_PosGet()
		MATH_VecSetNormalize(av_quat_start[i_quat_index])

		av_quat_end[i_quat_index] = MATH_VecCrossProduct(EVENT_PafDirGet(tmid_paf_event), av_quat_start[i_quat_index])
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(av_quat_start[i_quat_index], av_quat_end[i_quat_index])

		switch(i_etat_courant)
		{
			case ETAT_KO_au_sol :
			case ETAT_mort :	
				MATH_VecSetHorzNormalize(av_quat_end[i_quat_index])
				break

			default:
				MATH_VecSetNormalize(av_quat_end[i_quat_index])
		}
		i_quat_index = MATH_Modulo(i_quat_index + 1, 10)
	}
}
