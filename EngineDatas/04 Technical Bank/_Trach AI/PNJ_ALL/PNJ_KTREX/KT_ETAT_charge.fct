#include "KT_defines.var"

#define		Cf_dist_detect_vide							20.0

int				ti_trame
int				ti_col
int				ti_frame
int				ti_tiptop_ok
int				ti_charge_action
int				ti_trace_charge
int				ti_type_paf
float			tf_puis

float			tf_interet
float			tf_dist_col
float			tf_dist_actor
float			tf_dot
float			tf_rotation_coef
float			tf_speed

vector		tv_charge_sight
vector		tv_charge_end_pos
vector		tv_sens_paf
vector		tv_sens_collision
vector		tv_temp
vector		tv_perfect_sight
vector		tv_new_sight
vector		tv_new_sight_res_loc
vector		tv_pos

object		to_tete
object		to_col_ray_object
object		to_col_wall_object
object		to_obj
object		to_bone

messageid		tmid_vision

//if( i_Kong_Mashing )
//	ti_trace_charge = vrai
//else
	ti_trace_charge = faux


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux	
	o_charge_actor = nobody
	COL_ColSetActivationSet( none, C_bit_zde_fight)
	f_time_last_charge = TIME_Get()
	if( ti_trace_charge )
	{
		DBG_TraceString("=== FIN DE LA CHARGE ===")
		DBG_TraceEOL()
	}
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_charge)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_charge

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	COL_ColSetActivationSet(C_bit_zde_fight, none)
	i_fight_paf = faux
	SND_RequestPlay(6)
	ACT_ActionSet(Action_Normal_Charge)
	f_time_start_etat = 0.0
	i_charge_mode = Ci_charge_en_cours
	v_charge_stop_vector = Cv_NullVector
	o_fury_actor = nobody
	i_charge_paf_KONG = faux
	f_orientation_coef = 8.0
	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux	
	i_paf_nb = 0
	i_derap_detect_fury = faux
	
	if( ti_trace_charge )
	{
		DBG_TraceString("=== DEBUT DE LA CHARGE ===")
		DBG_TraceEOL()
	}
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE ======================================================

o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	macro_change_etat("KT_ETAT_Grabbed_by_Kong")

// Detection du vide ================================================
macro_checkchute


// DETECT PAF ===================================================
AI_Execute("KT_exec_check_paf")
if (o_paf_actor)
{
	if( ti_trace_charge )
	{
		DBG_TraceString("paffé => stoppe charge ")
		DBG_TraceEOL()
	}
	macro_change_etat("KT_ETAT_paf")
}

// Jack fait diversion
//Macro_Check_Paf_Jauge_Crier

// DETECT FURY =================================================
if( o_fury_check_actor )
{
	// TEST FURY CANCEL (CHARGE + ATTAQUE)
	o_fury_actor = o_fury_check_actor
	KT_Charge_Freine_Mur()
	i_cri_filtre |= Ci_CRI_PAS_D_ATTENTE_BLESSE
	i_derap_detect_fury = vrai
	if( ti_trace_charge )
	{
		DBG_TraceString("Kong passe en furie => stoppe charge")
		DBG_TraceEOL()
	}
}

// INTERET ========================================================
KT_Interet_Update(o_fight_actor, C_EVENT_InteretStatusCharge)	// charge en cours


if( i_charge_mode == Ci_charge_en_cours )
{
	// TEST KONG EN MAUVAISE POSTURE ===========================================================
	if( o_fight_actor == o_Kong && @o_fight_actor Proc_KK_IsInBadSituation(C_ID_Tyranosaure) )
	{
		o_fury_actor = o_fight_actor
		KT_Charge_Freine_Mur()
		if( ti_trace_charge )
		{
			DBG_TraceString("Cible en finish => stoppe charge puis crie ensuite")
			DBG_TraceEOL()
		}
		goto FIN
	}

	// TEST CHARGE RATEE ==========================================
	tv_temp = MATH_VecNormalize(@o_charge_actor OBJ_PosGet() - OBJ_PosGet())
	tf_dot = MATH_VecDotProduct(OBJ_SightGet(), tv_temp)
	if( o_charge_actor && ( tf_dot < Cf_Cos75 ) && (ACT_ActionGet() == Action_Normal_Charge) && (f_time_start_etat > 0.5) && ! i_Kong_Mashing )
	{
		// L'attaque de REX a été esquivée -> frein avec collisions murs possibles
		KT_Charge_Freine_Mur()
		if( ti_trace_charge )
		{
			DBG_TraceString("KONG a esquivé mon attaque => stoppe charge ")
			DBG_TraceEOL()
		}
		goto FIN
	}

	// TEST KONG PAFFE ============================================
	if( i_charge_paf_KONG )
	{
		// j'ai paffé KONG en exec zdf zdc
		o_fury_actor = o_Kong
		KT_Charge_Freine_Mur()
		if( ti_trace_charge )
		{
			DBG_TraceString("j'ai paffé KONG (zdf / zdc) => stoppe charge ")
			DBG_TraceEOL()
		}
		goto FIN
	}
	else
	{
		// je n'ai pas encore paffé KONG
		to_col_wall_object = KT_Test_collision_Mur_LRAY_COL( vrai, vrai, OBJ_SightGet(), tv_sens_collision, v_collision_point)
		if( i_charge_paf_KONG )
		{
			// Je viens de paffer KONG en collision
			KT_Charge_Freine_Mur()
			if( ti_trace_charge )
			{
				DBG_TraceString("j'ai paffé KONG (collision) => stoppe charge ")
				DBG_TraceEOL()
			}
			if( @o_Kong Proc_KK_RefusePaf() )
			{
				i_charge_paf_KONG = faux
				o_fury_actor = nobody
				if( ti_trace_charge )
				{
					DBG_TraceString("******** KONG a refusé mon paf !!!???? *********")
					DBG_TraceEOL()
				}
			}
			else
			{
				o_fury_actor = o_Kong
				KT_Init_Paf_Charge( tv_sens_paf, ti_type_paf, tf_puis, i_charge_paf_KONG, v_charge_stop_vector )
				if( @to_col_wall_object AI_IsModel(get_KMashing_Object_path) )
					if( @to_col_wall_object COL_BV_PointCollide(@o_Kong OBJ_PosGet()) )
						to_col_wall_object = o_Kong
				EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type_paf, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_col_wall_object, -1, tf_puis, tv_sens_paf, COL_ZonePosGet(C_zde_fight))
			}
			goto FIN
		}
	}

	// TEST CIBLE TOUJOURS DANS PERIMETRE ========================
	if( ! KT_GaoDansMonTerritoire(o_charge_actor) )
	{
		KT_Charge_Freine_Mur()
		if( ti_trace_charge )
		{
			DBG_TraceString("KONG est sorti de mon périmètre => stoppe charge")
			DBG_TraceEOL()
		}
		goto FIN
	}

	// DETECT VIDE ==============================================
	tv_charge_sight = OBJ_SightGet()
	tv_charge_sight.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_charge_sight) )
		MATH_VecSetNormalize(tv_charge_sight)
	else
		tv_charge_sight = OBJ_SightGet()
	tv_charge_end_pos = COL_TipTopPointGet(tv_charge_sight, 0.0, faux, faux, faux, vrai)
	DBG_RenderVector(OBJ_PosGet(), tv_charge_end_pos - OBJ_PosGet(), color_jaune)
	tf_dist_col = MATH_VecNorm(tv_charge_end_pos - OBJ_PosGet())
	if( (MATH_VecDotProduct(OBJ_SightGet(), COL_RayObject_EdgeNormalGet()) > 0) && (tf_dist_col <= Cf_dist_detect_vide) )
	{
		// il y a un vide devant REX et il est suffisament proche pour que REX décide de s'arrêter
		to_col_ray_object = nobody
		to_col_ray_object = COL_RayObject_Dist( OBJ_PosGet() + cvector(0,0,1) , OBJ_SightGet(), Cf_dist_detect_vide, all, OBJ_C_IdentityFlag_AI + OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable )
		if( ! to_col_ray_object || (MATH_VecNorm(COL_RayObject_PosGet() - OBJ_PosGet()) > tf_dist_col) )
		{
			// un vide est détecté, et 
				// - il n'y a pas de mur (devant ou derrière le vide)
				// - ou le vide n'est pas derrière le mur
			to_col_ray_object = nobody
			to_col_ray_object = COL_RayObject_Dist( OBJ_PosGet() + cvector(0,0,2) , OBJ_SightGet(), Cf_dist_detect_vide, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable )
			if( ! i_Kong_Mashing )
			{
				if( ! to_col_ray_object || to_col_ray_object != o_Kong )
				{
					KT_Charge_Freine_Mur()
					if( ti_trace_charge )
					{
						DBG_TraceString("il y a du vide => stoppe charge")
						DBG_TraceEOL()
					}
				}
			}
		}
	}
}

FIN:

// REGARD ==============================================================================
i_flag_look = vrai
v_look_pos = KT_GetActorPosToLook(o_charge_actor)


// MODE DE CHARGE =======================================================================
ti_charge_action = Action_Normal_Charge
to_col_wall_object = nobody
switch ( i_charge_mode )
{
	case Ci_charge_en_cours :
		// CHARGE EN COURS ===================================================================
		
		@o_Kong Proc_KK_RAGE_Speed()

		v_orientation_sens = @o_charge_actor OBJ_PosGet() - OBJ_PosGet()
		if( f_time_start_etat < 0.5 )
			f_orientation_coef = MATH_FloatBlend(f_orientation_coef, 5.0, 10 * TIME_GetDt())
		else
			f_orientation_coef = MATH_FloatBlend(f_orientation_coef, 0.5, 10 * TIME_GetDt())
		
		// en charge, le TRex peut paffer plusieurs fois (pas de test if( ! i_fight_paf ) )
		COL_ColSetActivationSet(C_bit_zde_fight, none)
		i_flag_zde_fight_type = Ci_zde_fight_type_charge
		AI_Execute("KT_exec_zdf_zdc")
		COL_ColSetActivationSet(none, C_bit_zde_fight)
		
		// murs ???? ---------------------------
		to_col_wall_object = KT_Test_collision_Mur_LRAY_COL( vrai, vrai, OBJ_SightGet(), tv_sens_collision, v_collision_point)
		break

	case Ci_charge_stoppee :
		// CHARGE TERMINEE =====================================================================
//		v_orientation_sens = OBJ_SightGet()
//		f_orientation_coef = MATH_FloatBlend(f_orientation_coef, 0.5, 10 * TIME_GetDt())
//		switch ( ACT_ActionGet() )
//		{
//			case Action_Normal_ChargeDerap :
//				if( ACT_ActionFinished() )
//				{
//					macro_change_etat("KT_ETAT_attente")
//				}
//				break
//				
//			default: 
//				KT_Charge_Freine_Mur()
//				break
//				
//		}
		if ( i_charge_paf_KONG )
			KT_Uncol_Add( o_charge_actor)
//		if ( i_mode == Ci_mode_follow_Ann )
//			macro_change_etat("KT_ETAT_fight_ANN")
//		else
			macro_change_etat("KT_ETAT_derap")
		break
}


// RESULTAT COLLISIONS MURS ======================================================================
//if( to_col_wall_object && ( to_col_wall_object == o_Kong || to_col_wall_object == o_ANN ) )
if( to_col_wall_object && ( to_col_wall_object == o_Kong || to_col_wall_object == o_Jack ) )
{
	to_col_wall_object = nobody			// KONG ne compte pas comem un mur (mais les autres REX si)
}
if( to_col_wall_object )
{
	if( ! i_Kong_Mashing )
	{
		// REX se bugne dans un mur
		
		// VERIF que le paf a été bien envoyé
		tv_sens_paf = DYN_SpeedGetVector()
		tv_sens_paf.z = 0.0
		if ( ! MATH_VecNullEpsilon( tv_sens_paf) )
			MATH_VecSetNormalize(tv_sens_paf)
		else
			tv_sens_paf = OBJ_SightGet()		// Le moins pire
		
		if( ARR_ObjSearch( &ao_paf_list[0], i_paf_nb, to_col_wall_object) == -1 )
		{
			KT_Init_Paf_Charge( tv_sens_paf, ti_type_paf, tf_puis, faux, v_charge_stop_vector )
			EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type_paf, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_col_wall_object, -1, tf_puis, tv_sens_paf, COL_ZonePosGet( C_zde_fight))
		}
		
		if( KT_Test_collision_Mur_Prend_Paf(to_col_wall_object) )
		{
	//		if( ti_trace_charge )
	//		{
	//			DBG_TraceString("(charge_en_cours OU wall_on) + mur + vitesse => KO au sol")
	//			DBG_TraceEOL()
	//			DBG_TraceString("mur = ")
	//			DBG_TraceObject(to_col_wall_object)
	//			DBG_TraceEOL()
	//		}
			if( KT_Paf_Mur_Allowed())
			{
				KT_GFX_Impact(v_collision_point)
				
				f_delay_last_paf_mur = 0.0
				if( ! @o_Kong Proc_KK_Test_Mode( ETAT_Kong_colonne))
					EVENT_LIFE_LifeChange(ID_LIFE, Cf_PAF_Charge_Mur)
		//		KT_Paf_Effects(C_PAF_KK_Fort)
				f_coef_recul = 0.0
				GST_PAF_Trans_Rotate( OBJ_PosGet(), OBJ_SightGet(), Cv_NullVector, tv_sens_collision, 15.0, v_add_speed, f_add_rotation)	
			//	f_fatigue_time += Cf_fatigue_add_paf_wall
			
	//			to_bone = ANI_CanalObjectGet(Anim_Canal_Tete)
	//			KT_GFX_Particules(@to_bone OBJ_PosGet(), - OBJ_SightGet())
				
				
	//			f_time_gfx_particules = Cf_time_gfx_particules
				if ( EVENT_LIFE_CurLifeGet( ID_LIFE) <= 0.0 )
				{
					i_paf_mur_align = vrai
					
					f_fatigue_time = 5.0
					macro_change_etat("KT_ETAT_KO_au_sol")
				}
				else
				{
					i_paf_mur_leger = vrai
					v_paf_sens = - tv_sens_paf
					o_paf_actor = o_fight_actor
					macro_change_etat("KT_ETAT_paf")
				}
			}
			else
			{
				KT_Charge_Freine_Mur()
				if( ti_trace_charge )
				{
					DBG_TraceString("détection d'un mur et paf mur interdit => stoppe charge")
					DBG_TraceEOL()
				}
			}
		}
	}
}


// ORIENTATION ============================================
KT_OrientationFinaleSet()

