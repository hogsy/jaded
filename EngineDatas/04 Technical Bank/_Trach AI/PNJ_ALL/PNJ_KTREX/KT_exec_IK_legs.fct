#include "KT_defines.var"

int			ti_i
int			ti_frame_num
int			ti_flag_freeze_bone[2]
int			tai_flag_smoke[2]
int			ti_flag_collision
int			ti_k

float		tf_sign
float		tf_dot_product
float		tf_angle
float		tf_offset
float		tf_bassin_offset
float		tf_bassin_offset_min
float		tf_norm
float		tf_X
float		tf_Y
float		tf_coef
float		tf_IK_coef
float		tf_size_coef
float		tf_dt
float		tf_coef_min
float		tf_coef_max
float		tf_ray_start_offset
float		tf_target_coef

vector	tv_pied_pos
vector	tv_collide_pos
vector	tv_flexion_dir
vector	tv_ray_dir
vector	tv_last_pos
vector	tv_start_axis
vector	tv_dest_axis
vector	tv_ray_normale
vector	tv_bassin_dest_pos
vector	tv_dest_pos
vector	tv_X
vector	tv_Y
vector	tv_temp
vector	tv_rot_pivot_pos
vector	tv_look_axis
vector	tv_virtual_banking
vector	tv_ik_1st_bone_dir[2]
vector	tv_ik_2nd_bone_dir[2]
vector	tv_ray_start
vector	tv_virtual_sight

object	to_bassin
object	to_torse
object	to_epaule_droite
object	to_epaule_gauche                                                           
object	to_bone

#define Cf_offset_min						-4.0
#define Cf_offset_max						2.0
#define Cf_walk_Z_blend_speed			12.0


// ROTATION EN FONCTION DE LA VITESSE ==================================================================
v_IK_ref_ground_pos = OBJ_PosGet()

tv_virtual_banking = KT_Body_Speed_Rotate()
tv_ray_dir = tv_virtual_banking

if (@get_global i_IK_LEG_Off)
{
	KT_Reset_IK_Legs()
	return
}

if (OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Culled && i_etat_courant != ETAT_attaque && ACT_ActionGet() != Action_Fight_Attak_Humain && ACT_ActionGet() != Action_Fight_Attak_FPS )
{
	KT_Reset_IK_Legs()
	return
}

if (i_frame_nb < 10)
	tf_dt = 1000.0
else
	tf_dt = TIME_GetDt()

tai_flag_smoke[0] = faux
tai_flag_smoke[1] = faux


tf_size_coef = 2.5
tf_bassin_offset_min = -3.0

tf_coef_min	 = 0.15
tf_coef_max = 0.33
tf_ray_start_offset = 3.0

tv_ik_1st_bone_dir[Ci_IK_pied_gauche] = -@ao_IK_bones[Ci_IK_pied_gauche][0] OBJ_SightGet()
tv_ik_2nd_bone_dir[Ci_IK_pied_gauche] = @ao_IK_bones[Ci_IK_pied_gauche][2] OBJ_SightGet()

tv_ik_1st_bone_dir[Ci_IK_pied_droit] = -@ao_IK_bones[Ci_IK_pied_droit][0] OBJ_SightGet()
tv_ik_2nd_bone_dir[Ci_IK_pied_droit] = @ao_IK_bones[Ci_IK_pied_droit][2] OBJ_SightGet()


// EST-CE QU'ON S'ADAPTE AU RELIEF DU SOL ??? =============================================================
tf_bassin_offset = 0.0

for (ti_i = 0; ti_i < 2; ti_i++)
{
	if( ! i_flag_leg_IK[ti_i] && ! f_IK_coef[ti_i] )
		continue

	tf_coef = KT_Get_Move_Coef(ti_i)
	
	if (f_IK_coef[ti_i] == 1.0 && tf_coef != -1.0)
	{
		if (tf_coef < 0.5) 
		{
			// Le pied décole
			tf_coef /= 0.5
		
			f_IK_snap_coef[ti_i]	= 1.0 - tf_coef
			f_IK_ground_coef[ti_i] = 1.0 - tf_coef
		
			tv_pied_pos = v_IK_ground_pos[ti_i] 
			tv_pied_pos += MATH_VecDotProduct(@ao_IK_bones[ti_i][3] OBJ_PosGet() - tv_pied_pos, tv_ray_dir) * tv_ray_dir
	
			tv_pied_pos = MATH_VecBlendRotate(tv_pied_pos - OBJ_PosGet(), @ao_IK_bones[ti_i][3] OBJ_PosGet() - OBJ_PosGet(), tf_coef)
			tv_pied_pos += OBJ_PosGet()
	
			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][3] OBJ_SightGet() // MATH_VecBlend(v_IK_bone_last_valid_sight[ti_i], @ao_IK_bones[ti_i][3] OBJ_SightGet(), tf_coef)
			v_IK_bone_last_valid_banking[ti_i] = MATH_VecBlend(v_IK_bone_last_valid_banking[ti_i],  @ao_IK_bones[ti_i][3] OBJ_BankingGet(), tf_coef)
		}
		else if (tf_coef < 1.0)
		{
			// Le pied est en mouvement
			f_IK_snap_coef[ti_i] = 0.0
		
			f_IK_ground_coef[ti_i] = MATH_FloatMax(tf_coef - 0.8, 0.0) / 0.2
	
			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][3] OBJ_SightGet()
			v_IK_bone_last_valid_banking[ti_i] = @ao_IK_bones[ti_i][3] OBJ_BankingGet()
	
			tv_pied_pos = @ao_IK_bones[ti_i][3] OBJ_PosGet()
		}
		else 
		{
			// Le pied est posé
	//			f_feet_contact_duration[ti_i] += tf_dt
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 6.0 * tf_dt)
		
			if (f_IK_snap_coef[ti_i] == 1.0)
			{
				// OK, on a sauvé la position ou le pied a été posé
				v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][3] OBJ_SightGet()
				v_IK_bone_last_valid_banking[ti_i] = MATH_VecInCone(v_IK_bone_last_valid_banking[ti_i], @ao_IK_bones[ti_i][3] OBJ_BankingGet(), Cf_PiBy4, 1)
		
				tv_pied_pos = v_IK_ground_pos[ti_i] 
				tv_pied_pos += MATH_VecDotProduct(@ao_IK_bones[ti_i][3] OBJ_PosGet() - tv_pied_pos, tv_ray_dir) * tv_ray_dir
				
	//				DBG_RenderVector(tv_pied_pos, Cv_VerticalVector * 100.0, color_jaune)
			}
			else
			{
				// Première trame ou le pied est posé
				f_IK_snap_coef[ti_i] = 1.0	
			
				v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][3] OBJ_SightGet()
				v_IK_bone_last_valid_banking[ti_i] = @ao_IK_bones[ti_i][3] OBJ_BankingGet()
	
				tv_pied_pos = @ao_IK_bones[ti_i][3] OBJ_PosGet()
				
				tai_flag_smoke[ti_i] = vrai
			}
		}
	}
	else
	{
		f_IK_snap_coef[ti_i] -= MATH_FloatMin(f_IK_snap_coef[ti_i], 6.0 * tf_dt)	

		if (f_IK_snap_coef[ti_i])
		{
//			f_feet_contact_duration[ti_i] = 0.0
		
			tf_coef = f_IK_snap_coef[ti_i]
			f_IK_ground_coef[ti_i] = 1.0 - tf_coef
		
			tv_pied_pos = v_IK_ground_pos[ti_i] 
			tv_pied_pos += MATH_VecDotProduct(@ao_IK_bones[ti_i][3] OBJ_PosGet() - tv_pied_pos, tv_ray_dir) * tv_ray_dir

			tv_pied_pos = MATH_VecBlendRotate(tv_pied_pos - OBJ_PosGet(), @ao_IK_bones[ti_i][3] OBJ_PosGet() - OBJ_PosGet(), tf_coef)
			tv_pied_pos += OBJ_PosGet()

			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][3] OBJ_SightGet() // MATH_VecBlend(v_IK_bone_last_valid_sight[ti_i], @ao_IK_bones[ti_i][3] OBJ_SightGet(), tf_coef)
			v_IK_bone_last_valid_banking[ti_i] = MATH_VecBlend(v_IK_bone_last_valid_banking[ti_i],  @ao_IK_bones[ti_i][3] OBJ_BankingGet(), tf_coef)
		}
		else
		{
//			f_feet_contact_duration[ti_i] = 0.0
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 6.0 * tf_dt)
		
			v_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][3] OBJ_SightGet()
			v_IK_bone_last_valid_banking[ti_i] = @ao_IK_bones[ti_i][3] OBJ_BankingGet()
	
			tv_pied_pos = @ao_IK_bones[ti_i][3] OBJ_PosGet()
		}
	}

	tv_ray_start = tv_pied_pos
	tv_ray_start -= MATH_VecDotProduct(tv_ray_start - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_ray_dir) * tv_ray_dir

	ti_flag_collision = faux

	if (@get_global i_IK_LEG_Target)
	{
		if (COL_RayObject_Dist(tv_ray_start, -tv_ray_dir, f_IK_leg_length[ti_i], all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel))
			ti_flag_collision = vrai
	}
	else
	{
		@get_global i_raptor_ray_on_colmap_nb++
		if (COL_RayObject_Dist(tv_ray_start, -tv_ray_dir, f_IK_leg_length[ti_i], all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
			ti_flag_collision = vrai
	}
	

	if (ti_flag_collision)
	{
		// OK ON TOUCHE UN SOL, ON VA POUVOIR POSITIONNER EN IK ==============================================
		tv_collide_pos = COL_RayObject_PosGet()
		tv_ray_normale = COL_RayObject_NormalGet()

//		DBG_RenderVector(tv_ray_start, tv_collide_pos - tv_ray_start, color_vert)
//		DBG_RenderVector(tv_collide_pos, tv_ray_normale, color_jaune)
		
		tf_offset = MATH_VecDotProduct(tv_collide_pos - tv_ray_start, -tv_ray_dir)
		if (tf_offset >= tf_ray_start_offset)
			ti_flag_collision = vrai
		else
			ti_flag_collision = faux
	}
//	else
//	{
//		DBG_RenderVector(tv_ray_start, -tv_ray_dir * f_IK_leg_length[ti_i], color_rouge)
//	}
	
	if (ti_flag_collision)
	{
		v_IK_ground_pos[ti_i] = tv_collide_pos
		v_IK_ground_normale[ti_i] = MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_ray_normale, 4.0 * tf_dt)
		tf_offset =MATH_VecDotProduct(tv_collide_pos - v_IK_ref_ground_pos, tv_ray_dir)
	}
	else
	{
		v_IK_ground_pos[ti_i] = tv_pied_pos
		v_IK_ground_normale[ti_i] = MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_virtual_banking, 4.0 * tf_dt)
		tf_offset = 0.0	
//		DBG_RenderVector(tv_ray_start, -tv_ray_dir * f_IK_leg_length[ti_i], color_rouge)	
	}		

	tf_offset = MATH_FloatMin(tf_offset, f_IK_leg_length[ti_i] * 0.33)
	
	if (tf_offset && tf_offset > f_IK_Z_offset[ti_i])
		f_IK_Z_offset[ti_i] = tf_offset // MATH_FloatBlend(f_IK_Z_offset[ti_i], tf_offset, 20.0 * tf_dt)
	else
		f_IK_Z_offset[ti_i] = MATH_FloatBlend(f_IK_Z_offset[ti_i], tf_offset, Cf_walk_Z_blend_speed * tf_dt)

	v_IK_dest_pos[ti_i] = tv_pied_pos
	v_IK_dest_pos[ti_i] += tv_ray_dir * f_IK_Z_offset[ti_i]
	
//	DBG_RenderVector(v_IK_dest_pos[ti_i], -tv_ray_dir * f_IK_Z_offset[ti_i], color_cyan)

	f_IK_speed[ti_i] = 1.0
}


if (i_flag_bite_leg)
	f_head_bite_angle = MATH_FloatBlend(f_head_bite_angle, 0.35, 4.0 * tf_dt)
else if (f_head_bite_angle)
	f_head_bite_angle = MATH_FloatBlend(f_head_bite_angle, 0.0, 6.0 * tf_dt)


// ROTATION DU BASSIN AUTOUR D'UN PIVOT (PAF ET SUIVI REGARD)
if (f_IK_coef[Ci_IK_pied_gauche] && f_IK_coef[Ci_IK_pied_droit])
{
	tf_IK_coef = MATH_FloatMin(f_IK_coef[Ci_IK_pied_gauche], f_IK_coef[Ci_IK_pied_droit])
	
	tv_rot_pivot_pos = @o_ventre OBJ_PosGet()
	tv_temp = @o_ventre MATH_VecGlobalToLocal(@ao_head_bones[i_head_bone_nb] OBJ_PosGet() - tv_rot_pivot_pos)
	
	// ROTATION BASSIN POUR SECOUER =====================================================================
	if (f_head_bite_angle)
		@ao_head_bones[i_head_bone_nb] OBJ_RotateLocalX(f_head_bite_angle)

	// ROTATION BASSIN EN FONCTION DES ACCUMULATION DE PAFS ===============================================
	for (ti_i = 0; ti_i < 10; ti_i++)
	{
		ti_k = MATH_Modulo(i_quat_index + ti_i, 10)
	
		if (af_quat_time[ti_k] == -1.0)
			continue	
	
		tf_coef = TIME_Get() - af_quat_time[ti_k]
		if (tf_coef < 1.0)	
		{
			tf_coef = MATH_FloatMin(tf_coef * 10.0, 1.0) * (1.0 - tf_coef)
			tf_coef *= tf_IK_coef
	
			tv_X = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(av_quat_start[ti_k])
			tv_Y = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(av_quat_end[ti_k])

			@ao_head_bones[i_head_bone_nb] OBJ_Rotate_FromTo(tv_X, MATH_VecBlend(tv_X, tv_Y, tf_coef * af_quat_coef[ti_k]))
		}
		else
		{
			af_quat_time[ti_k] = -1.0
		}
	}

	// ROTATION DU BASSIN EN FONCTION DU SUIVI DE REGARD ============================================================
	tv_virtual_sight = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(OBJ_SightGet())

	tv_look_axis = v_look_axis

	f_IK_bassin_look_rot_coef = 0.2

	@ao_head_bones[i_head_bone_nb] OBJ_Rotate_FromTo(tv_virtual_sight, MATH_VecBlendRotate(tv_virtual_sight, @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(tv_look_axis), f_IK_bassin_look_rot_coef * tf_IK_coef * f_look_blend_coef))

	// ROTATION DU BASSIN POUR MANGER ============================================================================
	switch(ACT_ActionGet())
	{
		case Action_Mange :
			if (o_cadavre_bone)
			{
				v_IK_bassin_eat_pos = @o_cadavre_bone OBJ_PosGet()
				f_IK_bassin_eat_rot_coef += MATH_FloatMin(1.0 - f_IK_bassin_eat_rot_coef, 6.0 * tf_dt)
			}
			else
			{
				f_IK_bassin_eat_rot_coef -= MATH_FloatMin(f_IK_bassin_eat_rot_coef, 6.0 * tf_dt)
			}
			break

		default:
			f_IK_bassin_eat_rot_coef -= MATH_FloatMin(f_IK_bassin_eat_rot_coef, 6.0 * tf_dt)
	}

	if (f_IK_bassin_eat_rot_coef)
	{
		tv_virtual_sight = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(OBJ_SightGet())
		tv_virtual_sight	.x = 0.0
	
		tv_dest_axis = MATH_VecBlendRotate(tv_virtual_sight, @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(v_IK_bassin_eat_pos - OBJ_PosGet()), f_IK_bassin_eat_rot_coef * tf_IK_coef)
		tv_dest_axis.x = 0.0
		@ao_head_bones[i_head_bone_nb] OBJ_Rotate_FromTo(tv_virtual_sight, tv_dest_axis)
	}

	// ON REPOSITIONNE LE BASSIN QUI A TOURNE AUTOUR DU PIVOT ========================================================
	tv_temp = @o_ventre MATH_VecLocalToGlobal(tv_temp)
	tv_temp += tv_rot_pivot_pos

	// ON RAJOUTE UN DEPLACEMENT LIE AU PAF ======================================================================
	if (! TIME_Elapsed(f_visual_paf_time, 0.5) )
	{
		tf_coef = TIME_Get() - f_visual_paf_time
		tf_coef /= 0.5
		tf_coef = 1.0 - tf_coef
		tf_coef *= tf_coef
		tf_coef = MATH_Sin(tf_coef * Cf_Pi)

		tv_temp += v_visual_paf_dir * (tf_coef * 0.4)
		tv_temp.z -= tf_coef * 0.3
	}

	@ao_head_bones[i_head_bone_nb] OBJ_PosSet(tv_temp)
}
else
{
	f_IK_bassin_eat_rot_coef = 0.0
	f_IK_bassin_look_rot_coef = 0.0
	f_IK_bassin_ground_rot_coef = 0.0
}


// DECALAGE EN Z DU BASSIN POUR QUE LES PIEDS PUISSENT TOUCHER LE SOL ============================================
tf_bassin_offset = MATH_FloatMin(f_IK_Z_offset[Ci_IK_pied_gauche], f_IK_Z_offset[Ci_IK_pied_droit]) * 0.75

switch(ACT_ActionGet())
{
	default:
		for (ti_i = 0; ti_i < 2; ti_i++)
		{
			if (i_flag_leg_IK[ti_i] || f_IK_coef[ti_i])
			{
				tv_X = v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet()
				tv_X -= MATH_VecDotProduct(tv_X, tv_ray_dir) * tv_virtual_banking
			
				tf_X = MATH_VecDotProduct(tv_X, tv_X)
		
				tf_Y = 0.0
				for (ti_k = 0; ti_k < 3; ti_k++)
					tf_Y += af_IK_bones_length[ti_i][ti_k]
		
				tf_Y *= 0.99
				tf_Y *= tf_Y
				
				tf_norm = tf_Y
				tf_norm -= tf_X
			
				tf_norm = MATH_FloatMax(tf_norm, 0.0)
			//		if (tf_norm < 0.0)
			//			DBG_Error("Ha ha !!!")	
			
				tf_norm = MATH_FloatSqrt(tf_norm)
			
				tf_offset = tf_norm + MATH_VecDotProduct(v_IK_dest_pos[ti_i] - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_virtual_banking)
			
				tf_bassin_offset = MATH_FloatMin(tf_bassin_offset, tf_offset)
			}
		}
		break
}

tf_bassin_offset = MATH_FloatMax(tf_bassin_offset, tf_bassin_offset_min)
//tf_bassin_offset = MATH_FloatBlend(tf_bassin_offset, tf_bassin_offset_min, MATH_Sin(TIME_Get() * 2.0))

f_bassin_Z_offset	= MATH_FloatBlend(f_bassin_Z_offset, tf_bassin_offset, 12.0 * tf_dt)

tv_bassin_dest_pos = @ao_head_bones[i_head_bone_nb] OBJ_PosGet()
tv_bassin_dest_pos += tv_virtual_banking * f_bassin_Z_offset

@ao_head_bones[i_head_bone_nb] OBJ_PosSet(tv_bassin_dest_pos)
v_IK_bassin_pos = tv_bassin_dest_pos


// ROTATION DU BASSIN POUR MORDRE ============================================================================
if (f_IK_coef[Ci_IK_pied_gauche] && f_IK_coef[Ci_IK_pied_droit])
{
	tf_IK_coef = MATH_FloatMin(f_IK_coef[Ci_IK_pied_gauche], f_IK_coef[Ci_IK_pied_droit])

	if (o_grab_actor || i_flag_bite_ok)
	{
		f_IK_bassin_bite_rot_coef -= MATH_FloatMin(f_IK_bassin_bite_rot_coef, 2.0 * tf_dt)
	}
	else
	{
		switch(ACT_ActionGet())
		{
//			case Action_Fight_Mord :
//				if ( ! ACT_ActionItemGet() && i_flag_bite_no_wall)
//				{
//					v_IK_bassin_bite_start_quat = av_bassin_bite_quat[0]
//					f_IK_bassin_bite_rot_coef = MATH_FloatMax(f_IK_bassin_bite_rot_coef, MATH_FloatMin(ANI_RatioGet(0) / 0.25, 1.0))
//					break
//				}
//		
//			case Action_Fight_Mord_Face :
//				if ( ! ACT_ActionItemGet()  && i_flag_bite_no_wall)
//				{
//					v_IK_bassin_bite_start_quat = av_bassin_bite_quat[1]
//					f_IK_bassin_bite_rot_coef += MATH_FloatMin(1.0 - f_IK_bassin_bite_rot_coef, 6.0 * tf_dt)
//					break
//				}
//	
//			case Action_Fight_Mord_Haut :
//				if ( ! ACT_ActionItemGet() && i_flag_bite_no_wall)
//				{
//					if (ANI_CurrentFrameGet(0) < 35)
//					{
//						v_IK_bassin_bite_start_quat = av_bassin_bite_quat[2]
//					}
//					else
//					{
//						to_bone = ANI_CanalObjectGet(Anim_Canal_Machoire)
//
//						tv_temp = @to_bone OBJ_PosGet()
//						tv_temp += @to_bone OBJ_BankingGet() * 1.5
//						tv_temp -= @to_bone OBJ_SightGet() * 0.75
//						
//						DBG_RenderVector(@to_bone OBJ_PosGet(), tv_temp - @to_bone OBJ_PosGet(), color_jaune)
//
//						v_IK_bassin_bite_start_quat = @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(tv_temp - @ao_head_bones[i_head_bone_nb] OBJ_PosGet())
//					}
//				
//					f_IK_bassin_bite_rot_coef += MATH_FloatMin(1.0 - f_IK_bassin_bite_rot_coef, 6.0 * tf_dt)
//					break
//				}

			case Action_Fight_Attak_Humain :
			case Action_Fight_Attak_FPS :
				if ( ! ACT_ActionItemGet() && i_flag_bite_no_wall)
				{
					v_IK_bassin_bite_start_quat = av_bassin_bite_quat[3]
//					f_IK_bassin_bite_rot_coef += MATH_FloatMin(1.0 - f_IK_bassin_bite_rot_coef, 6.0 * tf_dt)

					tf_target_coef = MATH_FloatBlend(0, 1.0, MATH_FloatMax(ANI_RatioGet(0) - 0.5, 0.0) * 3.0)
					f_IK_bassin_bite_rot_coef += MATH_FloatMin(tf_target_coef - f_IK_bassin_bite_rot_coef, 6.0 * tf_dt)
					break
				}
	
			default:
				f_IK_bassin_bite_rot_coef -= MATH_FloatMin(f_IK_bassin_bite_rot_coef, 2.0 * tf_dt)
		}
	}
	
	if (f_IK_bassin_bite_rot_coef)
	{
		if (o_IK_bassin_bite_actor && i_flag_bite_no_wall)
			v_IK_bassin_bite_pos = @o_IK_bassin_bite_actor OBJ_PosGet()
	
		DBG_RenderVector(@ao_head_bones[i_head_bone_nb] OBJ_PosGet(), @ao_head_bones[i_head_bone_nb] MATH_VecLocalToGlobal(v_IK_bassin_bite_start_quat), color_rouge)
		tv_dest_axis = v_IK_bassin_bite_pos - @ao_head_bones[i_head_bone_nb] OBJ_PosGet()
		tv_dest_axis = MATH_VecInCone(tv_dest_axis, OBJ_SightGet(), Cf_PiBy3, 0)
		DBG_RenderVector(@ao_head_bones[i_head_bone_nb] OBJ_PosGet(), tv_dest_axis, color_vert)
		tv_dest_axis = MATH_VecBlendRotate(v_IK_bassin_bite_start_quat, @ao_head_bones[i_head_bone_nb] MATH_VecGlobalToLocal(tv_dest_axis), f_IK_bassin_bite_rot_coef * tf_IK_coef)
		@ao_head_bones[i_head_bone_nb] OBJ_Rotate_FromTo(v_IK_bassin_bite_start_quat, tv_dest_axis)
		DBG_RenderVector(@ao_head_bones[i_head_bone_nb] OBJ_PosGet(), @ao_head_bones[i_head_bone_nb] MATH_VecLocalToGlobal(v_IK_bassin_bite_start_quat), color_bleu)
	}
}
else
{
	f_IK_bassin_bite_rot_coef = 0.0
}


// ON REGARDE COMMENT LE BASSIN EST ORIENTE POUR INFLUENCER DIFFEREMMENT LES AXES DES CUISSES
tv_temp = v_look_axis
tv_temp -= MATH_VecDotProduct(tv_temp, OBJ_BankingGet()) * OBJ_BankingGet()
MATH_VecSetNormalize(tv_temp)	
tf_dot_product = MATH_VecDotProduct(tv_temp, OBJ_HorizonGet())
tf_sign = MATH_FloatSign(tf_dot_product)

tf_dot_product = 1.0 - MATH_AbsFloat(tf_dot_product)
tf_dot_product = MATH_FloatMax(tf_dot_product, 0.15)


// ON EXECUTE L'IK =============================================================================================================
for (ti_i = 0; ti_i < 2; ti_i++)
{
	if (i_flag_leg_IK[ti_i])
	{
		f_IK_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_coef[ti_i], tf_dt * 8.0)	
	
		f_IK_ground_coef[ti_i] *= f_IK_coef[ti_i]

		tv_pied_pos = MATH_VecBlend(MATH_VecLocalToGlobal(v_IK_local_offset[ti_i]), v_IK_dest_pos[ti_i] - OBJ_PosGet(), f_IK_speed[ti_i])
		v_IK_local_offset[ti_i] = MATH_VecGlobalToLocal(tv_pied_pos)
		tv_pied_pos += OBJ_PosGet()
	}
	else if (f_IK_coef[ti_i])
	{
//		f_feet_contact_duration[ti_i] = 0.0
	
		f_IK_coef[ti_i] -= MATH_FloatMin(f_IK_coef[ti_i], tf_dt * 12.0)

		f_IK_Z_offset[ti_i] *= f_IK_coef[ti_i]
		f_IK_ground_coef[ti_i] *= f_IK_coef[ti_i]
		f_IK_snap_coef[ti_i] *= f_IK_coef[ti_i]

		if ( ! f_IK_coef[ti_i] )
		{
			v_IK_ground_normale[ti_i] = tv_virtual_banking
			continue
		}
	
		v_IK_dest_pos[ti_i] = @ao_IK_bones[ti_i][3] OBJ_PosGet()
		tv_pied_pos = MATH_VecBlendRotate(v_IK_dest_pos[ti_i] - OBJ_PosGet(), MATH_VecLocalToGlobal(v_IK_local_offset[ti_i]), f_IK_coef[ti_i])
		v_IK_local_offset[ti_i] = MATH_VecGlobalToLocal(tv_pied_pos)
		tv_pied_pos += OBJ_PosGet()
	}
	else
	{
		v_IK_ground_normale[ti_i] = tv_virtual_banking
		continue
	}

	tf_coef = MATH_VecDotProduct(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), -tv_ray_dir)
	tf_coef -= tf_ray_start_offset
	tf_coef /= f_IK_leg_length[ti_i] * 0.8
	tf_coef = MATH_FloatLimit(tf_coef, 0.0, 1.0)
	tf_coef = 1.0 - tf_coef
	
	f_IK_tenseur[ti_i] = MATH_FloatBlend(f_IK_tenseur[ti_i], tf_coef, 6.0 * tf_dt)	

	if (ti_i == Ci_IK_pied_gauche && tf_sign == 1.0)
		tf_coef = tf_dot_product
	else if (ti_i == Ci_IK_pied_droit && tf_sign == -1.0)
		tf_coef = tf_dot_product
	else
		tf_coef = 1.0
		
	tv_ik_1st_bone_dir[ti_i] = MATH_VecBlendRotate(- @ao_IK_bones[ti_i][0] OBJ_SightGet(), tv_ik_1st_bone_dir[ti_i], tf_coef)
	tv_ik_1st_bone_dir[ti_i] = MATH_VecBlendRotate(@ao_IK_bones[ti_i][0] OBJ_BankingGet(), tv_ik_1st_bone_dir[ti_i], 0.5)
	tv_ik_2nd_bone_dir[ti_i] = -v_IK_bone_last_valid_banking[ti_i]

	OBJ_LIB_IK_3_Bones(	ao_IK_bones[ti_i][0], ao_IK_bones[ti_i][1], ao_IK_bones[ti_i][2],
									af_IK_bones_length[ti_i][0], af_IK_bones_length[ti_i][1], af_IK_bones_length[ti_i][2], 
//											tv_pied_pos, -@ao_IK_bones[ti_i][0] OBJ_SightGet(), @ao_IK_bones[ti_i][2] OBJ_SightGet(),
									tv_pied_pos, tv_ik_1st_bone_dir[ti_i], tv_ik_2nd_bone_dir[ti_i],
									f_IK_tenseur[ti_i], f_IK_coef[ti_i] )

	@ao_IK_bones[ti_i][3] OBJ_BankingGeneralSet(
		MATH_VecBlend(@ao_IK_bones[ti_i][3] OBJ_SightGet(), v_IK_bone_last_valid_sight[ti_i], f_IK_coef[ti_i]) , 
		MATH_VecBlend(@ao_IK_bones[ti_i][3] OBJ_BankingGet(), v_IK_bone_last_valid_banking[ti_i], f_IK_coef[ti_i]) )

	if (f_IK_ground_coef[ti_i])
	{
		tv_start_axis = @ao_IK_bones[ti_i][3] MATH_VecGlobalToLocal(tv_virtual_banking)
//		tv_start_axis = v_IK_feet_Z_axis[ti_i]

		tv_dest_axis = MATH_VecBlend(tv_start_axis, @ao_IK_bones[ti_i][3] MATH_VecGlobalToLocal(v_IK_ground_normale[ti_i]), f_IK_ground_coef[ti_i])
		@ao_IK_bones[ti_i][3] OBJ_Rotate_FromTo(tv_start_axis, tv_dest_axis)
	}
}

