// KK_Joy = Point ds la sphère de déplacement

#include "KT_defines.var"

int			ti_action
float		tf_dot, tf_dot2
float		tf_vol
vector	tv_affiche
vector	tv_JOY
object	to_snap

// Force de Kong

v_grabbed_joy_cercle_positon_reelle = glob_joyvector_get 
DBG_RenderVector(OBJ_PosGet(),v_grabbed_joy_cercle_positon_reelle * 10,color_rouge)

tv_JOY = v_grabbed_joy_cercle_positon_reelle * ( Cf_vitesse_decal_tete * TIME_GetDt())
v_grabbed_joy_cercle_positon += tv_JOY
f_grabbed_time_force += TIME_GetDt()

ti_action = ACT_ActionGet()
if (glob_joynorm_get)
{
	if ( MATH_VecDotProduct( tv_JOY, v_grabbed_joy_cercle_positon) > 0.0)
	{
		// Joy dans le sens de l inclinaison de la tete
		f_grabbed_time_force = 0.0
		if ( i_grabbed_reequilibre)
		{
			i_grabbed_IA = faux
			i_grabbed_reequilibre = faux
		}
		v_grabbed_force_tete = MATH_VecBlend( v_grabbed_force_tete, -0.8 * tv_JOY, 2.5 * TIME_GetDt())
	}
}
else if ( f_grabbed_time_force < 2.0)
{
	// Kong ne force plus retour a l'équilibre
	v_grabbed_force_tete = MATH_VecBlend( v_grabbed_force_tete, - 0.8 * v_grabbed_joy_cercle_positon, 6.0 * TIME_GetDt())
	i_grabbed_IA = faux
}

v_grabbed_old_joy = tv_JOY
// Force du TREX
v_grabbed_joy_cercle_positon += v_grabbed_force_tete 


f_KK_joy_norm = MATH_VecNorm(v_grabbed_joy_cercle_positon)
f_KK_joy_norm = MATH_FloatMin( f_KK_joy_norm , Cf_KK_joy_max)
if ( !MATH_VecNullEpsilon( v_grabbed_joy_cercle_positon))
	MATH_VecSetNorm( v_grabbed_joy_cercle_positon, f_KK_joy_norm)
f_KK_joy_norm /= Cf_KK_joy_max	// entre 0 & 1
tf_dot = MATH_VecDotProduct( v_grabbed_joy_cercle_positon, @o_KONG OBJ_HorizonGet())	
tf_dot2 = MATH_VecDotProduct( v_grabbed_joy_cercle_positon, @o_KONG OBJ_SightGet())
if ( MATH_AbsFloat( tf_dot) > MATH_AbsFloat( tf_dot2))
{
	if ( tf_dot < 0)
	{
		i_KK_joy_sens = Ci_joy_KK_ForceD
		if ( tf_dot2 < 0)
			i_KK_joy_sens2nd = Ci_joy_KK_Tire
		else
			i_KK_joy_sens2nd = Ci_joy_KK_Pousse
	}
	else
	{
		i_KK_joy_sens = Ci_joy_KK_ForceG
		if ( tf_dot2 < 0)
			i_KK_joy_sens2nd = Ci_joy_KK_Tire
		else
			i_KK_joy_sens2nd = Ci_joy_KK_Pousse
	}
}
else
{
	if ( tf_dot2 < 0)
	{
		i_KK_joy_sens = Ci_joy_KK_Tire
		if ( tf_dot < 0)
			i_KK_joy_sens2nd = Ci_joy_KK_ForceD
		else
			i_KK_joy_sens2nd = Ci_joy_KK_ForceG
	}
	else
	{
		i_KK_joy_sens = Ci_joy_KK_Pousse
		if ( tf_dot < 0)
			i_KK_joy_sens2nd = Ci_joy_KK_ForceD
		else
			i_KK_joy_sens2nd = Ci_joy_KK_ForceG
	}
}
 
i_KK_joy_press_action = faux
if( IO_ButtonJustPressed( JoyPSX_Button_croix))
	i_KK_joy_press_action = vrai
	

DBG_RenderVector( OBJ_PosGet() + cvector( 0.0, 0.0, 5.0), v_grabbed_force_tete * 8.0, 0xFF0000)

tf_vol = f_KK_joy_norm 
// todo ==> il faut récuperer l'instance du son
// SND_InsertVarSet(instance, 1, tf_vol)

// DEBUG
if ( i_dbg_sphere_ON)
{
	tv_affiche = @o_KONG MATH_VecGlobalToLocal( v_grabbed_joy_cercle_positon)
	
	tv_affiche.x = - tv_affiche.x
	STR_CreateText("X", cvector( 0.5,0.5,0.0), 0.2)
	STR_CreateText("o", (( tv_affiche /30.0) + cvector( 0.5,0.5,0.0)), 0.2)
	
	tv_affiche = @o_KONG MATH_VecGlobalToLocal( v_grabbed_joy_cercle_positon_reelle)
	tv_affiche.x = - tv_affiche.x
	STR_CreateText("+", (( tv_affiche /30.0) + cvector( 0.5,0.5,0.0)), 0.2)
}	
// DEBUG