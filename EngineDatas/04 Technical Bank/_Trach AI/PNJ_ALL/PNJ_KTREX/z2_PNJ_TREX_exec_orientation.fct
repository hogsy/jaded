
#include "PNJ_TREX_defines.var"

int				ti_i
// Détection LRay
int				ti_res_loc_lray
int				ti_lray
vector		tav_lray_normales[2]
int				tai_lray_gmat_flags[Ci_max_wall]
float			tf_ray_side_decalage
float			tf_ray_add_size
// Détection Coll
int				ti_res_loc_coll
int				ti_coll
vector		tav_coll_normales[Ci_max_wall]
int				tai_coll_gmat_flags[Ci_max_wall]
// Cumul LRay+Coll
int				ti_cumul
vector		tav_cumul_normales[Ci_max_wall]
int				tai_cumul_gmat_flags[Ci_max_wall]
// Résolution locale
vector		tv_new_sight_init
vector		tv_new_sight_res_loc
vector		tv_new_sight_ok
int				ti_flag_stop_resolution_locale
vector		tv_trace_res_loc_screen_pos 
int				ti_trace_res_loc_screen
int				ti_trace_res_loc_log

ti_trace_res_loc_screen = vrai
ti_trace_res_loc_log = vrai
ti_res_loc_lray = vrai
ti_res_loc_coll = vrai
ti_flag_stop_resolution_locale = faux


// ORIENTATION SOUHAITEE
tv_new_sight_init = MATH_VecBlendRotate(OBJ_SightGet(), v_orientation_sens, f_orientation_coef * TIME_GetDt())



if( DYN_SpeedGet() < Cf_charge_vitesse_peut_freiner )
{
	// DETECTION DES OBSTACLES PAR LANCER DE RAYON
	tf_ray_side_decalage = 3.0
	tf_ray_add_size = 2.0
	if( o_fight_actor && o_fight_actor == o_ANN )
		ti_res_loc_lray = faux
	
	if( ti_res_loc_lray )
		RES_LOC_LIB_2LRay( tf_ray_side_decalage, tf_ray_add_size, v_orientation_sens, ti_lray, &tav_lray_normales[0], &tai_lray_gmat_flags[0] )
	else
		ti_lray = 0
	
	// DETECTION DES OBSTACLES PAR COLLISION
	if( ti_res_loc_coll )
		RES_LOC_LIB_Collision( v_orientation_sens, ti_coll, &tav_coll_normales[0], &tai_coll_gmat_flags[0])
	else
		ti_coll = 0
	
	// FUSION DES RESULTATS DES DEUX TYPES DE DETECTION DES OBSTACLES
	RES_LOC_LIB_Cumul_LRay_Coll( &tav_cumul_normales[0], &tai_cumul_gmat_flags[0], ti_cumul, &tav_lray_normales[0], &tai_lray_gmat_flags[0], ti_lray, &tav_coll_normales[0], &tai_coll_gmat_flags[0], ti_coll)
	
	if( ti_trace_res_loc_log )
	{
		DBG_TraceString("nb d'obstacles = ")
		DBG_TraceInt(ti_cumul)
		DBG_TraceString(" = ")
		DBG_TraceInt(ti_lray)
		DBG_TraceString(" lray ")
		for(ti_i = 0; ti_i < ti_lray; ti_i++)
		{
			if( tai_lray_gmat_flags[ti_i] & Gmat_KK_Force_Left )
				DBG_TraceString("(G)")
			if( tai_lray_gmat_flags[ti_i] & Gmat_KK_Force_Right )
				DBG_TraceString("(D)")
		}
		DBG_TraceString(" + ")
		DBG_TraceInt(ti_coll)
		DBG_TraceString(" coll ")
		for(ti_i = 0; ti_i < ti_coll; ti_i++)
		{
			if( tai_coll_gmat_flags[ti_i] & Gmat_KK_Force_Left )
				DBG_TraceString("(G)")
			if( tai_coll_gmat_flags[ti_i] & Gmat_KK_Force_Right )
				DBG_TraceString("(D)")
		}
		DBG_TraceEOL()
	}
	
	
	// RESOLUTION LOCALE
//	tv_new_sight_res_loc = RES_LOC_LIB_Contournement(tv_new_sight_init, v_orientation_sens, i_force_contourne_on, f_force_contourne_sens, ti_cumul, &tav_cumul[0], &tai_gmat_flags[0])
	tv_new_sight_res_loc = RES_LOC_LIB_Contournement(tv_new_sight_init, v_orientation_sens, i_force_contourne_on, f_force_contourne_sens, ti_cumul, &tav_cumul_normales[0], &tai_cumul_gmat_flags[0])
	if( tv_new_sight_res_loc != tv_new_sight_init || i_force_contourne_on )
	{
		i_flag_resolution_locale = vrai
		tv_new_sight_ok = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight_res_loc, 2 * TIME_GetDt())
		
		DBG_RenderVector(OBJ_PosGet(), tv_new_sight_res_loc * 5, color_cyan)
		if( i_etat_courant == ETAT_charge && ACT_ActionGet() == Action_Normal_Charge )
		{
			ACT_ActionSet(Action_Normal_Trot)
			f_time_start_etat = 0.0		// séquence de fin de charge
		}
	}
	else
		ti_flag_stop_resolution_locale = vrai
}
else
	ti_flag_stop_resolution_locale = vrai

// PAS DE RESOLUTION LOCALE
if( ti_flag_stop_resolution_locale )
{
	i_flag_resolution_locale = faux
	tv_new_sight_ok = tv_new_sight_init
	
	if( i_etat_courant == ETAT_charge && i_charge_exit == Ci_charge_en_cours && ACT_ActionGet() != Action_Normal_Charge )
		ACT_ActionSet(Action_Normal_Charge)		// on remet l'anim de charge	
}


// ORIENTATION DEFINITIVE	
OBJ_BankingGeneralSet(tv_new_sight_ok, Cv_VerticalVector)

if( ti_trace_res_loc_screen )
{
	if( i_flag_resolution_locale )
	{
		tv_trace_res_loc_screen_pos = Cv_NullVector
		Str_DisplayTextOnce("TREX RES LOC", tv_trace_res_loc_screen_pos)
		if( i_force_contourne_on )
		{
			Str_DisplayTextOnce("Sens Force", tv_trace_res_loc_screen_pos + cvector(0,0.05,0))
			if( f_force_contourne_sens == 1.0 )
				Str_DisplayTextOnce("Gauche", tv_trace_res_loc_screen_pos + cvector(0,0.1,0))
			else
				Str_DisplayTextOnce("Droite", tv_trace_res_loc_screen_pos + cvector(0,0.1,0))
		}
	}
}

