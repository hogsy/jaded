
//===========================================================================================
// TESTE SI UN ACTEUR ESSAIE D'INTIMIDER LE TREX
//===========================================================================================


int				ti_rank

float			tf_norm 

vector		tv_pos_centre_cone
vector		tv_pos_orient_cone
vector		tv_sens 

object		to_actor 
messageid	EVT_Fury_ID

o_fury_check_actor = nobody

//if( o_Kong && @o_Kong Proc_KK_RAGE_Test() )
//{
//	o_fury_check_actor = o_Kong
//}
//
//return

ti_rank = -1
for(	EVT_Fury_ID = MSG_GlobalScan(C_EVENT_TYPE_Fury, &ti_rank);
		MSG_GlobalIsValid(EVT_Fury_ID);
		EVT_Fury_ID = MSG_GlobalScan(C_EVENT_TYPE_Fury, &ti_rank) )
{
	// TREX dans le cone d'une intimidation ?
	if( EVENT_FuryTypeGet(EVT_Fury_ID) != Ci_KK_Fury_Type_Roar )
		continue
	
	to_actor = MSG_GlobalGetSender(EVT_Fury_ID)
	tv_pos_centre_cone = @to_actor OBJ_PosGet() + @to_actor MATH_VecLocalToGlobal(Cv_KK_Fury_decalage_position)
	
	tv_pos_orient_cone = EVENT_FurySensGet(EVT_Fury_ID)
	tv_sens = OBJ_PosGet() - tv_pos_centre_cone
	tv_sens.z = 0.0
	tf_norm = MATH_VecNorm(tv_sens)
//	if ( tf_norm < EVENT_FuryPuissanceGet(EVT_Fury_ID))
	if( tf_norm < 30.0 )
	{
		// TREX assez proche
		tv_sens /= tf_norm
//		if ( MATH_VecDotProduct(tv_pos_orient_cone, tv_sens) > MATH_Cos( EVENT_FuryAngleGet(EVT_Fury_ID)))
		{
			// TREX dans l'angle
			o_fury_check_actor = to_actor
			i_fury_type = EVENT_FuryTypeGet(EVT_Fury_ID)
			return			
		}
	}
}

