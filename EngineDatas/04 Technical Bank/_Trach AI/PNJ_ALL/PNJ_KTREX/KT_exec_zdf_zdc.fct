#include "KT_defines.var"

#define			Cf_Design_Flag_Kong_No_Paf			0b0000000000000001


int				ti_collision_nb
int				ti_i
float			tf_puis
int				ti_grab
int				ti_type_paf
int				ti_charge_paf_KONG_now
int				ti_slow_motion

vector		tv_sens_paf
vector		tv_sens_paf_init
vector		tv_temp
vector		tv_offset
vector		tv_pos
vector		tv_horizon_ref

object		tao_zde_zde_list[20]
object		to_collide_object
object		to_col_ray_object
object		to_grab
object		to_gueule
object		to_client
object		to_bone
object		to_actor

float				tf_dot
float				tf_angle
float				tf_sign

ti_collision_nb = COL_ZDE_ZDEListGet( &tao_zde_zde_list[0], C_zde_fight, C_zde_corps, all, none, Ci_Filter_IdentityFlag)
if ( ti_collision_nb )
{
	// ACTEURS EN COLLISION =================================================
	for (ti_i = 0; ti_i < ti_collision_nb; ti_i++)
	{
		to_actor = tao_zde_zde_list[ti_i]
		ti_charge_paf_KONG_now = faux
		ti_type_paf = 0		// type du paf à envoyer
		tf_puis = 0.0
		ti_slow_motion = faux
		
		// CIBLE DU PAF ================================================================
//		if( to_actor == o_ANN )
//		{
//			if( MSG_GlobalIsValid(EVENT_FindEventPereTarget(Ci_LNK_EVENT_OFFSET + Ci_LNK_KKGRAB_OBJECT, o_ANN, o_Kong)) )
//				continue		// ANN grabbée par KONG
//			else
//			{
//				if( ! KT_GaoDansMonTerritoire(o_Kong) )
//					continue		// si un périmètre est défini et que KONG n'est pas dedans, ne pas tuer ANN (kaméra ANN et KONG ailleurs)
//			}
//			
//			if( ! o_interaction_target )
//				continue			// ne pas paffer ANN si on n'est pas en intéraction avec elle
//			
//			if( i_interaction_cpt != Ci_script_KAnn_cycle_max )
//				continue			// ne pas paffer ANN si ce n'est pas la véritable attaque			
//		}
		if( to_actor == o_Jack )
		{
			if( @o_Jack Proc_KIndigene_Kong_LiaisonStatusGet() != Ci_Kong_KIndigene_LinkStatus_None )
				continue			// Jack est sur Kong
		}
		else if( to_actor == o_Kong )
		{
			// test spécial pour KONG
			if( @o_Kong ACT_DesignFlagTest(Cf_Design_Flag_Kong_No_Paf) )
			{
				// cette anim interdit potentiellement d'envoyer des pafs à KONG
				if( MATH_VecDotProduct( @o_Kong OBJ_SightGet(), OBJ_SightGet() ) < 0 )
					continue			// REX arrive face à KONG : paf annulé
			}
		}
		else if( @to_actor AI_IsModel(get_PNJ_KTREX_Path) )
		{
			// c'est un TREX
			if( i_etat_courant == ETAT_attaque )
				continue		// les TREX ne s'attaquent pas entre eux
		}
		
		
		// MULTI-PAF SUR MEME ACTEUR ================================================
		if( ARR_ObjSearch( &ao_paf_list[0], i_paf_nb, to_actor ) != -1 )
			continue		// Ne paffe pas 2x le même acteur		
		
		
		// TEST VALIDITE DU PAF =======================================================
		switch( i_flag_zde_fight_type )
		{
			case Ci_zde_fight_type_corps :
				// Grabbé par Kong -> le TRex paffe avec son corps
				if( to_actor == o_grabbed_actor_KK_ref)
					continue		// Ne peut pas paffer l'acteur qui le fait tourner
				break
				
			case Ci_zde_fight_type_charge :
				// Charge -> le TRex paffe plusieurs fois
				if( to_actor == o_Kong )
				{
					// a paffé KONG en charge
					ti_charge_paf_KONG_now = vrai
					i_charge_paf_KONG = vrai
				}				
				break
				
			case Ci_zde_fight_type_projectile :
			case Ci_zde_fight_type_projection_laterale :
				// Charge -> le TRex paffe plusieurs fois
				if( to_actor == o_Kong )
					continue		// Ne paffe pas Kong
				else if( ! @o_Kong Proc_KK_EstUnEnnemiDeKong(to_actor) )
					continue		// Ne pas envoyer de pafs aux éléments du décor
				break	
				
			case Ci_zde_fight_type_machoire :
				// Le TRex mord
				switch( ACT_ActionGet() )
				{
					case Action_Fight_Paf_G_Defense :
					case Action_Fight_Paf_D_Defense :
						break
					
					default:
						if( ! o_Grab_Attak_Target )
						{
							// Le TRex n'a pas déjà niaké un raptor
							if( to_actor != o_fight_actor )
								continue			// REX ne paffe que l'acteur qu'il a sélectionné
							
							v_grab_vector = OBJ_SightGet()
							i_grab_type = Ci_GrabKong_Type_TRex_Choppe
							if ( i_etat_courant == ETAT_attaque)
								ti_grab = vrai
							else
								ti_grab = faux
							
							o_Grab_Attak_Target = LNK_ThisClientGet(to_actor, Ci_LNK_GRAB_KONG, mid_GRABKONG, ti_grab, "KT_exec_grab_object_param", nofunc, nofunc)
							if( o_Grab_Attak_Target )
							{
								// Le TRex va niaker un raptor : pas de paf
								SND_RequestPlay(Ci_SND_Bite)
								to_gueule = ANI_CanalObjectGet(Anim_Canal_Machoire)
								LNK_GrabKong_BoneSet(mid_GRABKONG, to_gueule)
								LNK_GrabKong_TypeSet(mid_GRABKONG, Ci_GrabKong_Type_TRex_Choppe)
								break		// il ne peut pas paffe les autres acteurs s'il grabbe celui-ci
							}
						}
						break
				}
				break
				
			case Ci_zde_fight_type_coup_de_tete :
			case Ci_zde_fight_type_coup_de_queue :
				// Aucune restriction
				break
			
			default:
				DBG_Error("Rex : mode de paf inconnu (machoire / coup de tete / charge / corps / se releve / projectile)")
				break
		}
	
		// PAF VALIDE : TYPE ET SENS DE PAF ====================================================

		// On comptabilise le paf
		i_fight_paf = vrai
		i_fight_just_paf = vrai
		ao_paf_list[i_paf_nb] = to_actor
		i_paf_nb++
		
		switch ( i_flag_zde_fight_type )
		{
			case Ci_zde_fight_type_corps :
				// Grabbé par Kong
				ti_type_paf = C_PAF_KK_Moyen	// + C_PAF_KK_Projection
				tf_puis = Cf_DMG_Balayage
				tv_sens_paf = MATH_VecCrossProduct(OBJ_SightGet(), Cv_VerticalVector)
				if( MATH_VecDotProduct(tv_sens_paf, v_grab_grav_speed) < 0 )
					tv_sens_paf *= -1
				MATH_VecNormalize(tv_sens_paf)
				break
				
			case Ci_zde_fight_type_charge :
				// Le TRex charge
				KT_Init_Paf_Charge( tv_sens_paf, ti_type_paf, tf_puis, ti_charge_paf_KONG_now, v_charge_stop_vector )
				DBG_RenderVector(OBJ_PosGet(),tv_sens_paf * 5 , color_rouge)
				break
				
			case Ci_zde_fight_type_projectile :
			case Ci_zde_fight_type_projection_laterale :
				// Lancé par Kong
				ti_type_paf = C_PAF_KK_Moyen + C_PAF_KK_Projection
				tf_puis = Cf_DMG_Projection					
				tv_sens_paf = DYN_SpeedGetVector()
				tv_sens_paf .z = 0.0
				if ( ! MATH_VecNullEpsilon( tv_sens_paf) )
					MATH_VecSetNormalize(tv_sens_paf)
				else
					tv_sens_paf = OBJ_SightGet()		// Le moins pire
				break
			
			case Ci_zde_fight_type_machoire :
				// Coup de dents
				ti_type_paf = C_PAF_KK_Fort
				tf_puis = Cf_DMG_Attack_Machoire
//				i_cri_apres_un_paf_type = 1	// haut
				i_cri_filtre |= Ci_CRI_FORCE_HAUT_SI_PAF
				tv_sens_paf = v_look_virtual_sight
				break

			case Ci_zde_fight_type_coup_de_tete :
				// Coup de tête
				ti_type_paf = C_PAF_KK_Moyen
				tf_puis = Cf_DMG_Attack_CoupDeTete
				
				to_bone = ANI_CanalObjectGet(Anim_Canal_Tete)
				tv_offset = @to_bone OBJ_PosGet() - OBJ_PosGet()
				tv_offset.z = 0.0
				switch( ACT_ActionGet())
				{
					case Action_Attak_CpTeteD :
					case Action_DEF_CpTeteD :
						tv_horizon_ref = - OBJ_HorizonGet()
						tv_sens_paf_init = MATH_VecCrossProduct(tv_offset, Cv_VerticalVector)
						break
						
					case Action_Attak_CpTeteG : 
					case Action_DEF_CpTeteG :
						tv_horizon_ref = OBJ_HorizonGet()
						tv_sens_paf_init = - MATH_VecCrossProduct(tv_offset, Cv_VerticalVector)
						break
				}
				tv_sens_paf = tv_sens_paf_init
//				DBG_RenderVector(COL_ZonePosGet(C_zde_fight), tv_sens_paf_init * 5.0, color_cyan)
				tf_angle = 2 * Cf_PiBy3
				tv_sens_paf = MATH_VecInCone(tv_sens_paf_init, OBJ_SightGet(), tf_angle, 0)
//				DBG_RenderVector(COL_ZonePosGet(C_zde_fight), tv_sens_paf * 5.0, color_jaune)
				if( MATH_VecDotProduct(tv_horizon_ref, tv_sens_paf) < 0 )
				{
					// vecincone pas du bon côté
					tf_angle *= -1
					tv_sens_paf = MATH_VecInCone(tv_sens_paf_init, OBJ_SightGet(), tf_angle, 0)
//					DBG_RenderVector(COL_ZonePosGet(C_zde_fight), tv_sens_paf * 5.0, color_jaune)
				}
				break
			
			case Ci_zde_fight_type_coup_de_queue :
				// Coup de tête
//				ti_slow_motion = vrai
//				i_cri_apres_un_paf_type = 0		// bas
				i_cri_filtre = Ci_CRI_FORCE_BAS_SI_PAF
				ti_type_paf = C_PAF_KK_Fort
				tf_puis = Cf_DMG_Attack_CoupDeQueue
				to_bone = ANI_CanalObjectGet(103)
				tv_temp = @to_bone OBJ_BankingGet()
				tv_temp.z = 0.0
				if( ! MATH_VecNullEpsilon(tv_temp) )
					MATH_VecSetNormalize(tv_temp)
				else
					tv_temp = @to_bone OBJ_BankingGet()
				switch( ACT_ActionGet())
				{
					case Action_Attak_CpQueueD :
					case Action_DEF_CpQueueD :
						tv_sens_paf = - MATH_VecCrossProduct(tv_temp, Cv_VerticalVector)
						break
					case Action_Attak_CpQueueG : 
					case Action_DEF_CpQueueG :
						tv_sens_paf = MATH_VecCrossProduct(tv_temp, Cv_VerticalVector)
						break
				}
				break
			
			default:				
				DBG_Error("Rex : mode de paf inconnu (machoire / coup de tete / charge / corps / se releve / projectile)")
				break
		}
		
		// TESTS SUPPLEMENTAIRES SELON L'ACTEUR PAFFé =================================================
		if (to_actor == o_Kong )
		{
			if( ti_type_paf & C_PAF_KK_Fort )
			{
				if( ! @to_actor Proc_KK_RefusePaf() )
				{
					if( ! KT_Rage_en_cours() )
					{
						i_cri_filtre |= Ci_CRI_A_PAFFE_KONG
						o_fury_actor = o_Kong				// déclenchement du hurlement à la fin de l'attaque car TREX a paffé KONG (sauf paf recalage)
					}
//					if( ti_slow_motion )
//						KT_SlowMotion(vrai)
				}
			}
		}
//		else if( to_actor == o_ANN)
//		{			
//			tf_puis = 0
//			ti_type_paf |= C_EVENT_PAF_KK_Tue			// Tue ANN
//		}
		else if( to_actor == o_Jack)
		{			
			tf_puis = 1000.0
			ti_type_paf = C_PAF_KK_KiTue			// Tue JACK
		}
		
		// ENVOI DU PAF =================================================================================
		DBG_RenderVector( COL_ZonePosGet( C_zde_fight), tv_sens_paf * 5.0, color_bleu)
		if( MATH_VecNullToler(tv_sens_paf, 0.1) )
		{
			tv_sens_paf = OBJ_SightGet()
			#ifndef _FINAL_
			DBG_TraceString("le trex envoie un paf avec un sens nul !!! sur ")
			DBG_TraceObject(to_actor)
			DBG_TraceString(" et en mode i_flag_zde_fight_type = ")
			DBG_TraceInt(i_flag_zde_fight_type)
			DBG_TraceEOL()
			DBG_Error("le trex envoie un paf avec un sens nul !!! (regarder le log)")
			#endif
		}
		mid_paf_EVENT_Send = EVENT_AddEventPafCanal( C_EVENT_FILTER_Enemy, ti_type_paf, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_actor, -1, tf_puis, tv_sens_paf, COL_ZonePosGet( C_zde_fight))
		SND_RequestPlay(Ci_SND_Bite)
	}
}


