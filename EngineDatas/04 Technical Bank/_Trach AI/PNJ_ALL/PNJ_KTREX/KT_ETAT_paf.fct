#include "KT_defines.var"

int			ti_lance_contre

object	to_bone


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	o_fury_actor = nobody		// ne pas crier après un paf
	KT_ReAttackDelay()
	
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_paf)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_paf

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = faux
	
	DYN_SpeedSetVector( OBJ_SightGet() * 5.0)
	f_time_start_etat = 0.0
	
	//f_fatigue_time += Cf_fatigue_add			// chaque coup fatigue
	i_paf_va_se_vautrer = faux	
	o_paf_actor_memo = o_paf_actor
	KT_Action_Paf_Select()
}
else
{
	f_time_start_etat += TIME_GetDt()
	ai_grabbed_availibility[ Ci_LNK_GRAB_KONG] = vrai	// La première trame a fau pour pas accepter une liaison qu on viens de couper
}

// ANALYSE =======================================================================================================
if ( ! MATH_FloatNullEpsilon( f_time_start_etat))
	o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	macro_change_etat("KT_ETAT_Grabbed_by_Kong")


// détection du vide
macro_checkchute

AI_Execute("KT_exec_check_paf")
if (o_paf_actor)
{
	o_paf_actor_memo = o_paf_actor
	KT_Action_Paf_Select()
//	// Remplissage de la jauge pour tomber
//	if( f_jauge_croutage >= Cf_jauge_croutage_max )
//	{
//		// Combo -> gros recul
//		f_jauge_croutage = 0.0
//		f_coef_recul = 0.0
//		v_add_speed = v_paf_sens * 50.0
//	}
}

//KT_Interet_Update(o_fight_actor, C_EVENT_InteretStatusLock)
KT_Interet_Update(o_paf_actor_memo, C_EVENT_InteretStatusLock)

if ( i_paf_va_se_vautrer)
{
	// NOUVELLE GESTION
//	f_fatigue_time = 5.0
	v_paf_sens = - OBJ_SightGet()
	macro_change_etat("KT_ETAT_KO_au_sol")
}


// COMPORTEMENT =================================================================================================

//if( ACT_ActionGet() == Action_Fight_GrabTT_Paf )
//	Str_DisplayTextOnce("GROS PAF RECUL", cvector(0,0.5,0))

// Grab spécial possible dans ce cas la
if ( ACT_ActionGet()  == Action_Fight_GrabTT_Paf )
{
//	i_grabbed_special = vrai

	OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), -v_paf_sens, 8.0 * TIME_GetDt()), Cv_VerticalVector)
}

if (ACT_ActionFinished() || ! KT_Action_Paf_EnCours(ACT_ActionGet()) )
{
//	macro_change_etat(fct_main_etat)			// pas bon car peut retourner en fight ANN !!!
//	if( o_ANN && o_paf_actor_memo == o_ANN )
//	{
//		o_fight_actor = o_ANN
//		macro_change_etat("KT_ETAT_fight_ANN")
//	}
	if( o_Jack && o_paf_actor_memo == o_Jack )
	{
		o_fight_actor = o_Jack
		macro_change_etat("KT_ETAT_fight_JACK")
	}
	else
	{
		o_fight_actor = o_Kong
		macro_change_etat("KT_ETAT_fight_KONG")
	}
}
else
{
	// TEST CONTRE-ATTAQUE
	ti_lance_contre = faux
	if( i_contre_attaque_action && ANI_CurrentFrameGet(0) >= 20 )
	{
		// contre autorisé, frame anim paf début contre dépassée
		if( f_jauge_contre_attaque >= 3.0 )
		{
			// CONTRE PAFS
			f_jauge_contre_attaque = 0.0
			ti_lance_contre = vrai
		}
		if( f_jauge_contre_repousse >= 2.0 )
		{
			// CONTRE REPOUSSE
			f_jauge_contre_repousse = 0.0
			ti_lance_contre = vrai
		}
	}
	if( ti_lance_contre )
	{
		i_contre_attaque_mode = vrai
		o_fight_actor = o_paf_actor_memo
		if( MATH_VecDotProduct(@o_fight_actor OBJ_PosGet() - OBJ_PosGet(), OBJ_SightGet()) < 0 )
		{
			// acteur de dos => coup de queue
			if( MATH_VecDotProduct(@o_fight_actor OBJ_PosGet() - OBJ_PosGet(), OBJ_HorizonGet()) > 0 )
				i_KK_attaque_action = Action_Attak_CpQueueG
			else
				i_KK_attaque_action = Action_Attak_CpQueueD
			i_flag_zde_fight_type = Ci_zde_fight_type_coup_de_queue
		}
		else
		{
			// acteur de face => anim défense (mini charge)
			if( i_DBG_contre_attaque_mode )
			{
				i_KK_attaque_action = i_contre_attaque_action
				i_flag_zde_fight_type = Ci_zde_fight_type_machoire
			}
			else
			{
				// test defense avec les anims coup de tete
				if( i_contre_attaque_action == Action_PAF_Repousse )
				{
					// paf repousse : doit faire le choix de l'anim de contre
					if( MATH_VecDotProduct(@o_fight_actor OBJ_PosGet() - OBJ_PosGet(), OBJ_HorizonGet()) > 0 )
						i_KK_attaque_action = Action_Attak_CpTeteG
					else
						i_KK_attaque_action = Action_Attak_CpTeteD
				}
				else 
				{
					// choix d'anim de contre déjà effectué
					if( i_contre_attaque_action == Action_Fight_Paf_D_Defense )
						i_KK_attaque_action = Action_Attak_CpTeteG
					else
						i_KK_attaque_action = Action_Attak_CpTeteD
				}
				i_flag_zde_fight_type = Ci_zde_fight_type_coup_de_tete
			}
		}
		macro_change_etat("KT_ETAT_attaque")
	}
}



//// REGARD
//if( ACT_ActionGet() == Action_Paf_Mur_Petit )
//{
//	// projeté dans un mur par KONG : regard activé une partie de l'anim (cf. action bit et track capa)
//	i_flag_look = vrai
//	to_tete = @o_Kong ANI_CanalObjectGet(Anim_Canal_Tete)
//	v_look_pos = @to_tete OBJ_PosGet()
//}
//

