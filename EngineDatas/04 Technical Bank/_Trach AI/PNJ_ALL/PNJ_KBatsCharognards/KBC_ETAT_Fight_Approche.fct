#include "KBC_defines.var"

messageid		tmid_vision

object			to_head

vector			tv_sight
vector			tv_pos
vector			tv_sight2

float				tf_dist

int					ti_can_paf


// SORTIE ETAT =========================================================================
if (i_sort_etat)
{
	i_paf_send = faux
	f_angle_rotation_max = Cf_angle_rotation_max_default
	
	i_sort_etat = faux
	return
}

// ENTREE ETAT =========================================================================
if (i_etat_courant != ETAT_Fight_Approche)
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Fight_Approche
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KBC_DBG_Trace_Gao(i_DBG_trace_etat, "etat fight approche", o_cible_attaque)
	
	KBC_AttackModeSelect()
	
	// INIT DEPLACEMENT --------------------------------------------------------
	v_cible_pos = @o_cible_attaque OBJ_PosGet()
	KBC_ref_speed_set(f_vitesse_fight_approche)
	f_speed = 0.0

	AI_Execute("KBC_exec_dyn_on")

	@get_global f_time_bats_last_plongeon = TIME_Get()

	o_backup_wp_depl_utilise	= o_backup_nearest_cible_wp
	KBC_WP_Reservation_Del(o_backup_wp_depl_utilise)
	
	if( ! MATH_VecNullEpsilon(v_softcol_decal_current) )
	{
		// soft col en cours
		f_softcol_link_length = MATH_VecNorm(@o_cible_attaque OBJ_PosGet() - OBJ_PosGet())
	}
	
	i_flag_depl_horiz = faux
	
	// Rotation
	f_angle_rotation_max = Cf_angle_rotation_max_contact			// les bats rouges ne sont pas limitées dans la rotation
	
	if( i_big_bat )
	{
		KBC_BigBat_UncolAdd()
		f_bigbat_gamespeed_coef = @get_global f_game_speed	// le courant et pas 1.0 car si ça se trouve y'a une autre bat...
	}
	
	i_flag_depl_fini = faux		// ne pas passer en DODGED immédiatement !!!
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ==========================================================================================================
MACRO_CHECK_PAFS

// FIN D'ATTAQUE ? =================================================================
if( 0 )
{
	ANNULE_ATTAQUE:
	KBC_BigBat_Abort()
	AI_Execute("KBC_exec_init_attente")
}
AI_Execute("KBC_exec_check_fight_exit")
if( i_fight_exit_flag )
{
	goto ANNULE_ATTAQUE
}

// SMALL BATS CLAW ATTACK ----------------------------------------------------------------------------------------
if( OBJ_SqrDist(o_cible_attaque) <= ( f_plongeon_abort_dist * f_plongeon_abort_dist * f_zoom) )
{
	if( f_time_start_etat > 0.25 )
		SND_RequestPlay(Ci_SND_Parachute)
	macro_change_etat("KBC_ETAT_Fight_Contact")
}

// COMPORTEMENT ===========================================================

KBC_Interet_Update(mid_interet_attaque, C_EVENT_InteretStatusAttack, o_cible_attaque, tmid_vision)		// j'ai fini d'attendre
to_head = @o_cible_attaque ANI_CanalObjectGet(Anim_Canal_Tete)
if( ! to_head )
	to_head = o_cible_attaque

v_look_pos = @to_head OBJ_PosGet()
tv_sight = @o_cible_attaque OBJ_PosGet() - OBJ_PosGet()
i_flag_frein = faux
i_flag_neck = vrai

// UPDATE TARGET POSITION -----------------------------------------------------------------
v_cible_pos = v_look_pos
v_dest_pos = v_cible_pos
@o_tmp_obj_next OBJ_PosSet(v_dest_pos)

@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
o_next_wp = o_tmp_obj_next

AI_Execute("KBC_exec_MOVE_beziers")		// 1è condition pour i_flag_depl_fini

// ACTION --------------------------------------------------------------------------------------------------------------
tf_dist = 40.0
if( OBJ_SqrDist(o_cible_attaque) > (tf_dist * tf_dist) )
{
	ACT_ActionSet(i_ACTION_Vol_Standard)
	KBC_action_frequency_set(2.0)
	KBC_ref_speed_set(f_vitesse_fight_approche)
}
else
{
	tv_pos = OBJ_PosGet()
	if( v_dest_pos.z > tv_pos.z )
	{
		if( ACT_ActionGet() != i_ACTION_Vol_Standard )
			ACT_ActionSet(i_ACTION_Vol_Standard)
		KBC_ref_speed_set(f_vitesse_fight_approche * 0.6)
	}
	else
	{
		if( f_approche_plane_countdown )
		{
			if( ACT_ActionGet() != ACTION_Vol_Plane )
				ACT_ActionSet(ACTION_Vol_Plane)
			f_approche_plane_countdown -= MATH_FloatMin(f_approche_plane_countdown, TIME_GetDt())
			if( ! f_approche_falaise_countdown )
				f_approche_falaise_countdown = 1.0	// 1 cycle de battement d'ailes
		}
		else
		{
			if( ACT_ActionGet() != i_ACTION_Vol_Standard )
				ACT_ActionSet(i_ACTION_Vol_Standard)
			f_approche_falaise_countdown -= MATH_FloatMin(f_approche_falaise_countdown, TIME_GetDt())
			if( ! f_approche_falaise_countdown )
				f_approche_plane_countdown = MATH_RandFloat(0.75, 1.0)
		}
		KBC_ref_speed_set(f_vitesse_fight_approche)
	}
	KBC_action_frequency_set(1.0)
}

