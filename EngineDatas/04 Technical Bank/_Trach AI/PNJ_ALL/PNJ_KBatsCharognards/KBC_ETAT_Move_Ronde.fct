#include "KBC_defines.var"

object			to_next_next_wp

messageid		tmid_vision

vector			tv_sens_paf


// SORTIE ETAT
if (i_sort_etat)
{
	i_flag_reseau_oneway = faux
	i_calc_net_apres_mashing = faux
	KBC_action_frequency_set(1.0)	// reset for bigbat
	
	i_sort_etat = faux
	return
}

// ENTREE ETAT
if (i_etat_courant != ETAT_Move_Ronde)
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Move_Ronde
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KBC_DBG_Trace(i_DBG_trace_etat, "etat move ronde")
	
	i_ronde_slow_down = faux
	
	// vitesse
	KBC_action_frequency_set(1.0)
	if( i_KONG_ride_walling_bat )
		KBC_ref_speed_set(f_KONG_ride_walling_bat_speed)
	else if( MSG_GlobalIsValid(mid_grab_charogne) )
	{
		KBC_ref_speed_set(f_vitesse_move_grab)
	}
	else
	{
		// ronde standard
		KBC_ref_speed_set(f_vitesse_move_ronde)
		if( i_big_bat )
		{
//			if( i_calc_net_apres_mashing )
//			{
				KBC_ref_speed_set(10.0)
				KBC_action_frequency_set(3.0)
//			}
//			else
//			{
//				KBC_ref_speed_set(f_vitesse_move_ronde)
//				KBC_action_frequency_set(0.5)
//			}
		}
	}
	
	// next WP
	if( i_etat_ancien != ETAT_Move_Decolle )
	{
		if( i_calc_net_apres_mashing )
			o_ronde_next_wp = WAY_WPNearestOfPos(OBJ_PosGet(), net_idle, CAPA_WP_depart_apres_mashing, none, Ci_Filter_CapaFlag)
		else
			o_ronde_next_wp = WAY_WPNearestOfPos(OBJ_PosGet(), net_idle, all, CAPA_WP_depart_apres_mashing, Ci_Filter_CapaFlag)
		@o_tmp_obj_next OBJ_PosSet(@o_ronde_next_wp OBJ_PosGet())
		o_next_wp = o_tmp_obj_next
	}
	
	// suivi du réseau (exec_vol_courbe)
	i_flag_reseau_oneway = vrai
	n_reseau = net_idle
	
	// destination
	v_dest_pos = @o_next_wp OBJ_PosGet()
	v_cible_pos = Cv_NullVector
	
	// suivi du regard
	to_next_next_wp = KBC_WAY_NetNextWP(net_idle, o_ronde_next_wp, 0, 0)
	if( ! to_next_next_wp )
		to_next_next_wp = o_ronde_next_wp		// blindage IA pour les conneries LD.... net_idle doit etre cyclique...
	
	v_look_pos = @to_next_next_wp OBJ_PosGet()
	
	// orientation wp arrivée ronde
	@o_tmp_obj_next OBJ_BankingGeneralSet(@to_next_next_wp OBJ_PosGet() - @o_ronde_next_wp OBJ_PosGet(), Cv_VerticalVector)
	o_next_reacheable_wp_backup = o_ronde_next_wp
	

	i_force_test_inclinaison = vrai
	i_pause_mode = Ci_pause_mode_aucun		// raz mode pause
	i_paf_send = faux
}
else
{
	f_time_start_etat += TIME_GetDt()
	if( i_bigbat_AttackSequenceReady && ! i_ronde_slow_down && f_time_start_etat > 5.0 && ! MSG_GlobalIsValid(mid_grab_charogne) )
	{
		// réduire la vitesse de ronde de la big bat pour le fight
		i_ronde_slow_down = vrai
		i_calc_net_apres_mashing = faux		// c'ets bon je me suis éloigné
		KBC_ref_speed_set(f_bigbat_idle_speed)
		KBC_action_frequency_set(0.5)
	}
}


// ANALYSE ===========================================================================================
MACRO_CHECK_PAFS

if( ! MSG_GlobalIsValid(mid_grab_charogne) 
	&& ! JOUR_NUIT_HeureCorrecte(f_Heure_Debut, f_Heure_Fin) )
	AI_Execute("KBC_exec_init_attente")

o_cadavre = KBC_Cadavre_Nearest(faux)
if( o_cadavre ) 
{
	KBC_Cadavre_Nouveau_Select(o_cadavre)		// marqué comme "visité"
	KBC_Interet_Update(mid_interet_charogne, C_EVENT_InteretStatusFoodchainLocked, o_cadavre, tmid_vision)
	macro_change_etat("KBC_ETAT_Move_Cadavre")
}


if( ! MSG_GlobalIsValid(mid_grab_charogne) 
	&& KBC_Test_Attaque() 
	&& f_time_since_last_obstacle >= Cf_delai_since_last_obstacle_pour_attaque )
{
	if( ! i_attaque_a_partir_de_la_ronde )
		AI_Execute("KBC_exec_init_attaque")		// la bat va se positionner pour attaquer
}
else if( ! MSG_GlobalIsValid(mid_grab_charogne) && o_cible_attaque )
{
	// la bat reste en ronde jusqu'à prendre l'intérêt sur la proie
	if( KBC_Get_Interet_Status_Model_Nb(o_cible_attaque, -1, vrai) < i_nb_attaques_simultanees )
	{
		i_flag_reserve_interet = vrai
		AI_Execute("KBC_exec_init_attaque")
	}
}

if( i_flag_reserve_interet )
	KBC_Interet_Update(mid_interet_attaque, C_EVENT_InteretStatusLock, o_cible_attaque, tmid_vision)

//if( o_big_bat_target )
//	KBC_Interet_Update(mid_interet_attaque, C_EVENT_InteretStatusLock, o_big_bat_target, tmid_vision)


KBC_select_action()
//if( KBC_select_action() )
//	KBC_action_frequency_set(Cf_freq_standard)

if( ! f_time_cri_presence )
	KBC_Sound_Cri_Presence_Play()

i_flag_neck = vrai

// Déplacement
i_flag_frein = faux
AI_Execute("KBC_exec_MOVE_beziers")
if( i_flag_depl_fini )
{
	// ignorer le wp de pause si j'ai la capa "décolle"
	if( i_pause_mode == Ci_pause_mode_atterrissage && OBJ_CapaTest(CAPA_Decolle) )
	{
		DBG_TraceString("************** ")
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" didn't take care of ")
		DBG_TraceObject(o_wp_pause)
		DBG_TraceString(" because if already has capa 0 *************** ")
		DBG_TraceEOL()
		
		i_pause_mode = Ci_pause_mode_aucun
		OBJ_CapaSet(0, CAPA_Decolle)
		o_next_wp = o_ronde_next_wp
	 	o_next_wp = KBC_WAY_NetNextWP(n_reseau,  o_next_wp , 0, 0)
	 	o_next_reacheable_wp_backup = o_next_wp
	}
	//----------------------------------------------------------------------------------------------------------------------------
	if( i_pause_mode == Ci_pause_mode_atterrissage)
	{
		// La bat vient d'atteindre un wp ou elle doit faire une pause
		i_atterrissage_mode = Ci_atterrissage_nid_pause
		macro_change_etat("KBC_ETAT_Move_Atterrit")
	}
	else if( i_pause_mode == Ci_pause_mode_on_y_va )
	{
		// c'est bientôt la pause : init suivi de regard
		v_look_pos = @o_wp_pause OBJ_PosGet()
	}
	else if( i_pause_mode == Ci_pause_mode_aucun)
	{
		// c'est pas encore la pause : init suivi de regard
		to_next_next_wp = KBC_WAY_NetNextWP(n_reseau, o_next_wp, 0, 0)
		if( to_next_next_wp )		// réseau pas terminé !!!
			v_look_pos = @to_next_next_wp OBJ_PosGet()
		else
			v_look_pos = @o_next_wp OBJ_PosGet()
	}
}

// release prey ? --------------------------------------------------------------------------------------------------------------------------------------------------------
if( o_cible && o_last_wp_backup && @o_last_wp_backup OBJ_CapaTest(CAPA_WP_Release_Grabbed_Actor) )
{
	o_cible = LNK_ServeurGet(Ci_LNK_GRAB_TRANSPORTE, mid_grab_charogne, faux, nofunc, nofunc)
	o_attack_interaction = LNK_ClientGet(Ci_LNK_INTERACTION, mid_attack_interaction_LKN_ID, faux, "KBC_exec_interaction_add_data", nofunc, "KBC_exec_interaction_init")
	f_release_grab_actor_keep_kamera = Cf_duree_just_release_keep_kamera
}


// Attaque sur KONG en ride walling ? ------------------------------------------------------------------------------------------------------------------------
if( KBC_Special_Ride_Walling_Attack_en_cours() )
{
	o_cible_attaque = o_Kong
	KBC_ZDE_Size_n_Pos()
	if( COL_ZDE_ZDECollide(o_cible_attaque, C_zde_fight, C_zde_corps) )
	{
		f_time_last_attaque = TIME_Get()
		SND_RequestPlay(Ci_SND_Envoie_Paf)		// son si paf ou ride
		tv_sens_paf = @o_cible_attaque OBJ_PosGet() - OBJ_PosGet()
		DBG_RenderVector( @o_cible_attaque OBJ_PosGet(), tv_sens_paf, color_rouge)
		i_paf_send = vrai
		v_paf_sent_position = OBJ_PosGet()					
		if( ! i_DBG_send_paf_OFF )
			EVENT_AddEventPaf( C_EVENT_FILTER_Enemy, i_paf_to_send_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_cible_attaque, Ci_dmg_attaque_air, tv_sens_paf )
		
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" paffe ")
		DBG_TraceObject(o_cible_attaque)
		DBG_TraceString(" (attack sur kong ride walling)")
		DBG_TraceEOL()
	}
}


if( i_bigbat_AttackSequenceReady 
	&& ! OBJ_CapaTest(CAPA_BigBat_attaque_possible) 
	&& ! f_bigbat_delai_no_attack
	&& ! OBJ_CapaTest(CAPA_BigBat_attaque_en_cours)
	&& ! MSG_GlobalIsValid(mid_grab_charogne)		// pas si j'ai Ann
	&& f_total_time > 1.0 )	// attention aux checkpoint 
{
	OBJ_CapaSet(CAPA_BigBat_attaque_possible, none)		// MANAGER
	KBC_DBG_Trace(i_DBG_trace_etat, "en ronde et ready for attack sequence => capa 6 on")
}

