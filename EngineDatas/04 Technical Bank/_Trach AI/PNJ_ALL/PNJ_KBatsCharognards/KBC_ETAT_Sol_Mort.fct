#include "KBC_defines.var"

message	tm_msg

int				ti_i
int				ti_cpt

object		tao_lray_bone[3]
object		to_ray_object

vector		tv_lray_pos
vector		tv_inclinaison


// SORTIE ETAT
if (i_sort_etat)
{
	i_sort_etat = faux
	return
}

// ENTREE ETAT
if (i_etat_courant != ETAT_Mort)
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Mort
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KBC_DBG_Trace(i_DBG_trace_etat, "etat sol mort")
	
	AI_Execute("KBC_exec_dyn_on")
	
	if( i_big_bat )
		ACT_ActionSet(ACTION_Finished_Mort)
	else if( i_mort_au_sol_sur_le_dos )
		ACT_ActionSet(ACTION_Mort_sur_le_dos)
	else
		ACT_ActionSet(ACTION_Mort)
	
	OBJ_Me().des_int1 = Ci_DISPLAY_NOTHING
	OBJ_InfoPhotoParamSet(0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0)
	
	v_paf_offset = Cv_NullVector
	
	if( f_time_mort == 0 )
	{
		// 1ère fois qu'on vient dans l'état mort
		EVENT_LIFE_CurLifeSet(ID_LIFE, 0.0)
		//SND_RequestPlay(Ci_SND_Cri_Mort)
		OBJ_CapaSet(CAPA_Dead_on_Ground, none)
		OBJ_CapaSet(CAPA_Dead, none)
	}
	
	if( MSG_GlobalIsValid(mid_interet_attaque) )
		MSG_GlobalDelete(mid_interet_attaque, C_EVENT_EOFDEL)
	
	// exécution des trig exec de la mort
	if( ! i_TrigExecMort_done )
	{
		i_TrigExecMort_done = vrai		// ne pas le faire à chaque fois qu'on revient dans cet état (bat grabbées...)
		for(ti_i = 0; ti_i < Ci_trigexec_max_nb; ti_i++ )
		{
			if( AI_TriggerIsValid(aTrigExecMort[ti_i]) )
				call_trigger(aTrigExecMort[ti_i])
		}
	}
}
else
{
	f_time_start_etat += TIME_GetDt()
	
	if( ! i_big_bat )		// pas pour la big bat
	{
		// le timer de mort avance si personne n'a d'intéret sur la bat
//		if( ! KBC_Get_Interet_Status_Model_Nb(OBJ_Me(), -1, faux) )
//			f_time_mort += TIME_GetDt()			

		if( ! KBC_Get_Interet_Status_Model_Nb(OBJ_Me(), C_EVENT_InteretStatusFoodchain, faux)
		&& ! KBC_Get_Interet_Status_Model_Nb(OBJ_Me(), C_EVENT_InteretStatusFoodchainLocked, faux) )
			f_time_mort += TIME_GetDt()			
		
		// test  position stable ?
		if( ! i_splash_flag )
		{
			if( ! i_ground_lray_test_done )
			{
				i_ground_lray_test_done = vrai
				ti_cpt = 0
				tao_lray_bone[0] = ANI_CanalObjectGet(Anim_Canal_Cou)
				tao_lray_bone[1] = ANI_CanalObjectGet(Anim_Canal_Bassin)
				tao_lray_bone[2] = ANI_CanalObjectGet(Anim_Canal_OrteilDroit)
				
				for( ti_i=0; ti_i < 3; ti_i++)
				{
					tv_lray_pos = @tao_lray_bone[ti_i] OBJ_PosGet() + (v_ground_normale * 0.5)
					DBG_RenderVector(tv_lray_pos, - v_ground_normale, color_rouge)
					to_ray_object = COL_RayObject_Dist(tv_lray_pos, - v_ground_normale, 1.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
					if( to_ray_object && to_ray_object != OBJ_Me() )
						ti_cpt++
				}
				
				if( ti_cpt != 3 )
				{
					// la bat n'est pas stable au sol
					f_time_mort = Cf_duree_mort
				}
			}
		}
	}
}


if (o_grabbed_actor)
{
	o_grabbed_actor = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong, vrai, nofunc, nofunc)
	if ( ! o_grabbed_actor)
	{
//		AI_CBDel(o_last_grabbed_actor, CallBack_After_Blend, "KBC_cb_set_pos")	
		AI_CBAdd(OBJ_Me(), CallBack_After_Blend, "KBC_cb_afterblend")
	}
}


// ANALYSE ======================================================================

AI_Execute("KBC_exec_check_paf")		// paf foodchain

//if( v_zdm_cur_size == Cv_ZDM_Sol )
{
	// la callback n'est efffacée qu'une fois que la ZDM est de la bonne taille
	AI_CBDel(OBJ_Me(), CallBack_After_Blend, "KBC_cb_afterblend")
	AI_CBDel(OBJ_Me(), CallBack_Info, "KBC_cb_info")
}


o_predateur = LNK_ServeurGet(Ci_LNK_GRAB_RAPTOR, mid_predateur, vrai, nofunc, nofunc)
if( o_predateur )
{
	macro_change_etat("KBC_ETAT_Grabbed_Predateur")
}


// COMPORTEMENT =====================================================================

i_flag_neck = faux

if( ! i_big_bat && ( f_time_mort >= Cf_duree_mort || ! f_point_de_viande ) )
	macro_change_etat("KBC_ETAT_Sol_Fade")

if( i_splash_flag )
	tv_inclinaison = Cv_VerticalVector
else if( ! MATH_VecNullEpsilon(v_ground_normale) )
	tv_inclinaison = v_ground_normale
else
	tv_inclinaison = Cv_VerticalVector
OBJ_BankingSet(MATH_VecBlendRotate(OBJ_BankingGet(), tv_inclinaison, 10.0 * TIME_GetDt()))

