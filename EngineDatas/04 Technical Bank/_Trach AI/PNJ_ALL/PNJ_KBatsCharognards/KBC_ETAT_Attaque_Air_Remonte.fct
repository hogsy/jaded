
#include "KBC_defines.var"

//=============================================================================
// LA BAT REMONTE SE POSITIONNER POUR PORTER UNE NOUVELLE ATTAQUE
//=============================================================================


// Axe d'attaque
vector				tv_axe_attaque		// axe de l'attaque reçue (perso -> bat)
vector				tv_normale				// normale entre l'axe de l'attaque reçue et la verticale, pour décaler la bat
vector				tv_temp


// SORTIE ETAT
if (i_sort_etat)
{
	GST_Climb_ActionFrequencyMultiply(1.0)		// fréquence du battement des ailes
	
	i_sort_etat = faux
	return
}

// ENTREE ETAT
if (i_etat_courant != ETAT_Attaque_Air_Remonte)
{
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Attaque_Air_Remonte
	
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	
	v_cible_pos = @o_cible_attaque OBJ_PosGet()
	
	// destination et suivi du regard
	if( ( ! i_nb_attaques ) || i_flag_obstacle )
	{
		// position de la toute 1ère attaque (ou après avoir rencontré un obstacle en attaquant)
		
		// calcul de la normale à l'impact
		tv_axe_attaque = OBJ_PosGet() - v_cible_pos
		MATH_VecSetHorzNormalize(tv_axe_attaque)
		tv_normale = MATH_VecCrossProduct(tv_axe_attaque, Cv_VerticalVector)
		tv_normale *= MATH_FloatSign( MATH_VecDotProduct(tv_normale, OBJ_SightGet() ) )	// choix de la normale selon son sens 
		MATH_VecNormalize(tv_normale)
		tv_normale *= 10.0
		
		tv_temp = OBJ_PosGet() + tv_normale		// point pour calculer l'axe de riposte
//		DBG_RenderVector( OBJ_PosGet(),  tv_temp - OBJ_PosGet(), color_bleu )
	
		v_decalage = decalage(tv_temp - v_cible_pos, 10.0, 10.0)
//		DBG_RenderVector( v_cible_pos,  v_decalage, color_vert )
		
		v_dest_pos = v_cible_pos + v_decalage
	}
	else
	{
		// position 2è ou 3è attaque : dans l'axe du sight du bat
		
		tv_normale = OBJ_SightGet()
		MATH_VecSetHorzNormalize(tv_normale)
		tv_temp = OBJ_PosGet() + (10.0 * tv_normale)		// point 1 : à 10m devant
//		DBG_RenderVector( OBJ_PosGet(),  tv_temp - OBJ_PosGet(), color_bleu )
		
		tv_normale = MATH_VecCrossProduct(tv_normale, Cv_VerticalVector)
		tv_normale *= MATH_FloatSign( MATH_VecDotProduct(tv_normale, OBJ_SightGet() ) )	// choix de la normale selon son sens 
		MATH_VecNormalize(tv_normale)
		tv_normale *= 10.0
//		DBG_RenderVector( tv_temp,  tv_normale, color_jaune )
		tv_temp += tv_normale		// point 2 : à 10m sur le côté du point 1 
		
		v_decalage = decalage(tv_temp - OBJ_PosGet(), 10.0, 10.0)		// axe de déplacement : pos bat -> point 2
//		DBG_RenderVector( OBJ_PosGet(),  v_decalage, color_vert )
		
		v_dest_pos = OBJ_PosGet() + v_decalage
	}
	// position wp
	@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
	
	// sight wp
	@o_tmp_obj_next OBJ_BankingGeneralSet(@o_cible_attaque OBJ_PosGet() - v_dest_pos, Cv_VerticalVector)	
	o_next_wp = o_tmp_obj_next
	
	// position et orientation last WP (infos courantes du bat au moment ou il se fait paffer pour effet smooth)
	@o_tmp_obj_last OBJ_PosSet(OBJ_PosGet())
	@o_tmp_obj_last OBJ_BankingGeneralSet(OBJ_SightGet(), OBJ_BankingGet())
	o_last_wp = o_tmp_obj_last
	
	// lien à parcourir
	f_link_coef = 0.0
	f_link_length = MATH_VecNorm(@o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet())
	
	f_ref_speed = Cf_speed_attaque
	
	ACT_ActionSet(ACTION_Vol)	
	
	i_flag_obstacle = faux
	
	GST_Climb_ActionFrequencyMultiply(2.0)		// fréquence du battement des ailes
}


v_look_pos = v_dest_pos
DBG_RenderVector( @o_last_wp OBJ_PosGet(), @o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet(), color_vert)


//======== MEMOIRE DU BAT ========

AI_Execute("KKBC_exec_get_interet_attaque")


// ======== DEPLACEMENT ==========

AI_Execute("KKBC_exec_vol_courbe")
if( i_flag_depl_fini )
{
	if( (i_nb_attaques == Ci_nb_attaques_max) || i_flag_attaque_success )
	{
		// le bat a réussi son attaque OU il a raté toutes ses attaques OU il a perdu son agresseur de vue => il repart
		i_nb_attaques = 0
		i_flag_attaque_success = faux
		i_agresseur_ID = -1
		o_cible_attaque = nobody
		AI_Execute("KKBC_exec_attente_choix")
	}
	else
		macro_change_etat("KKBC_ETAT_Attaque_Air_Plonge")		// le bat attaque
}

