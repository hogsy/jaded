#include "KBC_defines.var"

#define			Cf_vitesse_min		0.5

float		tf_dist
float		tf_ref_speed
float		tf_dist_a_kong
float		tf_dot


// CALCUL RESTRICTION SPEED ==================================================

//if( i_etat_courant == ETAT_Fight_Pause )
//	tf_dot = 1.0		// pas de réduction de vitesse pour revenir à la ronde après une attaque piqué
////else if( i_etat_courant == ETAT_Move_Network && (i_etat_ancien == ETAT_Fight_Pique_Remonte || i_etat_ancien == ETAT_Fight_Pause) )
//else if( i_etat_ancien == ETAT_Fight_Pique_Remonte || i_etat_ancien == ETAT_Fight_Pause )
//	tf_dot = 1.0		// pas de réduction de vitesse pour revenir à la ronde après une attaque piqué

//if( i_big_bat )
//	tf_dot = 1.0	
//else
	tf_dot = KBC_Move_Speed_Dot()

if( i_big_bat )
	tf_dot = MATH_FloatMax(0.75, tf_dot)

//tf_dot = 1.0
//tv_sight_horiz = OBJ_SightGet()
//tv_move_horiz = tv_sight_horiz		// par défaut, dot = 1.0
//
//switch( i_modele )
//{
//	case Ci_MODELE_Bat_Rouge :
//		goto CALCUL_SPEED
//		break
//
//	case Ci_MODELE_Bat_Grise :
//	case Ci_MODELE_Bat_Noire :
//
//		if( MATH_VecNullEpsilon(tv_sight_horiz) )
//			goto CALCUL_SPEED
//		MATH_VecSetNormalize(tv_sight_horiz)
//		// déplacement
//		if( i_etat_courant == ETAT_Fight_Contact )
//		{
//			// vers ma position d'attaque (retrait ou coup de griffe)
////			tv_move_horiz = v_dest_pos - OBJ_PosGet()
//			// pas de modif : par défaut, pas de frein dans cet état
//		}
//		else if( i_etat_courant == ETAT_Move_Atterrit )
//		{
//			tv_move_horiz = @o_next_wp OBJ_SightGet()
//		}
//		else if( i_speed_beziers_flag )
//		{
//			// vers mon next wp
//			i_speed_beziers_flag = faux
//			if( @o_next_wp OBJ_PosGet() != @o_last_wp OBJ_PosGet() )
//				tv_move_horiz = @o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet()
//		}
//		else if( i_speed_vertical_flag )
//		{
//			// décolle
//			i_speed_vertical_flag = faux
//			tv_move_horiz = v_dest_pos - OBJ_PosGet()
//		}
//		
//		if( MATH_VecNullEpsilon(tv_move_horiz) )
//			goto CALCUL_SPEED
//		MATH_VecSetNormalize(tv_move_horiz)
//		// dot
//		tf_dot = MATH_VecDotProduct(tv_sight_horiz, tv_move_horiz)
//		
//		if( i_modele == Ci_MODELE_Bat_Grise )
//		{
//			// BAT GRISE : coef de 0.5 à 1.0
//			tf_dot *=0.25
//			tf_dot += 0.75
//		}
//		else 
//		{
//			// BAT NOIRE : coef de 0.25 à 1.0
//			tf_dot += 1.0		// 0.0 -> 2.0
//			tf_dot *= 0.5		// 0.0 -> 1.0
//			tf_dot = MATH_FloatMax(tf_dot, 0.25)
//		}
//		break
//}		
//
// CALCUL SPEED ==============================================================
//CALCUL_SPEED:

tf_ref_speed = f_ref_speed * tf_dot 		// * f_sens_depl_vitesse_coef

if( i_flag_frein ) // && ! i_big_bat )
{
	// vitesse bornée en fonction de la distance restante
	tf_dist = MATH_VecNorm( v_dest_pos - OBJ_PosGet())
//	if( KBC_ReseauSoftColRayonOptimEnabled(i_etat_courant) )
//		tf_dist = MATH_FloatMax(0.0, tf_dist - f_softcol_rayon_current)			// la bat considère qu'elle a atteint le wp si son rayon de col molles l'a atteint
	
	tf_ref_speed = MATH_FloatMin(tf_ref_speed, tf_dist * 0.5 )
}

// vitesse forcée nulle ou vitesse min pour avancer ? -----------------------------------
if( o_next_reacheable_wp_backup && @o_next_reacheable_wp_backup OBJ_CapaTest(CAPA_WP_Vitesse_Nulle) )
	tf_ref_speed = 0.0
else
{
	if( i_etat_courant != ETAT_Fight_Contact )
		tf_ref_speed = MATH_FloatMax(tf_ref_speed, Cf_vitesse_min)		// vitesse min pour continuer à avancer

	// vitesse en fonction de la distance à KONG ? --------------------------------------------
	if( OBJ_CapaTest(CAPA_waits_for_KONG) )
	{
		switch( i_etat_courant )
		{
			case ETAT_Move_Atterrit :
			case ETAT_Move_Decolle :
				break
			default:
				tf_dist_a_kong = OBJ_SqrDistHorz(o_Kong)
				f_waits_for_KONG_dist_coef = KBC_GetSpeedDistCoef(f_waits_for_KONG_dist_go, f_waits_for_KONG_dist_stop, tf_dist_a_kong)
				tf_ref_speed *= f_waits_for_KONG_dist_coef
				break
		}
	}
}

// diminution accélération
if( MSG_GlobalIsValid(mid_grab_charogne) )
	f_speed_blend_coef = MATH_FloatMin(2.0, f_speed_blend_coef)

f_speed = MATH_FloatBlend(f_speed, tf_ref_speed, f_speed_blend_coef * TIME_GetDt())			// calcul d'une vitesse progressive

// vitesse coll molles
f_softcol_link_speed = MATH_FloatBlend(f_softcol_link_speed, f_ref_speed, f_speed_blend_coef * TIME_GetDt())

// raz coef
f_speed_blend_coef = Cf_coef_blend_speed_def

