#include "KBC_defines.var"

object		to_piedD
object		to_piedG
object		to_bone

vector 		tv_temp
vector		tv_pivot
vector		tv_X
vector		tv_Y

float			tf_aide_prio
float			tf_rayon
float			tf_coef

int				ti_i
int				ti_k
int				ti_target


// SUIVI DU REGARD =================
AI_Execute("KBC_exec_IK_neck")

// ZDE CORPS =======================
to_bone = ANI_CanalObjectGet(BAT_Canal_Torse)
tv_temp = @to_bone OBJ_PosGet() - OBJ_PosGet()
tv_temp = MATH_VecGlobalToLocal(tv_temp)
COL_ZonePosSet(C_zde_corps, tv_temp / f_zoom)

//if( i_big_bat_attack )
//	tf_rayon = Cf_rayon_corps_big_bat_attack
//else
//	tf_rayon = Cf_rayon_corps_bat
if( i_big_bat )
	tf_rayon = 1.0
else
	tf_rayon = 2.75 		//1.8 FRED: J'ai grossis pour que ce soit super tolerant.
COL_ZoneSizeSet(C_zde_corps, cvector(tf_rayon, tf_rayon, tf_rayon))


// GRAB ================================================================
to_piedD = ANI_CanalObjectGet(Anim_Canal_OrteilDroit)
to_piedG = ANI_CanalObjectGet(Anim_Canal_OrteilGauche)
tv_temp = @to_piedG OBJ_PosGet() - @to_piedD OBJ_PosGet()
v_grab_object_pos = @to_piedD OBJ_PosGet() + ( tv_temp / 2 )


// TARGET DE FIGHT ======================================================
ti_target = faux
if( EVENT_LIFE_CurLifeGet(ID_LIFE) )
{
	switch( i_etat_courant )
	{
		case ETAT_KK_Grabbed_by_Kong :
		case ETAT_KK_Ride :
		case ETAT_KK_Projectile :
		case ETAT_KK_Finish :
		case ETAT_KK_Finished :
			break
		
		default:
			ti_target = vrai
			break
	}
}
if( ti_target )
{
	if( o_Jack && MSG_GlobalIsValid(mid_grab_charogne) && o_cible == o_Jack )
		tf_aide_prio = C_AIDE_AU_TIR_Prio_GrabAnn
	else if( o_Jack && o_cible_attaque == o_Jack )
		tf_aide_prio = C_AIDE_AU_TIR_Prio_AttackAnn
	else
		tf_aide_prio = C_AIDE_AU_TIR_Prio_Ennemi
	Proc_KongFight_TargetAdd(OBJ_Me(), COL_ZonePosGet(C_zde_corps), COL_ZoneSizeGet(C_zde_corps),  tf_aide_prio, 0)
}


// PAFS QUATERNION ==========================================================================
tv_pivot = @o_torse OBJ_PosGet()
tv_temp = @o_torse MATH_VecGlobalToLocal(@o_bassin OBJ_PosGet() - tv_pivot)

for (ti_i = 0; ti_i < 10; ti_i++)
{
	ti_k = MATH_Modulo(i_quat_index + ti_i, 10)

	if (af_quat_time[ti_k] == -1.0)
		continue	

	tf_coef = TIME_Get() - af_quat_time[ti_k]
	if (tf_coef < 1.0)
	{
		tf_coef = MATH_FloatMin(tf_coef * 10.0, 1.0) * (1.0 - tf_coef)

		tv_X = @o_bassin MATH_VecGlobalToLocal(av_quat_start[ti_k])
		tv_Y = @o_bassin MATH_VecGlobalToLocal(av_quat_end[ti_k])
		if( ! EVENT_LIFE_CurLifeGet(ID_LIFE) )
			tf_coef = MATH_FloatMin(tf_coef, 0.25)
		@o_bassin OBJ_Rotate_FromTo(tv_X, MATH_VecBlend(tv_X, tv_Y, tf_coef * af_quat_coef[ti_k]))
	}
	else
	{
		af_quat_time[ti_k] = -1.0
	}
}
// ON REPOSITIONNE LE BASSIN QUI A TOURNE AUTOUR DU PIVOT ----------------
tv_temp = @o_torse MATH_VecLocalToGlobal(tv_temp)
tv_temp += tv_pivot
@o_bassin OBJ_PosSet(tv_temp)	
tv_temp = tv_temp

