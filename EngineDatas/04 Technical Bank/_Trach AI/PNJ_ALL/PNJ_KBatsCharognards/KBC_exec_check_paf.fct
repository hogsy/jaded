#include 		"KBC_defines.var"

int					ti_paf_rank				// Rang du paf dans la liste
int					ti_cur_paf_canal		// localisation du paf
int					ti_cur_paf_type
int					ti_dbg
int					ti_saigne
int					ti_ko
int					ti_nmi
int					ti_mng_info
int					ti_g_pris_1_paf
int					ti_paf_qui_me_tue
int					ti_skip_multiplicateur

messageid		tmid_paf_ID				// ID du paf

message		tmsg_paf_filter			// Message filtre pour la lecture de la liste

float				tf_cur_paf_force_init			// dégats du paf courant (valeur init)
float				tf_cur_paf_force_modif			// dégats du paf courant (valeur modifiée)
float				tf_best_paf_force		// dégats du + gros paf
float				tf_recul_coef
float				tf_HP_init
float				tf_life
float				tf_sum_pafs_force								// dégats des pafs de la trame

object			to_cur_paf_pere		// père du paf
object			to_javelin
object			to_head

vector			tv_temp1
vector			tv_temp2
vector			tv_cur_paf_dir			// recul du paf
vector			tv_pos
vector			tv_dir
vector			tv_sight
vector			tv_me_to_Kong
vector			tv_sum_pafs_dir			// vecteur de recul des pafs de la trame
vector			tv_cur_paf_pos
vector			tv_best_paf_pos

//===========================================================
// Détection des pafs qui ont touché le bat
//===========================================================

if( i_flag_check_paf_done )
	return
	
// raz var globales -------------------
i_flag_check_paf_done = vrai
i_paf_type = 0
o_best_paf_pere = nobody
o_best_paf_pere_enabled = nobody
i_paf_change_etat_flag = faux
i_paf_rotate_flag = faux

// raz var temporaires --------------
ti_dbg = faux
ti_g_pris_1_paf = faux
ti_paf_qui_me_tue = faux
tf_sum_pafs_force = 0.0
tv_sum_pafs_dir = Cv_NullVector
tf_best_paf_force = 0.0
tf_HP_init = EVENT_LIFE_CurLifeGet(ID_LIFE)

MSG_SetNull( tmsg_paf_filter)
tmsg_paf_filter.msg_gao1 = OBJ_Me()
ti_paf_rank = -1
for (	tmid_paf_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_paf_rank, tmsg_paf_filter);
		MSG_GlobalIsValid(tmid_paf_ID);
		tmid_paf_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_paf_rank, tmsg_paf_filter) )
{
	ti_skip_multiplicateur = faux
	tf_cur_paf_force_init = EVENT_PafPuisGet(tmid_paf_ID) * PAF_Unit
	if( i_etat_courant == ETAT_KK_Finish )
	{
		if( @get_Kong_Path o_Kong i_mode_mort )
			continue		// too late...
		else
		{
			tf_cur_paf_force_init = tf_HP_init		// doit tuer la bat !!!!
			ti_skip_multiplicateur = vrai
		}
	}
	to_cur_paf_pere = EVENT_PereGet(tmid_paf_ID)
	ti_cur_paf_canal = EVENT_PafCanalGet(tmid_paf_ID)
	ti_cur_paf_type = EVENT_PafTypeGet(tmid_paf_ID)				// cumul des filtres de tous les pafs de la trame
	tv_cur_paf_pos = EVENT_PafPositionGet(tmid_paf_ID)
	
	// ignorer les pafs viande reçus par erreur =======================================
	if( ti_cur_paf_type & C_PAF_KK_FoodChain ) 
	{
		if( tf_HP_init > 0.0 )		// ceux reçus alors qu'on n'est pas encore mort
			continue
		switch( i_etat_courant )
		{
			case ETAT_Mort :
			case ETAT_Grabbed_Predateur :
				break
			default:
				// ceux reçus alors qu'on n'est ni mort au sol ni grabbé par un prédateur
				continue
		}
	}
	
	// ignorer certains pafs de kong sur la big bat =================================================
	if( i_big_bat && o_Kong && to_cur_paf_pere == o_Kong )
	{
		if( @o_Kong Proc_KK_JumpStatusGet() )	// 0 = On n'est pas en Jump // 1 = On est en Implusion Jump // 2 = On est dans la courbe de saut. // 3 = On est en reception de saut
			continue
		switch( i_etat_courant )
		{
			case ETAT_BigBat_Fight_Plonge :
			case ETAT_BigBat_Fight_Dodged :
				tv_me_to_Kong = @o_Kong OBJ_PosGet() - OBJ_PosGet()
				tv_me_to_Kong.z = 0.0
				MATH_VecSetNormalize(tv_me_to_Kong)
				tv_sight = OBJ_SightGet()
				tv_sight.z = 0.0
				MATH_VecSetNormalize(tv_sight)
				if( MATH_VecDotProduct(tv_sight, tv_me_to_Kong) < 0.0 && OBJ_SqrDist(o_Kong) > 49 ) // je suis dans le dos de kong & je suis trop loin derrière kong
					continue
				break
		}
	}
	
	// SENS DU PAF =====================================================================
	if( o_Kong && to_cur_paf_pere == o_Kong )
	{
		tv_cur_paf_dir = OBJ_PosGet() - @to_cur_paf_pere OBJ_PosGet()
		tv_temp1 = tv_cur_paf_dir
		tv_temp1.z = 0
		if ( ! MATH_VecNullEpsilon( tv_temp1))
			MATH_VecSetNormalize(tv_temp1)		
		else
			tv_temp1 = OBJ_SightGet()
		tv_temp2 = MATH_VecCrossProduct(Cv_VerticalVector, tv_temp1)
		tv_cur_paf_dir = MATH_VecRotate(tv_temp1, tv_temp2, - Cf_PiBy8)
		MATH_VecSetNormalize(tv_cur_paf_dir)
	}
	else
	{
		tv_cur_paf_dir = EVENT_PafDirGet(tmid_paf_ID)
		if( tv_cur_paf_dir.z < 0.0 )
			tv_cur_paf_dir.z = 0.0	// interdit les pafs qui font tomber
		if( ! MATH_VecNullEpsilon(tv_cur_paf_dir) )
			MATH_VecSetNormalize(tv_cur_paf_dir)
		else
			tv_cur_paf_dir = - OBJ_SightGet()		// blindage, le - pire...
	}
	
	if( KBC_Take_Paf() )
	{
		// quitte la ciné
		i_CineStack = 0
		OBJ_CapaSet(CAPA_CINE_Terminee, none)
		
		// lacher ANN
		if( MSG_GlobalIsValid(mid_grab_charogne) )
			o_cible = LNK_ServeurGet(Ci_LNK_GRAB_TRANSPORTE, mid_grab_charogne, faux, nofunc, nofunc)
		
		// le paf repousse de l'écrasement de la big bat doit tuer les petites bats
		if( ! i_big_bat && (ti_cur_paf_type & C_PAF_KK_Repousse) && o_Kong && to_cur_paf_pere == o_Kong && @o_Kong Proc_KK_Test_Mode(ETAT_Kong_finish) )
			ti_cur_paf_type = C_PAF_KK_Moyen
		
		// DOMMAGES ===================================================================
		tf_cur_paf_force_modif = tf_cur_paf_force_init
		if( ti_cur_paf_type & C_PAF_KK_FoodChain )
		{
			// paf viande
			f_time_meat_bite += 0.25
			f_point_de_viande -= MATH_FloatMin(f_point_de_viande, tf_cur_paf_force_init)
		}
		else
		{
			// paf dommages
			if( i_big_bat && tf_cur_paf_force_init > 100.0 )
			{
				// blindage : un head shot sniper sur la bat noire = 20 dmg
				tf_cur_paf_force_modif = 20.0
			}
			else if( ti_cur_paf_type & C_PAF_KK_Repousse )
			{
				// repousse = on force 0 dmg
				tf_cur_paf_force_modif = 0.0
			}
			else if( ti_cur_paf_type & C_PAF_KK_Ecrasement )
			{
				// ecrase = tue les petites bats
				if( ! i_big_bat )
					ti_cur_paf_type |= C_PAF_KK_KiTue
			}
			else if( o_Jack && to_cur_paf_pere == o_Jack )
			{
				// multiplicateurs de dmg pour Jack
				if( ! ti_skip_multiplicateur )
				{
					switch( ti_cur_paf_canal )
					{
						case Anim_Canal_Tete  :
							if( ! i_big_bat )
								tf_cur_paf_force_modif *= 2.0
							break
						case BAT_Canal_AileDroite :
						case BAT_Canal_AileGauche :
							tf_cur_paf_force_modif *= 0.5
							break
					}
				}
			}
			// On soustrait les dmg aux HP
			if( MSG_GlobalIsValid(ID_LIFE) )
			{
				if (ti_cur_paf_type & C_PAF_KK_KiTue)
					EVENT_LIFE_CurLifeSet(ID_LIFE, 0.0)
				else
					EVENT_LIFE_LifeChange(ID_LIFE, tf_cur_paf_force_modif)
			}
		}
		
		if( i_DBG_trace_etat )
		{
			DBG_TraceObject(OBJ_Me())
			DBG_TraceString(" : prend un paf de ")
			DBG_TraceObject(to_cur_paf_pere)
			DBG_TraceString(" qui fait ")
			DBG_TraceFloat(tf_cur_paf_force_init)
			DBG_TraceString(" -> ")
			DBG_TraceFloat(tf_cur_paf_force_modif)
			DBG_TraceString(" dmg (hp init = ")
			DBG_TraceFloat(tf_HP_init)
			DBG_TraceString(")")
			DBG_TraceEOL()
		}
		if( tf_cur_paf_force_modif == 2.5 )
			tf_cur_paf_force_modif = tf_cur_paf_force_modif
		
		i_paf_type |= ti_cur_paf_type				// cumul des filtres de tous les pafs de la trame
		
		// JAVELOT
		if( ti_cur_paf_type & C_PAF_KK_Javelin )
		{
			switch(ti_cur_paf_canal)
			{
				case Anim_Canal_PiedGauche :
				case Anim_Canal_PiedDroit :
				case BAT_Canal_AileGauche :
				case BAT_Canal_AileDroite :
					break
				default:
					// dans le cas d'un paf par lance, l'objet lance est stocké dans le gao2 du message correspondant
					to_javelin = EVENT_Gao2Get(tmid_paf_ID)
					macro_set_javelin_plug_timer(to_javelin, 2.5)
					break
			}
		}
		
		// REPOUSSE ou CUMUL DMG ---------------------------------
		if( ti_cur_paf_type & C_PAF_KK_Repousse )
		{
			i_paf_repousse_flag = vrai
			if( ! i_big_bat )
			{
				// mon attaque courante ne paffera plus car je me suis fais repousser
				i_paf_send = vrai
				f_wait_sinus_duration = 0.3
			}
		}
		else
			KBC_Paf_Cumul_Add(tf_cur_paf_force_modif)
		
		// COEF DE RECUL =============================
		if( tf_HP_init > 0.0 )
		{
			if( i_big_bat && EVENT_LIFE_CurLifeGet(ID_LIFE) <= 0.0 )
				tf_recul_coef = 2.0		// ne pas sortir de l'arène pour subir le finish !!!!!
			else
				tf_recul_coef = KBC_PafReculGet(ti_cur_paf_type, to_cur_paf_pere) 
		}
		else
			tf_recul_coef = 0.0
	}
	
	if( tf_best_paf_force <= tf_cur_paf_force_modif )
	{
		tf_best_paf_force = tf_cur_paf_force_modif
		o_best_paf_pere = to_cur_paf_pere
		if( KBC_Gao_in_Territory(to_cur_paf_pere, faux) )
			o_best_paf_pere_enabled = to_cur_paf_pere
	}
	
	// cumul des pafs
	tf_sum_pafs_force += tf_cur_paf_force_modif
	tv_sum_pafs_dir += tv_cur_paf_dir * tf_recul_coef
	DBG_RenderVector(OBJ_PosGet(), tv_sum_pafs_dir, color_rouge)
	
	if( o_Kong && to_cur_paf_pere == o_Kong )
	{
		i_paf_rotate_flag = vrai	// effet punch de kong
		if( KBC_Pafs_Effects_Check(ti_cur_paf_type) )
			@o_Kong Proc_KK_Pafs_Effects(faux)
	}
	
	// BIG BAT MANAGER
	ti_mng_info = faux
	if( i_big_bat && o_Kong && to_cur_paf_pere == o_Kong && o_bigbat_manager && (@o_bigbat_manager OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Active) )
	{
		// ne tenir compte que des pafs de Kong pour le manager (pas ceux de Ann)
		tf_life = EVENT_LIFE_CurLifeGet(ID_LIFE)
		ti_nmi = @o_Kong Proc_KK_Get_BIG_NMI_Count(OBJ_Me())
		if( tf_life > 0.0 )
			ti_mng_info = vrai
		else if( ti_nmi > 0 ) // && ! OBJ_CapaTest(CAPA_0HP) )
			ti_mng_info = vrai		// informe le manager de son finish mais pas des pafs reçus par la suite
		if( ti_mng_info )
		{
			// comptabiliser le paf (pour le spawner) si c'est un paf qui me fait pas passer en agonie ou s'il y a une autre big bat
			KBC_BigBat_AttackIncCpt()		// attaque compabilisée (retourner en attente pour un autre msg)
			if( ! ( ti_cur_paf_type & C_PAF_KK_Repousse ) )
				@o_bigbat_manager KBM_BigBat_Paffee(i_bigbat_manager_index)		// j'ai été paffée (-> lance les small bats ?)
		}
	}
	
	// QUATERNION POUR CHAQUE PAF
	PAF_FEEDBACK:
	if( TIME_Elapsed(f_quat_last_time, 0.15) )
	{
		if( ti_cur_paf_type & C_PAF_KK_FoodChain )
			af_quat_coef[i_quat_index] = 0.1
		else if (TIME_Elapsed(f_quat_last_time, 0.5))
			af_quat_coef[i_quat_index] = 0.5
		else
			af_quat_coef[i_quat_index] = 0.3
		
		f_quat_last_time = TIME_Get()
		af_quat_time[i_quat_index] = f_quat_last_time
		
		av_quat_start[i_quat_index] = tv_cur_paf_pos
		av_quat_start[i_quat_index] -= @o_torse OBJ_PosGet()
		MATH_VecSetNormalize(av_quat_start[i_quat_index])
		
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(tv_cur_paf_dir, av_quat_start[i_quat_index])
		av_quat_end[i_quat_index] = MATH_VecCrossProduct(av_quat_start[i_quat_index], av_quat_end[i_quat_index])
		
		MATH_VecSetNormalize(av_quat_end[i_quat_index])
		
		i_quat_index = MATH_Modulo(i_quat_index + 1, 10)
	}
	
	// flag mémo pafs
	ti_g_pris_1_paf = vrai

	if( tf_HP_init > 0.0 && EVENT_LIFE_CurLifeGet(ID_LIFE) <= 0.0 )
		ti_paf_qui_me_tue = vrai
}



// si j'ai pris au moins 1 paf ===================================================
if( ti_g_pris_1_paf )
{
	if( ! KBC_Take_Paf() )
	{
		// je suis censé être insensible ? j'annule les pafs après avoir fait les feedbacks
		SND_RequestPlay(Ci_SND_Paf_Petit)
		o_best_paf_pere = nobody
		o_best_paf_pere_enabled = nobody
		i_paf_type = 0
	}
	else
	{
		i_interaction_Ann_fake_paf = faux
		
		ti_saigne = faux
		if( ti_paf_qui_me_tue )
			ti_saigne = vrai
		else if( tf_HP_init > 0.0 && ! i_paf_repousse_flag )
			ti_saigne = vrai
		if( ti_saigne )
		{
			if( o_Kong && o_best_paf_pere == o_Kong )
			{
				if( i_etat_courant == ETAT_KK_Grabbed_by_Kong )
				{
					tv_pos = v_grabbed_pos
					tv_dir = v_grabbed_pos - @o_Kong OBJ_PosGet()
				}
				else
				{
					tv_pos = OBJ_PosGet() + (OBJ_SightGet() * - 0.1 ) + (OBJ_BankingGet() * 0.3 ) 
					tv_dir = tv_sum_pafs_dir
				}
				if( ! MATH_VecNullToler(tv_dir, 0.1) )
					MATH_VecSetNormalize(tv_dir)
				else
					tv_dir = - OBJ_SightGet()
				DBG_RenderVector(tv_pos, tv_dir * 5, color_cyan)
				KBC_GFX_Particules_PafDeKong(tv_pos, tv_dir)
			}
//			else
//			{
//				BC_GFX_Particules_PafDeJack(tv_cur_paf_pos, tv_sum_pafs_dir)
//			}
		}
		
		// SOUND
		if( ti_paf_qui_me_tue )
		{
			SND_RequestPlay(Ci_SND_Cri_Mort)
			
			if( ! i_big_bat )		// la big bat inc les stats dans le finish
				KBC_STATS_NMI_Killed(o_best_paf_pere)
			i_obbox_on = faux		// on suppr les obbox des ailes
			f_obbox_size_coef = 0.8	// on diminue la taille des autres obbox
			AI_Execute("KBC_exec_set_obbox")
			
			if( i_etat_courant == ETAT_Wait_Perche )		// Une bat perchée qui est paffée crie pour réveiller les bats alentour si elle ne meurt pas sur le coup
				EVENT_AddEventSound(C_EVENT_FILTER_BatCharognard, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet(), 30.0)
		}
		else if( ! ( i_paf_type & C_PAF_KK_FoodChain ) )
		{
			// ne pas crier sur un paf foodchain
			if( o_Kong && o_best_paf_pere == o_Kong )
				SND_RequestPlay(Ci_SND_Paf_Kong_Hit)
			else if( tf_sum_pafs_force > ( EVENT_LIFE_MaxLifeGet(ID_LIFE) * 0.5 ) )
				SND_RequestPlay(Ci_SND_Paf_Gros)
			else
				SND_RequestPlay(Ci_SND_Paf_Petit)
		}
		
		if( ti_paf_qui_me_tue )
			i_paf_change_etat_flag = vrai			// paf qui me tue -> jouer une anim -> changer d'état
		if( KBC_Paf_Cumul_Check_Cumul() )
			i_paf_change_etat_flag = vrai			// paf assez fort pour jouer une anim -> changer d'état
		
		i_force_test_inclinaison = vrai			// force le test de l'inclinaison de la courbe entre ma position et le point que je choisi pour partir
		
		// APPLICATION DU RECUL ==============================
		switch( i_etat_courant )
		{
			case ETAT_KK_Grabbed_by_Kong :
			case ETAT_Grabbed_Predateur :
				break
			default:
				v_paf_offset += tv_sum_pafs_dir
				f_paf_offset_coef = 0.0
				break
		}
		
		// BACKUP DIRECTION DU PAF POUR S'ORIENTER PENDANT LA CHUTE ========
		v_last_paf_sight = tv_sum_pafs_dir
		v_last_paf_sight.z = 0.0
		if( ! MATH_VecNullEpsilon(v_last_paf_sight) )
			MATH_VecSetNormalize(v_last_paf_sight)
		else
			v_last_paf_sight = - OBJ_SightGet()		// le - pire....
		DBG_RenderVector(OBJ_PosGet(), v_last_paf_sight * 10, color_vert)
		
//		i_DBG_trace_etat = 1
	}
}

