#include "KBC_defines.var"

vector		tv_sight
vector		tv_normale

int				ti_plafond
int				ti_orientation


// SORTIE ETAT
if (i_sort_etat)
{
	i_flag_frein = faux
	i_force_test_inclinaison = vrai
	f_speed = 0.0
	i_big_bat_attack_decolle = faux
	
	i_sort_etat = faux
	return
}

// ENTREE ETAT
if (i_etat_courant != ETAT_Move_Decolle )
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Move_Decolle
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KBC_DBG_Trace(i_DBG_trace_etat, "etat move decolle")
	
	if( MSG_GlobalIsValid(mid_grab_charogne) )
		ACT_ActionSet(ACTION_Vol_Proie)							// le bat transporte une charogne
	else
		ACT_ActionSet(i_ACTION_Vol_Standard)						// le bat ne transporte pas de charogne

	// le bat se rend en vol direct au-dessus de lui (mais ne tourne pas la tête)
	v_cible_pos = Cv_NullVector
	if( i_envol_palier )
	{
		if( i_envol_palier == 1 )
			v_decalage = cvector(0.0, 0.0, Ci_envol_palier_1st) * OBJ_ZoomGet()
		else
			v_decalage = cvector(0.0, 0.0, Ci_envol_palier_autre) * OBJ_ZoomGet()
	}
	else if( i_big_bat )
		v_decalage = cvector(0.0, 0.0, 3.5 * OBJ_ZoomGet())
	else
		v_decalage = cvector(0.0, 0.0, 2.0 * OBJ_ZoomGet())
	v_dest_pos = OBJ_PosGet() + v_decalage
	
//	if( MSG_GlobalIsValid(mid_grab_charogne) )
//	{
//		o_next_wp = WAY_WPNearestOfPos( OBJ_PosGet(), net_idle, all, none, Ci_Filter_CBitsFlag)
//		if( o_next_wp == o_last_wp_backup )
//			o_next_wp = WAY_NetNextWP(net_idle, o_next_wp, all, none)		// ne pas regarder le wp d'où je décolle mais le suivant
//	}
	
	if( i_etat_ancien != ETAT_Fight_Contact )
		f_speed = 0.0
	
	if( i_big_bat && i_big_bat_attack_decolle )
	{
		KBC_ref_speed_set(4.0)
		KBC_action_frequency_set(2.0)
		i_flag_frein = faux
	}
	else if( i_etat_ancien == ETAT_Move_Atterrit )
	{
		KBC_ref_speed_set(10.0)
		KBC_action_frequency_set(1.0)
		i_flag_frein = faux
	}
	else if( MSG_GlobalIsValid(mid_grab_charogne) )
	{
		KBC_ref_speed_set(10.0)
		KBC_action_frequency_set(1.0)
		i_flag_frein = faux
	}
	else
	{
		KBC_reset_attaque()
		
		KBC_ref_speed_set(5.0)
		KBC_action_frequency_set(1.0)
		i_flag_frein = faux
	}
	
	DYN_Off()
	
	f_rot_blend_coef = 0.0				// coef de rotation du bat vers le réseau (grab transporte)
//	f_time_action = TIME_Get()		// le bat ne se tourne pas tout de suite
	
	i_flag_net_1st_move = vrai		// pour le calcul du wp cible du deplacement
	
	if( i_big_bat && i_big_bat_attack_decolle )
	{
		@o_tmp_obj_last OBJ_PosSet(OBJ_PosGet())
		@o_tmp_obj_last OBJ_BankingGeneralSet(OBJ_SightGet(), OBJ_BankingGet())
//		@o_tmp_obj_next OBJ_PosSet(OBJ_PosGet() + (3 * OBJ_SightGet()) + (5 * Cv_VerticalVector))
//		@o_tmp_obj_next OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
		tv_sight = MATH_VecNormalize(@o_big_bat_attack_wp OBJ_PosGet() - OBJ_PosGet())
		@o_tmp_obj_next OBJ_PosSet(OBJ_PosGet() + (3 * tv_sight) + (5 * Cv_VerticalVector))
		@o_tmp_obj_next OBJ_BankingGeneralSet(tv_sight, Cv_VerticalVector)
		o_cible_depl = o_tmp_obj_next
//		o_cible_depl = o_big_bat_attack_wp
	}
	else if( i_big_bat && MSG_GlobalIsValid(mid_grab_charogne) && o_wp_pause )
	{
		o_cible_depl = KBC_WAY_NetNextWP(net_idle, o_wp_pause, 0, 0)
		if( ! o_cible_depl )
			o_cible_depl = KBC_Choix_Cible_Deplacement_Calme()		// blindage réseau terminé ou changement de réseau
	}
	else if( ( i_etat_ancien == ETAT_Move_Atterrit ) && ( i_atterrissage_mode == Ci_atterrissage_nid_pause ) )
	{
		o_cible_depl = KBC_WAY_NetNextWP(net_idle, o_wp_pause, 0, 0)
		if( ! o_cible_depl )
			o_cible_depl = KBC_Choix_Cible_Deplacement_Calme()		// blindage réseau terminé ou changement de réseau
	}
	else
		o_cible_depl = KBC_Choix_Cible_Deplacement_Calme()				// raz pour le recalculer en décollant
	
	o_next_wp = o_cible_depl		// new new new 29 juin 2005
	o_next_reacheable_wp_backup = o_cible_depl
	
	if( i_big_bat )
	{
		if( ! i_big_bat_attack_decolle )		// crie pour une attaque pas parce qu'elle s'enfuit de kong en tenant ann
			SND_RequestPlay(Ci_SND_Decolle)
		if( i_etat_ancien == ETAT_Fight_Pause )
		{
			tv_sight = MATH_VecNormalize(@o_cible_depl OBJ_PosGet() - OBJ_PosGet())
			v_dest_pos += (5.0 * tv_sight )
		}
	}
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===========================================================================================
MACRO_CHECK_PAFS

// COMPORTEMENT ======================================================================

if( i_big_bat_attack_decolle )
{
	AI_Execute("KBC_exec_MOVE_beziers")
	if( i_flag_depl_fini )
	{
		o_cible_depl = o_big_bat_attack_wp
		o_next_wp = o_big_bat_attack_wp
		macro_change_etat("KBC_ETAT_Fight_Network")
	}
	
	// suivi du regard
	i_flag_neck = vrai
	v_look_pos = @o_big_bat_target OBJ_PosGet() } else {
	if( f_envol_wait )
	{
		// attente avant de s'envoler
		f_envol_wait = MATH_FloatMax(0.0, f_envol_wait - TIME_GetDt())
		f_speed = 0.0
	}
	else
	{
		AI_Execute("KBC_exec_MOVE_vertical")
		
		ti_plafond = faux
		if( COL_CollideType(COL_C_Ground) )
		{
			tv_normale = COL_NormalGet(COL_C_Ground)
			if( tv_normale.z < 0 )
				ti_plafond = vrai
		}
		
		if( i_flag_depl_fini || ti_plafond )
		{
			// décollage terminé
			if( ! ti_plafond && (i_envol_palier && i_envol_palier != Ci_envol_palier_nb) )
			{
				i_envol_palier++
				i_flag_depl_fini = faux	// new !!!
				v_dest_pos = OBJ_PosGet() + v_decalage
				f_envol_wait = Cf_envol_wait_length
			}
			else
			{
				if( i_flag_cine )
				{
					i_flag_cine = faux
					i_cine_close = vrai
				}
				else
				{
					// Retour sur le réseau de ronde
//					if( i_big_bat && i_big_bat_attack_decolle )
//					{
//						macro_change_etat("KBC_ETAT_Fight_Network")
//					}
//					else 
					if( i_etat_ancien == ETAT_Move_Atterrit 
						&& i_atterrissage_mode == Ci_atterrissage_nid_pause )
					{
						o_next_wp = KBC_WAY_NetNextWP(net_idle, o_wp_pause, 0, 0)
						o_ronde_next_wp = o_next_wp
						o_next_reacheable_wp_backup = o_next_wp
						macro_change_etat("KBC_ETAT_Move_Ronde")
						return
					}
					else
					{
						AI_Execute("KBC_exec_init_attente")
					}
				}
			}
		}
	}

	// suivi du regard
	i_flag_neck = vrai
	v_look_pos = @o_cible_depl OBJ_PosGet()
	
	
	// orientation
	if( ! MSG_GlobalIsValid(mid_grab_charogne) )
	{
//		if( TIME_Elapsed(f_time_action, 1.0) )
			ti_orientation = vrai
//		else
//			ti_orientation = faux
	}
	else 
	{
		if( i_envol_palier > 1 )
			ti_orientation = vrai
		else
			ti_orientation = faux
	}
	
	if( ti_orientation )
	{
		// la bat n'a pas de proie ou elle a une proie et elle a décollé depuis + d'1 sec -> elle s'oriente vers sa destination
		if( o_cible_depl )
			tv_sight = @o_cible_depl OBJ_PosGet() - OBJ_PosGet()
		else
			tv_sight = OBJ_SightGet()
		
		f_rot_blend_coef = MATH_FloatBlend(f_rot_blend_coef, 1.0, 10 * TIME_GetDt() )
		OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), tv_sight, f_rot_blend_coef * TIME_GetDt()), Cv_VerticalVector )
	}
}


