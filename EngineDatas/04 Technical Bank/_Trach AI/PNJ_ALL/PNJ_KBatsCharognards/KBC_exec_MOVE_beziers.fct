#include "KBC_defines.var"

vector		tv_sight				// nouveau sight
vector		tv_sight_backup
vector		tv_banking_backup
vector		tv_temp
vector		tv_pos_new
vector		tv_sight_new

float			tf_dot1
float			tf_dot2
float			tf_coef

int				ti_softcol_next_wp
int				ti_wp_deja_passe


ti_wp_deja_passe = faux

i_flag_depl_fini = faux		// flag pour indiquer que le lien a été parcouru en entier


if( i_big_bat && i_etat_courant == ETAT_Fight_Network )
{
	i_beziers_flag_last_trame = faux		// ne pas passer sous le sol pour atteindre mon wp d'attaque
}

if( i_big_bat && i_bigbat_AttackSequenceReady && i_etat_courant == ETAT_Move_Ronde )
{
	i_beziers_flag_last_trame = faux		// ne pas passer en bas == près de Kong
}


if( ! i_beziers_flag_last_trame )
{
	// réinit test béziers si je ne me déplaçais pas en béziers la trame d'avant
	i_flag_depl_horiz = faux
	v_beziers_sight = OBJ_SightGet()
	v_beziers_banking = OBJ_BankingGet()
}

// BLINDAGE BATS SANS POINT D'ATTAQUE MEMORISE (SPAWN KAMERA....)
if( ! o_next_wp )
{
	@o_tmp_obj_next OBJ_PosSet(OBJ_PosGet() + OBJ_SightGet())
	@o_tmp_obj_next OBJ_BankingGeneralSet(OBJ_SightGet(), OBJ_BankingGet())
	o_next_wp = o_tmp_obj_next
}
KBC_beziers_init_position()

i_speed_beziers_flag = vrai
i_speed_vertical_flag = faux
if( i_big_bat )
	f_speed_blend_coef = 2.5
AI_Execute("KBC_exec_MOVE_calc_speed")

	
ti_softcol_next_wp = faux
if( i_etat_courant != ETAT_Chute_WP && ! MATH_VecNullEpsilon(v_softcol_decal_current) )
{
	// je suis en déplacement + coll molles
	f_softcol_link_length -= (f_softcol_link_speed * TIME_GetDt())
	if( f_softcol_link_length < 0.0 )
	{
		if( i_DBG_trace_beziers_ON )
			KBC_Beziers_Display(0.0, color_cyan)
		ti_softcol_next_wp = vrai		// link dépassé
	}
}


BEZIERS_COMPUTE:
f_beziers_speed = f_speed * TIME_GetDt()
f_link_coef = f_beziers_speed

if( ! f_link_length )
	tf_coef = 0.0
else
{
	tf_coef = f_link_coef / f_link_length
}

if( ! ti_wp_deja_passe
	&& ( i_big_bat_attack || i_etat_courant != ETAT_Fight_Approche )		// la sortie du mode n'est pas fct du parcours de la courbe, mais fct de la distance à la cible
	&& ( tf_coef >= 1.0 
		|| ( f_link_length <= f_softcol_rayon_current && KBC_ReseauSoftColRayonOptimEnabled(i_etat_courant) )
		|| ti_softcol_next_wp ) )
{
	o_next_reacheable_wp_backup = nobody		// wp atteint
	
	i_flag_depl_fini = vrai				// déplacement total terminé (et pas juste le demi-tour)
	i_flag_depl_horiz = faux			// nouveau lien : reset test horiz
	ti_softcol_next_wp = faux		// 1 seul franchissement de wp à la fois		
	
	if( i_big_bat_attack )
	{
		if( i_etat_courant == ETAT_BigBat_Fight_Repart )
			return			// retourne en ronde
		
		KBC_BigBatAttack_GetNextPos()
		ti_wp_deja_passe = vrai
		o_next_wp = o_tmp_obj_next
		KBC_beziers_init_position()
		tf_coef = 0.0
	}
	else if( i_flag_cine )
	{
		return
	}
	else if( i_etat_courant == ETAT_Fight_Approche )
	{
		KBC_Attaque_Calc_Deplacement(Ci_attaque_positionnement_retrait)
	}
	else if( ! i_flag_reseau_oneway && ! i_flag_reseau_array )
	{
		// le bat ne doit pas aller à un autre wp
		o_last_wp = nobody
		return
	}
	else
	{
		if( i_flag_reseau_oneway )
		{
			// wp suivant sur un réseau cyclique dans un seul sens
			switch( i_pause_mode )
			{
				case Ci_pause_mode_aucun :
				{
					// vol en ronde standard
					o_last_wp = o_ronde_next_wp
					o_last_wp_backup = o_last_wp 
					o_next_wp = KBC_WAY_NetNextWP(n_reseau, o_last_wp, 0, 0)
					o_ronde_next_wp = o_next_wp
					
					if( @o_last_wp_backup OBJ_CapaTest(CAPA_WP_destroy_bat) )
					{
						DBG_TraceObject(OBJ_Me())
						DBG_TraceString(" : je viens d'atteindre un wp avec la capa 15 : destroy !!!!")
						DBG_TraceEOL()
						OBJ_Destroy()				// fin de ride !!!
					}
					
					if( ! o_ronde_next_wp )
					{
						DBG_TraceObject(OBJ_Me())
						DBG_TraceString(" : pas de next wp sur le réseau de ronde : destroy !!!!")
						DBG_TraceEOL()
						OBJ_Destroy()				// fin de ride !!!
					}
					
					o_next_reacheable_wp_backup = o_next_wp
					if( @o_next_wp OBJ_CapaTest(CAPA_WP_pause) )
					{
						// le prochain wp est un wp de pause
						o_wp_pause = o_next_wp
						tv_sight = @o_next_wp OBJ_PosGet() - OBJ_PosGet()
						// cas particulier, pas de coef de zoom !!!
						@o_tmp_obj_next OBJ_PosSet(@o_next_wp OBJ_PosGet() + KBC_Calc_Pos_Decalage( - tv_sight, Cf_atterrissage_decal_H, Cf_atterrissage_decal_Z, faux) ) 
						@o_tmp_obj_next OBJ_BankingGeneralSet(tv_sight, Cv_VerticalVector)
						o_next_wp = o_tmp_obj_next
						v_dest_pos = @o_tmp_obj_next OBJ_PosGet()
						i_pause_mode = Ci_pause_mode_on_y_va
						// durée avant la mise à mort de ANN ??
						f_nid_kill_ann_delay = MATH_RandFloat(1.5, 3.0)
//						if( @o_wp_pause OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_DesignStruct) )
//							f_nid_kill_ann_delay = o_wp_pause.des_float1
					}
					
					break
				}
				case Ci_pause_mode_on_y_va :
				{
					// la bat se dirigeait vers un wp de pause
					// maintenant elle va atterrir
					i_pause_mode = Ci_pause_mode_atterrissage
					o_cible_depl = o_wp_pause
					o_next_reacheable_wp_backup = o_wp_pause
					return		// changement d'état (atterrissage -> pause)
					break
				}
				default:
				{
					// ???
					DBG_Error("cas non géré (mode pause)")
					break
				}
			}
		}
		else if( i_flag_reseau_array )
		{
			AI_Execute("KBC_exec_network_pos_next")
			
			if( i_reseau_wp_count == 1)
				i_flag_frein = vrai
			else if( ! i_reseau_wp_count )
				i_flag_frein = faux
			if( i_etat_courant == ETAT_Move_JourNuit )
				i_flag_frein = faux		// jamais de frein pour repartir !!!
			if( ! i_reseau_wp_count )
				return		// déplacement terminé -> changement d'état
		}
		
		// nouveau lien
		KBC_beziers_init_position()
		
		ti_wp_deja_passe = vrai
		tf_coef = 0.0			// courbe recalculée depis ma position courante
		
		if( ! MATH_VecNullEpsilon(v_softcol_decal_current) )
		{
			// soft col en cours
			f_softcol_link_length = f_link_length
		}
		else
		{
			// soft col terminée
			 f_softcol_link_length = Cf_Infinit
		}
	}
	
	goto BEZIERS_COMPUTE
}


// TEST INCLINAISON =======================================================
if( ! i_flag_depl_horiz )
{
	// test courbe verticale
	tv_temp = @o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet()
	if( MATH_VecNullEpsilon(tv_temp) )
		tf_dot1 = 0.0
	else
	{
		MATH_VecSetNormalize(tv_temp)
		tf_dot1 = MATH_VecDotProduct(tv_temp, - Cv_VerticalVector)
	}
	
	// test demi tour
	tf_dot2 = MATH_VecDotProduct(@o_next_wp OBJ_SightGet(), @o_last_wp OBJ_SightGet())

	// résultat
	if( MATH_AbsFloat(tf_dot1) > Cf_Cos45 || tf_dot2 < 0 )
		i_flag_depl_horiz = vrai
}


// POSITION DE LA BAT ====================================================
KBC_Calc_Beziers(tv_pos_new, tv_sight_new, tf_coef)
OBJ_PosSet(tv_pos_new)

if( i_DBG_trace_beziers_ON )
	KBC_Beziers_Display(tf_coef, color_blanc)

// ORIENTATION DE LA BAT ==================================================
tv_sight = tv_sight_new
if( MATH_VecNullEpsilon(tv_sight) )
	tv_sight = OBJ_SightGet()

//DBG_RenderVector(OBJ_PosGet(), v_beziers_sight, color_vert)
//DBG_RenderVector(OBJ_PosGet(), v_beziers_banking, color_bleu)

tv_sight_backup = OBJ_SightGet()											// backup sight courant
tv_banking_backup = OBJ_BankingGet()									// backup banking courant

// JE M'ORIENTE SUR LA BEZIERS POUR CONTINUER A M'ORIENTER SUR LA BEZIERS
tv_sight = KBC_BlendRotate(v_beziers_sight, tv_sight, 100.0, f_rotation_angle_courant * (30.0 * Cf_1Degre) )		// 30 ° x30 (à cause du getdt)
OBJ_SightGeneralSet(tv_sight, MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 5 * TIME_GetDt()))

v_beziers_sight = OBJ_SightGet()											// backup sight trame courante sur la béziers
v_beziers_banking = OBJ_BankingGet()									// backup banking trame courante sur la béziers

//DBG_RenderVector(OBJ_PosGet(), v_beziers_sight, color_jaune)
//DBG_RenderVector(OBJ_PosGet(), v_beziers_banking, color_cyan)

// correction position bat
if( i_flag_depl_horiz || MSG_GlobalIsValid(mid_grab_charogne) )
{
	OBJ_BankingGeneralSet(tv_sight, MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 5 * TIME_GetDt()))
}


i_beziers_flag_cette_trame = vrai


