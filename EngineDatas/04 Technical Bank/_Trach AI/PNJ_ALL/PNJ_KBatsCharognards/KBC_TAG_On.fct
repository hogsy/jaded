#include "KBC_defines.var"

#define		Cf_ralenti_fixe_duree			0.2	// 0.3		// durée où le jeu reste avec la valeur de ralenti initiale
#define		Cf_ralenti_annule_duree		1.0	// 0.3		// durée que le jeu met à revenir à la vraie vitesse

vector		tv_new_soft_collision
vector 		tv_zdm_perfect_size
vector		tv_zdm_offset
vector		tv_pos
vector		tv_sinus
vector		tv_traction
vector		tv_collide_pos

float			tf_coef
float			tf_archimede
float			tf_Z_offset

int				ti_soft_collision_flag_old
int				ti_ask_for_interaction
int				ti_lockkam 
int				ti_bigbat_kamera
int				ti_zdm_active
int				ti_col_report

object		to_collide_object

// LRAY ==========================================================
if( i_splash_flag )
	OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)		// pouvoir toucher les swamps
else
	OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)		// raz

// PAF RECUL =====================================================
// d'abord appliquer le recul paf
OBJ_PosSet(OBJ_PosGet() + (f_paf_offset_coef * v_paf_offset * (TIME_GetDt() * 5.0)) )
// ensuite diminuer le paf
f_paf_offset_coef = MATH_FloatBlend(f_paf_offset_coef, 1.0, 10 * TIME_GetDt())
v_paf_offset = MATH_VecBlend(v_paf_offset, Cv_NullVector, 1.0* TIME_GetDt())


// OFFSET SUIVI DE RESEAU ==========================================
OBJ_PosSet(OBJ_PosGet() + MATH_VecLocalToGlobal(v_KONG_ride_walling_offset) )


// CUMUL DE PAFS  ============================================================
KBC_Paf_Cumul_Check_Time()

// WAIT SINUS =================================================================
tv_pos = OBJ_PosGet()
tv_pos -= v_wait_sinus
if( i_wait_sinus_flag && ! i_big_bat )
{
	tv_sinus = cvector(MATH_Sin(f_wait_sinus_frequence * 1.4 * f_zoom * TIME_Get()), MATH_Sin(f_wait_sinus_frequence * 0.65 * f_zoom * TIME_Get()), MATH_Sin(f_wait_sinus_frequence * 1.4 * f_zoom * TIME_Get()))
	v_wait_sinus = MATH_VecBlend(v_wait_sinus, tv_sinus, 5 * TIME_GetDt())
}
else
{
	v_wait_sinus = MATH_VecBlend(v_wait_sinus, Cv_NullVector, 3 * TIME_GetDt())
}
tv_pos += v_wait_sinus
OBJ_PosSet(tv_pos)



// COLLISION MOLLES ============================================================
ti_soft_collision_flag_old = i_softcol_flag
KBC_SoftCol_Rayon_Resize()
//DBG_RenderCircle(OBJ_PosGet(), f_softcol_rayon_current * f_zoom, Cv_NullVector, color_rouge)		
if( i_KONG_ride_walling_bat || ! KBC_SoftCol_IsEnabled() || MSG_GlobalIsValid(mid_grab_charogne) ) // || ACT_ActionGet() == ACTION_Falaise_Attaque )
{
	// états col molles interdites
	i_softcol_flag = faux
	v_softcol_decal_perfect = Cv_NullVector
	tf_coef = 5.0
}
else
{
	// test des col molles
	i_softcol_flag = KBC_SoftCol_Check(tv_new_soft_collision)
	if( ! i_softcol_flag )
	{
		// pas de col molles
		v_softcol_decal_perfect = Cv_NullVector
		tf_coef = 3.0
	}
	else
	{
		// col molles...
		if( ! ti_soft_collision_flag_old )
		{
			// je passe en coll molle maintenant et je n'avais pas de résidus de col molles (franchissement de wp)
			if( MATH_VecNullEpsilon(v_softcol_decal_current) )
			{
				f_softcol_link_speed = f_beziers_speed
			}
		}
		v_softcol_decal_perfect = tv_new_soft_collision
		tf_coef = 1.0
	}
}
v_softcol_decal_current = MATH_VecBlend(v_softcol_decal_current, v_softcol_decal_perfect, tf_coef * TIME_GetDt())
DBG_RenderVector(OBJ_PosGet(), v_softcol_decal_current, color_bleu)
OBJ_PosSet(OBJ_PosGet() + ( v_softcol_decal_current * 20.0 * TIME_GetDt() ) )


// POSITION DU BALANCIER ====================================================
AI_Execute("KBC_exec_balancier")


// TEST BEZIERS ??? =========================================================
if( i_beziers_flag_cette_trame )
	i_beziers_flag_last_trame = vrai
else
	i_beziers_flag_last_trame = faux

// CADAVRES ===============================================================
KBC_Cadavre_Check()
KBC_Cadavre_Check_New()
if( ! o_cadavre )
{
	EVENT_Delete(mid_interet_charogne, C_EVENT_EOFDEL)		// pour les bats qui comptent les interets
}


// VITESSE =================================================================
if( i_big_bat )
	tf_coef = 0.90		// 0.92
else
	tf_coef = 0.95
v_vitesse_derapage *= Amorti_Coef_Dt(tf_coef)
if( i_vitesse_derapage_init )
{
	v_vitesse_derapage = v_vitesse_last_move
//	DBG_RenderVector(OBJ_PosGet(), v_vitesse_derapage, color_cyan)
}
//DBG_RenderVector(OBJ_PosGet(), v_vitesse_derapage, color_bleu)

OBJ_PosSet(OBJ_PosGet() + (v_vitesse_derapage * TIME_GetDt()))

// etat fight pause apres une big bat attaque ratée = dérape PUIS s'envole, il faut donc rafraichir la positon de wait
if( MATH_VecNullToler(v_vitesse_derapage, Cf_vitesse_derapage_null_toler) && v_vitesse_derapage != Cv_NullVector )
{
	v_fight_wait_pos = OBJ_PosGet()
	v_vitesse_derapage = Cv_NullVector
}

v_vitesse_last_move = (OBJ_PosGet() - v_vitesse_last_pos) / TIME_GetDt()
v_vitesse_last_pos = OBJ_PosGet()


// TAILLE & POSITION ZDM ===================================================================
if( i_etat_courant == ETAT_KK_Finished )
{
	KBC_ZDM_Sol_Get(tv_zdm_perfect_size, tv_zdm_offset)
//	tv_zdm_perfect_size = Cv_ZDM_Sol
//	tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Sol.x)
}
else if( i_etat_courant == ETAT_Sol_Interaction_Ann )
{
	KBC_ZDM_Sol_Get(tv_zdm_perfect_size, tv_zdm_offset)
//	tv_zdm_perfect_size = Cv_ZDM_Sol
//	tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Sol.x)
}
else if( i_etat_courant == ETAT_Fight_Contact )
{
	tv_zdm_perfect_size = Cv_ZDM_Contact
	tv_zdm_offset = Cv_NullVector
}
else if( i_etat_courant == ETAT_Move_Atterrit || i_etat_courant == ETAT_Move_Decolle )
{
	tv_zdm_perfect_size = Cv_ZDM_Trans_Sol_Air		// diminuée pour les transitions air / sol...
	tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Trans_Sol_Air.x)
}
else if( KBC_est_au_sol() )
{
	KBC_ZDM_Sol_Get(tv_zdm_perfect_size, tv_zdm_offset)
//	tv_zdm_perfect_size = Cv_ZDM_Sol
//	tv_zdm_offset = cvector(0.0, 0.0, Cv_ZDM_Sol.x)z
}
else
{
	tv_zdm_perfect_size = Cv_ZDM_Air
	tv_zdm_offset = cvector(0.0, 0.0, 0.2)
}

// taille de la ZDM
if( f_total_time == 0.0 )
	v_zdm_cur_size = tv_zdm_perfect_size	// à l'init, taille ok
else if( ! MATH_VecNullToler(v_zdm_cur_size - tv_zdm_perfect_size, 0.05) )
{
	v_zdm_cur_size = MATH_VecBlend(v_zdm_cur_size, tv_zdm_perfect_size, 5 * TIME_GetDt())
	if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
		DYN_FlagsSet(DYN_C_OptimizeColDisable, none)
}
else
	v_zdm_cur_size = tv_zdm_perfect_size
COL_ZoneSizeSet(C_zdm_pied, v_zdm_cur_size)


// offset de la ZDM
if( f_total_time == 0.0 )
	v_zdm_cur_offset = tv_zdm_offset
else if( ! MATH_VecNullToler( tv_zdm_offset - v_zdm_cur_offset, 0.05) )
	v_zdm_cur_offset = MATH_VecBlend(v_zdm_cur_offset, tv_zdm_offset, 20 * TIME_GetDt())
else
	v_zdm_cur_offset = tv_zdm_offset
COL_ZonePosSet(C_zdm_pied, v_zdm_cur_offset )


// ACTIVATION ZDM ??? ================================================================
if ( i_etat_courant == ETAT_KK_Projectile || i_etat_courant == ETAT_KK_Finished )
{
	// géré dans l'état
}
else 
{
	if( i_splash_flag )
		ti_zdm_active = faux
	else if( i_etat_courant == ETAT_Chute_WP )
		ti_zdm_active = faux
	else if( i_etat_courant == ETAT_Fight_Contact )
		ti_zdm_active = vrai		// même en ciné !!!
	else if( KBC_IsEtatCine(i_etat_courant ) )
		ti_zdm_active = faux
	else if( MSG_GlobalIsValid(mid_grab_charogne) && ! KBC_est_au_sol() )
		ti_zdm_active = faux
	else
	{
		switch( i_etat_courant )
		{
			case ETAT_KK_Ride :
			case ETAT_KK_Finish :
				ti_zdm_active = faux
				break
			default:
				ti_zdm_active = vrai
				break
		}
	}
	if( ti_zdm_active )
		COL_ColSetActivationSet(C_bit_zdm_pied, none)			// active zdm pied
	else
		COL_ColSetActivationSet(none, C_bit_zdm_pied)			// désactive zdm pied
}

// KAMERA =======================================================
if( ! i_KK_do_not_Target_Me )
{
	ti_lockkam = vrai
	if( i_little_bat )		// bats rouges
		ti_lockkam = faux
	else if( ! i_big_bat )
	{
		// bats grises
		if( ! KBC_IsEtatAttaque(i_etat_courant) )
			ti_lockkam = faux
	}
	else if( i_etat_courant == ETAT_Mort )
		ti_lockkam = faux
	if( ti_lockkam )
		EVENT_AddEventLockCam(OBJ_Me(), C_EVENT_LockCamStatus_Fight, Cv_NullVector)
}

// ACTION FREQUENCY --------------------------------------------------------------------------
f_anim_frequency_cur = MATH_FloatBlend(f_anim_frequency_cur, f_anim_frequency_ref, 3.0 * TIME_GetDt())
ACT_LIB_ActionFrequencyMultiply(f_anim_frequency_cur)


OBJ_CapaSet(none, CAPA_Release_Grabbed_Actor)		// reset capa


// SPEECH =========================================================
AI_Execute("KBC_exec_Speech")


// BIG BAT SLOW MOTION ==============================================
if( i_bigbat_gamespeed_flag )
{
	f_bigbat_gamespeed_coef = MATH_FloatBlend(f_bigbat_gamespeed_coef, 0.5, 10 * TIME_GetDt())
	@get_global f_game_speed = f_bigbat_gamespeed_coef
}
else if( i_bigbat_gamespeed_end_flag )
{
	f_bigbat_gamespeed_coef = MATH_FloatBlend(f_bigbat_gamespeed_coef, 1.0, 10 * TIME_GetDt())
	if( MATH_FloatNullToler(1.0 - f_bigbat_gamespeed_coef, 0.1) )
	{
		f_bigbat_gamespeed_coef = 1.0
		i_bigbat_gamespeed_end_flag = faux
	}
	@get_global f_game_speed = f_bigbat_gamespeed_coef
}


// GESTION DES UNCOLS ==================================================================
if( i_big_bat )
{
	if( i_big_bat_uncol_end_flag )
	{
		if( o_big_bat_uncol && ! OBJ_LIB_Virtual_Collision(OBJ_Me(), o_big_bat_uncol, faux) )
		{
			i_big_bat_uncol_end_flag = faux
			@o_big_bat_uncol COL_UnCollidableDel(OBJ_Me())
			o_big_bat_uncol = nobody
		}
	}
}
else
{
//	if( o_Kong )
//		KBC_UncollideAdd(o_Kong, Cf_EVENT_Duree_1Trame)
	if( o_cible && o_cible != o_Jack)
		KBC_UncollideAdd(o_cible, Cf_EVENT_Duree_1Trame)
	if( o_cadavre )		// ne pas cumuler pour le même acteur
		KBC_UncollideAdd(o_cadavre, Cf_EVENT_Duree_1Trame)
	if( o_cible_attaque && ( i_etat_courant == ETAT_Fight_Approche || i_etat_courant == ETAT_Fight_Contact) )
	{
		if( o_cible_attaque != o_Jack )
			KBC_UncollideAdd(o_cible_attaque, Cf_EVENT_Duree_1Trame)
		else if( @o_Jack Proc_KIndigene_Kong_LiaisonStatusGet() != Ci_Kong_KIndigene_LinkStatus_None )
			KBC_UncollideAdd(o_Kong, Cf_EVENT_Duree_1Trame)
	}
	if( o_predateur )
		KBC_UncollideAdd(o_predateur, Cf_EVENT_Duree_1Trame)
	if( o_bone_ride_KK )
		KBC_UncollideAdd(o_bone_ride_KK, Cf_EVENT_Duree_1Trame)
	if( o_finished_actor )
		KBC_UncollideAdd(o_finished_actor, Cf_EVENT_Duree_1Trame)
	if( o_I_finish_actor )
		KBC_UncollideAdd(o_I_finish_actor, Cf_EVENT_Duree_1Trame)
	if( o_grabbed_actor )
		KBC_UncollideAdd(o_grabbed_actor, Cf_EVENT_Duree_1Trame)
	// Test durée uncol
	KBC_UncollideCheck()
}


// BIG BAT FIGHT KAMERA ================================================
if( i_big_bat )
{
	ti_bigbat_kamera = vrai
	if( ! i_bigbat_AttackSequenceReady )
		ti_bigbat_kamera = faux
	else if( MSG_GlobalIsValid(mid_grab_charogne) )
		ti_bigbat_kamera = faux
	else if( f_bigbat_delai_no_kamera )		// apres un paf ou une attaque mashing
		ti_bigbat_kamera = faux
	else if( i_charge_KK_dodge )
		ti_bigbat_kamera = faux
	else if( EVENT_LIFE_CurLifeGet(ID_LIFE) <= 0.0 )
		ti_bigbat_kamera = faux
	else if( i_calc_net_apres_mashing )
		ti_bigbat_kamera = faux
	else
	{
		if( ! o_bigbat_manager )		// TEMP !!!!!
		{
			switch( i_etat_courant )
			{
				case ETAT_Fight_Wait_Prio :
				case ETAT_Fight_Wait_Begin :
					break
				default:
					ti_bigbat_kamera = faux
					break
			}
		}
		else
		{
			switch( i_etat_courant )
			{
				case ETAT_BigBat_Fight_Plonge :
				case ETAT_BigBat_Fight_Poursuit :
				case ETAT_BigBat_Fight_Repart :
				case ETAT_Paf :
				case ETAT_Paf_KK_Ecrase :
					ti_bigbat_kamera = faux
					break
				case ETAT_Move_Ronde :
					if( o_ronde_next_wp && @o_ronde_next_wp OBJ_CapaTest(CAPA_WP_no_kamera_capa) )
						ti_bigbat_kamera = faux
					break
			}
		}
	}
	if( ti_bigbat_kamera )
		OBJ_CapaSet(CAPA_BigBat_Kamera, none)
	else
		OBJ_CapaSet(none, CAPA_BigBat_Kamera)
}



// ARCHIMEDE ============================================================================
if( i_splash_flag )
{
	AI_Execute("KBC_exec_dyn_on")
	DYN_GravitySet(Cv_NormalGravity)
	tv_traction = Cv_NullVector
	DYN_FrictionVectorSet(cvector(6.0, 6.0, 0.0))
	ti_col_report =COL_GMatReportGet(Gmat_KK_Face_eau)
	if (ti_col_report != -1)
	{
		to_collide_object = COL_ObjectGet(COL_C_ReportIndex + ti_col_report)
		tv_collide_pos = COL_CollidedPointGet(COL_C_ReportIndex + ti_col_report) 
		f_water_Z = tv_collide_pos.z
	}
	tf_Z_offset = KBC_Get_Water_DiffZ()
	tf_archimede = f_water_Z - OBJ_PosGet().z + tf_Z_offset
	tf_archimede /= tf_Z_offset
	tf_archimede = MATH_FloatLimit(tf_archimede, 0.0, 2.0)
	if (tf_archimede)
	{
		tv_traction.z -= tf_archimede * DYN_GravityVectorGet().z * 0.85
		DYN_FrictionVectorSet(cvector(6.0, 6.0, 4.0))
	}
	DYN_TractionSet(tv_traction)
}
else
{
	tf_archimede = 0.0
	f_water_Z = -Cf_Infinit
}


// PAF VIANDE ===============================================================================
if (f_time_meat_bite)
{
	AI_Execute("KBC_exec_dyn_on")
	DYN_GravitySet(Cv_NormalGravity)
	if( i_splash_flag )
		DYN_SpeedSetVector(cvector(MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(-0.5, -0.2)) * f_zoom)
	else
		DYN_SpeedSetVector(cvector(MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(-0.5, 0.5), MATH_RandFloat(0.0, 1.0)) * f_zoom)
}

// DEBUG DEBUG DEBUG ================================================
AI_Execute("KBC_exec_DEBUG")


