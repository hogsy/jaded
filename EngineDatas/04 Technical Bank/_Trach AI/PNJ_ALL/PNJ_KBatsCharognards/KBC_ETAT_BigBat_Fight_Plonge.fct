#include "KBC_defines.var"

messageid		tmid_vision

object			to_head

vector			tv_sight
vector			tv_pos
vector			tv_sight2

float				tf_dist

int					ti_can_paf


// SORTIE ETAT =========================================================================
if (i_sort_etat)
{
	i_paf_send = faux
	f_angle_rotation_max = Cf_angle_rotation_max_default

	if( i_etat_courant != ETAT_BigBat_Fight_Poursuit )
		KBC_BigBat_UncolDel()
	
	i_bigbat_attack_imparable = faux
	i_bigbat_gamespeed_end_flag = vrai
	
	i_sort_etat = faux
	return
}

// ENTREE ETAT =========================================================================
if (i_etat_courant != ETAT_BigBat_Fight_Plonge)
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_BigBat_Fight_Plonge
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KBC_DBG_Trace_Gao(i_DBG_trace_etat, "etat big bat fight plonge", o_cible_attaque)
	
	KBC_AttackModeSelect()

	// INIT DEPLACEMENT --------------------------------------------------------
	v_cible_pos = @o_cible_attaque OBJ_PosGet()
	KBC_ref_speed_set(f_vitesse_fight_approche)
	f_speed = 0.0

	AI_Execute("KBC_exec_dyn_on")

	@get_global f_time_bats_last_plongeon = TIME_Get()

	o_backup_wp_depl_utilise	= o_backup_nearest_cible_wp
	KBC_WP_Reservation_Del(o_backup_wp_depl_utilise)
	
	if( ! MATH_VecNullEpsilon(v_softcol_decal_current) )
	{
		// soft col en cours
		f_softcol_link_length = MATH_VecNorm(@o_cible_attaque OBJ_PosGet() - OBJ_PosGet())
	}
	
	i_flag_depl_horiz = faux
	
	// Rotation
	f_angle_rotation_max = Cf_angle_rotation_max_contact			// les bats rouges ne sont pas limitées dans la rotation
	
	if( i_big_bat )
	{
		KBC_BigBat_UncolAdd()
		f_bigbat_gamespeed_coef = @get_global f_game_speed	// le courant et pas 1.0 car si ça se trouve y'a une autre bat...
	}
	
	i_flag_depl_fini = faux		// ne pas passer en DODGED immédiatement !!!
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE ==========================================================================================================
MACRO_CHECK_PAFS


// FIN D'ATTAQUE ? =================================================================
if( 0 )
{
	ANNULE_ATTAQUE:
	KBC_BigBat_Abort()
	AI_Execute("KBC_exec_init_attente")
}
AI_Execute("KBC_exec_check_fight_exit")
if( i_fight_exit_flag )
{
	goto ANNULE_ATTAQUE
}

if( o_cible_attaque == o_Kong && @o_Kong Proc_KK_IsInBadSituation(C_ID_BatCharognard ) )
{
	goto ANNULE_ATTAQUE
}

if( o_cible_attaque == o_Kong && KBC_KongModeProcheMur() )
{
	KBC_DBG_Trace(i_DBG_trace_etat, "Kong en walling, raccorche, grimper ou autre...")
	goto ANNULE_ATTAQUE
}

AI_Execute("KBC_exec_check_fury")
if( o_fury_check_actor )
{
	KBC_DBG_Trace(i_DBG_trace_etat, "detecte passage en fury -> je cancelle mon attaque")
	goto ANNULE_ATTAQUE
}

@o_Kong Proc_KK_RAGE_Speed()		// ralenti moteur si Fury
KBC_ZDE_Size_n_Pos()
if( ! i_big_bat_attack_scream && OBJ_SqrDist(o_cible_attaque) < 225.0 )
{
	i_big_bat_attack_scream = vrai
	SND_RequestPlay(Ci_SND_Big_Bat_Dodge_Now)
}

ti_can_paf = vrai
// Kong tente de frapper = je ne le paffe pas
if( ! i_paf_send && i_big_bat_attack_scream && ! i_bigbat_attack_imparable )
{
	if( @o_Kong Proc_KK_Frappe() )
	{
		ti_can_paf = faux
		if( @get_Kong_Path o_Kong o_fight_actor != OBJ_Me() )
			ti_can_paf = vrai		// il regarde quelqu'un d'autre	// me tourne le dos
		else if( @o_Kong Proc_KK_Frappe_Phase_Get() == 2 )
			ti_can_paf = vrai		// Kong a raté
		else 
		{
			tv_sight = OBJ_SightGet()
			tv_sight.z = 0.0
			MATH_VecSetNormalize(tv_sight)
			DBG_RenderVector(OBJ_PosGet(), tv_sight, color_vert)
			
			// est ce que Kong est tourné ver smoi ?
			tv_sight2 = @o_Kong Proc_KK_LookDirectionGet()
			tv_sight2.z = 0.0
			MATH_VecSetNormalize(tv_sight2)
			DBG_RenderVector(OBJ_PosGet(), tv_sight2, color_jaune)
			
			if( MATH_VecDotProduct(tv_sight, tv_sight2) > 0.0 )
				ti_can_paf = vrai
			else
			{
				// est-ce que j'ai traversé Kong sans qu'il me paffe ?
				tv_sight2 = @o_Kong OBJ_PosGet() - OBJ_PosGet()
				tv_sight2.z = 0.0
				
				MATH_VecSetNormalize(tv_sight2)
				DBG_RenderVector(OBJ_PosGet(), tv_sight2, color_cyan)
				if( MATH_VecDotProduct(tv_sight, tv_sight2) < 0.0 )
					ti_can_paf = vrai
			}
		}
	}
}

if( ti_can_paf )
{
	if( ! i_paf_send && ! i_attaque_fin_desynchro_flag && COL_ZDE_ZDECollide(o_cible_attaque, C_zde_fight, C_zde_corps) )
	{
		if( i_bigbat_attack_imparable || ( o_cible_attaque == o_Kong && ! @o_Kong Proc_KK_RefusePafFromGao(OBJ_Me()) ) )
		{
			// je teste si Kong accepte mon paf car si je le paffe pas je passe en fight pause et pas en fight remonte
			KBC_DBG_Trace(i_DBG_trace_etat, "paffe Kong !!! (plongeon)")
			KBC_Paf_n_Pursuit()
			KBC_BigBatAttack_GetNextPos()		// remonte
			OBJ_CapaSet(none, CAPA_BigBat_attaque_en_cours)
			KBC_BigBat_AttackIncCpt()		// attaque comptabilisée
			macro_change_etat("KBC_ETAT_BigBat_Fight_Poursuit")
		}
	}
}


// COMPORTEMENT ===========================================================

KBC_Interet_Update(mid_interet_attaque, C_EVENT_InteretStatusAttack, o_cible_attaque, tmid_vision)		// j'ai fini d'attendre
to_head = @o_cible_attaque ANI_CanalObjectGet(Anim_Canal_Tete)
if( ! to_head )
	to_head = o_cible_attaque

v_look_pos = @to_head OBJ_PosGet()
tv_sight = @o_cible_attaque OBJ_PosGet() - OBJ_PosGet()
i_flag_frein = faux
i_flag_neck = vrai

// UPDATE TARGET POSITION -----------------------------------------------------------------
//v_cible_pos = v_look_pos
//v_dest_pos = v_cible_pos
//@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
//
//@o_tmp_obj_next OBJ_BankingGeneralSet( tv_sight, Cv_VerticalVector)
//o_next_wp = o_tmp_obj_next


f_speed_blend_coef = 2.5
AI_Execute("KBC_exec_MOVE_beziers")		// 1è condition pour i_flag_depl_fini

// dot product pour savori qu'on a dépassé KONG (s'il s'est rapproché par rapport à la position mémorisée)
if( MATH_VecDotProduct(OBJ_SightGet(), @o_cible_attaque OBJ_PosGet() - OBJ_PosGet()) < 0 )
	i_flag_depl_fini = vrai		// 2è condition pour i_flag_depl_fini
if( i_flag_depl_fini )
{
	f_paf_pause_time = 1.5
	KBC_action_frequency_set(2.0)
	i_vitesse_derapage_init = vrai
	i_charge_KK_dodge = vrai		// STEPH ADD
	KBC_BigBat_AttackIncCpt()		// attaque comptabilisée
	macro_change_etat("KBC_ETAT_BigBat_Fight_Dodged")
}


// ACTION --------------------------------------------------------------------------------------------------------------
tf_dist = 15.0
if( OBJ_SqrDist(o_cible_attaque) > (tf_dist * tf_dist) )
{
	ACT_ActionSet(i_ACTION_Vol_Standard)
	KBC_action_frequency_set(2.0)
}
else
{
	ACT_ActionSet(ACTION_Vol_Plane)
	KBC_action_frequency_set(1.0)
}
