#include "KBC_defines.var"

messageid		tmid_vision

vector	tv_sight
vector	tv_me_to_cadavre

float		tf_dot
float		tf_water

int			ti_interet



// SORTIE ETAT ============================================================
if (i_sort_etat)
{
	i_flag_reseau_array = faux
	if( i_etat_courant != ETAT_Move_Atterrit )
		o_cadavre = nobody	
	f_cadavre_occupation_delay = 0.0
	i_sort_etat = faux
	return
}


// ENTREE ETAT ============================================================
if( i_etat_courant != ETAT_Move_Cadavre )
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Move_Cadavre
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
//	i_DBG_trace_etat = 1
	KBC_DBG_Trace_Gao(i_DBG_trace_etat, "etat move cadavre", o_cadavre)
	
	KBC_Calc_Pos_Cadavre()
	@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
	@o_tmp_obj_next OBJ_BankingGeneralSet(v_dest_sight, Cv_VerticalVector)
	o_cible_depl = o_tmp_obj_next
	
	// CALCUL DU RESEAU et du next_wp
	i_mode_depl = Ci_mode_depl_cadavre
	n_reseau = net_move
	i_reseau_wp_count = 10				// pour bien spécifier qu'on a pas terminé de parcourir le réseau (mais qu'on veut commencer)
	i_flag_reseau_array = vrai
	i_force_test_inclinaison = vrai			// test d'inclinaison
	i_flag_depl_wp_apres_reseau = faux
	AI_Execute("KBC_exec_network_pos_next")
	
	ACT_ActionSet(i_ACTION_Vol_Standard)
	KBC_ref_speed_set(Cf_speed_vol)
	i_cadavre_mode = Ci_cadavre_mode_deplacement
	f_obstacle_duration = 0.0		// check obstacle pour aller chopper de la bouffe
	
	// TEST DISTANCE JOUEUR
	i_cadavre_joueur_proche_flag = faux
	f_cadavre_joueur_proche_duree = 0.0
	
	f_cadavre_atterissage_delay = 0.0	// MATH_RandFloat(0.5,1.5)			// min 0.5 pour l'orientation à la fin sinon saute lors de l'anim d'aterrissage
	f_cadavre_occupation_delay = MATH_RandFloat(15.0, 20.0)		// délai max je reste occupé sans pouvoir attarrir (interet foodchain)
	i_cadavre_atterrissage_1st_test_done = faux
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE ===========================================================================================
MACRO_CHECK_PAFS
if( o_best_paf_pere_enabled )
{
	o_cible_attaque = o_best_paf_pere_enabled
	i_cadavre_joueur_proche_flag = vrai
	AI_Execute("KBC_exec_init_attaque")
}

if( KBC_ModeCharognardKongTropProche() )
{
	KBC_DBG_Trace(i_DBG_trace_etat, "KONG est trop proche !!!")
	KBC_Cadavre_Del(o_cible)
	AI_Execute("KBC_exec_init_attente")
}

if( ! KBC_EstToujoursUnCadavre(o_cadavre) )
{
	KBC_DBG_Trace_Gao(i_DBG_trace_etat, "ma cible n'est plus un cadavre, je repars...", o_cadavre)
	KBC_Cadavre_Del(o_cadavre)
	AI_Execute("KBC_exec_init_attente")
}

// EMERGENCY ABORT =============================
if( o_cadavre && ! KBC_TargetStillActive(o_cadavre) )
{
	KBC_Cadavre_Del(o_cadavre)
	o_cadavre = nobody
	AI_Execute("KBC_exec_init_attente")
}


// TEST CADAVRE DANS TERRITOIRE (FEU ???)
if( ! KBC_Gao_in_Territory(o_cadavre, vrai) )
{
	KBC_DBG_Trace_Gao(vrai, "ma proie n'est plus dans mon territoire (feu ???) alors je repars", o_cadavre)
	AI_Execute("KBC_exec_init_attente")
}
 

// Obstacle ----------------------------------------------------------------------------------
AI_Execute("KBC_exec_check_obstacle")
if( i_flag_obstacle )
{
	KBC_DBG_Trace_Gao(i_DBG_trace_etat, "un obstacle l'empeche d'atteindre", o_cadavre)
	AI_Execute("KBC_exec_init_attente")
}

// INTERET --------------------
ti_interet = vrai
if( i_cadavre_mode == Ci_cadavre_mode_observe && IsWaterUnderPos(@o_cadavre OBJ_PosGet()) )
	ti_interet = faux		// dans l'eau, maintenir jusqu'à ce qu'on observe
if( ti_interet )
	KBC_Interet_Update(mid_interet_charogne, C_EVENT_InteretStatusFoodchain, o_cadavre, tmid_vision)


// TEST JOUEUR PROCHE PENDANT CYCLE FOODCHAIN
AI_Execute("KBC_exec_cadavre_joueur_proche")


// DUREE D'OCCUPATION MAX =========================================
f_cadavre_occupation_delay -= MATH_FloatMin(f_cadavre_occupation_delay, TIME_GetDt())
if( ! f_cadavre_occupation_delay )
{
	KBC_DBG_Trace_Gao(i_DBG_trace_etat, "temps d'occupation du cadavre écoulé, je repars en abandonnant...", o_cadavre)
	f_speed = 0.0
	o_cadavre = nobody
	AI_Execute("KBC_exec_init_attente")
}

// update pos & look
if( i_flag_depl_wp_apres_reseau )
	KBC_Calc_Pos_Cadavre_Update()

// suivi du regard
i_flag_neck = vrai
v_look_pos = v_cible_pos

// jour ?  cassos si j'ai pas atterit à temps
if( ! JOUR_NUIT_HeureCorrecte(f_Heure_Debut, f_Heure_Fin) )
	AI_Execute("KBC_exec_init_attente")

switch( i_cadavre_mode )
{
	case Ci_cadavre_mode_deplacement :
		i_flag_frein = faux
		
		AI_Execute("KBC_exec_MOVE_beziers")
		if( i_flag_depl_fini && ( ! i_reseau_wp_count ) )
		{
			i_cadavre_mode = Ci_cadavre_mode_observe
			i_vitesse_derapage_init = vrai
		}
		break
		
	case Ci_cadavre_mode_observe :
		// blend orientation violent sinon risque de saute au début de l'anim d'atterrissage
		if( i_cadavre_atterrissage_1st_test_done )
			i_wait_sinus_flag = vrai		// sinus si on nous a déjà refusé l'atterrissage (sinon pas de sinus car la position calculée est nickel pour l'anim d'atterrissage)
		OBJ_BankingGeneralSet(
			MATH_VecBlendRotate(OBJ_SightGet(), @o_cadavre OBJ_PosGet() - OBJ_PosGet(), 10.0 * TIME_GetDt()),
			MATH_VecBlendRotate(OBJ_BankingGet(), Cv_VerticalVector, 10.0 * TIME_GetDt()))
		// test orientation
		tv_sight = OBJ_SightGet()
		tv_sight.z = 0.0
		if( ! MATH_VecNullToler(tv_sight, 0.1) )
			MATH_VecSetNormalize(tv_sight)
		else
			tv_sight = OBJ_SightGet()
		DBG_RenderVector(OBJ_PosGet(), tv_sight, color_jaune)
		tv_me_to_cadavre = @o_cadavre OBJ_PosGet() - OBJ_PosGet()
		tv_me_to_cadavre.z = 0.0
		if( ! MATH_VecNullToler(tv_me_to_cadavre, 0.1) )
			MATH_VecSetNormalize(tv_me_to_cadavre)
		else
			tv_me_to_cadavre = OBJ_SightGet()
		DBG_RenderVector(OBJ_PosGet(), tv_me_to_cadavre, color_cyan)
		tf_dot = MATH_VecDotProduct(tv_sight, tv_me_to_cadavre)
		
		// délai
		f_cadavre_atterissage_delay -= MATH_FloatMin(f_cadavre_atterissage_delay, TIME_GetDt())
		if( ! f_cadavre_atterissage_delay && tf_dot > Cf_Cos10 )
		{
			i_cadavre_atterrissage_1st_test_done = vrai
			if( KBC_Cadavre_Libre(o_cadavre) 
				&& KBC_Cadavre_Safe(o_cadavre) 
				&& ! KBC_Gao_Is_Near_Fire(o_cadavre) 
				&& ! IsWaterUnderPos(@o_cadavre OBJ_PosGet()) )
			{
				// c safe je peux me poser
				i_atterrissage_mode = Ci_atterrissage_sur_charogne
				o_cible = o_cadavre
				i_charogne_ID = KBC_Cadavre_Get_ID(o_cadavre)
				KBC_Interet_Update(mid_interet_charogne, C_EVENT_InteretStatusFoodchainLocked, o_cadavre, tmid_vision)	// il est à moi !!!
				i_trex_pos_index = -1
				macro_change_etat("KBC_ETAT_Move_Atterrit")
			}
			else
			{
//				if( i_mode_agressif_ON )
				{
					// cadavre pas safe mais je dois rester occupé quand même, je vais retester s'il est dispo dans un moment
					KBC_DBG_Trace_Gao(i_DBG_trace_etat, "pas libre ou trop dangereux, je n'atterrit pas, j'attend un peu... ", o_cadavre)
					f_cadavre_atterissage_delay = MATH_RandFloat(1.5, 3.0)
				}
//				else
//				{
//					KBC_DBG_Trace_Gao(i_DBG_trace_etat, "cadavre pas safe ou pas dispo mais je suis un vrai charognard, je repars en abandonnant...", o_cadavre)
//					f_speed = 0.0
//					o_cadavre = nobody
//					AI_Execute("KBC_exec_init_attente")
//				}
			}
		}
		break
}

