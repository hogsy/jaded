#include "KBC_defines.var"

//=====================================================================
// Retourne le nb de solts d'intérêts pris pas une bat
//=====================================================================
procedure_ultra int KBC_Interet_Slots_Nb_Get()
{
	if( i_big_bat )
		return 2
	else
		return 1
}


//=====================================================================
// Retourne le rayon courant de check de collisions molles de la bat
//=====================================================================
procedure_ultra float KBC_SoftCol_Rayon_Get()
{
	return f_softcol_rayon_current
}


//=====================================================================
// Retourne le vecteur de décalage courant de collisions molles de la bat
//=====================================================================
procedure_ultra vector KBC_SoftCol_Decal_Get()
{
	return v_softcol_decal_current
}


//=====================================================================
// Retourne le coef de zoom de la bat
//=====================================================================
procedure_ultra float KBC_Zoom_Get()
{
	return f_zoom
}


//=====================================================================
// Retourne vrai si c'est une grosse bat
//=====================================================================
procedure_ultra int KBC_IsABigBat()
{
	return i_big_bat
}


//=====================================================================
// Modifie l'état init pour que la bat sache qu'elle vient d'être spawnée pour un finish
//=====================================================================
procedure_ultra void KBC_Init_Spawn_Finish()
{
	i_etat_init = Ci_etat_init_spawn_finish_IA
	i_follower = faux		// si la bat qui me spawne était une follower
	i_I_finish_leader = faux
}


//=====================================================================
// Retourne vrai si la grosse bat est en train d'attaquer KONG
//=====================================================================
procedure_ultra int KBC_BigBatAttacksKong()
{
	if( o_big_bat_target == o_Kong )
		return OBJ_CapaTest(CAPA_BigBat_attaque_en_cours)
	return faux
}


//=====================================================================
// Retourne le wp d'atterrissage sur le nid (position de Ann grabbée)
//=====================================================================
procedure_ultra object KBC_GetLandingWP()
{
	if( i_etat_courant == ETAT_Move_Atterrit )
		return o_wp_pause
	
	return nobody
}


//=====================================================================
// Retourne vrai si KONG peut esquiver la bat (si faux, KONG va dasher vers la bat)
//=====================================================================
procedure_ultra int KBC_Proc_canBeDodged()
{
	if (! i_big_bat)					// Small Bat pas de Dodge
		return faux

	if (! o_big_bat_target)		// Big Bats pas de Dodge si Pas en Attaque
		return faux

	switch( i_etat_courant )
	{
		case ETAT_Agonie :		// Big Bats pas de Dodge si morte ou agonisante
		case ETAT_Mort :
		case ETAT_Sol_Ecrasement :
			return faux
		default:
			return vrai
	}
}


procedure_ultra float KBC_Proc_Get_Ride_Pos_Coef()
{
	return f_pos_blend_coef_ride
}


procedure_ultra void KBC_Interact_Ann_Take_Fake_Paf()
{
	if( i_etat_courant == ETAT_Fight_Contact && f_time_start_etat > 1.0 )
		i_interaction_Ann_fake_paf = vrai		// ann appelle cette fct en continue, c moi qui restreint !!!
}

procedure_ultra int KBC_Launch_Reward()
{
	return i_KK_Is_Reward
}

procedure_ultra void KBC_Set_Manager(object to_manager, int ti_index)	// synchronisation avec le manager
{
	i_bigbat_manager_index = ti_index
	o_bigbat_manager = to_manager
	if( i_DBG_trace_etat )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" : se synchronise avec ")
		DBG_TraceObject(o_bigbat_manager)
		DBG_TraceString(" (indice = ")
		DBG_TraceInt(i_bigbat_manager_index)
		DBG_TraceString(" )")
		DBG_TraceEOL()
	}
}

procedure_ultra int KBC_BigBat_AttackEnCours_KameraCCKongtoBat()
{
	if( i_big_bat )
	{
		switch( i_etat_courant )
		{
			case ETAT_Fight_Wait_Begin :
				if ( f_wait_begin_remaining_time < 0.5)
					return vrai
				break
			case ETAT_BigBat_Fight_Plonge :
				if( OBJ_SqrDist(o_Kong) > (25*25) )
					return vrai
				break
		}
	}
	return faux
}


procedure_ultra int KBC_BigBat_Ronde()		// pour activer la vague de spawner une fois la bat loin
{
	if( i_big_bat && i_etat_courant == ETAT_Move_Ronde && ! i_calc_net_apres_mashing )
		return vrai
	return faux
}

// pour le helper "dodge "et pour désactiver la caméra si kong ets proche du mashing
// 0 : du début de l'attente jusqu'au paf / dodge
// 1 : la phase d'attente (moins les 0.5 dernières sec)
// 2 : après la phase d'attente (les 0.5 dernières sec + le piqué)
procedure_ultra int KBC_BigBat_PlungeonAttack(int ti_phase)
{
	if( i_big_bat )
	{
		switch( i_etat_courant )
		{
			case ETAT_Fight_Wait_Prio :
				if( ti_phase == 0 || ti_phase == 1 )
					return vrai
				break
			case ETAT_Fight_Wait_Begin :
				if( ti_phase == 0 )
					return vrai
				if( f_wait_begin_remaining_time > 0.5 )
				{
					if( ti_phase == 1 )
						return vrai
				}
				else
				{
					if( ti_phase == 2 )
						return vrai
				}
				break
			case ETAT_BigBat_Fight_Plonge :
				if( ti_phase == 0 || ti_phase == 2 )
					return vrai
				break
		}
	}
	return faux
}

procedure_ultra int KBC_IsGrabbingAnn()
{
	if( o_Jack && MSG_GlobalIsValid(mid_grab_charogne) && o_cible == o_Jack )
		return vrai
	return faux
}

