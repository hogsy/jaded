#include "KBC_defines.var"

// Constantes pour positionner le bat pour l'anim "atterrissage tr att proie"
#define		Cf_atterrissage_distance		1.813
#define		Cf_atterrissage_hauteur		1.886
#define		Ci_coef_blend_correction		50

object			to_tete
object			to_bone
object			to_cadavre_backup

messageid		tmid_vision

vector		tv_pos_grab		// position de grab de la charogne
vector		tv_decal_grab 		// décalage pour la position de grab
vector		tv_decal_anim		// décalage pour positionner le bat pour l'anim d'atterrissage
vector		tv_temp

int				ti_trex_pos_index


// SORTIE ETAT ===============================================================
if (i_sort_etat)
{
	i_flag_frein = faux
	i_flag_attente_hors_champ = faux
	// FOODCHAIN
	if( i_etat_courant != ETAT_Mange )
	{
		if( o_cadavre && @o_cadavre AI_IsModel(get_KCadavre_path) )
			@o_cadavre KCadavre_EmplacementLibere(i_trex_pos_index)
		i_trex_pos_index = -1	// réinit pos miam miam :)
		o_cadavre = nobody
	}
	// FOODCHAIN
	
	i_sort_etat = faux
	return
}


// OFFSETS ===============================================================

// décalage pour bien se positionner sur le cadavre -----------------------------------------
switch( i_atterrissage_mode )
{
	// ATTERRISSAGE SUR CADAVRE --------------------------------------------------------------------
	case Ci_atterrissage_sur_charogne :
		if( @o_cible AI_IsModel(get_KCadavre_path) )
		{
			// TREX fake
			if( i_trex_pos_index == -1 )
			{
				// je n'ai pas encore choisi ma place
				i_trex_pos_index = @o_cible KCadavre_EmplacementGetDisponibleIndex()
				if( i_trex_pos_index == -1 )
				{
					// il n'y a pas de place disponible :(
					KBC_DBG_Trace_Gao(1, "il n'y a plus de place dispo sur le cadavre, je ne peux pas atterrir donc je me casse !!!", o_cible)
					// je simule l'init de l'état (pour la sortie de l'état précédent)
					i_etat_ancien = i_etat_courant
					i_etat_courant = ETAT_Move_Atterrit
					if (fct_last_etat)
					{
						i_sort_etat = vrai
						AI_Execute(fct_last_etat)
					}
					fct_last_etat = AI_TrackCurGet()
					f_time_start_etat = 0.0
					AI_Execute("KBC_exec_init_attente")
					return
				}
			}
			// j'ai de la place :)
			v_cible_pos = @o_cible KCadavre_EmplacementGetPosition(i_trex_pos_index)
			tv_pos_grab = v_cible_pos
		}
		else if( i_charogne_ID == C_ID_Tyranosaure )
		{
			// Choix du positionnement sur le TRex
			if( @o_cible AI_IsModel(get_PNJ_KTREX_Path) )
			{
				// vrai TREX mort
				if( i_trex_pos_index == -1 )
				{
					ti_trex_pos_index = @get_global i_Bat_On_TRex_Position_Index
					i_trex_pos_index = MATH_Modulo(ti_trex_pos_index+1, 6)
					@get_global i_Bat_On_TRex_Position_Index = i_trex_pos_index
				}
				switch( i_trex_pos_index )
				{
					case 2 :
						to_bone = @o_cible ANI_CanalObjectGet(Anim_Canal_Tete)
						tv_decal_grab = @to_bone MATH_VecLocalToGlobal(cvector(0.3,0.8,0)) * @o_cible OBJ_ZoomGet()
						break
					case 1 :
						to_bone = @o_cible ANI_CanalObjectGet(Anim_Canal_Ventre)
						tv_decal_grab = @to_bone MATH_VecLocalToGlobal(cvector(-0.8,0,0)) * @o_cible OBJ_ZoomGet()
						break
					case 0 :
						to_bone = @o_cible ANI_CanalObjectGet(Anim_Canal_Bassin)
						tv_decal_grab = @to_bone MATH_VecLocalToGlobal(cvector(-1,0,0)) * @o_cible OBJ_ZoomGet()
						break
					case 3 :
						to_bone = @o_cible ANI_CanalObjectGet(Anim_Canal_Torse)
						tv_decal_grab = @to_bone MATH_VecLocalToGlobal(cvector(0,0.8,0)) * @o_cible OBJ_ZoomGet()
						break
					case 4 :
						to_bone = @o_cible ANI_CanalObjectGet(Anim_Canal_PiedDroit)
						tv_decal_grab = @to_bone MATH_VecLocalToGlobal(cvector(-0.3,0,0)) * @o_cible OBJ_ZoomGet()
						break
					case 5 :
					default:
						to_bone = @o_cible ANI_CanalObjectGet(Anim_Canal_Bassin)
						tv_decal_grab = @to_bone MATH_VecLocalToGlobal(cvector(-0.3,-0.6,-2)) * @o_cible OBJ_ZoomGet()
						break
				}
				v_cible_pos = @to_bone OBJ_PosGet()
				tv_pos_grab = v_cible_pos
			}
			else
			{
				DBG_Error("[KBATS] Un TREX est mort mais il ne s'agit ni d'un K-TREX ni d'un KCadavre ??? Je ne sais pas gérer ça, ce n'est pas prévu !!!!")
			}
		}
		else if( @o_cible AI_IsModel(get_PNJ_Bidoche_path) )
		{
			tv_decal_grab = cvector(0,0,0.1) * @o_cible OBJ_ZoomGet()
			v_cible_pos = @o_cible OBJ_PosGet()
			tv_pos_grab = v_cible_pos
		}
		else if( i_charogne_ID != -1 )
		{
			tv_decal_grab = @"univ" Enemy_av_GrabTransporte_Offset[i_charogne_ID] * @o_cible OBJ_ZoomGet()
			v_cible_pos = @o_cible OBJ_PosGet()
			tv_pos_grab = v_cible_pos
		}
		else
		{
			tv_decal_grab = cvector(0,0,0.2) * @o_cible OBJ_ZoomGet()
			v_cible_pos = @o_cible OBJ_PosGet()
			tv_pos_grab = v_cible_pos
		}
		break
	
	// ATTERRISSAGE DANS LE NID (avec ou sans proie) -------------------------------
	case Ci_atterrissage_nid_pause :
		tv_decal_grab = Cv_NullVector
		v_cible_pos = @o_cible_depl OBJ_PosGet()
		tv_pos_grab = v_cible_pos
		break
}


// ENTREE ETAT ===============================================================
if (i_etat_courant != ETAT_Move_Atterrit )
{
	i_etat_ancien_ancien = i_etat_ancien
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Move_Atterrit
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	KBC_DBG_Trace(i_DBG_trace_etat, "etat move atterrit")
	
	if( o_cadavre )
		o_cible = o_cadavre
	
	v_dest_sight = OBJ_SightGet()
	DBG_RenderVector(OBJ_PosGet(), v_dest_sight * 5, color_bleu)
	// décalage 1 : position pour grabber
	DBG_RenderVector(v_cible_pos, tv_decal_grab, color_bleu)
	// décalage 2 ; pour l'anim d'atterrissage
	tv_decal_anim = KBC_Calc_Pos_Decalage( - v_dest_sight, Cf_atterrissage_distance, Cf_atterrissage_hauteur, vrai)	// position pour anim
	DBG_RenderVector(v_cible_pos + tv_decal_grab, tv_decal_anim, color_jaune)
	// décalage 3 : décalage total
	v_decalage = tv_decal_grab + tv_decal_anim
	v_dest_pos = tv_pos_grab + v_decalage		// position de destination
	DBG_RenderVector(v_cible_pos, v_decalage, color_vert)
	
	// wp d'arrivée
	@o_tmp_obj_next OBJ_PosSet(v_dest_pos)
	@o_tmp_obj_next OBJ_BankingGeneralSet( v_dest_sight, Cv_VerticalVector)
	o_next_wp = o_tmp_obj_next
	
	f_time_action = TIME_Get()
	
	o_next_reacheable_wp_backup = nobody		// antibug... ???
	
	KBC_select_action()
	KBC_action_frequency_set(1.0)
	KBC_ref_speed_set(Cf_speed_atterrit)
	f_obstacle_duration = 0.0		// check obstacle pour aller chopper de la bouffe
	f_speed = 0.0
	KBC_Sound_Cri_Presence_Play()
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===========================================================================================
MACRO_CHECK_PAFS
if( o_best_paf_pere_enabled )
{
	o_cible_attaque = o_best_paf_pere_enabled
	i_cadavre_joueur_proche_flag = vrai
	AI_Execute("KBC_exec_init_attaque")
}

DBG_RenderVector(v_cible_pos, tv_decal_grab, color_bleu)

if( o_cible && i_atterrissage_mode == Ci_atterrissage_sur_charogne )//&& ! KBC_Cadavre_Test(o_cible, i_charogne_ID) )
{
	if( ! KBC_EstToujoursUnCadavre(o_cible) )
	{
		KBC_DBG_Trace_Gao(i_DBG_trace_etat, "ma cible n'est plus un cadavre, je repars...", o_cible)
		KBC_Cadavre_Del(o_cible)
		AI_Execute("KBC_exec_init_attente")
	}
	
	if( KBC_ModeCharognardKongTropProche() )
	{
		KBC_DBG_Trace(i_DBG_trace_etat, "KONG est trop proche !!!")
		KBC_Cadavre_Del(o_cible)
		AI_Execute("KBC_exec_init_attente")
	}
}


// EMERGENCY ABORT =============================
if( o_cible && ! KBC_TargetStillActive(o_cible) )
{
	KBC_Cadavre_Del(o_cible)
	o_cible = nobody
	AI_Execute("KBC_exec_init_attente")
}

// TEST CIBLE DANS TERRITOIRE (FEU ???)
if( o_cible && ! KBC_Gao_in_Territory(o_cible, vrai) )
{
	KBC_DBG_Trace_Gao(vrai, "ma cible n'est plus dans mon territoire (feu ???) alors je repars", o_cible)
	AI_Execute("KBC_exec_init_attente")
}

// TEST CADAVRE DANS TERRITOIRE (FEU ???)
if( o_cadavre && ! KBC_Gao_in_Territory(o_cadavre, vrai) )
{
	KBC_DBG_Trace_Gao(vrai, "mon cadavre n'est plus dans mon territoire (feu ???) alors je repars", o_cadavre)
	AI_Execute("KBC_exec_init_attente")
}


// Test Bidoche rammassée ----------------------------
if( o_cible && @o_cible AI_IsModel(get_PNJ_Bidoche_path) && @o_cible OBJ_CapaTest(CAPA_Bidoche_Snapped_Jack) )
{
	KBC_DBG_Trace(i_DBG_trace_etat, "ma proie était une bidoche qui vient d'être ramassée")
	AI_Execute("KBC_exec_init_attente")
}

if( o_cible )
	KBC_Interet_Update(mid_interet_charogne, C_EVENT_InteretStatusFoodchainLocked, o_cible, tmid_vision)


// Obstacle ----------------------------------------------------------------------------------
AI_Execute("KBC_exec_check_obstacle")
if( i_flag_obstacle )
{
	KBC_DBG_Trace(i_DBG_trace_etat, "un obstacle l'empeche d'atterrir ")
	to_cadavre_backup = o_cadavre
	AI_Execute("KBC_exec_init_attente")
	o_cadavre = to_cadavre_backup
}


// Suivi du regard =======================================================================
i_flag_neck = faux
if( ACT_ActionGet() == ACTION_Mange_Attente )
{
	if( o_cible )
	{
		to_tete = @o_cible ANI_CanalObjectGet(Anim_Canal_Tete)
		if( ! to_tete )
			to_tete = o_cible
		i_flag_neck = vrai
		v_look_pos = @o_cible OBJ_PosGet()
	}
}
else if( ACT_ActionGet() == ACTION_Mange_Attente )
{
	// pas de proie, posée : elle regarde JACK
	if( @get_global i_Player_is_Kong )
		v_look_pos = @o_Kong OBJ_PosGet()
	else
		v_look_pos = @o_Jack OBJ_PosGet()
}
else if( o_cible_depl )
{
	// pas de proie, en vol : la bat observe son nid
	i_flag_neck = vrai
	v_look_pos = @o_cible_depl OBJ_PosGet()
}



// TEST JOUEUR PROCHE PENDANT CYCLE FOODCHAIN
if( i_atterrissage_mode == Ci_atterrissage_sur_charogne )
{
	AI_Execute("KBC_exec_cadavre_joueur_proche")
}


// ========== DEPLACEMENT ===========================================================

if( ACT_ActionGet() == i_ACTION_Vol_Standard || ACT_ActionGet() == ACTION_Vol_Proie )
{
//	f_beziers_pourcent = Cf_beziers_pourcent_courbe_atterrissage
	AI_Execute("KBC_exec_MOVE_beziers")
	if( i_flag_depl_fini )
	{
		// on recale bien la bat
		OBJ_PosSet( @o_next_wp OBJ_PosGet() )
		OBJ_BankingGeneralSet( @o_next_wp OBJ_SightGet(), @o_next_wp OBJ_BankingGet())
		
		// bat arrivé -> anim d'atterrissage sur le cadavre
		ACT_ActionSet( ACTION_Vol_Atterrissage_fin )			// wp anim atterrissage_fin atteint -> passage en anim atterrissage_fin
		@o_tmp_obj_last OBJ_PosSet( v_cible_pos + tv_decal_grab )								// TODO : supprimer cette ligne de debug !!!
		@o_tmp_obj_last OBJ_BankingGeneralSet( v_dest_sight, Cv_VerticalVector)	// TODO : supprimer cette ligne de debug !!!
		@o_next_wp OBJ_PosSet(v_cible_pos)		// pour le calcul de restriction de speed en fonction de ma position / wp next
	}
}
else if( ACT_ActionGet() == ACTION_Vol_Atterrissage_fin) 
{
	f_speed = 0.0			// vitesse nulle pour redécoller si paf
	if( ACT_ActionFinished() )
	{
		tv_temp = v_cible_pos + tv_decal_grab - OBJ_PosGet()
		if( MATH_VecNorm(tv_temp) > 0.5 )
		{
			KBC_DBG_Trace(i_DBG_trace_etat, "n'a pas atterit où elle le souhaitait = il doit y avoir un obstacle")
			AI_Execute("KBC_exec_init_attente")
		}
		ACT_ActionSet(ACTION_Mange_Attente)					// le bat a atterrit -> il attend avant de manger
		f_time_action = TIME_Get()		// durée d'attente (cas atterrissage nid sans proie)
		DYN_Off()		// pour ne pas glisser
	}
	else if( ANI_CurrentFrameGet(0) > 45 )
	{
		if( MSG_GlobalIsValid(mid_grab_charogne) )
			LNK_GrabStatusSet(mid_grab_charogne, Ci_GrabTransporte_Type_Atterrit)		// la proie change d'anim
	}
}
else if( ACT_ActionGet() == ACTION_Mange_Attente )
{
	if( MSG_GlobalIsValid(mid_grab_charogne) )
		LNK_GrabStatusSet(mid_grab_charogne, Ci_GrabTransporte_Type_Pose)		// la proie change d'anim
	switch( i_atterrissage_mode )
	{
		case Ci_atterrissage_sur_charogne : 
			i_mange_mode = Ci_mange_gouter_charogne
			macro_change_etat("KBC_ETAT_Sol_Mange")		// le bat a attendu -> il va manger la charogne
			break

		case Ci_atterrissage_nid_pause :
			if( i_big_bat )
				macro_change_etat("KBC_ETAT_BigBat_Sol_Wait")		// test validité liaison dans etat sol interaction Ann
			else if( TIME_Elapsed(f_time_action, 5.0) )
			{
				// une bat std décolle au bout de 5 sec, la bat noire attend la capa 0 
				i_envol_palier = 0
				macro_change_etat("KBC_ETAT_Move_Decolle")
			}
			break
	}
}

// Décolle grace à la capa ----------------------------------------------
if( OBJ_CapaTest(CAPA_Decolle) )
{
	OBJ_CapaSet(0, CAPA_Decolle)
	if( MSG_GlobalIsValid(mid_grab_charogne) )
	{
		LNK_GrabStatusSet(mid_grab_charogne, Ci_GrabTransporte_Type_Vole)		// la proie change d'anim
		i_request_txt_forced = GeneKAnn_C_danger_need
	}
	i_envol_palier = 2
	macro_change_etat("KBC_ETAT_Move_Decolle")
}

