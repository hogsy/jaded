#include "KBC_defines.var"

float			tf_norm
float			tf_angle

vector		tv_last_pos

// mem ancienne position du balancier
tv_last_pos = v_balancier_pos

// position du point de balancier
v_balancier_pos.z -= TIME_GetDt() * 2.0											// gravité
//v_balancier_pos.z = OBJ_PosGet().z											// gravité
//v_balancier_pos += v_balancier_speed * (TIME_GetDt() * 0.75)			// déplacement
v_balancier_pos += v_balancier_speed * TIME_GetDt()						// déplacement

v_balancier_pos -= OBJ_PosGet()							// v_balancier_pos = vecteur entre le bats et le balancier
//DBG_RenderVector(OBJ_PosGet(), v_balancier_pos, color_cyan)
tf_angle = (Cf_PiBy8 / 2.0)
//DBG_RenderCone(OBJ_PosGet(), - Cv_VerticalVector, tf_angle, color_vert)
v_balancier_pos = MATH_VecInCone(v_balancier_pos, - Cv_VerticalVector, tf_angle, 0)
//DBG_RenderVector(OBJ_PosGet(), v_balancier_pos, color_jaune)

tf_norm = MATH_VecNorm(v_balancier_pos)
if( ! MATH_FloatNullEpsilon(tf_norm) )
{
	v_balancier_pos /= tf_norm									// normalize
	v_balancier_pos *= Cf_bras_de_levier						// positionne à la bonne distance du bats
	
	if( KBC_Balancier_Enabled() )
		OBJ_SightGeneralSet(OBJ_SightGet(), -v_balancier_pos)
	
}

v_balancier_pos += OBJ_PosGet()						// nouvelle position du balancier (distance bats / balancier + position bats)

v_balancier_speed = (v_balancier_pos - tv_last_pos) / TIME_GetDt()			// vitesse balancier : distance parcourue depuis la dernière frame / durée de la frame
