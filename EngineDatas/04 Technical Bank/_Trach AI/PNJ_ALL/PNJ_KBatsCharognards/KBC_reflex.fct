#include "KBC_defines.var"

messageid		tmid_vis_ID
messageid		tmid_vision
messageid		tmid_life

object			to_canal
object			to_kamera

vector			tv_pos_2D
vector			tv_pos
vector			tv_kamera_horizon
vector			tv_offset
vector			tv_ground_normale

float				tf_interet
float				tf_liferatio
//float				tf_HP_avant_paf
float				tf_rayon_vision
float				tf_kamera_dot
float				tf_blend
float				tf_bigbat_mash_or_climb

int					ti_context
int					ti_ground_ID
int					ti_type_sol
int					ti_NMI_state
int					ti_instant_grab_ann_done
int					ti_bigbat_mashing
int					ti_bigbat_climbing

string				str_txt


// MAIN ACTORS ======================================================
AI_Execute("KBC_exec_check_main_actors")


if (i_my_index == -1)
{
	i_my_index = @get_global i_soft_col_bat_nb
	@get_global ao_soft_col_bat[i_my_index] = OBJ_Me()
	@get_global i_soft_col_bat_nb++
}

//if( IO_KeyPressed(65) )
//	KBC_GFX_Particules(OBJ_PosGet() + OBJ_SightGet(), - OBJ_SightGet())

i_budy_nb = 0

// WAIT SINUS -------------------------------------------------------------------------------------------------
i_wait_sinus_flag = faux
f_wait_sinus_duration -= MATH_FloatMin(f_wait_sinus_duration, TIME_GetDt())
if( f_wait_sinus_duration )
	i_wait_sinus_flag = vrai

f_dont_check_cadavre -= MATH_FloatMin(f_dont_check_cadavre, TIME_GetDt())

// TEST TRIGGER SMALL KNMI MUST DIE ---------
if( ! i_big_bat && @get_global i_Small_KNMI_must_die )
{
	OBJ_Destroy()
}

i_check_sang_already_done = faux
f_attack_interaction_delai -= MATH_FloatMin(f_attack_interaction_delai, TIME_GetDt()) f_change_anim_delay -= MATH_FloatMin(f_change_anim_delay, TIME_GetDt())

// BIG BAT --------------------------------
f_bigbat_delai_no_attack -= MATH_FloatMin(f_bigbat_delai_no_attack, TIME_GetDt())
f_bigbat_delai_no_kamera -= MATH_FloatMin(f_bigbat_delai_no_kamera, TIME_GetDt())
f_big_bat_no_paf -= MATH_FloatMin(f_big_bat_no_paf, TIME_GetDt())
f_release_grab_actor_keep_kamera -= MATH_FloatMin(f_release_grab_actor_keep_kamera, TIME_GetDt())
i_bigbat_gamespeed_flag = faux
o_fury_check_actor = nobody
// BIG BAT --------------------------------
f_time_meat_bite -= MATH_FloatMin(f_time_meat_bite, TIME_GetDt())

// Release_Grabbed_Actor (avant le test de CAPA_BigBat_attaque_possible !!!! pour pouvoir la passer à vrai dans la même trame)
if( i_big_bat && OBJ_CapaTest(CAPA_Release_Grabbed_Actor) )
{
	// capa resetée à la fin de l'IA pour pouvoir la tester dans l'état !!!
	o_cible = LNK_ServeurGet(Ci_LNK_GRAB_TRANSPORTE, mid_grab_charogne, faux, nofunc, nofunc)
	o_attack_interaction = LNK_ClientGet(Ci_LNK_INTERACTION, mid_attack_interaction_LKN_ID, faux, "KBC_exec_interaction_add_data", nofunc, "KBC_exec_interaction_init")
//	f_release_grab_actor_keep_kamera = 0.5
}


// TRIGGER INSTANT GRAB ANN =============================================
ti_instant_grab_ann_done = faux
if( o_Jack && @get_global o_KBigBat_instant_grab_Ann == OBJ_Me() )
{
	if( ! MSG_GlobalIsValid(mid_grab_charogne) || EVENT_TargetGet(mid_grab_charogne) != o_Jack )
	{
		ti_instant_grab_ann_done = KBC_InstantGrabAnn()
	}
	else
	{
		ti_instant_grab_ann_done = vrai
	}
	if( ti_instant_grab_ann_done )
	{
		@get_global o_KBigBat_instant_grab_Ann = nobody
		if( @get_global i_KBigBat_instant_grab_Ann_reset )
		{
			AI_Execute("KBC_exec_init_attente")
			@get_global i_KBigBat_instant_grab_Ann_reset = faux
		}
	}
}


// FOLLOWER : retourne en follower si sortie du mode
if( i_follower_init && ! i_follower && EVENT_LIFE_CurLifeGet(ID_LIFE) > 0.0 )
{
	switch( i_etat_courant )
	{
		case ETAT_KK_Finish : 
		case ETAT_KK_Grabbed_by_Kong :
		case ETAT_KK_Projectile :
		case ETAT_KK_Ride :
		case ETAT_Paf :
		case ETAT_Paf_KK_Ecrase :
		case ETAT_Sol_Ecrasement :
		case ETAT_Fight_Follower : 		// pas la peine ! :)
			break
		default:
			tmid_life = EVENT_LIFE_MSGID_Get(o_follow_gao)
			if( MSG_GlobalIsValid(tmid_life) )
			{
				if( ! EVENT_LIFE_Est_Blesse(tmid_life) )
				{
					f_follow_blend_coef = 0.0
					macro_change_etat("KBC_ETAT_Wait_Follower")
				}
			}
			break
	}
}

to_canal = ANI_CanalObjectGet(Anim_Canal_Tete)
tv_pos_2D = VIEW_3dWorldTo2d(0, @to_canal OBJ_PosGet())
//if( i_big_bat ) 
//{
//	Str_DisplayFloatOnce(f_speed, tv_pos_2D)
//	Str_DisplayFloatOnce(f_anim_frequency_cur, tv_pos_2D + cvector(0,0.05,0))
//}

f_total_time += TIME_GetDt()

// état de KONG ? ------------------------- 
i_KONG_is_in_walling = faux
i_KONG_is_in_mashing = faux
i_KONG_is_on_ground = faux
if( o_Kong )
{
	if( KBC_KONG_is_in_Walling() )
		i_KONG_is_in_walling = vrai
	if( KBC_KONG_is_in_Mashing() )
		i_KONG_is_in_mashing = vrai
	if( KBC_KONG_is_on_Ground() )
		i_KONG_is_on_ground = vrai
}


i_vitesse_derapage_init = faux

// DELAI SOFTCOL HORIZ
f_softcol_no_down_delai -= MATH_FloatMin(f_softcol_no_down_delai, TIME_GetDt())

// DELAI NE PAS REATTAQUER
f_paf_delai_aucune_attaque -= MATH_FloatMin(f_paf_delai_aucune_attaque, TIME_GetDt())

// BEZIERS CETTE TRAME
i_beziers_flag_cette_trame = faux
f_beziers_speed = 0.0
i_speed_beziers_flag = faux
i_speed_vertical_flag = faux
f_beziers_pourcent = Cf_beziers_pourcent_courbe_standard

// OBSTACLE
f_time_since_last_obstacle += TIME_GetDt()

// DESYNCHRO
f_time_attaque_fin_desynchro -= MATH_FloatMin(f_time_attaque_fin_desynchro, TIME_GetDt())

// SOUND
i_flag_check_sound_valide = faux

// ROTATION
f_rotation_angle_courant = MATH_FloatMin(f_angle_rotation_max, f_rotation_angle_courant + (5 * TIME_GetDt()))


// CHECKS ============================
i_flag_check_paf_done = faux
i_flag_check_vision_done = faux
i_seen_actor_nb = 0
i_flag_check_cadavres_done = faux
if( JOUR_NUIT_HeureCorrecte(f_Heure_Debut, f_Heure_Fin) 
	|| i_etat_courant == ETAT_Move_Atterrit
	|| i_etat_courant == ETAT_Mange )
{
	AI_Execute("KBC_exec_check_vision")
	AI_Execute("KBC_exec_check_cadavres")
}

// FACE DE MORT =========================================
if( COL_GMatReportGet(Gmat_KK_Face_de_mort) != -1 )
{
	KBC_DBG_Trace(i_DBG_trace_etat, "face de mort...")
	OBJ_Destroy()
}


// COLLISION GROUND =======================================
tv_ground_normale = Cv_NullVector
if( KBC_est_au_sol() )
{
	f_time_air = 0.0
	tv_ground_normale = Cv_VerticalVector
	if (COL_CollideType(COL_C_Ground))
	{
		tv_ground_normale = COL_ZonePosGet(C_zdm_pied)
		tv_ground_normale -= COL_CollidedPointGet(COL_C_Ground)
		if( ! MATH_VecNullEpsilon(tv_ground_normale) )
			MATH_VecSetNormalize(tv_ground_normale)
		if (tv_ground_normale.z < 0.0)
			tv_ground_normale*= -1.0
	}
}
else
{
	f_time_air += TIME_GetDt()
	if( f_time_air > 0.2 )
		tv_ground_normale = Cv_VerticalVector
}
if( ! MATH_VecNullEpsilon(tv_ground_normale) )
{
	v_ground_normale = MATH_VecBlendRotate(v_ground_normale, tv_ground_normale, 8.0 * TIME_GetDt())
//	DBG_RenderVector(OBJ_PosGet(), v_ground_normale * 10.0, color_bleu)
	if( ! MATH_VecNullEpsilon(v_ground_normale) )
		MATH_VecSetNormalize(v_ground_normale)
}


// SND SPLASH EN MOURANT DANS L'EAU
if( EVENT_LIFE_CurLifeGet(ID_LIFE) <= 0.0 
	&& (i_etat_courant == ETAT_Chute_Libre || i_etat_courant == ETAT_Chute_WP) 
//	&& COL_GMatReportGet(Gmat_KK_Face_eau) != -1)
	&& IsInWater(OBJ_PosGet(), f_water_Z) )
{
	// GFX
	if( MATH_VecNullToler(v_water_GFX_pos, 0.01) )
		v_water_GFX_pos = OBJ_PosGet()
	if( f_water_GFX_time )
		KBC_GFX_Splash(v_water_GFX_pos)
	f_water_GFX_time -= MATH_FloatMin(f_water_GFX_time, TIME_GetDt())
	// SND
	if( ! i_splash_flag )
	{
		i_splash_flag = vrai
		SND_RequestPlay(Ci_SND_Splash)
	}	
}


// DYNAMIQUE ==============================================
if( ! i_splash_flag )
{
	if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
	{
		DYN_TractionSet(Cv_NullVector)
		if( i_etat_courant != ETAT_KK_Finished && i_etat_courant != ETAT_Paf )		// géré dans l'état
		{
			if( KBC_est_au_sol() || i_etat_courant == ETAT_Chute_Libre )
				DYN_GravitySet(Cv_NormalGravity)
			else if (i_etat_courant == ETAT_KK_Projectile)
				DYN_GravitySet(Cv_Bat_throw_gravity)
			else
				DYN_GravitySet(Cv_NullVector)
		}
	}
}


f_time_cri_paf = MATH_FloatMax(0.0, f_time_cri_paf - TIME_GetDt())
f_time_cri_presence = MATH_FloatMax(0.0, f_time_cri_presence - TIME_GetDt())


if( EVENT_LIFE_CurLifeGet(ID_LIFE) )
{
//	EVENT_LIFE_StateDisplay( ID_LIFE, tv_pos_2D)
	EVENT_LIFE_LifeDisplay( ID_LIFE, tv_pos_2D + cvector(0.0,-0.05,1.5))
	
	// GRAB -----------------------------------------------------------------------------
	if( MSG_GlobalIsValid(mid_grab_charogne) )
		KBC_Interet_Update(mid_interet_charogne, C_EVENT_InteretStatusGrab, o_cible, tmid_vision)
	
	if( JOUR_NUIT_HeureCorrecte(f_Heure_Debut, f_Heure_Fin) )
	{
		// VISION ------------------------------------------------------------------------
		tmid_vis_ID = EVENT_AddEventVision(
								C_ID_BatCharognard, 
								C_EVENT_FILTER_None, 
								OBJ_Me(), 
								Cf_EVENT_Duree_1Trame, 
								OBJ_PosGet(), 
								C_EVENT_Visibility_Full_Mvt, 
								Cf_rayon_corps_bat * f_zoom, 
								100.0, 
								C_EVENT_CONTEXT_STANDARD, 
								0, 
								EVENT_LIFE_CurLifeGet(ID_LIFE) / EVENT_LIFE_MaxLifeGet(ID_LIFE))
		
		// TERRITOIRE ------------------------------------------------------------------
		if( KBC_est_au_sol() )
		{
			ti_type_sol = GRID_CapaGet(OBJ_PosGet())
			ti_type_sol &= 0x0000000f
			
			if( ti_type_sol != Ci_sol_mur )
				EVENT_VisionTerritoryUdpate(tmid_vis_ID)			// n'update pas le territoire sur une case jaune
		}
		
		// HORS CHAMP -----------------------------------------------------------------
		if( KBC_IsHorsChampCamera() )
		{
			if( f_duree_dans_champ_camera )
				f_time_debut_wait_hors_champ = TIME_Get()		// la trame d'avant j'étais à l'écran
			f_duree_dans_champ_camera = 0.0
		}
		else
			f_duree_dans_champ_camera += TIME_GetDt()
		
		// ENEMY ---------------------------------------------------------------------------
		if( i_big_bat )
		{
			if( i_etat_courant == ETAT_Sol_Ecrasement || i_etat_courant == ETAT_Mort || i_etat_courant == ETAT_Fade )
				ti_NMI_state = C_EVENT_EnemyState_Quiet			// ignorée par les humains
			else
				ti_NMI_state = C_EVENT_EnemyState_Fight			// menaçante / agressive
		}
		else
		{
			switch( i_etat_courant )
			{
				case ETAT_Mort :
				case ETAT_Wait_Grotte :
				case ETAT_Chute_Libre :
				case ETAT_Chute_WP :
				case ETAT_Sol_Ecrasement :
				case ETAT_TEST :
					ti_NMI_state = C_EVENT_EnemyState_Quiet			// ignorée par les humains
					break
					
				case ETAT_Fight_Approche :
				case ETAT_Fight_Contact :
				case ETAT_Fight_Network :
				case ETAT_Fight_Pause :
				case ETAT_Fight_Wait_Begin :
				case ETAT_Fight_Wait_Prio :
				case ETAT_Paf :
					ti_NMI_state = C_EVENT_EnemyState_Fight			// menaçante / agressive
					break
				
				default:
					ti_NMI_state = C_EVENT_EnemyState_Wait			// présente...
					break
			}
		}
		EVENT_AddEventEnemy(C_ID_BatCharognard, OBJ_Me(), ti_NMI_state)
		
		// MESSAGES ------------------------------------------------------------------
		switch( i_etat_courant )
		{
			case ETAT_Paf :
			case ETAT_BigBat_Fight_Dodged :
			case ETAT_BigBat_Fight_Poursuit :
			case ETAT_BigBat_Fight_Repart :
				// ignore les messages dans ces états là
				break
			default:
				AI_Execute("KBC_exec_check_msg")	
				break
		}
	}
}
else
{
	if( f_point_de_viande && i_etat_courant != ETAT_Fade && i_etat_courant != ETAT_Grabbed_Predateur )
		EVENT_AddEventCadavre(C_ID_BatCharognard, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet())
}


// TEST GRABBED ==================================================
switch( i_etat_courant )
{
	case ETAT_Fade :
		o_grabbed_actor = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong, faux, nofunc, nofunc)
		break
		
	case ETAT_KK_Grabbed_by_Kong :
	case ETAT_KK_Finished : 
		o_grabbed_actor = o_grabbed_actor
		// pas de sortie d'état ici
		break
		
	case ETAT_KK_Projectile :
		o_grabbed_actor = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong, vrai, nofunc, nofunc)
		if( o_grabbed_actor )
		{
			if( @o_grabbed_actor AI_IsModel(get_Kong_Path) )
			{
				// kong ne me regrabbe pas qd il m'a jeté
				o_grabbed_actor = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong, faux, nofunc, nofunc)
			}
			else
			{
				// rex (ou autre ?) peut me grabber
				macro_change_etat("KBC_ETAT_Grabbed_by_Kong")
			}
		}
		break
		
	default:
		o_grabbed_actor = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong, vrai, nofunc, nofunc)
		if( o_grabbed_actor )
		{
			if( LNK_GrabKong_TypeGet( mid_grabbed_by_Kong) == Ci_GrabKong_Type_Finish )
			{
				o_finished_actor = o_grabbed_actor
				o_grabbed_actor = nobody
				macro_change_etat("KBC_ETAT_BigBat_Finished")
			}
			else
				macro_change_etat("KBC_ETAT_Grabbed_by_Kong")
		}
		break
}


// LA BIG BAT EMPECHE KONG DE GRIMPER / FAIRE LE MASHING =====================================================
if( i_big_bat && o_Kong && ! MSG_GlobalIsValid(mid_grab_charogne) && i_etat_courant != ETAT_Fight_Contact && i_etat_courant != ETAT_Mort )
{
	ti_bigbat_mashing = faux
	ti_bigbat_climbing = faux
	tf_bigbat_mash_or_climb = 0.0
	if( o_zone_detect_mashing && KBC_Gao_in_BV(o_Kong, o_zone_detect_mashing) && @o_Kong Proc_KK_Test_Mode(ETAT_Kong_grab_mashing) )
	{
		ti_bigbat_mashing = vrai
		tf_bigbat_mash_or_climb = 1.0
	}
	if( o_zone_detect_climbing && KBC_Gao_in_BV(o_Kong, o_zone_detect_climbing) && @o_Kong Proc_KK_Test_Mode(ETAT_Kong_walling) )
	{
		ti_bigbat_climbing = vrai
		tf_bigbat_mash_or_climb = 0.75
	}
	if( ti_bigbat_mashing || ti_bigbat_climbing )
	{
		f_mashing_detect_timer += TIME_GetDt()
		if( f_mashing_detect_timer > tf_bigbat_mash_or_climb )
		{
			if( ! @get_global i_KBigBat_anti_mashing )
			{
				KBC_DBG_Trace(i_DBG_trace_etat, "KONG est en mashing / climbing : je l'attaque !!!")
				KBC_reset_attaque()		// abracadabra
				OBJ_CapaSet(CAPA_BigBat_Attaque_Mashing, none)
				to_kamera = @get_global o_camera
				tv_pos = @to_kamera OBJ_PosGet()
				if( ti_bigbat_mashing )
				{
					tv_kamera_horizon = @to_kamera OBJ_HorizonGet()
					tf_kamera_dot = MATH_VecDotProduct(tv_kamera_horizon, @o_Kong OBJ_PosGet() - @to_kamera OBJ_PosGet())
					if( tf_kamera_dot < 0.0 )
						tv_offset = -2 * @to_kamera OBJ_HorizonGet()		// à gauche des mashing c plutot serré...
					else
						tv_offset = 4 * @to_kamera OBJ_HorizonGet()		// à droite des mashing y'a de la place
					tv_offset += 4 * @to_kamera OBJ_SightGet()
					DBG_RenderVector(tv_pos, tv_offset, color_rouge)
					tv_pos += tv_offset
				}
				OBJ_PosSet(tv_pos)
				COL_StartMatrixSet(tv_pos)
		 		EVENT_LIFE_CurLifeSet(ID_LIFE, MATH_FloatMax(EVENT_LIFE_CurLifeGet(ID_LIFE), Cf_BigBat_AntiMashingLifePoints) )
				o_cible_attaque = o_Kong
				OBJ_BankingGeneralSet(@o_cible_attaque OBJ_PosGet() - OBJ_PosGet(), Cv_VerticalVector)
				v_look_pos = @o_cible_attaque OBJ_PosGet()
				SND_RequestPlay(Ci_SND_Cri_Attack_Loin)
				COL_CrossableSet(Gmat_KK_Cross_All_But_Kong_And_Raptors, none)		// peut ressortir de la zone de KONG
				OBJ_CapaSet(none, CAPA_Dead_on_Ground)
				OBJ_CapaSet(none, CAPA_Dead)
				@get_global i_KBigBat_anti_mashing = vrai		// 1 big bat à la fois !!!!
				KBC_BigBat_Abort_for_Mashing_Attack()
				KBC_ref_speed_set(15.0)
				f_speed = 15.0
				v_vitesse_derapage = Cv_NullVector
				KBC_action_frequency_set(2.0)
				macro_change_etat("KBC_ETAT_Fight_Contact")
			}
			else
			{
				// 1 autre bat se charge de paffer le sagouin qui veut franchir le pilier
				EVENT_LIFE_CurLifeSet(ID_LIFE, MATH_FloatMax(EVENT_LIFE_CurLifeGet(ID_LIFE), Cf_BigBat_AntiMashingLifePoints) )
				COL_CrossableSet(Gmat_KK_Cross_All_But_Kong_And_Raptors, none)		// peut ressortir de la zone de KONG
				OBJ_CapaSet(none, CAPA_Dead_on_Ground)
				OBJ_CapaSet(none, CAPA_Dead)
				
				f_mashing_detect_timer = -5.0		// bidouille ne pas repasser ici !!!!
				KBC_BigBat_Abort()
				AI_Execute("KBC_exec_init_attente")		// reset
			}
		}
	}
	else
		f_mashing_detect_timer = 0.0
}
else
	f_mashing_detect_timer = 0.0


v_old_pos = OBJ_PosGet()


//if( AI_TriggerIsValid(trig_test) && call_trigger(trig_test) )
//	Str_DisplayTextOnce("trig_test valide !!!", cvector(0.5,0.5,0))

