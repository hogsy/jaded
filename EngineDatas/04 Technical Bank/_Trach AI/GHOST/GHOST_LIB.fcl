#include "GHOST_defines.var"

Include_UltraProcedure_Header

#define Cf_pourcentage			0.3333
#define Cf_angle_ondule_ton_corps				0.5

//procedure_local void GHOST_Init_OBBOX(float tf_size_coef)
//{
//	int			ti_i
//	object	to_bone	
//
//	if (f_obbox_size_coef == tf_size_coef)
//		return
//		
//	f_obbox_size_coef = tf_size_coef
//
//	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
//	{
//		if (ti_i == i_modules_nb - 1)
//			to_bone = ANI_CanalObjectGet(Anim_Canal_Bassin)
//		else
//			to_bone = ANI_CanalObjectGet(ti_i)
//		@to_bone OBJ_FlagsIdentitySet(OBJ_C_IdentityFlag_OBBox, none)
//		@to_bone BV_OBBoxMinSet(cvector(-0.25 * tf_size_coef, -0.25, -0.25 * tf_size_coef))
//		@to_bone BV_OBBoxMaxSet(cvector(0.25 * tf_size_coef, 0.25 , 0.25 * tf_size_coef))
//	}
//}


procedure_local void GHOST_Init_Modules()
{
	int			ti_i
	
	float		tf_size

	// TETE ============================================================================================
	if (!ao_modules[0])
	{	
		ao_modules[0] = OBJ_Me()
		@ao_modules[0] OBJ_FlagsIdentitySet(none, OBJ_C_IdentityFlag_OBBox)	

		tf_size = i_modules_nb * dist_between_module
	
//		DBG_RenderVector(OBJ_PosGet(), cvector(tf_size, 0.0, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(-tf_size, 0.0, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, tf_size, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, -tf_size, 0.0), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, 0.0, tf_size), color_cyan)
//		DBG_RenderVector(OBJ_PosGet(), cvector(0.0, 0.0, -tf_size), color_cyan)
//		DBG_RenderSphere(OBJ_PosGet(), tf_size, 0x40FF00FF)

		tf_size *= 1.1

		@ao_modules[0] BV_MinSet(-cvector(tf_size, tf_size, tf_size))
		@ao_modules[0] BV_MaxSet(cvector(tf_size, tf_size, tf_size))

//		@ao_modules[0] OBJ_ZoomSet(f_size_coef)
		@ao_modules[0] OBJ_ScaleSet(@ao_modules[0] OBJ_ScaleGet() * f_size_coef)
	}

	for (ti_i = 1; ti_i < i_modules_nb; ti_i++)
	{
		af_modules_length[ti_i] = ti_i * dist_between_module

		if (!ao_modules[ti_i])
		{	
			ao_modules[ti_i] = @get_WP OBJ_Duplicate(OBJ_PosGet())

//			ao_modules[ti_i] = ANI_CanalObjectGet(ti_i)
//			@ao_modules[ti_i] OBJ_HierarchyResetCurrent()

			@ao_modules[ti_i] OBJ_ScaleSet(@ao_modules[ti_i] OBJ_ScaleGet() * f_size_coef)
			@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i - 1] OBJ_PosGet() - (@ao_modules[ti_i - 1] OBJ_SightGet() * dist_between_module))
		}
	}
	
//	GHOST_Init_OBBOX(1.4)

	return
}

procedure_local void GHOST_Align_Modules()
{
	int			ti_i
	
	for (ti_i = 1; ti_i < i_modules_nb; ti_i++)
	{
		@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i - 1] OBJ_PosGet() - (@ao_modules[ti_i - 1] OBJ_SightGet() * dist_between_module))
		@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet(), @ao_modules[ti_i - 1] OBJ_BankingGet())
	}
	
	return
}

procedure_local void GHOST_Update_Last_Virtual_Wp(object to_module, object to_father)
{
	int			ti_before_index	

	float		tf_Z_offset

	vector	tv_pos	

	tf_Z_offset = dist_between_module * 0.5

	if (to_father == nobody)
		to_father = OBJ_HierarchyGet()

	ti_before_index = MATH_Modulo(i_virtual_net_last_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

	av_virtual_wp_pos[i_virtual_net_last_wp_index] = @to_module OBJ_PosGet()
	av_virtual_wp_pos[i_virtual_net_last_wp_index] += @to_module OBJ_BankingGet() * f_Z_noise

	ai_virtual_wp_flag[i_virtual_net_last_wp_index] = 0
	if (f_delay_until_last_ground_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_ground_col
	if (f_delay_until_last_wall_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_wall_col
	if (@to_module OBJ_PosGet().z < f_water_Z + tf_Z_offset)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_water_col

	if (ao_virtual_wp_father[ti_before_index])
		tv_pos = @ao_virtual_wp_father[ti_before_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_before_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_before_index])
	else
		tv_pos = av_virtual_wp_pos[ti_before_index]
	af_virtual_link_length[i_virtual_net_last_wp_index] = MATH_VecNorm(tv_pos - av_virtual_wp_pos[i_virtual_net_last_wp_index])

	av_virtual_wp_sight[i_virtual_net_last_wp_index] = @to_module OBJ_SightGet()
	av_virtual_wp_banking[i_virtual_net_last_wp_index] = @to_module OBJ_BankingGet()

	ao_virtual_wp_father[i_virtual_net_last_wp_index] = to_father

	if (to_father)
	{	
		av_virtual_wp_pos[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_pos[i_virtual_net_last_wp_index] - @ao_virtual_wp_father[i_virtual_net_last_wp_index] OBJ_PosGet())
		av_virtual_wp_sight[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_sight[i_virtual_net_last_wp_index])
		av_virtual_wp_banking[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_banking[i_virtual_net_last_wp_index])
	}
}

procedure_local int GHOST_Add_Virtual_Wp(object to_module, object to_father)
{
	int				ti_before_index	

	float			tf_Z_offset

	vector		tv_pos
	
	tf_Z_offset = dist_between_module * 0.5

	if (to_father == nobody)
		to_father = OBJ_HierarchyGet()

	ti_before_index = i_virtual_net_last_wp_index
	i_virtual_net_last_wp_index = MATH_Modulo(i_virtual_net_last_wp_index + 1, Ci_virtual_wp_nb)	

	av_virtual_wp_pos[i_virtual_net_last_wp_index] = @to_module OBJ_PosGet()
	av_virtual_wp_pos[i_virtual_net_last_wp_index] += @to_module OBJ_BankingGet() * f_Z_noise

	ai_virtual_wp_flag[i_virtual_net_last_wp_index] = 0
	if (f_delay_until_last_ground_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_ground_col
	if (f_delay_until_last_wall_col < 0.2)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_wall_col
	if (@to_module OBJ_PosGet().z < f_water_Z + tf_Z_offset)
		ai_virtual_wp_flag[i_virtual_net_last_wp_index] |= Ci_virtual_net_water_col

	if (ti_before_index != -1)
	{
		if (ao_virtual_wp_father[ti_before_index])
			tv_pos = @ao_virtual_wp_father[ti_before_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_before_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_before_index])
		else
			tv_pos = av_virtual_wp_pos[ti_before_index]
		af_virtual_link_length[i_virtual_net_last_wp_index] = MATH_VecNorm(tv_pos - av_virtual_wp_pos[i_virtual_net_last_wp_index])
	}

	av_virtual_wp_sight[i_virtual_net_last_wp_index] = @to_module OBJ_SightGet()
	av_virtual_wp_banking[i_virtual_net_last_wp_index] = @to_module OBJ_BankingGet()

	ao_virtual_wp_father[i_virtual_net_last_wp_index] = to_father

	if (to_father)
	{
		av_virtual_wp_pos[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_pos[i_virtual_net_last_wp_index] - @ao_virtual_wp_father[i_virtual_net_last_wp_index] OBJ_PosGet())
		av_virtual_wp_sight[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_sight[i_virtual_net_last_wp_index])
		av_virtual_wp_banking[i_virtual_net_last_wp_index] = @ao_virtual_wp_father[i_virtual_net_last_wp_index] MATH_VecGlobalToLocal(av_virtual_wp_banking[i_virtual_net_last_wp_index])
	}

	return(i_virtual_net_last_wp_index)
}

procedure_local void GHOST_Virtual_Net_Init(int ti_flag_update_wp_flag, object to_father)
{
	int			ti_i
	int			ti_index

	f_Z_noise = 0.0

	if (ti_flag_update_wp_flag)
	{
		i_on_ground_modules_nb = 0
		i_in_water_modules_nb = 0
	
		f_delay_until_last_ground_col = 1000.0
		f_delay_until_last_wall_col = 1000.0
	}

	for (ti_i = i_modules_nb - 1; ti_i >= 0; ti_i--)
	{
		ti_index = GHOST_Add_Virtual_Wp(ao_modules[ti_i], to_father)

		if (ti_flag_update_wp_flag)
			ai_virtual_wp_flag[ti_index] = 0
	}

	return
}

procedure_local void GHOST_Snake(int ti_first_index, float	tf_rigidity_coef, vector tv_father_speed)
{
	int			ti_i
	int			ti_iterations
	
	float		tf_norm
	float		tf_Z_offset
	float		tf_friction	
	float		tf_dot_product
	float		tf_time_offset
	float		tf_inv_dt

	vector	tv_move
	vector	tav_last_pos[100]
	vector	tv_precedent
	vector	tv_temp
	
	if (ti_first_index >= i_modules_nb )
	{
		v_ray_pos = OBJ_PosGet()
		v_ray_pos.z -= f_size_coef * 10.0
		v_ray_normal = Cv_VerticalVector
		return
	}

	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = dist_between_module * 0.5

	// AJOUTER LA VITESSE ET LA GRAVITE
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
		
		tv_move = Cv_NullVector
		if (ti_i > ti_first_index)
			tv_move += 0.6 * av_modules_speed[ti_i]
		tv_move += cvector(0.0, 0.0, -1.0)
		tv_move += tv_father_speed
		tv_move *= TIME_GetDt()
	
		tv_temp = @ao_modules[ti_i] OBJ_PosGet()
		tv_temp += tv_move

		tf_dot_product = MATH_VecDotProduct(tv_temp - v_ray_pos, v_ray_normal) - tf_Z_offset
		if (tf_dot_product < 0.0)
		{
			tv_temp -= tf_dot_product * v_ray_normal
			tav_last_pos[ti_i] -= (MATH_VecDotProduct(tav_last_pos[ti_i]  - v_ray_pos, v_ray_normal) - tf_Z_offset) * v_ray_normal
		}
		
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}
	
	// EN SNAKE
	
	// CORPS
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i - 1] OBJ_PosGet()
		MATH_VecSetNormalize(tv_temp)
		tv_temp = MATH_VecBlendRotate(tv_temp, - @ao_modules[ti_i - 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())
		@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_temp, @ao_modules[ti_i - 1] OBJ_BankingGet())	

		tv_temp *= dist_between_module
		tv_temp += @ao_modules[ti_i - 1] OBJ_PosGet()
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}

	// ROTATION PAR MODULES
	f_Z_angle += TIME_GetDt() * (DYN_SpeedGet() * 4.0)
	while (f_Z_angle > Cf_2Pi)
		f_Z_angle -= Cf_2Pi

	tf_time_offset = 0.8

	// CALCUL DES SPEED
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * 4)
	
		av_modules_speed[ti_i] = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		av_modules_speed[ti_i] *= tf_inv_dt
	}
}

procedure_local void GHOST_Inv_Snake(int ti_first_index, float tf_rigidity_coef, vector tv_father_speed)
{
	int			ti_i
	int			ti_iterations
	
	float		tf_norm
	float		tf_Z_offset
	float		tf_friction	
	float		tf_dot_product
	float		tf_time_offset
	float		tf_inv_dt

	vector	tv_move
	vector	tav_last_pos[100]
	vector	tv_precedent
	vector	tv_temp
	
	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = dist_between_module * 0.5

	// AJOUTER LA VITESSE ET LA GRAVITE
	for (ti_i = ti_first_index; ti_i >= 0; ti_i--)
	{
		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
		
		tv_move = Cv_NullVector
		if (ti_i > ti_first_index)
			tv_move += 0.6 * av_modules_speed[ti_i]
		tv_move += cvector(0.0, 0.0, -1.0)
		tv_move += tv_father_speed
		tv_move *= TIME_GetDt()
	
		tv_temp = @ao_modules[ti_i] OBJ_PosGet()
		tv_temp += tv_move

		tf_dot_product = MATH_VecDotProduct(tv_temp - v_ray_pos, v_ray_normal) - tf_Z_offset
		if (tf_dot_product < 0.0)
		{
			tv_temp -= tf_dot_product * v_ray_normal
			tav_last_pos[ti_i] -= (MATH_VecDotProduct(tav_last_pos[ti_i]  - v_ray_pos, v_ray_normal) - tf_Z_offset) * v_ray_normal
		}
		
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}
	
	// EN SNAKE
	
	// CORPS
	for (ti_i = ti_first_index; ti_i >= 0; ti_i--)
	{
		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i + 1] OBJ_PosGet()
		MATH_VecSetNormalize(tv_temp)
		tv_temp = MATH_VecBlendRotate(tv_temp, @ao_modules[ti_i + 1] OBJ_SightGet(), tf_rigidity_coef * TIME_GetDt())

		@ao_modules[ti_i] OBJ_SightGeneralSet(tv_temp, @ao_modules[ti_i + 1] OBJ_BankingGet())	

		tv_temp *= dist_between_module
		tv_temp += @ao_modules[ti_i + 1] OBJ_PosGet()
		@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	}

	// CALCUL DES SPEED
	for (ti_i = ti_first_index; ti_i >= 0; ti_i--)
	{
		av_modules_speed[ti_i] = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		av_modules_speed[ti_i] *= tf_inv_dt
	}
}


procedure_local void GHOST_Modules_Update(int ti_first_module_index, object to_father)
{
	int			ti_i
	int			ti_current_wp_index
	int			ti_next_wp_index
	int			ti_before_index

	float		tf_dist	
	float		tf_coef
	float		tf_time_offset	
	float		tf_net_length
	float		tf_inv_dt

	object	to_wp	

	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_start_sight
	vector	tv_dest_sight
	vector	tv_start_banking
	vector	tv_dest_banking

//	if (!f_move_length && i_etat_courant != -1)
//		return

//	i_on_ground_modules_nb = 0
	i_on_virtual_net_modules_nb = 0

	tf_time_offset = 0.8
	tf_inv_dt = 1.0 / TIME_GetDt()

	if ( ti_first_module_index  == 0 )
	{
		f_virtual_net_offset = 0.0
	
		ti_current_wp_index = i_virtual_net_last_wp_index
		ti_before_index = MATH_Modulo(i_virtual_net_last_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

		if (ao_virtual_wp_father[ti_before_index])
			tv_point_A = @ao_virtual_wp_father[ti_before_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_before_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_before_index])
		else
			tv_point_A = av_virtual_wp_pos[ti_before_index]
	
		tf_dist = MATH_VecNorm(tv_point_A - OBJ_PosGet())
		if (tf_dist >= dist_between_module * 1.5)
			GHOST_Add_Virtual_Wp(OBJ_Me(), to_father)
		else
			GHOST_Update_Last_Virtual_Wp(OBJ_Me(), to_father)

		av_modules_speed[0] = OBJ_PosGet() - v_head_last_pos
		av_modules_speed[0] *= tf_inv_dt

		f_Z_angle += TIME_GetDt() * (MATH_VecNorm(av_modules_speed[0]) * 4.0 / f_size_coef)
		while (f_Z_angle > Cf_2Pi)
			f_Z_angle -= Cf_2Pi
	}

	tf_net_length = f_virtual_net_offset

	ti_current_wp_index = i_virtual_net_last_wp_index
	ti_next_wp_index = MATH_Modulo(ti_current_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

//	for (ti_i = 0; ti_i < Ci_virtual_wp_nb; ti_i++)
//		DBG_RenderVector(av_virtual_wp_pos[ti_i], Cv_VerticalVector, color_bleu)

	for (ti_i = 1; ti_i < i_modules_nb; ti_i++)
	{
		if (ao_virtual_wp_father[ti_current_wp_index] != ao_virtual_wp_father[ti_next_wp_index])
		{
			if (ao_virtual_wp_father[ti_current_wp_index])
				tv_start_pos = @ao_virtual_wp_father[ti_current_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_current_wp_index])
			else
				tv_start_pos = av_virtual_wp_pos[ti_current_wp_index]
		
			if (ao_virtual_wp_father[ti_next_wp_index])
				tv_dest_pos = @ao_virtual_wp_father[ti_next_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_next_wp_index])
			else
				tv_dest_pos = av_virtual_wp_pos[ti_next_wp_index]

			af_virtual_link_length[ti_current_wp_index] = MATH_VecNorm(tv_dest_pos - tv_start_pos)
		}
	
		tf_coef = af_modules_length[ti_i]
		tf_coef -= tf_net_length
		tf_coef /= af_virtual_link_length[ti_current_wp_index]

//		DBG_RenderVector(av_virtual_wp_pos[ai_virtual_wp_index[ti_i]], av_virtual_wp_pos[ai_virtual_wp_index[ti_i] + 1] - av_virtual_wp_pos[ai_virtual_wp_index[ti_i]], color_rouge)	

		// On dépasse la longueur du lien ?
		while(tf_coef > 1.0)
		{
			tf_net_length += af_virtual_link_length[ti_current_wp_index]
		
			ti_current_wp_index = ti_next_wp_index
			ti_next_wp_index = MATH_Modulo(ti_current_wp_index + Ci_virtual_wp_nb - 1, Ci_virtual_wp_nb)

			if (ao_virtual_wp_father[ti_current_wp_index] != ao_virtual_wp_father[ti_next_wp_index])
			{
				if (ao_virtual_wp_father[ti_current_wp_index])
					tv_start_pos = @ao_virtual_wp_father[ti_current_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_current_wp_index])
				else
					tv_start_pos = av_virtual_wp_pos[ti_current_wp_index]
			
				if (ao_virtual_wp_father[ti_next_wp_index])
					tv_dest_pos = @ao_virtual_wp_father[ti_next_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_next_wp_index])
				else
					tv_dest_pos = av_virtual_wp_pos[ti_next_wp_index]
	
				af_virtual_link_length[ti_current_wp_index] = MATH_VecNorm(tv_dest_pos - tv_start_pos)
			}

			tf_coef = af_modules_length[ti_i]
			tf_coef -= tf_net_length
			tf_coef /= af_virtual_link_length[ti_current_wp_index]
		}

		// Tout module sur un wp virtuel collision ou hierarchisé ou dans l'eau ne sera plus animé en snake
		if (ti_i > i_on_ground_modules_nb)
		{
			if (ao_virtual_wp_father[ti_current_wp_index] && ao_virtual_wp_father[ti_next_wp_index])
				i_on_ground_modules_nb = ti_i
			else if (ai_virtual_wp_flag[ti_current_wp_index] & (Ci_virtual_net_ground_col | Ci_virtual_net_wall_col))
				i_on_ground_modules_nb = ti_i
			else if ( ! ai_virtual_wp_flag[ti_current_wp_index] )
				break
		}
		
		// Ce module est positionné sur le réseau virtuel, c'est à dire qu'il n'est pas "en l'air"
		i_on_virtual_net_modules_nb = ti_i

		if (ti_i < ti_first_module_index)
			continue	

		if (ao_virtual_wp_father[ti_current_wp_index])
		{
			tv_start_pos = @ao_virtual_wp_father[ti_current_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_current_wp_index])
			tv_start_sight = @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_sight[ti_current_wp_index])
			tv_start_banking = @ao_virtual_wp_father[ti_current_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_banking[ti_current_wp_index])
		}
		else
		{
			tv_start_pos = av_virtual_wp_pos[ti_current_wp_index]
			tv_start_sight = av_virtual_wp_sight[ti_current_wp_index]
			tv_start_banking = av_virtual_wp_banking[ti_current_wp_index]
		}

		if (ao_virtual_wp_father[ti_next_wp_index])
		{
			tv_dest_pos = @ao_virtual_wp_father[ti_next_wp_index] OBJ_PosGet() + @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_pos[ti_next_wp_index])
			tv_dest_sight = @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_sight[ti_next_wp_index])
			tv_dest_banking = @ao_virtual_wp_father[ti_next_wp_index] MATH_VecLocalToGlobal(av_virtual_wp_banking[ti_next_wp_index])
		}
		else
		{
			tv_dest_pos = av_virtual_wp_pos[ti_next_wp_index]
			tv_dest_sight = av_virtual_wp_sight[ti_next_wp_index]
			tv_dest_banking = av_virtual_wp_banking[ti_next_wp_index]
		}
		
		// Linear Interpolation
		tv_point_A = MATH_VecBlend(tv_start_pos, tv_dest_pos, tf_coef)
		if (ti_i == ti_first_module_index)
			tv_point_B = MATH_VecBlendRotate(tv_start_sight, tv_dest_sight, tf_coef)
		else
			tv_point_B = @ao_modules[ti_i - 1] OBJ_PosGet() - tv_point_A
		tv_point_C = MATH_VecBlendRotate(tv_start_banking, tv_dest_banking , tf_coef)

		if ( MATH_VecNullEpsilon(tv_point_B))
			tv_point_B = @ao_modules[ti_i] OBJ_SightGet()
		@ao_modules[ti_i] OBJ_SightGeneralSet(tv_point_B, tv_point_C)

//		if (ti_i && ai_virtual_wp_flag[ti_current_wp_index] & (Ci_virtual_net_ground_col | Ci_virtual_net_wall_col))
//			@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * Cf_angle_ondule_ton_corps)
	
		av_modules_speed[ti_i] = 	tv_point_A - @ao_modules[ti_i] OBJ_PosGet()
		av_modules_speed[ti_i] *= tf_inv_dt
		@ao_modules[ti_i] OBJ_PosSet(tv_point_A)

//		// Bezier Interpolation
//		tv_point_A = tv_start_pos
//		
//		tv_point_B = tv_point_A 
//		tv_point_B -= tv_start_sight * (af_virtual_link_length[ti_current_wp_index] * Cf_pourcentage)
//		
//		tv_point_D = tv_dest_pos
//			
//		tv_point_C = tv_point_D
//		tv_point_C += tv_dest_sight * (af_virtual_link_length[ti_current_wp_index] * Cf_pourcentage)
//
//		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_dest_sight)
//		
//		// Orientation
//		tv_dest_banking = MATH_VecBlendRotate(tv_start_banking, tv_dest_banking, tf_coef)
//		@ao_modules[ti_i] OBJ_SightGeneralSet(-tv_dest_sight, tv_dest_banking)
//		@ao_modules[ti_i] OBJ_RotateLocalZ(MATH_Sin((ti_i * tf_time_offset) + f_Z_angle) * Cf_angle_ondule_ton_corps)
//			
//		// Position
//		av_modules_speed[ti_i] = (tv_dest_pos - @ao_modules[ti_i] OBJ_PosGet())
//		av_modules_speed[ti_i] *= tf_inv_dt
//		@ao_modules[ti_i] OBJ_PosSet(tv_dest_pos)
	}
	
	// La dernière partie du corps est gérée en snake
	GHOST_Snake(ti_i, 6.0, Cv_NullVector)
}

procedure_local void GHOST_Renormalisation(int ti_first_index, int ti_last_index, int ti_iteration_nb)
{
	int			ti_i
	int			ti_k

	float		tf_norm
	float		tf_dot_product
	float		tf_Z_offset
	float		tf_inv_dt
	float		tf_move_length

	vector	tv_renormalisation[100]
	vector	tv_temp	
	vector	tv_col_pos
	vector	tv_col_normal

	tf_inv_dt = 1.0 / TIME_GetDt()
	tf_Z_offset = dist_between_module * 0.5

	// LES POINTS ONT BOUGE
	for (ti_k = 0; ti_k < ti_iteration_nb; ti_k++)
	{
		for (ti_i = ti_first_index; ti_i <= ti_last_index; ti_i++)
		{
			tv_renormalisation[ti_i] = Cv_NullVector

			if ( ! ti_i )
				continue

			tv_temp = @ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet()
			tf_norm = MATH_VecDotProduct(tv_temp, tv_temp)
			if (tf_norm > 0.001)
			{
				tf_norm = MATH_FloatSqrt(tf_norm)
				tv_temp /= tf_norm
				tf_norm -= dist_between_module
				tv_temp  *= tf_norm
			}
			else
			{
				tv_temp = @ao_modules[ti_i] OBJ_BankingGet()
				tv_temp *= af_modules_length[ti_i - 1]
			}

			tv_renormalisation[ti_i - 1] -= tv_temp * 0.5
			tv_renormalisation[ti_i] += tv_temp * 0.5
		}
		
		for (ti_i = ti_first_index; ti_i <= ti_last_index; ti_i++)
		{
			if (ai_modules_perfored[ti_i])
				continue
				
			if (ai_modules_locked[ti_i])
				continue

			tv_renormalisation[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(tv_renormalisation[ti_i], av_bone_col_normal[ti_i]), 0.0) * av_bone_col_normal[ti_i]
	
			@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i] OBJ_PosGet() + tv_renormalisation[ti_i])
		}
	}

	return
}


procedure_local void GHOST_IK_Init(int ti_modules_nb)
{
	int		ti_i
	
	f_IK_bezier_coef = 0.0

	i_on_ground_modules_nb = i_modules_nb - 1

	for (ti_i = 0; ti_i < ti_modules_nb; ti_i++)
	{
		af_IK_bezier_coef[ti_i] = 0.0
//		av_IK_bone_start_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()
	}

	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
		av_bone_col_normal[ti_i] = Cv_NullVector
}

procedure_local void GHOST_IK(int ti_modules_nb, vector tv_head_pos, vector tv_head_sight, float tf_IK_coef)
{
	int			ti_i
	int			ti_k
	
	float		tf_borne_inf
	float		tf_borne_sup
	float		tf_coef
	float		tf_totale_norm
	float		tf_pourcentage
	float		tf_step
	float		tf_perfect_length
	float		tf_sqr_length
		
	vector	tv_point_A
	vector	tv_point_B
	vector	tv_point_C
	vector	tv_point_D
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_pseudo_bone

	vector	tv_new_sight
	vector	tv_new_banking

//	if (!IO_KeyPressed(VK_SPACE))
//	{
//		GHOST_IK2(ti_modules_nb, tv_head_pos, tv_head_sight, tf_IK_coef)
//		return
//	}

	// PAS DU TOUT DE PILOTAGE !!!!
	if (!tf_IK_coef) //  || f_on_screen_pourcent == -1.0)
		return

	tf_step = 1.0 
	tf_step /= ti_modules_nb
//	tf_step /= 20	

	tf_perfect_length = ti_modules_nb * dist_between_module
	tf_perfect_length *= 0.99

	// C'EST PARTI POUR TROUVER UNE BONNE BEZIER ============================================
	tv_point_A = @ao_modules[ti_modules_nb] OBJ_PosGet()

	tv_point_D = tv_head_pos

	tf_coef = MATH_VecNorm(tv_point_D - tv_point_A)
	tf_coef = MATH_FloatLimit(tf_perfect_length - tf_coef, tf_perfect_length * 0.33, tf_perfect_length * 0.5)

	tv_point_B = tv_point_A
	tv_point_B += @ao_modules[ti_modules_nb] OBJ_SightGet() * tf_coef  

	tv_point_C = tv_point_D	
	tv_point_C -= tv_head_sight * tf_coef
	
//	tf_coef = MATH_Sin(TIME_Get()) * 10.0
//	MATH_LIB_A_Bezier_Display(ti_modules_nb, tf_coef, tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D)

	// =============================================================================
	// On fait une première dichotomie pour trouver en gros une courbe de la même longueur que celle du cou
	// =============================================================================
	tf_borne_inf = 0.0
	tf_borne_sup = 1.0
	ti_k = 0
	tf_totale_norm = 0.0

	tf_pourcentage = f_IK_B_weight	

	while(ti_k < 10)
	{
		ti_k++
	
		tf_totale_norm	= 0.0
	
		tv_start_pos = tv_point_A
		tv_dest_pos = tv_start_pos
	
		for (ti_i = 1; ti_i < ti_modules_nb - 1; ti_i++)
		{
			tf_coef = ti_i * tf_step
			tv_start_pos = tv_dest_pos
			tv_dest_pos = MATH_LIB_A_Bezier_Pos_Get(tf_coef, tf_pourcentage, tf_pourcentage, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
			tf_totale_norm += MATH_VecNorm(tv_dest_pos - tv_start_pos)
		}

//		MATH_LIB_A_Bezier_Display(ti_modules_nb, f_IK_B_weight, f_IK_C_weight, tv_point_A, tv_point_B, tv_point_C, tv_point_D)

		tf_totale_norm	+= MATH_VecNorm(tv_point_D - tv_dest_pos)

		if (MATH_AbsFloat(tf_totale_norm - tf_perfect_length) < 0.02)
		{
			// OK, C'est bon
			ti_k = ti_k
			break
		}
		else if (tf_totale_norm > tf_perfect_length)
		{
			tf_borne_sup = tf_pourcentage

			tf_pourcentage = tf_borne_inf + tf_borne_sup
			tf_pourcentage *=  0.5
		}
		else
		{
			tf_borne_inf  = tf_pourcentage

			tf_pourcentage = tf_borne_inf + tf_borne_sup
			tf_pourcentage *=  0.5
		}
	}

	f_IK_B_weight = MATH_FloatBlend(f_IK_B_weight, tf_pourcentage, 20.0 * TIME_GetDt())
	f_IK_C_weight = MATH_FloatBlend(f_IK_C_weight, tf_pourcentage, 20.0 * TIME_GetDt())
		
	// ON A ENFIN NOS 4 POINTS QUI DETERMINE LA COURBE ==============================================
#ifndef _FINAL_
	DBG_RenderVector(tv_point_A, tv_point_B - tv_point_A, color_rouge)
	DBG_RenderVector(tv_point_B, tv_point_C - tv_point_B, color_vert)
	DBG_RenderVector(tv_point_C, tv_point_D - tv_point_C, color_bleu)
	MATH_LIB_A_Bezier_Display(ti_modules_nb, f_IK_B_weight, f_IK_C_weight, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
#endif	

	tf_borne_inf = 0.0
	tv_start_pos = tv_point_A
	
	// =========================================================================
	// Pour les bones, on va rechercher une position sur la courbe telle que la longueur de l'os soit correcte
	// =========================================================================
	for (ti_i = ti_modules_nb - 1; ti_i > 0; ti_i--)
	{
		tf_borne_sup = 1.0
	
		ti_k = 0
	
		tf_sqr_length = dist_between_module
		tf_sqr_length *= 0.98
		tf_sqr_length *= tf_sqr_length
	
		while (ti_k < 10)
		{
			ti_k++
	
			tf_coef = tf_borne_inf 
			tf_coef += (tf_borne_sup - tf_borne_inf) * 0.5
		
//			tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_new_sight)
			tv_dest_pos = MATH_LIB_A_Bezier_Pos_Get(tf_coef, f_IK_B_weight, f_IK_C_weight, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
	
			tv_pseudo_bone = tv_dest_pos - tv_start_pos
			tf_totale_norm = MATH_VecDotProduct(tv_pseudo_bone, tv_pseudo_bone)
	
			if (MATH_AbsFloat(tf_totale_norm - tf_sqr_length) < 0.001)
			{
				// OK, C'est bon
				break
			}
			else if (tf_totale_norm > tf_sqr_length)
			{
				tf_borne_sup -= tf_borne_inf
				tf_borne_sup *= 0.5
				tf_borne_sup += tf_borne_inf 
			}
			else
			{
				tf_borne_inf -= tf_borne_sup
				tf_borne_inf *= 0.5
				tf_borne_inf += tf_borne_sup
			}
		}

		if (af_IK_bezier_coef[ti_i])
			af_IK_bezier_coef[ti_i] = MATH_FloatBlend(af_IK_bezier_coef[ti_i], tf_coef, 20.0 * TIME_GetDt())
		else
			af_IK_bezier_coef[ti_i] = tf_coef

		tf_coef = af_IK_bezier_coef[ti_i]
	
		tv_dest_pos = MATH_LIB_A_Bezier_Pos_Get(tf_coef, f_IK_B_weight, f_IK_C_weight, tv_point_A, tv_point_B, tv_point_C, tv_point_D)

		@ao_modules[ti_i] OBJ_PosSet(tv_dest_pos)
		DBG_RenderCircle(@ao_modules[ti_i] OBJ_PosGet(), dist_between_module * 0.5, Cv_NullVector, 0xFFFFFFFF)
	
		@ao_modules[ti_i] OBJ_SightSet(tv_new_sight)

		tv_start_pos = tv_dest_pos
	}
	
	@ao_modules[ti_i] OBJ_PosSet(tv_head_pos)
	DBG_RenderCircle(@ao_modules[ti_i] OBJ_PosGet(), dist_between_module * 0.5, Cv_NullVector, 0xFFFFFFFF)

	tv_new_banking = @ao_modules[ti_i + 1] OBJ_BankingGet()
	@ao_modules[ti_i] OBJ_SightGeneralSet(tv_head_sight, tv_new_banking)
	
//	@ao_modules[ti_i] OBJ_BankingGeneralSet(@ao_modules[ti_i + 1] OBJ_SightGet(), @ao_modules[ti_i + 1] OBJ_BankingGet())
//	@ao_modules[ti_i] OBJ_Rotate_FromTo(cvector(0.0, -1.0, 0.0), @ao_modules[ti_i] MATH_VecGlobalToLocal(tv_head_sight))

//	if (tf_IK_coef < 1.0)
//		GHOST_Renormalisation(1, ti_modules_nb - 1, 10)

	return
}

procedure_local void GHOST_Compute_Module_Speed()
{
	int				ti_i	

	float			tf_friction
	float			tf_ground_friction
	float			tf_water_friction
	float			tf_dt
	float			tf_exp
	float			tf_ground_exp
	float			tf_water_exp
	float			tf_javelin_exp
	float			tf_archimede
	float			tf_Z_offset

	vector		tv_temp

	tf_Z_offset = dist_between_module * 0.5
	
	tf_dt = TIME_GetDt()

	tf_friction = 1.0
	tf_exp = MATH_Exp(-tf_dt * tf_friction)

	tf_ground_friction = 6.0
	tf_ground_exp = MATH_Exp(-tf_dt * tf_ground_friction)

	tf_water_friction = 5.0
	tf_water_exp = MATH_Exp(-tf_dt * tf_water_friction)

	if (i_flag_start_ragdoll_damping)
		f_ragdoll_damping -= MATH_FloatMin(f_ragdoll_damping, TIME_GetDt())
	else
		f_ragdoll_damping = 1.0

	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
	{
//		DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), av_modules_forces[ti_i], color_cyan)	
	
		if (ai_modules_locked[ti_i])
		{
			av_modules_speed[ti_i] = Cv_NullVector
			continue
		}	

		if (ai_modules_perfored[ti_i])
		{
			av_modules_forces[ti_i] = cvector(0.0, 0.0, f_gravity)
			tv_temp = av_modules_forces[ti_i] / tf_ground_friction
			av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_ground_exp )
			continue
		}

//		// POUSSEE ARCHIMEDE
//		tf_archimede = MATH_FloatMax(f_water_Z - @ao_modules[ti_i] OBJ_PosGet().z + tf_Z_offset, 0.0)
//		tf_archimede /= tf_Z_offset * MATH_RandFloat(0.95, 1.25)
//		tf_archimede = MATH_FloatLimit(tf_archimede, 0.0, 6.0)
//		DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), cvector(0.0, 0.0, tf_archimede), color_bleu)
//		af_modules_archimede[ti_i] = tf_archimede
//		tf_archimede *= -f_gravity
//
		av_modules_forces[ti_i] += cvector(0.0, 0.0, f_gravity)
//		av_modules_forces[ti_i].z += tf_archimede

		tv_temp = av_modules_forces[ti_i]
		
		if (tf_archimede)
		{
			f_ragdoll_damping = 1.0

			tv_temp /= tf_water_friction
//			if (i_flag_kong_mode)
			{
				av_modules_speed[ti_i].x = tv_temp.x - ( (tv_temp.x - av_modules_speed[ti_i].x) * tf_water_exp )
				av_modules_speed[ti_i].y = tv_temp.y - ( (tv_temp.y - av_modules_speed[ti_i].y) * tf_water_exp )
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			}
//			else
//			{
//				av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_water_exp )
//			}
		}
		else if (af_bone_ground_col_timer[ti_i] < 0.15)
		{
			tv_temp /= tf_ground_friction

//			if (i_flag_kong_mode)
			{
				av_modules_speed[ti_i].x = tv_temp.x - ( (tv_temp.x - av_modules_speed[ti_i].x) * tf_ground_exp )
				av_modules_speed[ti_i].y = tv_temp.y - ( (tv_temp.y - av_modules_speed[ti_i].y) * tf_ground_exp )
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			}
//			else
//			{
//				av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_ground_exp )
//			}
		}
		else
		{
			tv_temp /= tf_friction
//			if (i_flag_kong_mode)
			{
				av_modules_speed[ti_i].x = tv_temp.x - ( (tv_temp.x - av_modules_speed[ti_i].x) * tf_exp )
				av_modules_speed[ti_i].y = tv_temp.y - ( (tv_temp.y - av_modules_speed[ti_i].y) * tf_exp )
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			}
//			else
//			{
//				av_modules_speed[ti_i] = tv_temp - ( (tv_temp - av_modules_speed[ti_i]) * tf_exp )
//			}
		}

		av_modules_speed[ti_i] *= f_ragdoll_damping
	}
}

procedure_local void GHOST_Rag_Doll(int ti_first_index)
{
	int			ti_i
	int			ti_iterations
	int			ti_bone_index
	int			ti_flag_paf

	float		tf_norm
	float		tf_Z_offset
	float		tf_dot_product
	float		tf_dt
	float		tf_inv_dt
	float		tf_sqr_n2_dist
	float		tf_sqr_n3_dist
	float		tf_sqr_n5_dist
	float		tf_attenuation
	float		tf_spring
	float		tf_move_length

	vector	tav_last_pos[100]
	vector	tv_temp
	vector	tv_col_pos
	vector	tv_col_normal
	vector	tv_force
	vector	tv_dest_banking
	vector	tv_delta_pos
	vector	tv_delta_speed
	vector	tv_A
	vector	tv_B
	vector	tv_prec
	vector	tv_next
	
	object	to_collided_object

	if (ti_first_index == i_modules_nb - 1)
		return

	tf_sqr_n2_dist = f_n2_dist * f_n2_dist 
	tf_sqr_n3_dist = f_n3_dist * f_n3_dist 
	tf_sqr_n5_dist = f_n5_dist * f_n5_dist

	tf_Z_offset = dist_between_module * 0.5

	tf_dt = TIME_GetDt()
	tf_inv_dt = 1.0 / tf_dt

	// DYNAMIQUE DES MODULES
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		if (ti_i == i_snaped_bone_index)
//			continue

		tav_last_pos[ti_i] = @ao_modules[ti_i] OBJ_PosGet()

		// GRAVITY
		av_modules_forces[ti_i] = Cv_NullVector

		// PAFs
		if (0) //i_flag_paf)
		{
//			if (ti_i == i_modules_pafed_index)
//			{
//				if (ai_modules_perfored[ti_i])
//				{
//				}
//				else
//				{	
//					av_modules_speed[ti_i].x = v_module_paf_dir.x
//					av_modules_speed[ti_i].y = v_module_paf_dir.y
//	
//					if (af_bone_ground_col_timer[ti_i] < 0.1 || av_modules_speed[ti_i].z < 0.0)
//						av_modules_speed[ti_i].z = MATH_FloatMax(v_module_paf_dir.z, 4.0)
//					else
//						av_modules_speed[ti_i].z = v_module_paf_dir.z
//				}
//					
//				af_bone_ground_col_timer[ti_i] = 1000.0
//			}
//			else
//			{
//				av_modules_speed[ti_i].x += v_module_paf_dir.x * 0.1
//				av_modules_speed[ti_i].y += v_module_paf_dir.y * 0.1
//
//				if (af_bone_ground_col_timer[ti_i] < 0.1 || av_modules_speed[ti_i].z < 0.0)
//					av_modules_speed[ti_i].z = MATH_FloatMax(v_module_paf_dir.z * 0.1, MATH_RandFloat(1.0, 2.0))
//				else
//					av_modules_speed[ti_i].z += v_module_paf_dir.z * 0.1
//
//				af_bone_ground_col_timer[ti_i] = 1000.0
//			}
//
//			av_modules_speed[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(av_modules_speed[ti_i], av_bone_col_normal[ti_i]), 0.0) * av_bone_col_normal[ti_i]
		}
		else
		{
			// SPRING
			if (0)
			{
				if (ti_i)
				{
					tv_delta_pos = tav_last_pos[ti_i]
					tv_delta_pos -= tav_last_pos[ti_i - 1]
				
					tv_delta_speed = av_modules_speed[ti_i]
					tv_delta_speed -= av_modules_speed[ti_i - 1]
					
					tv_force = tv_delta_pos
					tf_norm = MATH_VecDotProduct(tv_force, tv_force)
					if (tf_norm > 0.001)
					{
						tf_norm = MATH_FloatSqrt(tf_norm)
						tv_force /= tf_norm
	
						tf_attenuation = (MATH_VecDotProduct(tv_delta_speed, tv_delta_pos) / tf_norm) * f_damping_coef
					}
					else
					{
						tv_force = @ao_modules[ti_i] OBJ_SightGet()
						
						tf_attenuation = 0.0
					}
	
					tf_spring = (tf_norm - dist_between_module) * f_spring_coef
	
					tv_force *= tf_attenuation - tf_spring
	
	//				DBG_RenderVector(tav_last_pos[ti_i], tv_force, color_cyan)
	//				DBG_RenderVector(tav_last_pos[ti_i - 1], -tv_force, color_cyan)
				
					av_modules_forces[ti_i] += tv_force
					av_modules_forces[ti_i - 1] -= tv_force
				}
			}
			
		}
	}


	// TENSIONS
	if (0)
	{
		tv_force = tav_last_pos[0]
		tv_force -= tav_last_pos[5]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[0] += tv_force
			av_modules_forces[5] -= tv_force
		}

		tv_force = tav_last_pos[0]
		tv_force -= tav_last_pos[10]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[0] += tv_force
			av_modules_forces[10] -= tv_force
		}

		tv_force = tav_last_pos[0]
		tv_force -= tav_last_pos[14]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[0] += tv_force
			av_modules_forces[14] -= tv_force
		}

		tv_force = tav_last_pos[14]
		tv_force -= tav_last_pos[5]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[14] += tv_force
			av_modules_forces[5] -= tv_force
		}

		tv_force = tav_last_pos[5]
		tv_force -= tav_last_pos[10]
		
		tf_norm = MATH_VecDotProduct(tv_force, tv_force)
		if (tf_norm > 0.001 && tf_norm < tf_sqr_n5_dist)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_force /= tf_norm
			tv_force *= 1.0 - (tf_norm / f_n5_dist)
			tv_force *= f_rigidity_coef

			av_modules_forces[5] += tv_force
			av_modules_forces[10] -= tv_force
		}
	}

	// RIGIDITE
	if (1)
	{
		tv_next = @ao_modules[1] OBJ_PosGet()
		tv_next  -= @ao_modules[0] OBJ_PosGet()
		tf_norm = MATH_VecDotProduct(tv_next , tv_next )
		if (tf_norm > 0.001)
		{
			tf_norm = MATH_FloatSqrt(tf_norm)
			tv_next /= tf_norm
		}
		else
		{
			tv_next = @ao_modules[0] OBJ_SightGet()
		}
		
		for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
		{
			if (ti_i && ti_i < i_modules_nb - 1)
			{
				tv_prec = -tv_next
	
				tv_next = @ao_modules[ti_i + 1] OBJ_PosGet()
				tv_next -= @ao_modules[ti_i] OBJ_PosGet()
				tf_norm = MATH_VecNorm(tv_next)

				if (MATH_FloatNullToler(tf_norm, 0.001))
					continue
					
				tv_next /= tf_norm
				
				tf_dot_product = 1.0 + MATH_VecDotProduct(tv_prec, tv_next)	
				tf_dot_product *= 0.5
				tf_dot_product *= tf_dot_product
//				if (tf_dot_product > 0.3)
				{
//					DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), tv_next * dist_between_module, color_jaune)	
//					DBG_RenderVector(@ao_modules[ti_i] OBJ_PosGet(), tv_prec * dist_between_module, color_jaune)	

					tv_temp = MATH_VecCrossProduct(tv_prec, tv_next)
					if ( MATH_FloatNullToler( MATH_VecDotProduct(tv_temp, tv_temp), 0.001) )
						tv_temp = @ao_modules[ti_i] OBJ_HorizonGet()
					
					tv_A = MATH_VecCrossProduct(tv_prec, tv_temp)
					tf_norm = MATH_VecDotProduct(tv_A, tv_A)
					if (tf_norm < 0.001)
						continue

					tf_norm = MATH_FloatSqrt(tf_norm)
					tv_A /= tf_norm
		
					tv_B = MATH_VecCrossProduct(tv_temp, tv_next)
					tf_norm = MATH_VecDotProduct(tv_B, tv_B)
					if (tf_norm < 0.001)
						continue
						
					tf_norm = MATH_FloatSqrt(tf_norm)
					tv_B /= tf_norm
					
					tf_dot_product = MATH_FloatMin(tf_dot_product * 200.0, 20.0)	
			
					tv_A *= tf_dot_product 
					tv_B *= tf_dot_product
					
					av_modules_forces[ti_i - 1] += tv_A
					av_modules_forces[ti_i] -= tv_A + tv_B
					av_modules_forces[ti_i + 1] += tv_B
				}
			}
		}
	}

	// GIGOTAGE
	if (i_perfored_module_index != -1)
	{
		f_delay_before_bend -= MATH_FloatMin(f_delay_before_bend, TIME_GetDt())
		if ( ! f_delay_before_bend )
		{
			f_delay_before_bend = MATH_RandFloat(0.1, 0.3)
			for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
				av_modules_speed[ti_i] += cvector(MATH_RandFloat(-1.0, 1.0), MATH_RandFloat(-1.0, 1.0), MATH_RandFloat(-1.0, 1.0)) * (f_size_coef * 10.0)
		}
	}

	if (f_ragdoll_damping)
	{
//		// RENORMALISATION
//		GHOST_Renormalisation(ti_first_index, i_modules_nb - 1, 10)
	
		// CALCUL DE LA DYNAMIQUE
		GHOST_Compute_Module_Speed()
	
		// DEPLACEMENT
		for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
		{
			af_bone_col_timer[ti_i] += TIME_GetDt()
			af_bone_ground_col_timer[ti_i] += TIME_GetDt()
	
//			DBG_RenderVector(tav_last_pos[ti_i], av_modules_speed[ti_i], color_jaune)
			@ao_modules[ti_i] OBJ_PosSet(tav_last_pos[ti_i] + (av_modules_speed[ti_i] * tf_dt)) 
		}

		if (i_perfored_module_index != -1 && ! ai_modules_locked[i_perfored_module_index] )
		{
			if (MATH_VecDotProduct(av_modules_speed[i_perfored_module_index], av_modules_speed[i_perfored_module_index]) > 0.001)
				@ao_modules[i_perfored_module_index] OBJ_Rotate_FromTo(av_modules_quat[i_perfored_module_index], @ao_modules[i_perfored_module_index] MATH_VecGlobalToLocal(av_modules_speed[i_perfored_module_index]))
		}
	
		// COLLISIONS
		if (1) // && i_etat_courant != ETAT_Grabbed_By_Kong)
		{
//			if (o_KK_Grabbed_actor && @o_KK_Grabbed_actor Proc_KK_Try_To_Hit())
//				f_ray_can_paf_duration = 1.0
				
//			if (f_ray_can_paf_duration)
//				ti_flag_paf = vrai
//			else
				ti_flag_paf = faux
		
			for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
			{
				if (ai_modules_locked[ti_i])
				{
					af_bone_col_timer[ti_i] = 0.0
					continue
				}
	
				tv_temp = @ao_modules[ti_i] OBJ_PosGet()
				tv_temp -= tav_last_pos[ti_i]
				tf_norm = MATH_VecNorm(tv_temp)
	
				tf_move_length = tf_norm
	
				ti_iterations = 0
	
				while (tf_norm > 0.001 && ti_iterations < 5)
				{
					ti_iterations++
	
					tv_temp /= tf_norm
				
//					if ( ti_iterations == 1)
//						COL_CrossableSet(none, i_gmat_water_bit)
//					else
//						COL_CrossableSet(i_gmat_water_bit, none)
//
					to_collided_object = COL_RayObject_Dist(tav_last_pos[ti_i], tv_temp, tf_norm + dist_between_module, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
					if (to_collided_object)
					{
						tv_col_pos = COL_RayObject_PosGet()
						tv_col_normal = COL_RayObject_NormalGet()

//						if (COL_GMAT_FlagsGet(COL_C_Ray) & i_gmat_water_bit)
//						{
//							DBG_RenderVector(tv_col_pos, tv_col_normal, color_bleu)
//
//							if (MATH_AbsFloat(tv_col_normal.z) > Cf_Cos60)
//							{
////								f_water_Z = MATH_FloatMax(f_water_Z, tv_col_pos.z)
//								f_water_Z = tv_col_pos.z
//							}
//							
//							COL_CrossableSet(i_gmat_water_bit, none)
//							if (COL_RayObject_Dist(tav_last_pos[ti_i], tv_temp, tf_norm + f_size_coef, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
//							{
//								tv_col_pos = COL_RayObject_PosGet()
//								tv_col_normal = COL_RayObject_NormalGet()
//							}
//							else
//							{
//								break
//							}
//						}

						if (ti_flag_paf)
						{
							to_collided_object = COL_RayObject_ActorGet()
//							if (@to_collided_object OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI))
//								EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_collided_object, 10.0 * PAF_Unit, tv_temp)	
						}
						
						DBG_RenderVector(tv_col_pos, tv_col_normal, color_bleu)	
	
						tf_dot_product = MATH_VecDotProduct(tv_temp, -tv_col_normal)
						if (tf_dot_product > 0.3)
							tf_dot_product = -tf_Z_offset / tf_dot_product
						else
							tf_dot_product = 1000.0
							
						if (tf_dot_product < tf_norm + tf_Z_offset)
						{
							tv_temp *= tf_dot_product
							tv_temp += tv_col_pos
						}
						else
						{
							tv_temp = tv_col_pos
							tv_temp += tv_col_normal * tf_Z_offset
						}
	
//						if (MATH_VecDotProduct(tv_temp - tav_last_pos[ti_i], tv_temp - tav_last_pos[ti_i]) < tf_move_length) // * tf_move_length)
						if (MATH_VecNorm(tv_temp - tav_last_pos[ti_i]) < tf_move_length + tf_Z_offset)
						{
							@ao_modules[ti_i] OBJ_PosSet(tv_temp)
	
//							if (COL_GMAT_FlagsGet(COL_C_Ray) & i_gmat_death_bit)
//								i_flag_force_death = vrai
		
							af_bone_col_timer[ti_i] = 0.0
		
							if (ai_modules_perfored[ti_i])
							{
								ai_modules_locked[ti_i] = vrai
								av_modules_speed[ti_i] = Cv_NullVector
								break
							}
							else
							{
								if (tv_col_normal.z > Cf_Cos45)
									af_bone_ground_col_timer[ti_i] = 0.0	
				
								if (ti_iterations > 1)
									av_bone_col_normal[ti_i] = MATH_VecBlendRotate(av_bone_col_normal[ti_i], tv_col_normal, 0.5)
								else
									av_bone_col_normal[ti_i] = tv_col_normal
		
								// GLISSING !!!
								tv_temp = tav_last_pos[ti_i]
								tv_temp += av_modules_speed[ti_i] * tf_dt
								tv_temp -= @ao_modules[ti_i] OBJ_PosGet()
								tv_temp -= MATH_VecDotProduct(tv_temp, tv_col_normal) * tv_col_normal
								
								// BEUARK FRICTION
								tv_temp *= 0.8
		
								@ao_modules[ti_i] OBJ_PosSet(@ao_modules[ti_i] OBJ_PosGet() + tv_temp)
							
								av_modules_speed[ti_i] -= MATH_VecDotProduct(av_modules_speed[ti_i], tv_col_normal) * tv_col_normal
					
								tv_temp = @ao_modules[ti_i] OBJ_PosGet()
								tv_temp -= tav_last_pos[ti_i]
								tf_norm = MATH_VecNorm(tv_temp)
							}
						}
						else
						{
							break
						}
					}
					else
					{
						break
					}
				}
	
				if (ti_iterations == 0)
				{
					tf_norm = tf_norm
				}
			}
		}
	
	//	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	//		DBG_RenderSphere(@ao_modules[ti_i] OBJ_PosGet(), tf_Z_offset, 0x80804080)	
	
		// RENORMALISATION
		GHOST_Renormalisation(ti_first_index, i_modules_nb - 1, 10)
	}

	i_on_ground_modules_nb = 0
	i_in_water_modules_nb = 0
	
	// CALCUL DES SPEED ET DES ORIENTATIONS
	for (ti_i = ti_first_index; ti_i < i_modules_nb; ti_i++)
	{
//		if (ti_i == i_snaped_bone_index)
//			continue

//		if (tai_bone_collision[ti_i] && ai_modules_perfored[ti_i])
//			ai_modules_locked[ti_i] = vrai

		DBG_RenderCircle(@ao_modules[ti_i] OBJ_PosGet(), tf_Z_offset, Cv_NullVector, 0xFFFFFFFF)

		if (af_modules_archimede[ti_i])
		{
			i_in_water_modules_nb++

			if (af_modules_archimede[ti_i] < 1.5 && av_modules_speed[ti_i].z > -1.0)
				i_on_ground_modules_nb++
		}
		else if (af_bone_ground_col_timer[ti_i] < 0.15)
		{
			i_on_ground_modules_nb++
		}
		else
		{
			av_bone_col_normal[ti_i] = Cv_NullVector
		}

//		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
//		tv_temp *= tf_inv_dt
//		tv_temp -= MATH_VecDotProduct(tv_temp, av_bone_col_normal[ti_i]) * av_bone_col_normal[ti_i]
//			
//		av_modules_speed[ti_i] = tv_temp

		if (i_perfored_module_index != -1)
		{
			tv_dest_banking = @ao_modules[i_perfored_module_index] OBJ_BankingGet()
		}
		else if (af_bone_col_timer[ti_i] < 0.1)
		{
			tv_dest_banking = av_bone_col_normal[ti_i]
//			if ( ! f_lifecur )
//				tv_dest_banking *= -1.0
		}
		else
		{
//			tv_dest_banking = v_dest_banking
//			if ( f_lifecur )
				tv_dest_banking = Cv_VerticalVector
//			else
//				tv_dest_banking = -Cv_VerticalVector
		}

		tv_temp = @ao_modules[ti_i] OBJ_PosGet() - tav_last_pos[ti_i]
		tv_temp *= tf_inv_dt
		tv_temp -= MATH_VecDotProduct(tv_temp, av_bone_col_normal[ti_i]) * av_bone_col_normal[ti_i]
			
		av_modules_speed[ti_i] = tv_temp

		if (ti_i)
			tv_dest_banking = MATH_VecBlendRotate(tv_dest_banking, @ao_modules[ti_i - 1] OBJ_BankingGet(), 0.5)
		else
			tv_dest_banking = MATH_VecBlendRotate(tv_dest_banking, @ao_modules[ti_i + 1] OBJ_BankingGet(), 0.5)

		tv_dest_banking = MATH_VecBlendRotate(@ao_modules[ti_i] OBJ_BankingGet(), tv_dest_banking, 4.0 * TIME_GetDt())

		if ( ai_modules_locked[ti_i]  || ai_modules_perfored[ti_i] )
			continue

		if (ti_i == i_modules_nb - 1)
			@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i] OBJ_PosGet(), tv_dest_banking)
		else if (!ti_i)
			@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i] OBJ_PosGet() - @ao_modules[ti_i + 1] OBJ_PosGet(), tv_dest_banking)
		else
			@ao_modules[ti_i] OBJ_SightGeneralSet(@ao_modules[ti_i - 1] OBJ_PosGet() - @ao_modules[ti_i + 1] OBJ_PosGet(), tv_dest_banking)
	}
	
	if (!i_flag_start_ragdoll_damping && i_on_ground_modules_nb == i_modules_nb)
		i_flag_start_ragdoll_damping = vrai

//	COL_CrossableSet(i_gmat_water_bit, none)

	return
}

procedure_local void GHOST_Recompute_BV()
{
	int		ti_i

	vector	tv_module_pos		
	vector	tv_bv_min
	vector	tv_bv_max

	tv_bv_min = cvector(Cf_Infinit, Cf_Infinit, Cf_Infinit)
	tv_bv_max = -tv_bv_min

	for (ti_i = 0; ti_i < i_modules_nb; ti_i += 3)
	{
		tv_module_pos = @ao_modules[ti_i] OBJ_PosGet()

		tv_bv_min.x = MATH_FloatMin(tv_module_pos.x, tv_bv_min.x) 
		tv_bv_min.y = MATH_FloatMin(tv_module_pos.y, tv_bv_min.y) 
		tv_bv_min.z = MATH_FloatMin(tv_module_pos.z, tv_bv_min.z) 

		tv_bv_max.x = MATH_FloatMax(tv_module_pos.x, tv_bv_max.x) 
		tv_bv_max.y = MATH_FloatMax(tv_module_pos.y, tv_bv_max.y) 
		tv_bv_max.z = MATH_FloatMax(tv_module_pos.z, tv_bv_max.z) 
	}
	
	tv_bv_min -= OBJ_PosGet()
	tv_bv_max -= OBJ_PosGet()
	
	tv_bv_min -= cvector(f_size_coef, f_size_coef, f_size_coef)
	tv_bv_max += cvector(f_size_coef, f_size_coef, f_size_coef)
	
	BV_MinSet(tv_bv_min)
	BV_MaxSet(tv_bv_max)
}

