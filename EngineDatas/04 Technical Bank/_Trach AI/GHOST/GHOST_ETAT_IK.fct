#include "GHOST_defines.var"



Include_UltraProcedure_Header

int			ti_i

float		tf_coef
float		tf_exp
float		tf_time
float		tf_jump_duration

vector	tv_pos
vector	tv_sight
vector	tv_speed

object	to_head

#define Cv_gravity		cvector(0.0, 0.0, -20.0)
#define Cf_friction		1.0
#define Cv_friction		cvector(Cf_friction, Cf_friction, 0.0)

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux

	i_flag_ik = faux

	return
}

if (i_etat_courant != GHOST_ETAT_IK)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = GHOST_ETAT_IK
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = "GHOST_ETAT_IK"
	
	v_pile_dest_pos = Cv_NullVector
	for (ti_i = 0; ti_i <  i_modules_nb; ti_i++)
	{
		v_pile_dest_pos	+= @ao_modules[ti_i] OBJ_PosGet()
		av_modules_speed[ti_i] = Cv_NullVector
	}
	v_pile_dest_pos /= i_modules_nb
	
	v_pile_dest_pos = @o_main_actor OBJ_PosGet()

//	for (ti_i = 0; ti_i <  i_modules_nb; ti_i++)
//	{
//		tv_pos = v_pile_dest_pos
//		tv_pos.z += 0.5 * dist_between_module * ti_i
//		
//		tf_time = 1.0 + (ti_i * 0.05)
//
////		procedure vector DYN_LIB_ImpulsionGet_Friction(vector tv_start_pos, vector tv_dest_pos, vector tv_gravity, float tf_friction, byref float tf_time, int ti_flag_Z_friction, float tf_hauteur_saut)
//		av_modules_speed[ti_i] = DYN_LIB_ImpulsionGet_Friction(@ao_modules[ti_i] OBJ_PosGet(), tv_pos, Cv_gravity, Cf_friction, tf_time, faux, 0.0) 
//	}

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

to_head = @o_main_actor ANI_CanalObjectGet(Anim_Canal_Tete)

tf_time = i_modules_nb * 0.05
tf_time += 1.5

if (f_time_start_etat > tf_time)
{
	if ( ! i_flag_ik )
	{
		i_flag_ik = vrai

		@ao_modules[i_modules_nb - 1] OBJ_SightSet(Cv_VerticalVector)
		GHOST_IK_Init(i_modules_nb - 1)
	}

	tf_coef = MATH_FloatMin( (f_time_start_etat - tf_time) * 0.25, 1.0) 
	tf_coef *= tf_coef
	
	tv_pos = MATH_VecBlendRotate(@ao_modules[0]  OBJ_PosGet() - @ao_modules[i_modules_nb - 1] OBJ_PosGet(), @to_head  OBJ_PosGet() - @ao_modules[i_modules_nb - 1] OBJ_PosGet(), tf_coef)
	tv_pos += @ao_modules[i_modules_nb - 1] OBJ_PosGet()
	
	tv_sight = MATH_VecBlendRotate(@ao_modules[0] OBJ_SightGet(), @to_head OBJ_BankingGet(), 6.0 * TIME_GetDt())
	tv_sight.z = 0.0
	tv_sight = MATH_VecBlendRotate(Cv_VerticalVector, tv_sight, tf_coef)

//	DBG_RenderVector(tv_pos, tv_sight * 10.0, color_jaune)

	GHOST_IK(i_modules_nb - 1, tv_pos, tv_sight, tf_coef)
}
else
{
	tf_exp = MATH_Exp( - TIME_GetDt() * Cf_friction)
	
	for (ti_i = 0; ti_i <  i_modules_nb; ti_i++)
	{
		tf_time = (i_modules_nb - ti_i) * 0.05
		if (	f_time_start_etat < tf_time)
			continue
	
		tv_pos = v_pile_dest_pos
		tv_pos.z += (0.5 * dist_between_module) * (i_modules_nb - ti_i)
		
		tf_jump_duration = 1.5
	
		if (MATH_VecNull(av_modules_speed[ti_i]))
		{
	//		procedure vector DYN_LIB_ImpulsionGet_Friction(vector tv_start_pos, vector tv_dest_pos, vector tv_gravity, float tf_friction, byref float tf_time, int ti_flag_Z_friction, float tf_hauteur_saut)
			av_modules_speed[ti_i] = DYN_LIB_ImpulsionGet_Friction(@ao_modules[ti_i] OBJ_PosGet(), tv_pos, Cv_gravity, Cf_friction, tf_jump_duration, faux, 0.0) 
		}
		else if (f_time_start_etat > tf_time + tf_jump_duration)
		{
			@ao_modules[ti_i] OBJ_PosSet(tv_pos)
			@ao_modules[ti_i] OBJ_SightGeneralSet(Cv_VerticalVector, cvector(1.0, 0.0, 0.0))
		}
		else
		{
	//		procedure vector DYN_LIB_Position_After_N_Seconds(vector tv_init_pos, byref vector tv_init_speed, vector tv_friction, vector tv_gravity, float tf_time, float tf_exp)
			tv_speed = av_modules_speed[ti_i]
			tv_pos = DYN_LIB_Position_After_N_Seconds(@ao_modules[ti_i] OBJ_PosGet(), tv_speed, Cv_friction, Cv_gravity, TIME_GetDt(), tf_exp)
			av_modules_speed[ti_i] = tv_speed
			@ao_modules[ti_i] OBJ_PosSet(tv_pos)
		}
	}
}

if (f_time_start_etat && IO_ButtonJustPressed(JoyPSX_Button_croix))
	AI_TrackCurChangeNow("GHOST_ETAT_Corde")

if (f_time_start_etat && IO_ButtonJustPressed(JoyPSX_Button_croix))
	AI_TrackCurChangeNow("GHOST_ETAT_Basic")