Include_UltraProcedure_Header
M_DeclareInteraction_Common
#include "IO_BentTree_Defines.var"

float			tf_dist
float			tf_coef

vector		tv_main_to_me

vector		v_NewBankingAngle

int 			i_Index

int 			i_Rank
message	m_MsgBuffer
messageid	mid_PafEvent
vector 		v_PafDirecetion
int 			i_IsPafRecorded

vector 		v_MoveVector

object		tao_zdecol_objects[NUM_NON_PAF]
int 			i_NumCols

// get kong's swing state, and store last.
if ( mi_KongExists )
{
	message m_Msg
	
	MSG_SetNull(m_Msg)
	
	mi_LastIsKongSwinging 	= mi_KongIsSwinging
	
	m_Msg.msg_id 				= C_KongInteraction_State_GetCurrent_k
	m_Msg = Dispatch_Interaction( get_kong, m_Msg )
	
	if ( m_Msg.msg_int1 == C_KongInteraction_State_ArchSwinging_k )
	{
		//DBG_Warning( "Kong is Swinging on Arch" )
		
		mi_KongIsSwinging = ETAT_swing_arch
	}
	else if ( m_Msg.msg_int1 == C_KongInteraction_State_PillardSwinging_k )
	{
		//DBG_Warning( "Kong is Swinging on Pillar" )
	
		mi_KongIsSwinging = ETAT_swing_pillard
	}
	else
	{
		mi_KongIsSwinging = faux
	}
	
	// reset time	
	if ( !mi_KongIsSwinging && mi_LastIsKongSwinging )
	{
		mf_CurrTreeBendFrequency = mf_TreeBendFrequency
	}
}

// swings based on weather or not Kong is actually swinging.  Don't do anything if this is a swing and Kong isn't swinging.
if ( mi_IsSwing && !mi_KongIsSwinging && !mi_LastIsKongSwinging )
{
	return
}
else
{
	i_NumCols = 0
	
	i_IsPafRecorded = FALSE
	
	tf_dist = OBJ_SqrDist( get_kong )
	
	// peek to see if there are any paff messages...if so, we might wanna stop the message processing
	//JIMI_NOTE: this shouldn't just be pafs, since it has to take into account Rex hits and thrown creatures
	for ( i_Index = 0; i_Index < C_Max_CollidableObjects; i_Index++ )
	{
		MSG_SetNull( m_MsgBuffer )
		
		m_MsgBuffer.msg_gao1 = OBJ_Me()
		
		i_Rank = -1
		
		v_PafDirecetion = Cv_NullVector
		
		for ( mid_PafEvent = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Paf, &i_Rank, m_MsgBuffer );
			MSG_GlobalIsValid( mid_PafEvent );
			mid_PafEvent = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Paf, &i_Rank, m_MsgBuffer ) )
		{
			// triggering the vines and/or particle emitters here should be done in a single function call that encapsulates all the stuff I do to prime and run them in the proximity way
			i_IsPafRecorded = TRUE
		}
	}
	
	// if paff or new move towards IO item, then start moving and emitting and waving
	if ( i_IsPafRecorded || ( tf_dist <= f_SensitivitySqrd && ( tf_dist < tf_LastDistance || mi_IsSwing ) ) )
	{
		// store last distance...Kong has to get closer to middle of sensitivity radius to acheive full bend
		tf_LastDistance = tf_dist
		
		// because of where the WP on KONG goes when he swings, we need some more room just while he is swinging once it is active
		if ( mi_IsSwing )
		{
			f_SensitivitySqrd = mf_OldSensSqrd + mf_OldSensSqrd + mf_OldSensSqrd + 10.0
		}
	
		// update time in radius
		mf_TimeInSensitivityRadius += TIME_GetDt()
	
		//JIMINOTE: got rid of the above 2 factors and put in this instead at the suggestion of Fred Houde...thanks Fred :)
		tf_coef = ( MATH_FloatSqrt( tf_dist ) / f_sensibility )
		
		// clamp scalar at 1.0 )
		if ( tf_coef > 0.999999 )
		{
			tf_coef  = 0.999999
		}
	
		// get vector from kong to me (the tree)
		//JIMI_NOTE: this shouldn't be just Kongs position, we need to take into account throw objects and Rex as sources of the bend
		if ( !mi_IsSwing )
		{
			tv_main_to_me = OBJ_PosGet() - @get_kong OBJ_PosGet()
		}
		else
		{
			if ( mi_IsSwing && mo_SwingPivotPoint )
			{
				tv_main_to_me = @get_kong OBJ_PosGet() - @mo_SwingPivotPoint OBJ_PosGet()
			}
			else
			{
				tv_main_to_me = @get_kong OBJ_PosGet() - OBJ_PosGet()
			}
		}
	
		tv_main_to_me = MATH_VecNormalize( tv_main_to_me )
		
		// calculate the new banking vector of the tree, clamping it to a max
		v_NewBankingAngle = MATH_VecBlend( v_init_banking, tv_main_to_me, tf_coef )
		
		mi_LoopStopper = 0
		
		while ( mf_MaxTotalBendAngleInRads < MATH_ACos( MATH_VecDotProduct( v_NewBankingAngle, v_init_banking ) ) && ( mi_LoopStopper <= C_Max_NumberOfAngleDecrements ) )
		{
			if ( mi_IsSwing && mi_IsSwing != 1 )
			{
				tf_coef *= 0.75
			}
			else if ( mi_IsSwing )
			{
				tf_coef *= 0.85
			}
			else
			{
				tf_coef *= 0.95
			}
			
			v_NewBankingAngle = MATH_VecBlend( v_init_banking, tv_main_to_me, tf_coef )
			
			mi_LoopStopper++
		}
		
		{
			if ( mi_IsSwing && !mi_KongIsSwinging && mi_LastIsKongSwinging )
			{
				int blarlo
				
				blarlo = 0
			}
			
			//JDV: 5/1/18 - use the current instead of initial
			// we have a new banking.  now we want to have a gradual transition to that banking.  prime all vars
			if ( !mi_IsActivelyBanking || ( mi_IsSwing && !mi_KongIsSwinging && mi_LastIsKongSwinging ) )
			{
				mf_GradualBankingStartTimeStamp	= TIME_Get()
				mi_IsOnBankBack 							= FALSE
				mf_MyLastBankCoef						= 0.0
				mf_MyCurrentCoef							= tf_coef
			}
			
			if ( !mi_IsActivelyBanking || ( mi_IsSwing && mi_KongIsSwinging || mi_LastIsKongSwinging  ) )
			{
				if ( mi_IsSwing == 1 && !mi_KongIsSwinging && mi_LastIsKongSwinging )
				{
					mv_EndingBank								= v_init_banking
				}
				else	
				{
					mv_EndingBank								= v_NewBankingAngle
				}
				
				mv_StartingBank								= OBJ_BankingGet()
			}
			
			AI_TrackChange( C_Track_BankingTransition, "bhv_GradualTransition" )
				
			// start the particle systems for when the tree gets hit
			AI_TrackChange( C_Track_PAGActivation, "bhv_PAGTimer" )
			
			if ( mi_IsNewVineWaveTriggered && ( TIME_Get() - mf_ActualTimeOfLastVineWaveStart >= mf_MinIntervalBetweenVineWaveStarts )  )
			{
				mi_IsNewVineWaveTriggered = faux
			}
		}
	}
	else
	{
		// reset time in sensitivity radius
		mf_TimeInSensitivityRadius = 0.0
		
		f_SensitivitySqrd = mf_OldSensSqrd
		
		// reset the storage of last distance
		if ( tf_dist > f_SensitivitySqrd )
		{
			tf_LastDistance = f_SensitivitySqrd
		}
		
		// update my current banking when Kong is moving away to stabilize it its most banked position (no bank back)
		if ( !mi_IsSwing )
		{
			mv_CurrentBank = OBJ_BankingGet()
		}
	}

	// check to see if we should knock down any of the moveable objects...right now horiz dist based, which is crappy, but good enough for now
	for ( i_Index = 0; i_Index < C_Max_Branches; i_Index++ )
	{
		if ( mo_Branch[i_Index] )
		{
			float 	f_Dist
			int 	ti_control_flag
			
			//collision
			i_NumCols =  @mo_Branch[i_Index] COL_ZDE_ZDEListGet(&tao_zdecol_objects[0], C_zde_corps, C_zde_corps, OBJ_C_IdentityFlag_ZDE , 0, 0)
			
			if ( i_NumCols > 0 )
			{
				if ( mi_IsBranchGradualBendable[i_Index] )
				{
					// calculate the amount which the branch should bend gradually to
					if ( !mi_IsBranchBending[i_Index] && !mi_IsBranchBroken[i_Index] )
					{
						mf_BranchHitDirection[i_Index]			= MATH_VecDotProduct( @tao_zdecol_objects[0] OBJ_SightGet(), @mo_Branch[i_Index] OBJ_SightGet() )
					
						mi_IsBranchBending[i_Index]				= vrai
						mf_BranchBendTimeStamp[i_Index]	= TIME_Get()
						mv_BranchInitPos[i_Index] 				= @mo_Branch[i_Index] OBJ_PosGet()
						
						AI_TrackChange( C_Track_BranchBend, "bhv_BranchBend.fct" )
					}
				}
				else
				{
					@mo_Branch[i_Index] OBJ_HierarchyReset()
					@mo_Branch[i_Index] ODE_Enable( vrai )
					ti_control_flag = @mo_Branch[i_Index] ODE_Geti( 0 )
					ti_control_flag &= ~0x20
					
					// Immovable
					@mo_Branch[i_Index] ODE_Seti( 0, ti_control_flag)
	
					@mo_Branch[i_Index] ODE_Setv( 0, @tao_zdecol_objects[0] OBJ_SightGet() )	//JIMINOTE: using first collided actor
					
					@mo_Branch[i_Index] ODE_Setf( 2, mf_BranchForce )
					@mo_Branch[i_Index] OBJ_FlagInactiveSet( faux )
					
					//trigger ode element specific particle systems. just use the PAGTimer and extend its stop condition to include the particles systems involved here.
					// these should have a flag list for weather the particle should follow the system (i.e. be dynamically linked in a hierarchy with the sub-object)
					// I need to make PAGTimer more generic such that it shouldn't automatically start the big pags (as well as not stop when the main object pags are done) 
				}
			}
		}
	}
}