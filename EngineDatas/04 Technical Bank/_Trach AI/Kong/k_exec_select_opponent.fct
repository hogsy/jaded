#include"k_define.var"


#define 			Cf_fight_dist_stay_on_me			12 * 12			// Rayon dans lequel on garde la perso courant quelque soit l'axe du JOY

int					ti_rank														// Rank
messageid		EVT_ID														// Message ID
message 		tm_message_filter										// Message Filtre
vector			tv_axis														// Axe best axis de recherche d'un ennemy
float				tf_best_dot, tf_dot 										// Dot courant + Best one
vector			tv_fight_kong_to_actor									// Axe Moi vers Enemy
object			to_gao														// Enemy
object			to_fight_actor_old
int					ti_fight_actor_cur
int					ti_ok

//// KEEP the CURRENT FIGHT ACTOR ? =========================================================================
//if ( o_fight_actor && OBJ_SqrDist(o_fight_actor) < Cf_fight_dist_stay_on_me )
//{
//	// Si on est proche de l'acteur qu'on fight alors je cherche s'il demande toujours un EventLockCam et si oui, je le valide.
//	// Sinon je l'invalide ce qui va provoquer le recherche d'un autre perso 
//	ti_rank = -1
//	MSG_SetNull(tm_message_filter)
//	tm_message_filter.msg_sender = o_fight_actor
//	EVT_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_LockCam, &ti_rank, tm_message_filter)
//	if (!MSG_GlobalIsValid(EVT_ID))
//		o_fight_actor  = nobody		// Actor do not ask FIGHT Anymore.
//	else
//	{
//		ai_fight_actor_flag[i_fight_actor_cur] = EVENT_Int1Get(EVT_ID)
//		av_fight_actor_pos[i_fight_actor_nbr] = @to_gao OBJ_PosGet()
//		av_fight_kong_to_actor[i_fight_actor_nbr] = tv_fight_kong_to_actor
//
//}
//else
//	o_fight_actor = nobody			// Actor too Far
//

// GET ANOTHER FIGHT ACTOR ? =============================================================================
//if (!o_fight_actor)
{
	// Je n'ai pas d'acteur de FIGHT donc j'en cherche un... Le plus dans l'axe du JOY ou a defaut du SIGHT

	ti_rank = -1
	tf_best_dot = -Cf_Infinit
	tv_axis = v_joy_sight_normalized
	
	i_fight_actor_nbr = 0
	i_fight_actor_cur = -1

	to_fight_actor_old = o_fight_actor
	o_fight_actor = nobody		// reset the current fight actor !!!!
	
	if ( DBG_WITHOUT_LOCK )
		return
	
	// On scan les EVENTS LOCKCAM
	for(	EVT_ID = MSG_GlobalScan(C_EVENT_TYPE_LockCam, &ti_rank);
			MSG_GlobalIsValid(EVT_ID);
			EVT_ID = MSG_GlobalScan(C_EVENT_TYPE_LockCam, &ti_rank))				// Next Please !
	{
		// J'ai Event Lock Cam
		to_gao = EVENT_PereGet(EVT_ID)
		if (OBJ_SqrDist(to_gao) < Cf_fight_dist_fight_actor)
		{
			// Il est relativement proche de moi donc potienciellement je m'y interesse.
			tv_fight_kong_to_actor = @to_gao OBJ_PosGet() - OBJ_PosGet()
			tv_fight_kong_to_actor.z = 0.0
			if ( !MATH_VecNullEpsilon( tv_fight_kong_to_actor ))
				MATH_VecSetNormalize( tv_fight_kong_to_actor)
			else
				tv_fight_kong_to_actor = OBJ_SightGet()
			
			// Backup information
			ao_fight_actor_list[i_fight_actor_nbr] = to_gao
			ai_fight_actor_flag[i_fight_actor_nbr] = EVENT_Int1Get(EVT_ID)
			av_fight_actor_pos[i_fight_actor_nbr] = @to_gao OBJ_PosGet()
			av_fight_kong_to_actor[i_fight_actor_nbr] = tv_fight_kong_to_actor
			
			// Celui là est much better :)
			if( @to_gao AI_IsModel(get_PNJ_KBats_path) && @to_gao KBC_IsABigBat() )
			{
				// BIG BAT
				if( @to_gao OBJ_CapaTest(OBJ_Capa_7) )
				{
					// Top top prio
					tf_best_dot = tf_dot
					i_fight_actor_cur = i_fight_actor_nbr
					o_fight_actor = to_gao
					i_fight_actor_nbr++
					return
				}
			}
			
			if( @to_gao AI_IsModel(get_PNJ_KBats_path) && ! @to_gao KBC_IsABigBat() )
			{
				// SMALL BAT
				if( ! @get_global i_Player_is_Kong )
					if( IsWaterUnderPos(@to_gao OBJ_PosGet()) )
						continue		// bat au-dessus du lac, ne pas se jeter dans l'eau !!!!
			}
			
			// Je prend L'ennemi le plus dans l'axe de mon axe.
			tf_dot = MATH_VecDotProduct(tv_fight_kong_to_actor, tv_axis)
			ti_ok = faux
			if (tf_dot > tf_best_dot )
				ti_ok = vrai
			if( ! @get_global i_Player_is_Kong )
			{
				// spécial auto fight
				if( o_fight_actor && @to_gao AI_IsModel(get_PNJ_KTREX_Path) && ! @o_fight_actor AI_IsModel(get_PNJ_KTREX_Path) )
				{
					// il y a un TREX et c'est pas lui la target de kong -> on force qu'il soit sa target
					ti_ok = vrai
					tf_dot = 1.0		// y'aura pas mieux que moi !!
				}
			}
			
			if( ti_ok )
			{
				tf_best_dot = tf_dot
				i_fight_actor_cur = i_fight_actor_nbr
				o_fight_actor = to_gao
			}
			i_fight_actor_nbr++	// Un ennemi de plus.
		}
	}
	
	
	// A-t-on trouvé au moins un ennemi ?
	if( i_fight_actor_nbr )
	{
		ti_fight_actor_cur = ARR_ObjSearch(&ao_fight_actor_list[0],i_fight_actor_nbr, to_fight_actor_old)
		if (ti_fight_actor_cur != -1)
		{
			// L'ancien Fight actor est present dans la liste
			if (OBJ_SqrDist(to_fight_actor_old) < Cf_fight_dist_stay_on_me)
			{
				// En en plus il est a une distance de stay on me... (Donc JE LE GARDE)
				i_fight_actor_cur = ti_fight_actor_cur
				o_fight_actor = to_fight_actor_old
			}
		}
	}
}