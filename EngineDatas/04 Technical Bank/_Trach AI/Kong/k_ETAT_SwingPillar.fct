#include"k_define.var"


int			ti_frame_lim
int			ti_capa

float		tf_dot1
float		tf_dot2

vector	tv_axe
vector	tv_axe2
vector	tv_axe_ortho
vector	tv_joy_sight

object	to_bassin

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	COL_ColSetActivationSet(C_bit_zdm_pied, none)	
	DYN_GravitySet(Cv_Kong_Gravity)
	COL_GeoColMapPosSet( 0, cvector( 0.0, 0.0, 2.8))
	if ( o_swing_reference_sol)
		OBJ_HierarchyReset()
	DYN_SpeedSetVector(v_jump_hotspot_speed)
	o_jump_hotspot = nobody
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Kong_swing_pillard) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Kong_swing_pillard


	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	// CAMERA -----------------------------------------------------------------
	@get_global v_kong_camera_vector =  v_climb_normale
	// GRAB CLIENT ACCEPT
	ai_SRV_ENABLE[Ci_LNK_KKFINISH_ON_KONG] = faux
	
	COL_ColSetActivationSet(none, C_bit_zdm_pied)
	
	v_jump_hotspot_speed = DYN_SpeedGetVector()
	v_jump_hotspot_speed -= @o_jump_hotspot OBJ_HorizonGet() * MATH_VecDotProduct( DYN_SpeedGetVector(), @o_jump_hotspot OBJ_HorizonGet())
	MATH_VecSetNorm( v_jump_hotspot_speed, 15.0)
//	DYN_SpeedSetVector( Cv_NullVector)
	DYN_GravitySet(Cv_NullVector)	
	DYN_TractionSet(Cv_NullVector)
	DYN_StreamSet(Cv_NullVector)
	DYN_FrictionVectorSet(Cv_NullVector)
	
//	ACT_ActionSet(Ci_Kanim_Swing_Ver_D)

	COL_GeoColMapPosSet( 0, cvector( 0.0, 0.0, -1.0))
	o_swing_reference_sol = @o_jump_hotspot OBJ_HierarchyGet()
	if ( o_swing_reference_sol)
		OBJ_HierarchySet( o_jump_hotspot)

	f_jump_hotspot_dist = MATH_VecDistance( OBJ_PosGet(), @o_jump_hotspot OBJ_PosGet())
	v_jump_force_sens = OBJ_SightGet()
	
//	ti_capa = o_jump_hotspot.des_int1
//	if( ti_capa & (HOTSPOT_Type_Limit1_4)
//	{
//		// Il y a des restriction au mouvement de Swing
//		tv_axe = OBJ_PosGet() - @to_hotspot OBJ_PosGet()
//		tv_axe.z = 0.0
//		tf_dot1 = MATH_VecDotProduct( tv_axe, @to_hotspot OBJ_SightGet())
//		tf_dot2 = MATH_VecDotProduct( tv_axe, -@to_hotspot OBJ_HorizonGet())
//		if ( tf_dot1 >=  0.0)
//		{
//			// Cas 1 ou 2
//			if ( tf_dot2 <=  0.0)
//			{
//				// On est dans le ¼ 2
//				if ( ti_capa & HOTSPOT_Type_Limit1_2)
//				{
//					// On est dans le mur problème  !!
//					to_hotspot  = nobody
//				}
//			}
//		}
//		else
//		{
//			// Cas 3 ou 4
//			if ( tf_dot2 <=  0.0)
//			{
//				// On est dans le ¼ 3
//					to_hotspot  = nobody
//			}
//		}
//	}


	// Calcul de la limite du swing en fonction de la configuration du WP de Swing et de la position d'entrée de Kong

	if( ACT_ActionGet() == Ci_Kanim_Swing_Jump_G)
		ACT_ActionSet(Ci_Kanim_Swing_Ver_D)
	else
		ACT_ActionSet(Ci_Kanim_Swing_Ver_G)

	ti_capa = o_jump_hotspot.des_int1
	if( ti_capa  & HOTSPOT_Type_Limit1_4) //( OBJ_Capa_14 + OBJ_Capa_15))
	{
		// Il y a des restriction au mouvement de Swing
		if ( ACT_ActionGet() == Ci_Kanim_Swing_Ver_D)
			v_swing_limite = @o_jump_hotspot OBJ_HorizonGet()
		else
			v_swing_limite = -@o_jump_hotspot OBJ_SightGet()
//		tv_axe = OBJ_PosGet() - @o_jump_hotspot OBJ_PosGet()
//		tv_axe.z = 0.0
//		tf_dot1 = MATH_VecDotProduct( tv_axe, @o_jump_hotspot OBJ_SightGet())
//		tf_dot2 = MATH_VecDotProduct( tv_axe, -@o_jump_hotspot OBJ_HorizonGet())
//		if ( tf_dot1 >=  0.0)
//		{
//			// Cas 1 ou 2
//			if ( tf_dot2 >=  0.0)
//			{
//				// On est dans le ¼ 1
//				i_swing_limite = 2		// sort a ½ tour 
//
//				if ( ti_capa & HOTSPOT_Type_Limit1_4)
//				{
//					// Partir du coté du Joy car il y a autant de place a D qu'a G
//					tv_axe = MATH_VecRotate( tv_axe, Cv_VerticalVector, Cf_PiBy2)
//					
//					if( MATH_VecDotProduct( v_joy_sight, tv_axe) < 0)
//					{
////						ACT_ActionSet(Ci_Kanim_Swing_Ver_G)
//						v_swing_limite = -@o_jump_hotspot OBJ_SightGet()
//					}
//					else
//					{
////						ACT_ActionSet(Ci_Kanim_Swing_Ver_D)
//						v_swing_limite = @o_jump_hotspot OBJ_HorizonGet()
//					}
//					
//				}
//			}	
//			else			
//			{
//				// On est dans le ¼ 2 // WORKS
//				i_swing_limite = 3 		// sort a 3½ tour
//				v_swing_limite = -@o_jump_hotspot OBJ_SightGet()
////				if ( ti_capa & HOTSPOT_Type_Limit1_4)
////				{
////					// Partir à G
////					ACT_ActionSet(Ci_Kanim_Swing_Ver_G)
////				}
//			}	
//		}
//		else
//		{
//			// Cas 3 ou 4
//			i_swing_limite = 3 		// sort a 3½ tour
//			if ( tf_dot2 >=  0.0)
//			{
//				// On est dans le ¼ 4
//	
//				// Partir à D
//				ACT_ActionSet(Ci_Kanim_Swing_Ver_D)
//				
//				if ( ti_capa & OBJ_Capa_14)
//				{
//					v_swing_limite = @o_jump_hotspot OBJ_HorizonGet()
//				}
//				else if ( ti_capa & OBJ_Capa_15)
//				{
//					v_swing_limite = @o_jump_hotspot OBJ_SightGet()
//				}
//			}	
//			else			
//			{
//				// On est dans le ¼ 3
//				DBG_Error("Cas anormal")
//			}	
//			
//		}
		ANI_FrequencySet( 0, 55)		// ralentir un poil l anim si celle ci ne doit pas se terminer
	}
//	else
//	{
//		i_swing_limite = 4		// Sort a 1 tour : 0 restriction
//		v_swing_limite = Cv_NullVector
//		// Partir du coté du Joy car il y a autant de place a D qu'a G
//		
//		// Vecteur otho a tv_axe
//		tv_axe = MATH_VecRotate( tv_axe, Cv_VerticalVector, Cf_PiBy2)
//		
////		if( MATH_VecDotProduct( v_joy_sight, tv_axe) > 0)
//		if( ACT_ActionGet() == Ci_Kanim_Swing_Jump_G)
//			ACT_ActionSet(Ci_Kanim_Swing_Ver_D)
//		else
//			ACT_ActionSet(Ci_Kanim_Swing_Ver_G)
//	}

	if ( ACT_ActionGet() == Ci_Kanim_Swing_Ver_D)
		f_swing_sign	= Cf_PiBy2  //2 * Cf_PiBy3
	else
		f_swing_sign	= -Cf_PiBy2 // 2 * Cf_PiBy3

	i_flag_just_Action_swing = faux
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ======================================================================
AI_Execute("k_exec_detect_paf")
if ( o_paf_actor)
{
	PAF_Test_ChangeEtatValid(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}
 
AI_Execute("k_exec_joy")
					
// COMPORTEMENT ================================================================


to_bassin = ANI_CanalObjectGet( Anim_Canal_Bassin)
tv_axe = @to_bassin OBJ_PosGet() - @o_jump_hotspot  OBJ_PosGet()
tv_axe.z = 0.0
MATH_VecSetNormalize( tv_axe)
tv_axe_ortho  = MATH_VecRotate( tv_axe, Cv_VerticalVector, f_swing_sign )
tv_axe2  = MATH_VecRotate( tv_axe, Cv_VerticalVector, MATH_FloatSign(f_swing_sign) * Cf_PiBy3 )
macro_render_Vector( @to_bassin OBJ_PosGet() , tv_axe_ortho * 5.0, color_vert)
macro_render_Vector( @to_bassin OBJ_PosGet() , v_swing_limite * 5.0, color_jaune)
macro_render_Vector( @to_bassin OBJ_PosGet() , tv_axe * 5.0, color_noire)
macro_render_Vector( @to_bassin OBJ_PosGet() , tv_axe2* 5.0, color_noire)

ti_capa = o_jump_hotspot.des_int1
if ( i_flag_just_Action )
{
	i_flag_just_Action_swing = vrai
	if ( ti_capa & HOTSPOT_Type_Limit1_4)
	{
		i_flag_just_Action = faux
	}
}

if ( ( i_flag_just_Action || ACT_ActionFinished()) ||
( MATH_VecDotProduct( v_swing_limite, tv_axe2 ) > 0 &&
MATH_VecDotProduct( v_swing_limite, tv_axe ) > 0 ))
{
	// Fenetre D : sauter 
	{
		// Pas de Sol référencé : sauter
		// ou alors le Saut était demandé 
		f_time_collide_ground = 0.0 	// Forcer un saut		
		i_jump_force_no_impulsion = vrai

		f_jump_force_distance = 10.0
			
		if ( MATH_VecNullEpsilon( v_swing_limite))
		{
			// Cas sans limite
//			v_jump_force_sens = MATH_VecInCone( v_joy_sight, tv_axe_ortho, Cf_1Degre * 15.0, 0)
			v_jump_force_sens = tv_axe_ortho
		}
		else
		{		
	
			// Si ce n est pas le saut volontaire, sauter dans le sens de la limite !!
			if ( i_flag_just_Action)
				tv_joy_sight = v_joy_sight
			else
				tv_joy_sight  = v_swing_limite

			if ( MATH_VecDotProduct( v_swing_limite, tv_axe ) > 0)
				tv_axe_ortho = v_swing_limite		// On a depasse la limite.

			v_jump_force_sens = MATH_VecInCone( tv_joy_sight, tv_axe_ortho, Cf_1Degre * 15.0, 0)
			
			// Cas avec limite : ne pas dépaser la limite.
 			ti_capa = o_jump_hotspot.des_int1
			if ( ti_capa & HOTSPOT_Type_Limit1_4)
			{
				v_swing_limite = -@o_jump_hotspot OBJ_HorizonGet() + @o_jump_hotspot OBJ_SightGet()
				v_jump_force_sens = MATH_VecInCone( v_jump_force_sens, v_swing_limite , Cf_PiBy2+Cf_PiBy4, 0)
			}
		}

	}
	// LE SAUT || LA CHUTE
  	if (!i_flag_just_Action_swing)
	{
		// CHUTE : car le joueur a pas sauté
		f_jump_force_distance = 5.0
		f_jump_force_hauteur = 0.0
		f_jump_force_amplitude = 0.5
		i_jump_force_chute = faux				// C'est tout de meme un petit saut et pas une chute
		i_jump_check_hotspot_fight = faux	// On ne peux pas enchainer sur un ennemi
		i_jump_check_hotspot = faux			// On ne peux pas enchainer
		v_jump_force_chute_orient = v_jump_force_sens							// Orientation de Kong pendant le saut
		macro_change_etat("k_ETAT_jump")
	}	
	else
	{
		// SAUT
		f_jump_force_hauteur = 2.5
		f_jump_force_distance = 13.0
		f_jump_force_amplitude = 1.5
		i_jump_check_hotspot = vrai	// On peux enchainer les HOT SPOT
		i_jump_check_hotspot_fight = vrai	// On peux enchainer sur un ennemi
		i_jump_force_chute = faux

		macro_change_etat("k_ETAT_jump")		
	}
}

