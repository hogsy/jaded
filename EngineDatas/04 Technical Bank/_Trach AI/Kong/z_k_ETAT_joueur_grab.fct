#include"k_define.var"

#define	Fin_IK	\
	ao_CL_GRABKONG[i_GrabKong_MainBloquee] = nobody	\
	i_GrabKong_MainBloquee = -1										\
	i_IK_end = vrai\
//	AI_CBDel( o_GrabKong_Target, CallBack_After_Blend, "k_exec_Ik_GrabKong")		\
//	o_GrabKong_Target = nobody


#define	Frein( coef)		\
{	float			t_dt				\
	f_GrabKong_frein = 1.0 	\
	t_dt = TIME_GetDt()			\
	while ( t_dt > 0)				\
	{									\
		f_GrabKong_frein *= coef // Amortie en Fonction du DT a faire		\
		t_dt -= 0.01666			\
	}									\
	v_GrabKong_speed_grab *= f_GrabKong_frein						\
	LNK_GrabKong_SpeedVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], v_GrabKong_speed_grab)	\
}

#define	Sweep_pre_calculs\
		DBG_RenderVector( OBJ_PosGet(), v_GrabKong_axe * 5.0, color_vert)\
		tv_temp = OBJ_PosGet() - @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() \
		MATH_VecSetHorzNormalize( tv_temp)\
		tv_temp2 = MATH_VecRotate( tv_temp, Cv_VerticalVector, f_GrabKong_rot_sign * Cf_PiBy2)\
		tv_posA = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() + (tv_temp2 * 5)\
		tv_posB = OBJ_PosGet() - (tv_temp2 * 5)\
		tv_temp = MATH_VecNormalize(tv_posB - tv_posA)\
		DBG_RenderVector( OBJ_PosGet(), tv_temp, color_rouge)\
		tv_posA = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() - (tv_temp2 * 5)\
		tv_posB = OBJ_PosGet() + (tv_temp2 * 5)\
		tv_temp2 = MATH_VecNormalize(tv_posB - tv_posA)\
		DBG_RenderVector( OBJ_PosGet(), tv_temp2, color_rouge)\
		DBG_RenderCircle( OBJ_PosGet(), 5, Cv_VerticalVector, color_rouge)\
		DBG_RenderCircle( @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet(), 5, Cv_VerticalVector, color_rouge)\
		tf_dot = MATH_VecDotProduct( tv_temp, tv_temp2 )

#define	InitiateGrab				\
{	i_GrabKong_MainBloquee = i_GrabKong_MainActionGrab\
	// Choix du mode : Kong CHARGE ou c'est le TREX ?\
	if ( i_GrabKong_special) \
	{	tv_sens =  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() - OBJ_PosGet() \
		MATH_VecSetHorzNormalize( tv_sens)\
		tf_dot3 = MATH_VecDotProduct( tv_sens, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet())\
		if ( tf_dot3 < 0)\
		{	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Attrape)\
			ACT_ActionSet( Ci_Kanim_GK_SePlaceG)\
			LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_Kanim_GK_JeteG)}\
		else	\
		{	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Attrape)\
			ACT_ActionSet( Ci_Kanim_GK_SePlaceD)\
			LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_Kanim_GK_JeteD)}\
	}\
	else if (  f_reflex_speed > @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] DYN_SpeedGet())		// Kong cours : considéréen charge\
	{	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_AttrapePousse)\
		ACT_ActionSet( Ci_Kanim_Grab_recal) \
		LNK_GrabKong_SpeedVectorSet(amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], v_col_speed_last)\
		LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  1)}\
	else\
	{	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Attrape)\
		ACT_ActionSet( Ci_Kanim_Grab_recal) \
		LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  1)}\
	LNK_GrabBoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], ANI_CanalObjectGet( Anim_Canal_MainDroite))\
	LNK_GrabKong_ArmSizeSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], 3.5)\
	to_tete = @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] ANI_CanalObjectGet( Anim_Canal_Tete)\
	tv_sight = @to_tete OBJ_PosGet() - OBJ_PosGet()\
	MATH_VecSetHorzNormalize( tv_sight)\
	v_frappe_sight = tv_sight\
	// Grab sur une grosse cible\
	o_GrabKong_Target = ao_CL_GRABKONG[i_GrabKong_MainBloquee]		// Acteur tenu en respet\
	i_IK_end = faux	// L IK s active donc par defaut elle est pas finie							\
	AI_CBAdd( o_GrabKong_Target, CallBack_After_Blend, "k_exec_Ik_GrabKong")		\
	f_grab_blend_main = 0.0							// Blend de la position de la main : entre la position del  anim et celle de l IK)\
	v_GrabKong_init_grab = OBJ_PosGet()		// Position de depard du grab pour un blend de position\
	v_GrabKong_speed_grab = LNK_GrabKong_SpeedVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])\
	f_GrabKong_speed_grab_min = Cf_charge_Kong_speed_min\
	i_GrabKong_mode = 1\
	f_time_start_etat = 0.0\
	// recherche du vecteur d offset entre la position idéale d encrage et Kong\
	tv_sens = OBJ_PosGet() - @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet()\
	tv_sens -= LNK_GrabKong_AncrageVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) * LNK_GrabKong_NeckSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])\
	tv_sens.z = 0.0\
	v_Grab_Kong_Offset_init = tv_sens	// vecteur differentiel de position initial\
}


#define	Cf_Blend_Rotation_MAX	5.0
#define	Cf_Blend_Acceleration		1.5
#define	Cf_Blend_Contre				20.0
#define	Cf_Blend_Desceleration	10.0

#define	Cf_dist_aide_tir_min			10
#define	Cf_dist_aide_tir_max		40
	
#define	Cf_Force_Jete						90.0									// Force du lancé du TREX par Kong
#define	Cf_Force_Sweep_Kong			10.0									// Force de Kong s'il lance le sweep
#define	Cf_charge_Kong_speed_min	15.0
#define	Cf_Sweep_speed_min			2.0

#define	Ci_ChargeDuTrex					0b0001
#define	Ci_ChargeDuTrexDeFace		0b0001
#define	Ci_ChargeDuTrexDeCote		0b0101
#define	Ci_ChargeDuTrexSWEEP		0b1001
#define	Ci_ChargeDeKong				0b0010
#define	Ci_ChargeDeKongDeFace		0b0010
#define	Ci_ChargeDeKongDeCote		0b0110
#define	Ci_ChargeDeKongSWEEP	0b1010


#define	Cf_cercle_tps_debat									0.75			// Tps de debat avant ECHEC
#define	Cf_debat_frein											0.965			// Freinage pendant que le TREX se debat
// Reglage pour le cas REX charge Kong le stop de face
#define	Cf_cercle_arret_tps_avt_frein						0.5			// Passage en sweep possible pendant ce delai + 0.151s du a l anim d accrochage
#define	Cf_cercle_arret_entree_sweep_vitesse_min	8.0			
#define	Cf_cercle_arret_vitesse_min_echec_grab		2.0			// si la vitesse passe sous cette limite echec: chute
#define	Cf_cercle_arret_frein									0.970			// vitesse de freinage du couple
#define	Cf_cercle_arret_angle_planchette				-Cf_Cos45	// Cos de l angle de detection planchette
// Reglage pour le cas REX charge Kong l'attrape de cote
#define	Cf_cercle_sweep_tps_degagement				0.5			// Passage en sweep possible pendant ce delai + 0.151s du a l anim d accrochage
#define	Cf_cercle_sweep_angle_degagement			-Cf_Cos45	// Cos de l angle autorisation de degagement
#define	Cf_cercle_sweep_cone_sortie					50.0			// Angle en degré dui cone de sortie
// Reglage pour le cas KONG CHARGE le TREX de face
#define	Cf_cercle_charge_tps_avt_frein					0.5			// Kong Pousse le TREX
#define	Cf_cercle_charge_angle_retourne				Cf_Cos45	// Kong Retourne le TREX
#define	Cf_cercle_charge_angleface						Cf_Cos45	// Angle de la zone : de face
#define	Cf_cercle_charge_angle_degage					-Cf_Cos30	// Angle au dessus duquel on ne peux plus degager le TREX(car il traverserait Kong)

int			ai_bones[32]
int			ti_cote
int			ti_col
int			ti_rank
int			ti_GrabKong_1_attrape_par_action
int			ti_Interuption_Grab
int			ti_status
int			ti_action
int			ti_valide
int			ti_degagement
int			ti_type
int			ti_force_ejection_sweep
int			ti_grab_ann

float		tf_norm 
float		tf_sign
float		tf_norm_levier
float		tf_dot, tf_dot2, tf_dot3
float		tf_dist
float		tf_H
float		tf_sin
float		tf_blend
float		tf_frame

vector	tv_axis
vector	tv_pos
vector	tv_bras
vector	tv_bras2
vector	tv_target
vector	tv_target2
vector	tv_sens_lance
vector	tv_sens
vector	tv_sight
vector	tv_axe
vector	tv_temp
vector	tv_temp2
vector	tv_pos_ancrage
vector	tv_speed
vector	tv_speed_grab_target
vector	tv_arm_pos
vector	tv_dest_pos
vector	tv_last_pos
vector	tv_KT
vector	tv_posA
vector	tv_posB

object	to_actor
object	to_bone 
object	to_tete 
object	to_gao
object	to_main
object	to_bras

messageid	tmid_NMI

// Test Dino Ride
object			to_ride_actor
int					ti_i
int					ti_main_grab_ride_actor

// Pose ANN
messageid		tmid_vis_ID
int					ti_wp_pose_ANN
int					ti_direct_exit
object			to_msg_sender


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux	
	i_exit_mode = faux
	i_GrabKong_attrape_jete = -1		// Cette variable est testé dans le reflex	

//	if( i_flag_grab_raptor_en_cours || i_flag_positionne_souche )
//	{
//		// Positionnement afterblend du raptor ou de la souche : on indique la main de snap
		i_flag_grab_raptor_en_cours = faux
		i_flag_positionne_souche = faux
//
//		if ( i_GrabKong_MainActionGrab)
//			to_bone = ANI_CanalObjectGet( Anim_Canal_MainGauche)
//		else
//			to_bone = ANI_CanalObjectGet( Anim_Canal_MainDroite)
//		LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], to_bone)
//	}
	
	// TOUT COUPER
	if ( i_GrabKong_MainBloquee != -1)
	{
		if ( MSG_GlobalIsValid( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]))
		{
			ao_CL_GRABKONG[i_GrabKong_MainBloquee] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], faux, "k_exec_grab_object_param", nofunc, nofunc)
		}
		Fin_IK               // que ce soit KONG ou REX qui coupe la liaison...
	}

//	o_GrabKong_Target = nobody
	i_flag_pose_ANN_en_cours = faux
	return
}

// RIDE SERVEUR ?
to_ride_actor = nobody
for (ti_i = 0; ti_i < Ci_Ride_Client_Nb; ti_i++)
{
	ao_bone_rider[ti_i] = LNK_ServeurGet(Ci_LNK_RIDE_DINO, amid_bone_rider_LNK_ID[ti_i], vrai, nofunc, nofunc)
	if ( ao_bone_rider[ti_i])
	{
		to_ride_actor = ao_bone_rider[ti_i]
		if( ! ti_i )		// || ti_i == 2 )
			ti_main_grab_ride_actor = 0		// grabbe dans le dos avec la main droite
		else
			ti_main_grab_ride_actor = 1		// grabbe dans le dos avec la main gauche
		break
	}
}


ti_direct_exit = faux		// annule la demande de grab (le joueur a demandé de grabber alors qu'il a ANN dans la main et qu'il n'y a pas de wp)


// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_grab) 
{
	i_etat_courant = ETAT_grab
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	// CAMERA CAMERA CAMERA
	@get_global i_kong_camera_status = Ci_Kcamera_deplacement	
	// CAMERA CAMERA CAMERA
	
	f_GrabKong_blend_orient = 0.0
	f_GrabKong_blend_pos = 0.0
	i_GrabKong_mode = 0				// Mode jouage d anim de Grab par defaut
	i_flag_just_throw = faux
	ti_wp_pose_ANN = faux
	
	// TEST WP POSE ANN
	if( i_flag_pose_ANN_this_trame && ao_CL[Ci_LNK_KKGRAB_OBJECT] 
	|| i_Grab_Torse_ANN)
	{
		// KONG se trouve à proximité d'un WP "Pose ANN"
		if ( i_flag_pose_ANN_this_trame)
			to_msg_sender = msg_last_message.msg_sender
		else
			to_msg_sender = nobody
//		if( !i_flag_pose_ANN_this_trame || MATH_VecDotProduct(v_joy_sight_normalized, @to_msg_sender OBJ_PosGet() - OBJ_PosGet()) > 0.0 )
		{
			// pas de WP ou bien KONG est tourné vers le WP
			if( ! i_GrabKong_Souche )		// ne porte pas de tronc
//				&& ! to_ride_actor )			// n'a pas un raptor sur le dos
			{
				if( ! i_Grab_Torse_Actor || i_Grab_Torse_ANN )
				{
					// ne tient personne dans les mains ou alors c ANN
					ti_wp_pose_ANN = vrai
					i_flag_pose_ANN_en_cours = vrai
					if ( i_flag_pose_ANN_this_trame)
						msg_pose_ANN = msg_last_message
					else
						MSG_SetNull( msg_pose_ANN)
					i_flag_just_grab = faux
					v_frappe_speed = Cv_NullVector						// Stopper la vitesse de deplacement quand on pose Ann
					v_GrabKong_init_grab = OBJ_PosGet()			// Position d ou debute le blend de position
					f_GrabKong_blend_pos	= 0.0							// blend de position
					if ( to_msg_sender)
					{
						v_frappe_sight = @to_msg_sender OBJ_PosGet()	- OBJ_PosGet() // Orientation
						v_frappe_sight.z = 0.0
					}
					else
						v_frappe_sight = OBJ_SightGet()
					if( MATH_VecNullEpsilon( v_frappe_sight))
						v_frappe_sight = OBJ_SightGet()
					else
						MATH_VecNormalize( v_frappe_sight)
				}
			}
		}
	}
	
	// DETERMINATION DU CHOIX GRAB / THROW
	if( ! ti_wp_pose_ANN )
	{
		// KONG n'a pas l'intention de poser ANN
		if( i_Grab_Torse_Main != -1 )
		{
			// Jeter ce qu'il y a dans la main choisie
			i_GrabKong_MainActionGrab = i_Grab_Torse_Main
			i_flag_just_grab = faux			// KONG n'a pas le droit de grabber autre chose s'il tient déjà quelque chose dans la main
			
			if( i_Grab_Torse_ANN )
				ti_direct_exit = vrai 			// Pas de WP à côté, KONG ne pose pas ANN et ne grabbe rien
			else
				i_flag_just_throw = vrai		// KONG jète le raptor
		}
		else if( i_GrabKong_Souche )
		{
			// lancer du tronc
			i_flag_just_grab = faux
			i_flag_just_throw = vrai
		}
	}
	
	i_GrabKong_Qui_Charge = 0	// Par defaut il n y a pas de grab donc status QUO

	// Par defaut on ne va pas tenter de chopper le raptor 
	i_GrabKong_raptor_test = faux
	i_GrabKong_special = faux
	if( i_flag_just_grab )
	{
		// GRAB
		i_GrabKong_orient = faux
		i_GrabKong_attrape_jete = Ci_Attrape
		
		// Tenter d'attraper devant lui
		DBG_TraceString("demande de GRAB")
		DBG_TraceEOL()
		i_GrabKong_Type = Ci_GrabKong_Type_Gros
		v_frappe_sight = v_joy_sight_normalized		// Orientation
		
		// Ann pas grabbable essayer d attraper autre chose
		i_GrabKong_Type = ~Ci_GrabKong_Type_Finish
		v_grab_object_pos= OBJ_PosGet() + v_joy_sight				// Position du point de grab demandé
		if( to_ride_actor )
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ThisClientGet(to_ride_actor, Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)
		else
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)
		if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
		{
			// J'attrape un objet fixe
			to_bone = nobody
			ti_type = LNK_GrabKong_TypeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])
			if ( ti_type & Ci_GrabKong_Type_Petit)
			{
				// J'attrape un object léger
				i_flag_grab_raptor_en_cours = vrai
				if( to_ride_actor )
				{
					// kong grabe depuis son dos pour jeter, on n'active encore pas l'IK du bras
					i_flag_ride_grab = vrai
					ACT_ActionSet( Ci_Kanim_AttrapeDos_D + i_GrabKong_MainActionGrab) 
				}
				else
				{
					// l'IK du bras activée
					i_Grab_Torse_Main = i_GrabKong_MainActionGrab
//					if ( i_GrabKong_MainActionGrab)
//						to_bone = ANI_CanalObjectGet( Anim_Canal_MainGauche)			// objet main gauche
//					else
//						to_bone = ANI_CanalObjectGet( Anim_Canal_MainDroite)				// objet main droite
					ACT_ActionSet( Ci_Kanim_Attrape_D + i_GrabKong_MainActionGrab)		// Attraper
				}
			}
			else if ( ti_type & Ci_GrabKong_Type_Souche)
			{
				// J'attrape une souche
				i_GrabKong_Souche = vrai		// Rajout par FRED
				// souche
				i_flag_positionne_souche = vrai
				// Lancer l anim d attrape mais rien a chopper
				ACT_ActionSet( Ci_Kanim_Attrape_D + i_GrabKong_MainActionGrab)		// Attraper
				v_frappe_sight = LNK_GrabKong_LanceVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) - OBJ_PosGet()		
			}
			else if ( ti_type & Ci_GrabKong_Type_Gros)
			{
//				BEWARE SPEC INC !!!!!!!!!!!!!!!!!!!!!!!!!
				i_GrabKong_special = (ti_type & Ci_GrabKong_Type_Special)				// Grab mode special
//				BEWARE SPEC INC !!!!!!!!!!!!!!!!!!!!!!!!!
				InitiateGrab																					// Gra	b normal passer en GRAB					
			}
			else if ( ti_type & Ci_GrabKong_Type_Finish)
				macro_change_etat("k_ETAT_finish")									// Grab de Type Finish : passer en MODE FINISH
			
			LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], to_bone)
		}
		else
		{
			// TENTER DE CHOPPER ANN
			if ( ao_CL[Ci_LNK_KKGRAB_OBJECT])
				ti_grab_ann = faux		// On a deja ann ne pas rechercher a l attraper
			else
			{
				v_grab_object_pos = OBJ_PosGet() + OBJ_SightGet()		// Position du point de grab demandé
				ao_CL[Ci_LNK_KKGRAB_OBJECT] = LNK_ClientGet(Ci_LNK_KKGRAB_OBJECT, amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], vrai, "k_exec_grab_object_param", nofunc, "k_exec_grab_object_init")		
				if ( ao_CL[Ci_LNK_KKGRAB_OBJECT])
					ti_grab_ann = vrai
				else
					ti_grab_ann = faux
			}
			if ( ti_grab_ann)
			{
				// Attraper Ann
				i_flag_positionne_ANN = vrai
				i_GrabKong_MainActionGrab  = 0
//				i_Grab_Torse_Main = i_GrabKong_MainActionGrab 
				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Attrappe_Attend)
				LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], nobody)	// Ann bouge pas

				// test de la main D/G
//				if( ! i_GrabKong_MainActionGrab )
//					LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], ANI_CanalObjectGet(Anim_Canal_MainDroite) )
//				else
//					LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], ANI_CanalObjectGet(Anim_Canal_MainGauche) )
				ACT_ActionSet( Ci_Kanim_AttrapeAnn)
				v_frappe_sight = @ao_CL[Ci_LNK_KKGRAB_OBJECT] OBJ_PosGet()	- OBJ_PosGet() // Orientation
				v_frappe_sight.z = 0.0
				if( MATH_VecNullEpsilon( v_frappe_sight))
					v_frappe_sight = OBJ_SightGet()
				else
					MATH_VecNormalize( v_frappe_sight)
				v_GrabKong_init_grab = OBJ_PosGet()		// Position d ou debute le blend de position
				f_GrabKong_blend_pos = 0.0						// blend de position
			}
			else
			{
				// Lancer l anim d attrape mais rien a chopper
				i_GrabKong_raptor_test = vrai
				ACT_ActionSet( Ci_Kanim_Attrape_D + i_GrabKong_MainActionGrab)		// Attraper
			}					
		}
		
		i_flag_just_grab = faux 								// On vient de Grabber, on veut pas dégrabber
		f_coef_pied_d_appui = i_GrabKong_MainActionGrab			// Coef pied d'appui pour rotation pied
	}
	else if ( i_flag_just_throw)
	{
		// THROW
		i_Grab_Torse_Main = -1
		i_GrabKong_attrape_jete = Ci_Jete
		if(  glob_joynorm_get)
		{
			i_GrabKong_orient  = vrai
			tv_sens_lance = v_joy_sight
		}
		else
		{
			i_GrabKong_orient  = vrai
			tv_sens_lance = v_look_direction
		}
		
		// Lecture du joy
		v_frappe_sight = tv_sens_lance
		tv_bras = -v_look_sens_epaule
		if ( MATH_VecDotProduct( tv_sens_lance, tv_bras) > 0 )
			ti_cote = 1
		else
			ti_cote = 0
		
		if ( i_GrabKong_Souche)
		{
			i_GrabKong_orient  = vrai
			ACT_ActionSet( Ci_Kanim_souche_lance)	// Lancer
			f_coef_pied_d_appui = 0.5							// Coef pied d'appui pour rotation pied
		}		
//		else if ( ao_CL_GRABKONG[ 0] && ao_CL_GRABKONG[ 1])
//		{
//			// 1 truc dans chaque main jeter le plus dans l axe
//			i_GrabKong_orient  = vrai
//			i_GrabKong_MainActionGrab = ti_cote
//			ACT_ActionSet( Ci_Kanim_Jete_D + i_GrabKong_MainActionGrab)	// Lancer
//			f_coef_pied_d_appui = i_GrabKong_MainActionGrab						// Coef pied d'appui pour rotation pied
//		}
		else
		{
			//  1 seule main d occupée il faudra s orienter en jetant
			i_GrabKong_orient  = vrai
			if ( ao_CL_GRABKONG[ 0] )
				i_GrabKong_MainActionGrab = 0
			else
				i_GrabKong_MainActionGrab = 1
			ACT_ActionSet( Ci_Kanim_Jete_D + i_GrabKong_MainActionGrab)	// Lancer
			f_coef_pied_d_appui = i_GrabKong_MainActionGrab						// Coef pied d'appui pour rotation pied
		}
		v_frappe_speed = DYN_SpeedGetVector()										// Conserver un peu de vitesse de deplacemetn quand on lance
	}
	
	f_grab_blend_pos = 0.0
	f_time_start_etat = 0.0
	i_GrabKong_1_attrape_par_action = faux
	i_GrabKong_sweep_degagement = faux																	// Type de SWEPP particulier pour se degager de la trajectoire future du TREX quand Kong lance
	v_GrabKong_attrape_orient = Cv_NullVector																// Null tant que pas defini pendant l accrochage
	i_GrabKong_Throw = faux																						// Kong
	i_flag_ride_grab = faux																							// n'est plus en train de grabber le raptor sur son dos
	i_GrabKong_send_PAF = faux																				// Passe a vrai si Kong frappe le REX en grab
	i_GrabKong_je_vais_etre_jete = faux																		// Passe a vrai si le TREX va jeter Kong car grab trop long
}
else
{
	f_time_start_etat += TIME_GetDt()
	f_GrabKong_blend_pos += TIME_GetDt()
}


// ANALYSE =======================================================================

if ( i_GrabKong_MainBloquee != -1)
{
	// CHECK DE LA LIAISON
	if ( i_exit_mode)
		ti_valide = faux		// Sortie de mode demandée on ne veux plus de liaison
	else
		ti_valide = vrai
	if ( ao_CL_GRABKONG[i_GrabKong_MainBloquee])
		ao_CL_GRABKONG[i_GrabKong_MainBloquee] = LNK_ThisClientGet( ao_CL_GRABKONG[i_GrabKong_MainBloquee], Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], ti_valide, "k_exec_grab_object_param", nofunc, nofunc)
	else
		ao_CL_GRABKONG[i_GrabKong_MainBloquee] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], ti_valide, "k_exec_grab_object_param", nofunc, nofunc)
	if ( !ao_CL_GRABKONG[i_GrabKong_MainBloquee])
	{
		// LE Client a coupé la liaison
		if ( ! i_exit_mode)
		{
			// Degagement de laché de prise
			if ( i_GrabKong_je_vais_etre_jete)
			{
				tf_dot = MATH_VecDotProduct( OBJ_PosGet() - @o_GrabKong_Target OBJ_PosGet(), OBJ_HorizonGet())
				if ( tf_dot < 0)
					ACT_ActionSet(Ci_Kanim_GrabTT_pafG_byREX)		// A Gauche
				else
					ACT_ActionSet(Ci_Kanim_GrabTT_pafD_byREX)		// A Droite
	
				v_frappe_sight = Cv_NullVector
				i_exit_mode = vrai
			}
			
			// Lacher ANN : on informe ANN
			if(ao_CL[Ci_LNK_KKGRAB_OBJECT])
			{
				if( i_Grab_Torse_ANN )
				{
					i_Grab_Torse_ANN = faux
					i_Grab_Torse_Main = -1
				}
				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Lache)
			}
		}
		
		if ( ACT_ActionGet() == Ci_Kanim_GrabTT_Frappe)
		{
			if ( !i_GrabKong_send_PAF && ANI_CurrentFrameGet( 0) > 18)
			{
				i_GrabKong_send_PAF = vrai 
				EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_EVENT_PAF_Kong + C_EVENT_PAF_KK_Assome, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_GrabKong_Target, -1, 2, OBJ_SightGet(), COL_ZonePosGet( C_zde_fight))
			}
		}
	
		// Si une anim spéciale est demandé pour finir le mode( i_exit_mode = vrai)  attendre qu'elle soit ternimée
		if ( !i_exit_mode || ACT_ActionFinished())
		{
//			i_GrabKong_MainBloquee = -1
			i_IK_end = vrai
//			AI_CBDel( o_GrabKong_Target, CallBack_After_Blend, "k_exec_Ik_GrabKong")			// Arrete l IK sur la cible
//			o_GrabKong_Target = nobody
			macro_change_etat( "k_ETAT_deplacement")		// Grab Fini
		}
		else 
		{
			if ( !MATH_VecNullEpsilon( v_frappe_sight))
				OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), v_frappe_sight, 8.0 * TIME_GetDt()), Cv_VerticalVector)
			return
		}
	}

	// PUNCH
	if ( i_flag_just_intimidateD || i_flag_just_intimidateG)
	{
		LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Frappe)	
		ACT_ActionSet( Ci_Kanim_GrabTT_Frappe)
	}
//	macro_change_etat("k_ETAT_commun_frappe")

	// THROW
	if ( i_flag_just_grab)
		i_GrabKong_Throw = vrai
	if ( i_GrabKong_Throw && f_grab_blend_pos == 1 
	&& LNK_GrabKong_ActionGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]) != Ci_GrabKong_Lance
	&& LNK_GrabKong_ActionGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]) != Ci_GrabKong_Lance_SePositionne)
	{
		// Tenter de jeter
		i_GrabKong_mode = 0
		i_GrabKong_orient  = faux

		//  LACHER PRISE
		i_GrabKong_attrape_jete = Ci_Repousse
		i_GrabKong_MainActionGrab = i_GrabKong_MainBloquee
		
		// -----------------------------------------------------------------------------------------
		// CHOIX DE L ANIM D'EJECTION et de la FORCE d EJECTION
		// -----------------------------------------------------------------------------------------
		
		// Test de la validite de l angle d ejection en swing !!
		tv_temp = v_joy_sight
		tv_temp.z = 0.0																						// force de lancé de Kong
		tv_speed = LNK_GrabKong_SpeedVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])	// vitesse du TREX
		if (  MATH_VecNullEpsilon(tv_speed))
			tv_speed = OBJ_SightGet()
		else
			MATH_VecSetNormalize( tv_speed)
		// Formule de cumulation de force

		i_GrabKong_Lance_Anim = 0		// Par defaut on jete direct dans avoir a caler des anims
		ti_force_ejection_sweep = faux		// PAr defaut on ne force pas le Sweep
		v_joy_grab_lance_TREX = glob_joyvector_get * 100.0
//		if( LNK_GrabKong_ActionGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]) == Ci_GrabKong_Sweep
//		&& f_time_start_etat > 0.5 )
//		{
//			// Sweep depuis 0.5s
// 			v_joy_sight = MATH_VecInCone( v_joy_sight, tv_speed, Cf_1Degre * Cf_cercle_sweep_cone_sortie,0)
//		}
//		else
//		{
			// DEGAGEMENT EN MODE ARRET(  NON SWEEP)
			// De Face : anim en fonction du Joy
			// Anim

			i_GrabKong_Throw = faux
			v_GrabKong_init_grab = OBJ_PosGet()		// Positiond ou debute le blend de position
			i_IK_end = vrai
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], Ci_GrabKong_Lance_SePositionne)
			LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], v_joy_sight)	// Memorisation
			tf_dot = MATH_VecDotProduct( v_joy_sight,  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet())
			tf_dot2 = MATH_VecDotProduct( v_joy_sight,  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet())

			// TYPE DE LANCE EN FONCTION DE L ANGLE
// 			if ( tf_dot2 <  -Cf_Cos45 )
//			{
//				// Lancer le TREX en Arriere
//				i_GrabKong_Lance_Anim = Ci_Kanim_GK_Jete_dvt
//				ACT_ActionSet( Ci_Kanim_GK_SePlaceDvt)
//			}
//			else
			// ON LANCE TOUJOURS DE LA MEME FACON !!!
			ti_force_ejection_sweep = vrai		// Forcer le sweep sauf si on projete
//			if ( MATH_VecDotProduct(  LNK_GrabKong_AncrageVectorGet(  amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]), @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet()) < Cf_Cos5)
//			MODE SPECIAL SPEC 2 : PROJECTION
			if ( i_GrabKong_special)
			{
				// Jeter sur le coté
				i_GrabKong_special = faux					// forcer a jeter car ce flag servait au positionnement
				tv_sens =  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() - OBJ_PosGet() 
				MATH_VecSetHorzNormalize( tv_sens)
				tf_dot3 = MATH_VecDotProduct( tv_sens, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet())
				if ( tf_dot3 < 0)
				{
					// A Gauche
					// Lancer le TREX a Droite
					ti_force_ejection_sweep = faux
					i_GrabKong_Lance_Anim = Ci_Kanim_GK_JeteG
					ACT_ActionSet( Ci_Kanim_GK_SePlaceG)
				}
				else
				{
					// A Droite					
					// Lancer le TREX a Gauche
					ti_force_ejection_sweep = faux
					i_GrabKong_Lance_Anim = Ci_Kanim_GK_JeteD
					ACT_ActionSet( Ci_Kanim_GK_SePlaceD)
				}
			}
//		}

		
		tv_speed = v_joy_sight * Cf_Force_Jete


		v_GrabKong_axe = MATH_VecNormalize( tv_speed)
		f_GrabKong_rot_sign = MATH_FloatSign(MATH_VecDotProduct( v_GrabKong_axe, OBJ_HorizonGet()))

//		v_GrabKong_axe = tv_speed											// Axe de départ du mode rotation


		Sweep_pre_calculs
		if ( MATH_VecDotProduct( tv_temp, v_GrabKong_axe ) > tf_dot 
		&& MATH_VecDotProduct( v_GrabKong_axe, tv_temp2 ) > tf_dot 
		&& !i_GrabKong_Lance_Anim)
		{
			// KONG LANCE LE TREX VERS LUI MEME : SWEEP POUR DEGAGER KE TREX SUR LE COTE
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Sweep)
			v_GrabKong_speed_derape = Cv_NullVector						// vitesse de derapage de Kong
			v_GrabKong_axe = MATH_VecNormalize( tv_speed)			// Axe de départ du mode rotation
			v_GrabKong_speed_grab = v_GrabKong_axe * 40.0		 		// Determine la vitesse de rotation du sweep
			tv_temp = MATH_VecCrossProduct( OBJ_SightGet(), v_GrabKong_axe)
			f_GrabKong_wheel = tv_temp.z
			f_time_start_etat = 0.0
			i_GrabKong_sweep_degagement = vrai
			i_GrabKong_Throw = faux
			return
		}
		else
		{
			DBG_RenderCircle( OBJ_PosGet(), 2.5, Cv_VerticalVector, color_rouge)
			DBG_RenderVector( @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet(), tv_speed, color_vert)
			v_frappe_speed = Cv_NullVector
		}


		// DEGAGEMENT EN SWEEP

//		if ( ( LNK_GrabKong_ActionGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]) == Ci_GrabKong_Sweep
//		&& f_time_start_etat > 0.5 ) || ti_force_ejection_sweep )
		if ( ti_force_ejection_sweep )
		{
			// choix de l anim de l ancé du TREX
				tf_dot = MATH_VecDotProduct(  LNK_GrabKong_AncrageVectorGet(  amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]), @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet())
				if ( tf_dot > Cf_Cos5)
				{
					// Face
					if ( MATH_VecDotProduct( v_joy_sight, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet()) > 0 )
					{
						ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
						v_frappe_sight= -OBJ_HorizonGet()
					}
					else
					{
						ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
						v_frappe_sight= OBJ_HorizonGet()
					}
				}
				else if ( tf_dot < -Cf_Cos5)
				{
					// queue
					if ( MATH_VecDotProduct( v_joy_sight, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet()) < 0 )
					{
						ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
						v_frappe_sight= -OBJ_HorizonGet()
					}
					else
					{
						ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
						v_frappe_sight= OBJ_HorizonGet()
					}
				}
				else
				{
					// cote
					if ( MATH_VecDotProduct( v_joy_sight, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet()
					* MATH_VecDotProduct( @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet(), OBJ_HorizonGet())) < 0 )
					{
						ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
						v_frappe_sight= -OBJ_HorizonGet()
					}
					else
					{
						ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
						v_frappe_sight= OBJ_HorizonGet()
					}
				}

//			if ( MATH_VecDotProduct( v_joy_sight, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet()) > 0 )
//			{
//				ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
//				v_frappe_sight= -OBJ_HorizonGet()
//			}
//			else
//			{
//				ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
//				v_frappe_sight= OBJ_HorizonGet()
//			}		

		}
		
		if ( !i_GrabKong_Lance_Anim)
		{
			// Force additionelle de lancé
			if ( MATH_VecNullEpsilon( v_frappe_sight))
				tv_speed = cvector( 0, 0, 666)
			LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], tv_speed)
			LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
			LNK_GrabKong_ActionSet(amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], Ci_GrabKong_Lance)
			Fin_IK
			f_coef_pied_d_appui = i_GrabKong_MainActionGrab						// Coef pied d'appui pour rotation pied
		}
		else
			LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  i_GrabKong_Lance_Anim)
	}	
}

AI_Execute("k_exec_detect_paf")
if ( o_paf_actor)
{
	PAF_Test_ChangeEtatValid(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}

// COMPORTEMENT =================================================================	

// KONG ATTRAPPE LE RAPTOR SUR SON DOS
if( i_flag_ride_grab )
{
	if( ( i_Grab_Torse_Main == -1 ) && ACT_ActionFinished() )
	{
		// Pour IK bras
		if( ao_CL_GRABKONG[0] )
			i_Grab_Torse_Main = 0
		else if( ao_CL_GRABKONG[1] )
			i_Grab_Torse_Main = 1
	}
}

// WP "POSE ANN"
if( i_flag_pose_ANN_en_cours )
{
	if( ! MSG_GlobalIsValid(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT]) )
	{
		i_flag_pose_ANN_en_cours = faux
	}
	else
	{
//		if( i_Grab_Torse_ANN )
//		{
//			// KONG porte ANN dans sa main
////			if( (ACT_ActionGet() != Ci_Kanim_GO_PoseMainSol_droite) && (ACT_ActionGet() != Ci_Kanim_GO_PoseMainSol_gauche) )
////			{
////				if( ! i_Grab_Torse_Main )
////					ACT_ActionSet(Ci_Kanim_GO_PoseMainSol_droite)
////				else
////					ACT_ActionSet(Ci_Kanim_GO_PoseMainSol_gauche)
////			}
//			
//			switch (ACT_ActionGet())
//			{
//				case Ci_Kanim_GO_PoseMainGMainD :
//					if( ACT_ActionFinished())
//					{
//						to_actor = msg_pose_ANN.msg_sender
//						if ( @to_actor OBJ_CapaGet() & OBJ_Capa_0)
//							ACT_ActionSet(Ci_Kanim_GO_PoseHaut)
//						else
//							ACT_ActionSet(Ci_Kanim_GO_PoseSol)
//					}
//					break
//				default:
//					to_actor = msg_pose_ANN.msg_sender
//					if( i_Grab_Torse_Main )
//						ACT_ActionSet(Ci_Kanim_GO_PoseMainGMainD)				
//					else if ( @to_actor OBJ_CapaGet() & OBJ_Capa_0)
//						ACT_ActionSet(Ci_Kanim_GO_PoseHaut)
//					else
//						ACT_ActionSet(Ci_Kanim_GO_PoseSol)
//			}	
//			
//		}
//		else
//		{
			// KONG porte ANN sur son épaule : il la prend pour la poser

			switch ( ACT_ActionGet())
			{
				case Ci_Kanim_GO_PoseMainGMainD :
					if( ACT_ActionFinished())
					{
						f_time_start_etat = 0.0
						LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_PoseSol)
						LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT],  ANI_CanalObjectGet(Anim_Canal_MainDroite) )

						to_actor = msg_pose_ANN.msg_sender
						if ( to_actor && @to_actor OBJ_CapaGet() & OBJ_Capa_0)
							ACT_ActionSet(Ci_Kanim_GO_PoseHaut)
						else
							ACT_ActionSet(Ci_Kanim_GO_PoseSol)
					}
					break
				case Ci_Kanim_GO_PoseDosMainD :
					if( f_time_start_etat >= 0.1 && LNK_KKGrabObject_BoneGet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT]) != ANI_CanalObjectGet(Anim_Canal_MainDroite))
					{
						// changement d'os de snap
						LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_PoseSol)
						LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT],  ANI_CanalObjectGet(Anim_Canal_MainDroite) )
					}			
					if ( ACT_ActionFinished())
					{
						f_time_start_etat = 0.0
						to_actor = msg_pose_ANN.msg_sender
 						if ( to_actor && @to_actor OBJ_CapaGet() & OBJ_Capa_0)
							ACT_ActionSet(Ci_Kanim_GO_PoseHaut)
						else
							ACT_ActionSet(Ci_Kanim_GO_PoseSol)
					}
					break
				case Ci_Kanim_GO_PoseSol :
					// FIN de L IK
					i_Grab_Torse_ANN = faux
					i_Grab_Torse_Actor = faux
					i_Grab_Torse_Main = -1

					if ( f_time_start_etat < 0.6 )
						break
				case Ci_Kanim_GO_PoseHaut :
					// FIN de L IK
					i_Grab_Torse_ANN = faux
					i_Grab_Torse_Actor = faux
					i_Grab_Torse_Main = -1

					if( f_time_start_etat >= 0.3 ) 
					{
						@ao_CL[Ci_LNK_KKGRAB_OBJECT] MSG_Send(msg_pose_ANN)		// envoi du message à ANN
						
						LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Depose)
						if( ACT_ActionFinished() )
							i_flag_pose_ANN_en_cours = faux
					}
					break
				default:
					f_time_start_etat = 0.0
					if( i_Grab_Torse_ANN )
					{
						to_actor = msg_pose_ANN.msg_sender
						if( i_Grab_Torse_Main )
							ACT_ActionSet(Ci_Kanim_GO_PoseMainGMainD)				
						else
						{

							if ( to_actor && @to_actor OBJ_CapaGet() & OBJ_Capa_0)
								ACT_ActionSet(Ci_Kanim_GO_PoseHaut)
							else
								ACT_ActionSet(Ci_Kanim_GO_PoseSol)
						}
					}
					else
						ACT_ActionSet(Ci_Kanim_GO_PoseDosMainD)	
			}
//			if ( f_time_start_etat)
//			{
				// Positionnement de KONG
				to_actor = msg_pose_ANN.msg_sender
				if ( to_actor)
				{
					tv_pos = @to_actor OBJ_PosGet() - (MATH_VecNormalize(@to_actor OBJ_PosGet() - v_GrabKong_init_grab) * 2.5)
					tv_pos.z = OBJ_PosGet().z
					OBJ_PosSet( MATH_VecBlend( v_GrabKong_init_grab, tv_pos, MATH_FloatMin( 1.0, f_GrabKong_blend_pos / 0.5) ) )
				}
				
				// Orientation
				push(v_frappe_sight)					// Axis Dest
				push(8.0)								// Speed
				push(f_coef_pied_d_appui)			// Coef entre les deux pieds
				AI_Execute("k_exec_2Feet_SightSet")	
//			}
			
//			if(ACT_ActionGet() != Ci_Kanim_GO_PoseEpauleSol_droite)
//			{
//				ACT_ActionSet(Ci_Kanim_GO_PoseEpauleSol_droite)
//				f_time_start_etat = 0.0
//			}
//			else if( (f_time_start_etat >= 0.5) && ( LNK_KKGrabObject_BoneGet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT]) != ANI_CanalObjectGet(Anim_Canal_MainDroite) ) )
//			{
//				// changement d'os de snap
//				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_PoseSol)
//				LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT],  ANI_CanalObjectGet(Anim_Canal_MainDroite) )
//			}
//		}
		
//		if( f_time_start_etat >= 2.3 || ACT_ActionFinished() ) 
//		{
//			@ao_CL[Ci_LNK_KKGRAB_OBJECT] MSG_Send(msg_pose_ANN)		// envoi du message à ANN
//			
//			LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Depose)
//			if( ACT_ActionFinished() )
//				i_flag_pose_ANN_en_cours = faux
//			
//			if( i_Grab_Torse_ANN )
//			{
//				i_Grab_Torse_ANN = faux
//				i_Grab_Torse_Actor = faux
//				i_Grab_Torse_Main = -1
//			}
//		}
	}
	return
}

// GESTION DU GRAB TREX	
if( i_GrabKong_MainBloquee != -1)
{
	to_tete = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] ANI_CanalObjectGet( Anim_Canal_Tete)
	ti_action = LNK_GrabKong_ActionGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])
	switch( ti_action)
	{
		case Ci_GrabKong_ChuteVide :
			i_exit_mode = vrai
			ACT_ActionSet(Ci_Kanim_Attente + 1) // Version sans cycl
			break
		case Ci_GrabKong_Debat :
			// LE TREX SE DEBAT: SWEEP interdit et delai avant ECHEC
			Frein( Cf_debat_frein)				// Freinage fonction du DT		
			if( !i_GrabKong_special)
				ACT_ActionSet( Ci_Kanim_GrabTT_att)
			// DETECTION DE L ECHEC
//			if ( f_time_start_etat  >	Cf_cercle_tps_debat)
//			{
//				// La cible est stoppé dans son mouvement et le joueur n a pas agit : ECHEC
//				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Repousse)
//				v_GrabKong_speed_derape = v_GrabKong_speed_grab 
//				v_GrabKong_axe = OBJ_SightGet()		// Axe de départ du mode rotation
//				f_GrabKong_wheel = 0.0						// Le mode volant inutile dans ce cas la
//			}
			break
		case Ci_GrabKong_AttrapePousse :
			// KONG CHARGE
		
			// La vitesse est imposée par Kong qui Freine le mouvement
			if ( ACT_ActionFinished())
			{
				switch( ACT_ActionGet())
				{
					case Ci_Kanim_GK_SePlaceD :
					case Ci_Kanim_GK_AttJeteD :
						ACT_ActionSet( Ci_Kanim_GK_AttJeteD)
						break
					case Ci_Kanim_GK_SePlaceG :
					case Ci_Kanim_GK_AttJeteG :
						ACT_ActionSet( Ci_Kanim_GK_AttJeteG)		
						break
					default:
						ACT_ActionSet( Ci_Kanim_GrabTT_att)
				}
				LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
			}

			tv_temp =  OBJ_PosGet() - @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet()
			MATH_VecSetHorzNormalize( tv_temp)
			// ET ATTRAPE LE TREX DE FACE
			i_GrabKong_Qui_Charge = Ci_ChargeDeKongDeFace		// Kong charge
			i_GrabKong_Qui_Charge = Ci_ChargeDuTrexDeFace
			// DETECTION DE LA FIN DE L ATTRAPE + FREINAGE	

			tf_norm = MATH_FloatMax( MATH_VecNorm( v_GrabKong_speed_grab), Cf_Force_Sweep_Kong)

			if( f_grab_blend_pos == 1.0)
			{ 
//				if ( !i_GrabKong_special)
//				{
					// L'axe du Joy est dans la partie sweep
					// Partir en SWEEP
	 				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Sweep)
					v_GrabKong_speed_derape = v_GrabKong_speed_grab 
					v_GrabKong_speed_grab = OBJ_SightGet() * tf_norm			// La Vitesse de sweep en depend
					v_GrabKong_axe = OBJ_HorizonGet()		// Axe de départ du mode rotation
					f_GrabKong_rot_sign = MATH_FloatSign(MATH_VecDotProduct( v_GrabKong_axe, v_joy_sight))
					v_GrabKong_axe *= f_GrabKong_rot_sign
					tv_temp = MATH_VecCrossProduct( OBJ_SightGet(), v_GrabKong_axe)
					f_GrabKong_wheel = tv_temp.z
					i_GrabKong_Qui_Charge = 0
					f_time_start_etat = 0.0
//				}
//				else
//	 			{
//		 			// Mode spécial spec 1 : IMMOBILE
//		 			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Debat)				
//	 				ACT_ActionSet(Ci_Kanim_GrabTT_att)
//	 			}
			}

			f_grab_blend_pos = MATH_FloatMin( f_grab_blend_pos + ( 3.0 * TIME_GetDt()), 1.0)		// Blend de position et orientation idéale.
			break
		case Ci_GrabKong_Attrape :
			// LE TREX CHARGE
			// PHASE DE POSITIONEMENT DE KONG SUR L INIT DE L ACCROCH

			// La vitesse est imposée par Kong qui Freine le mouvement
			if ( ACT_ActionFinished())
			{
				switch( ACT_ActionGet())
				{
					case Ci_Kanim_GK_SePlaceD :
					case Ci_Kanim_GK_AttJeteD :
						ACT_ActionSet( Ci_Kanim_GK_AttJeteD)
						break
					case Ci_Kanim_GK_SePlaceG :
					case Ci_Kanim_GK_AttJeteG :
						ACT_ActionSet( Ci_Kanim_GK_AttJeteG)		
						break
					default:
						ACT_ActionSet( Ci_Kanim_GrabTT_att)
				}
				LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
			}				
			tv_temp =  OBJ_PosGet() - @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet()
			MATH_VecSetHorzNormalize( tv_temp)

			// KONG ATTRAPE LA CHARGE DU TREX DE FACE
			i_GrabKong_Qui_Charge = Ci_ChargeDuTrexDeFace	// TREX charge prise de face
		
			// DETECTION DU PASSAGE EN SWEEP
			tf_norm = MATH_FloatMax( MATH_VecNorm( v_GrabKong_speed_grab), Cf_Force_Sweep_Kong)

			if( f_grab_blend_pos == 1.0)
			{ 
//				if ( !i_GrabKong_special)
//				{
					// L'axe du Joy est dans la partie sweep
					// Partir en SWEEP
	 				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Sweep)
					v_GrabKong_speed_derape = v_GrabKong_speed_grab 
					v_GrabKong_speed_grab = OBJ_SightGet() * tf_norm			// La Vitesse de sweep en depend
					v_GrabKong_axe = OBJ_HorizonGet()		// Axe de départ du mode rotation
					f_GrabKong_rot_sign = MATH_FloatSign(MATH_VecDotProduct( v_GrabKong_axe, v_joy_sight))
					v_GrabKong_axe *= f_GrabKong_rot_sign
					tv_temp = MATH_VecCrossProduct( OBJ_SightGet(), v_GrabKong_axe)
					f_GrabKong_wheel = tv_temp.z
					i_GrabKong_Qui_Charge = 0
					f_time_start_etat = 0.0
//				}
//				else
//	 			{
//		 			// Mode spécial spec 1 : IMMOBILE
//		 			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Debat)				
//	 				ACT_ActionSet(Ci_Kanim_GrabTT_att)
//	 			}
			}
			f_grab_blend_pos = MATH_FloatMin( f_grab_blend_pos + ( 3.0 * TIME_GetDt()), 1.0)		// Blend de position et orientation idéale.
			break

		case Ci_GrabKong_Sweep :
			//PHASE DE MOUVEMENT DU SYSTEME BINAIRE KONG FAIT SWEEP LE TREX
			i_GrabKong_Qui_Charge = 0//Ci_ChargeDuTrexSWEEP		// MODE SWEEP
//			ACT_ActionSet(Ci_Kanim_GrabTT_att)
			ti_Interuption_Grab = faux


			// Speedvector modifié par la lecture du joy : le recupérer avant
			tv_speed_grab_target = LNK_GrabKong_SpeedVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])

			// LECTURE DU JOY EN MODE VOLANT !!
			if ( !i_GrabKong_sweep_degagement)
			{
				// Selon camera fight ou camera GENCAM
				tv_temp = MATH_VecCrossProduct( OBJ_SightGet(), v_joy_sight)
				if ( MATH_VecDotProduct( OBJ_SightGet(), v_joy_sight) < 0.0)
					if ( MATH_VecNullEpsilon( tv_temp))
						tv_temp = Cv_VerticalVector
					else
						MATH_VecSetNormalize( tv_temp)
// Cam dos
//				else
//					tv_temp = MATH_VecCrossProduct( @o_Kamera OBJ_SightGet(), v_joy_sight)
				
			
				f_GrabKong_wheel = MATH_FloatMin( f_GrabKong_wheel + (TIME_GetDt() * 3.0), 1.0)
//				if ( f_GrabKong_wheel_change_speed > 1.0)
//				{
//					f_GrabKong_wheel_change_speed = 0.0
//					f_GrabKong_wheel_speed = 1.2
//					f_GrabKong_wheel = 0.0
//				}
//				else
//					f_GrabKong_wheel_change_speed += TIME_GetDt()

				if ( !glob_joynorm_get)
				{
					// Freinage fonction du DT
					f_GrabKong_wheel_speed *= Amorti_Coef_Dt(0.90)
					f_GrabKong_wheel = 0.0
					f_GrabKong_wheel_speed_invert = f_GrabKong_wheel_speed
					if ( !i_GrabKong_special)
						ACT_ActionSet(Ci_Kanim_GrabTT_att)
				}
				else if ( MATH_VecDotProduct( v_joy_sight_old, OBJ_HorizonGet())  *  MATH_VecDotProduct( v_joy_sight, OBJ_HorizonGet()) > 0)
				{
					// Acceleration fonction du DT
					f_GrabKong_wheel_speed = MATH_FloatBlend( f_GrabKong_wheel_speed_invert, tv_temp.z * 2.0, f_GrabKong_wheel)   // 2.4
					if ( !i_GrabKong_special)
					{
						if ( tv_temp.z > 0.0)
							ACT_ActionSet( Ci_Kanim_GrabTT_tireD)
						else
							ACT_ActionSet( Ci_Kanim_GrabTT_tireG)
					}
				}
				else 																	// Le volant tourne pas dans le bon sens
				{ 
					// Freinage fonction du DT
					f_GrabKong_wheel_speed_invert = f_GrabKong_wheel_speed
					f_GrabKong_wheel = 0.0
				}
			}
			else
			{
				tv_temp = MATH_VecCrossProduct( v_joy_sight_old, v_joy_sight)		// Sens du volant a cette trame
				if ( !glob_joynorm_get || MATH_FloatNullEpsilon(f_GrabKong_wheel))
				{
					Frein( 0.990)			// Freinage fonction du DT
				}
				else if ( tv_temp.z * f_GrabKong_wheel > 0)			// Le Volant tourne toujours dans le bon sens
				{
					Frein( 1.005)				// Acceleration fonction du DT
				}				
			}
			// LECTURE DU JOY EN MODE VOLANT !!
			

//			// TEST SUR LES COLLISIONS
//			if ( @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] COL_CollideType(COL_C_Wall)) //COL_BestAngleWallGaoGet( v_joy_sight, Cf_Cos60,&ti_col))
//			{
//				// Le REX est bloqué par un mur
//				// accepter que les rotation qui permettent de le sortir du mur
//				if ( f_GrabKong_wheel_speed * f_GrabKong_wheel_speed_col > 0)
//					f_GrabKong_wheel_speed = 0.0		// rotation dans le sens de la collision
//			}
//			else
//				f_GrabKong_wheel_speed_col = f_GrabKong_wheel_speed




			// CALCUL DE LA VITESSE DE ROTATION
				
			// Vitesse de rotation dépendante de la vitesse du TREX

			// Vecteur Main Kong
			tv_target = OBJ_SightGet() * LNK_GrabKong_ArmSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])
			tv_target.z = 0.0
			tf_norm_levier = MATH_VecNorm( tv_target)
			tv_target /= tf_norm_levier

			if ( MATH_VecNullEpsilon( tv_speed_grab_target))
				tv_temp = tv_target
			else
				tv_temp = MATH_VecNormalize(tv_speed_grab_target)
			
			tf_dot = MATH_VecDotProduct( tv_temp , tv_target)
			if ( tf_dot < 0.0 && !MATH_VecNullEpsilon(v_GrabKong_speed_derape))
			{
				// Le Trex fonce trop sur nous on s'en écarte tout en voulant le faire tourner
				tf_dot = (0.25 * tf_dot) + 1.0
				tf_dot = 1.0
				tv_temp2.x = tv_temp.y
				tv_temp2.y = -tv_temp.x
				tv_temp2.z = 0.0
				tf_norm = MATH_VecNorm( v_GrabKong_speed_derape)
				v_GrabKong_speed_derape -= 0.15 * tv_temp2 * tf_norm * MATH_VecDotProduct( tv_temp2 , tv_target)
				MATH_VecSetNorm( v_GrabKong_speed_derape, tf_norm)
			}
			else
				tf_dot = 1.0			
			tf_norm = MATH_VecNorm( v_GrabKong_speed_grab)
			f_GrabKong_blend_orient = tf_dot * 1.5 * MATH_ASin( tf_norm * TIME_GetDt() / (2 * tf_norm_levier))


			// ROTATION
			tv_last_pos = OBJ_PosGet() + (OBJ_SightGet() * LNK_GrabKong_ArmSizeGet(amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]))

			if  ( !i_GrabKong_sweep_degagement)
				tv_sight = MATH_VecRotate( OBJ_SightGet(), Cv_VerticalVector, f_GrabKong_wheel_speed * TIME_GetDt()) // f_GrabKong_rot_sign * f_GrabKong_blend_orient )
			else
				tv_sight = MATH_VecRotate( OBJ_SightGet(), Cv_VerticalVector, f_GrabKong_rot_sign * f_GrabKong_blend_orient )

			push(tv_sight)							// Axis Dest
			push(80.0)								// Speed   80
			if ( f_GrabKong_wheel_speed > 0.0)
				push(1.0)			// Coef entre les deux pieds
			else
				push(0.0)			// Coef entre les deux pieds
//			push(0.5)			// Coef entre les deux pieds
			AI_Execute("k_exec_2Feet_SightSet")	
//
			// TRANSLATION due a la fin de l amortie du la charge du Trex
			OBJ_PosSet( OBJ_PosGet() +( v_GrabKong_speed_derape * TIME_GetDt()))

			v_GrabKong_speed_derape *= Amorti_Coef_Dt(0.95) 	// Amortie en Fonction du DT
			
			DBG_RenderSphere( (OBJ_PosGet() + cvector( 0.0, 0.0, 3.0))
			+ ( OBJ_SightGet() * LNK_GrabKong_ArmSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])), 1.0, 0xD00000FF) 
			// Tester le decrochage quand on est dans le ¼ de cercle
			if ( i_GrabKong_sweep_degagement)
			{
				Sweep_pre_calculs	
				if ( MATH_VecDotProduct( tv_temp, v_GrabKong_axe ) < tf_dot 
				|| MATH_VecDotProduct( v_GrabKong_axe, tv_temp2 ) < tf_dot )
				{	
					//SWEEP DE DEGAGEMENT FINI : KONG PEUX LANCER LE TREX
					ti_Interuption_Grab = 3			// Lancer
				} 		
			}

			// DETECTION DE DECROCHAGE AUTO
			switch ( ti_Interuption_Grab)
			{
				case 1:
					// Trop Lent
					LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Repousse)
					break							// Gestion de décrochage
				case 2:
					// trop long
					LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Relache)
					ACT_ActionSet(46)		// Emporté par son elan
					v_frappe_sight = tv_speed_grab_target
 					i_exit_mode = vrai
					break
				case 3:
					// fin du degagement pour lancer
					LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Lance)
					LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], v_GrabKong_axe * Cf_Force_Jete)
					if( f_GrabKong_rot_sign < 0)
					{
						// Jeter de coté
						ACT_ActionSet( Ci_Kanim_Lache_D )	// Lacher
						v_frappe_sight= -OBJ_HorizonGet()
		
					}
					else
					{
						// Jeter de coté
						ACT_ActionSet( Ci_Kanim_Lache_G )	// Lacher
						v_frappe_sight= OBJ_HorizonGet()
					}
					SND_RequestPlay(16)
					LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
					Fin_IK

					f_coef_pied_d_appui = i_GrabKong_MainActionGrab						// Coef pied d'appui pour rotation pied
					v_frappe_speed = Cv_NullVector
					break
				case 0:
					break
			}
			break
		case Ci_GrabKong_Frappe :
			i_IK_end = vrai
//			AI_CBDel( o_GrabKong_Target, CallBack_After_Blend, "k_exec_Ik_GrabKong")							
//			if ( ACT_ActionFinished())
			v_frappe_sight = OBJ_SightGet()
			i_exit_mode = vrai
			break
		case Ci_GrabKong_Lance_SePositionne :
			// Phase positionnement avant le lance
			i_GrabKong_Qui_Charge = 0
			if ( ACT_ActionGet() != Ci_Kanim_GrabTT_att)
			{
				tf_frame = ANI_NbFrameGet(0)
				tf_blend = ANI_CurrentFrameGet(0) / tf_frame
				to_bone = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] ANI_CanalObjectGet( 210)
				OBJ_PosSet( MATH_VecBlend( v_GrabKong_init_grab, @to_bone OBJ_PosGet(), tf_blend))
				OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), @to_bone OBJ_SightGet(), tf_blend), Cv_VerticalVector)
			}
			if ( ACT_ActionFinished())
			{
				if ( i_GrabKong_special)
				{
					// Mpode special projection se placer comme il faut
					ACT_ActionSet(Ci_Kanim_GrabTT_att)
					f_grab_blend_pos = 1.0			// Placement terminé
				}
				else
				{
					v_frappe_sight = Cv_NullVector
					ACT_ActionSet( i_GrabKong_Lance_Anim)	
					LNK_GrabKong_ActionSet(amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], Ci_GrabKong_Lance)
//					Fin_IK
				}
			}
				break
			case Ci_GrabKong_Lance:
				i_GrabKong_Qui_Charge = 0
				if ( ANI_CurrentFrameGet(0) > 60)
				{
					i_GrabKong_Qui_Charge = 0
					Fin_IK				
				}
				break
			case Ci_GrabKong_Repousse:
//				i_GrabKong_Qui_Charge = 0
//				if ( ANI_CurrentFrameGet(0) > 60)
//				{
//					i_GrabKong_Qui_Charge = 0
//					Fin_IK				
//				}
				i_GrabKong_je_vais_etre_jete = vrai
				break
	}
	
	// ORIENTATION ET DEPLACEMENT EN PHASE ATTRAPE
	
	if ( i_GrabKong_special)
	{
		ti_action = ACT_ActionGet()
		if ( ti_action == Ci_Kanim_GK_SePlaceD || ti_action == Ci_Kanim_GK_SePlaceG)
		{
			tf_frame = ANI_NbFrameGet(0)
			tf_blend = ANI_CurrentFrameGet(0) / tf_frame
			to_bone = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] ANI_CanalObjectGet( 210)
			OBJ_PosSet( MATH_VecBlend( v_GrabKong_init_grab, @to_bone OBJ_PosGet(), tf_blend))
			OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), @to_bone OBJ_SightGet(), tf_blend), Cv_VerticalVector)
		}
//		if ( ACT_ActionFinished())
//		{
//			if ( i_GrabKong_special)
//			{
//				// Mpode special projection se placer comme il faut
//				ACT_ActionSet(Ci_Kanim_GrabTT_att)
//				f_grab_blend_pos = 1.0			// Placement terminé
//			}
//		}
	}
	else if ( i_GrabKong_Qui_Charge & Ci_ChargeDuTrex)
	{
		// REX CHARGE
		tv_pos_ancrage = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet()
		tv_pos_ancrage += LNK_GrabKong_AncrageVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) *  LNK_GrabKong_NeckSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])
		tv_pos = tv_pos_ancrage
		tv_sens = v_Grab_Kong_Offset_init
		DBG_RenderVector( tv_pos_ancrage, v_Grab_Kong_Offset_init, color_rouge)
		tf_norm = MATH_FloatBlend( MATH_VecNorm(v_Grab_Kong_Offset_init) , LNK_GrabKong_ArmSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]), f_grab_blend_pos)
		MATH_VecSetNorm( tv_sens , tf_norm)
//		tv_sens = MATH_VecBlend( v_Grab_Kong_Offset_init, MATH_VecInCone( tv_sens, @ao_CL_GRABKONG[i_GrabKong_MainBloquee]  OBJ_SightGet(), Cf_1Degre *135.0, 0), f_grab_blend_pos)
		tv_sens = MATH_VecBlend( v_Grab_Kong_Offset_init, MATH_VecInCone( tv_sens, LNK_GrabKong_AncrageVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]), Cf_1Degre *135.0, 0), f_grab_blend_pos)
		DBG_RenderVector( tv_pos_ancrage, tv_sens, color_rouge)
		tv_pos += tv_sens
		tv_pos.z = OBJ_PosGet().z
		OBJ_PosSet( tv_pos)
	
		// Orientation
		tv_temp = tv_pos_ancrage - OBJ_PosGet()
		MATH_VecSetHorzNormalize( tv_temp )
		OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(),  tv_temp, f_grab_blend_pos), Cv_VerticalVector)	
	}
	else if ( i_GrabKong_Qui_Charge & Ci_ChargeDeKong )
	{
		// KONG CHARGE
		// Positionement de Kong en conservant sa vitesse
		tv_pos_ancrage = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet()
		tv_pos_ancrage += LNK_GrabKong_AncrageVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) * LNK_GrabKong_NeckSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])
		tv_sens = tv_pos_ancrage - OBJ_PosGet()	// Sens de deplacement
		tv_sens.z = 0.0
		tf_norm = MATH_VecNorm(tv_sens)			// Distance actuelle entre le point d ancrage et Kong

		DBG_RenderVector( OBJ_PosGet(), tv_sens, color_vert)
		if ( MATH_VecDotProduct( tv_sens, -@ao_CL_GRABKONG[i_GrabKong_MainBloquee]  OBJ_SightGet()) < -Cf_Cos45 * tf_norm)
		{
			if( MATH_VecNullEpsilon( v_GrabKong_attrape_orient))
				v_GrabKong_attrape_orient = MATH_VecInCone( tv_sens, -@ao_CL_GRABKONG[i_GrabKong_MainBloquee]  OBJ_SightGet(), Cf_1Degre *135.0, 0)
			else
				MATH_VecSetNorm( v_GrabKong_attrape_orient, MATH_VecNorm(tv_sens))	
			tv_sens = v_GrabKong_attrape_orient
					
			DBG_RenderVector( OBJ_PosGet(), tv_sens * 5.0, color_bleu)
			MATH_VecSetNorm( tv_sens, LNK_GrabKong_ArmSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]))
			tv_sens = tv_pos_ancrage - tv_sens - OBJ_PosGet()	
			tv_sens.z = 0.0
		}
		tf_norm = MATH_VecNorm( v_GrabKong_speed_grab)
		MATH_VecSetNorm(v_GrabKong_speed_grab , MATH_FloatBlend( tf_norm, MATH_FloatMax( f_GrabKong_speed_grab_min, tf_norm), 10.0 * TIME_GetDt()))
		tf_dist = (MATH_VecNorm(v_GrabKong_speed_grab) *TIME_GetDt()) // Distance parcouru normalement a cette vitesse
		MATH_VecSetNorm( tv_sens , tf_dist)	// Deplacement a effectuer
		tv_pos = OBJ_PosGet()
		tv_pos += tv_sens
		tv_pos.z = OBJ_PosGet().z
		OBJ_PosSet( tv_pos)
		
		// positionement du TREX
		tv_sens = tv_pos_ancrage - OBJ_PosGet()	// Sens de deplacement
		tv_sens.z = 0.0
		tf_norm = MATH_VecNorm(tv_sens)			// Distance actuelle entre le point d ancrage et Kong
		if ( tf_norm < LNK_GrabKong_ArmSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]))
		{
			// Pousser le TREX car kong s'est trop raproché
			MATH_VecSetNorm( tv_sens , LNK_GrabKong_ArmSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]) - tf_norm)
			@ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosSet( @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() + tv_sens)
			Frein( Cf_cercle_arret_frein)				// Freinage fonction du DT
			f_GrabKong_speed_grab_min *= Amorti_Coef_Dt( Cf_cercle_arret_frein)
		}
		
		// Orientation
		tv_temp = tv_pos_ancrage - OBJ_PosGet()
		MATH_VecSetHorzNormalize( tv_temp )
		OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(),  tv_temp, f_grab_blend_pos), Cv_VerticalVector)		
	}
}
// DEPLACEMENT ET ORIENTATION DANS LE CAS D UN GRAB SIMPLE
else if ( i_GrabKong_orient)
{
	push(v_frappe_sight)					// Axis Dest
	push(8.0)								// Speed
	push(f_coef_pied_d_appui)			// Coef entre les deux pieds
	AI_Execute("k_exec_2Feet_SightSet")	
}
else if( ! ti_direct_exit )
{
	// FRED : Modif concervation du Z de la gravité
	vector	tv_speedz
	push(v_frappe_sight)					// Axis Dest
	push(3.0)								// Speed
	push(f_coef_pied_d_appui)			// Coef entre les deux pieds
	AI_Execute("k_exec_2Feet_SightSet")	
	tv_speedz = OBJ_SightGet() * MATH_VecNorm( v_frappe_speed)
	tv_speedz.z = DYN_SpeedGetVector().z
	if (DYN_SpeedGet() < MATH_VecNorm(v_frappe_speed))
		DYN_SpeedSetVector(tv_speedz)
	v_frappe_speed *= Amorti_Coef_Dt(0.95)
}



// -------------------------------------------------------------------------------
// PARTIE COMMUNE GRAB SIMPLE ET GRAB TREX
// ANIM ET DETECTION GRAB ET LANCER
// -------------------------------------------------------------------------------
if ( !i_GrabKong_mode)
{
	// JETER ET AIDE AU TIR
	if ( ( i_GrabKong_attrape_jete == Ci_Jete && ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
	&& f_time_start_etat > 0.25)
	{
		// JETER	
		tv_sens_lance = v_frappe_sight			// sens du lancer mémorisé à l'init du mode
		i_Grab_Torse_Main = -1					// libère la main
		
		// AIDE AU TIR
		ti_rank = -1
		tmid_NMI = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank)	
		while ( MSG_GlobalIsValid( tmid_NMI))
		{
			to_actor = MSG_GlobalGetSender( tmid_NMI)
			
			if( to_actor == ao_CL_GRABKONG[i_GrabKong_MainActionGrab] )
			{
				tmid_NMI = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank)	
				continue
			}
			
			tv_sens = @to_actor OBJ_PosGet() - OBJ_PosGet()
			tv_sens.z = 0.0
			tf_norm = MATH_VecNorm(tv_sens )
			if( ( tf_norm >= Cf_dist_aide_tir_min ) && ( tf_norm <= Cf_dist_aide_tir_max ) )
			{
				// Ennemi pas trop proche et pas trop loin
				tv_sens /= tf_norm
				if ( MATH_VecDotProduct( tv_sens_lance, tv_sens) > Cf_Cos30)
				{
					// Ennemi dans l angle
					tv_sens_lance = tv_sens
					LNK_GrabKong_LanceObjectSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], to_actor)	// Cible precise
					to_tete = @to_actor ANI_CanalObjectGet(Anim_Canal_Tete)
					LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], @to_tete OBJ_PosGet() - @to_actor OBJ_PosGet() ) // Offset
					break
				}
			}
			tmid_NMI = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank)	
		}

		LNK_GrabKong_ActionSet(amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Lance)
		LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], tv_sens_lance)
		ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = nobody
		i_GrabKong_Souche = faux 
	}
	

	// INDICATEUR DEBUT GRAB RAPTOR POUR AFTERBLEND RAPTOR
	if( i_flag_grab_raptor_en_cours )
	{
		if( LNK_GrabKong_BoneGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) == nobody )
		{
			if( f_time_start_etat > 0.1 )
			{
				// Indication du bone pour positionner le raptor
				if ( i_GrabKong_MainActionGrab)
					to_bone = ANI_CanalObjectGet( Anim_Canal_MainGauche)
				else
					to_bone = ANI_CanalObjectGet( Anim_Canal_MainDroite)
				LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], to_bone)
				i_flag_grab_raptor_en_cours = faux
			}
		}
	}
	

	// TENTER DE CHOPPER LE RAPTOR
	if ( i_GrabKong_raptor_test )
	{
		i_GrabKong_Type = Ci_GrabKong_Type_Petit 
		v_grab_object_pos= OBJ_PosGet() + ( v_joy_sight * 4.0)				// Position du point de grab demandé
		ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)
		if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
		{
			// J'attrape un object léger : raptor
			i_GrabKong_raptor_test = faux 	// Grab reussi, ne plus tester
			i_flag_grab_raptor_en_cours = vrai	// Le test de cette variable est avant pour permettre 1 trame avec le BoneSet a nobody -> init a 0 de la variable de blend de pos sur le raptor
			// l'IK du bras activée
			i_Grab_Torse_Main = i_GrabKong_MainActionGrab
			LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], nobody)
			// Orientation
			v_frappe_sight = @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] OBJ_PosGet() - OBJ_PosGet()
			if( MATH_VecNullEpsilon( v_frappe_sight))
				v_frappe_sight = OBJ_SightGet()
			else
				MATH_VecNormalize( v_frappe_sight)

		}
	}
	
	if ( !ti_direct_exit)
		 i_Grab_Torse_Actor = faux		// Pas d IK sur la main pendant l anim les anims de GRab

	// POSITIONNEMENT DE ANN : LA FAIRE PASSER ANN DE LA MAIN A L'EPAULE
	if( i_flag_positionne_ANN && MSG_GlobalIsValid(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT]) )
	{
		if ( i_Grab_Torse_ANN)
			i_Grab_Torse_Main = i_GrabKong_MainActionGrab			// l'IK du bras activée
		
		if ( f_time_start_etat > 1.95 && !i_Grab_Torse_ANN)
		{
			// KONG porte ANN sur son épaule
			LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT],  ANI_CanalObjectGet(Anim_Canal_Snap_Ann) )
			LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Porte_Epaule)
			i_flag_positionne_ANN = faux	
		}
		else if ( f_time_start_etat > 1.15 && i_Grab_Torse_ANN)
		{
			// KONG porte ANN dans sa main
			LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Porte_Main)
			ti_direct_exit = vrai
			i_flag_positionne_ANN = faux	
		}
		else if (  f_time_start_etat > 0.55)
		{
			// KONG attrappe ANN
			LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Attrappe_Dans_Main)
			if( ! i_GrabKong_MainActionGrab )
				LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], ANI_CanalObjectGet(Anim_Canal_MainDroite) )
			else
				LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], ANI_CanalObjectGet(Anim_Canal_MainGauche) )
		}
		else if ( f_GrabKong_blend_pos)
		{
			// Positionnement de KONG
			tv_pos = @ao_CL[Ci_LNK_KKGRAB_OBJECT] OBJ_PosGet() - (MATH_VecNormalize(@ao_CL[Ci_LNK_KKGRAB_OBJECT] OBJ_PosGet() - v_GrabKong_init_grab) * 2.0)
			tv_pos.z = OBJ_PosGet().z
			OBJ_PosSet( MATH_VecBlend( v_GrabKong_init_grab, tv_pos, f_GrabKong_blend_pos / 0.55 ) )
		}
	}
	
	// POSITIONNEMENT DE LA SOUCHE DANS LA MAIN
	if( i_flag_positionne_souche && f_time_start_etat > 0.5)
	{
		i_flag_positionne_souche = faux
		if( i_GrabKong_MainActionGrab )
			to_bone = ANI_CanalObjectGet( Anim_Canal_MainGauche)		// souche main gauche
		else
			to_bone = ANI_CanalObjectGet( Anim_Canal_MainDroite)			// souche main droite
		LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], to_bone)
	}
	
	// FAIRE PASSER LA SOUCHE DE LA MAIN_G AU SNAP MAIN_D
	if( i_GrabKong_Souche && ACT_ActionFinished() )
	{
		// Kong vient de grabber une souche dans la main gauche et l'anim de grab est terminée -> la souche passe dans la main droite
		if( LNK_GrabKong_BoneGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) != ANI_CanalObjectGet(Anim_Canal_Snap_MainD) )
		{
			to_bone = ANI_CanalObjectGet( Anim_Canal_Snap_MainD)
			LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], to_bone)
		}
	}
	
	// DETECTION DE LA FIN DU MOUVEMENT
	if ((i_GrabKong_MainBloquee != -1 && i_GrabKong_MainBloquee == i_GrabKong_MainActionGrab && i_GrabKong_attrape_jete != Ci_Repousse)
	|| ACT_ActionFinished() || ti_direct_exit 
	|| ( i_Grab_Torse_ANN	&& ACT_ActionItemGet() == 1))		// ANN reste dans la main
	{
		// Anim terminée repasser en mode de déplacement
		if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab] && LNK_GrabKong_TypeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) == Ci_GrabKong_Type_Souche)
		{
			// SOUCHE GRAB PASSER EN MODE DEPLACEMENT AVEC SOUCHE
			macro_change_etat( "k_ETAT_depl_souche")		// Grab Fini
		}
		macro_change_etat( "k_ETAT_deplacement")		// Grab Fini
	}
}