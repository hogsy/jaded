#include"k_define.var"


int			ti_flag_compression
int			ti_freq

float		tf_coef
float		tf_norm

object	to_collide_object

vector	tv_temp
vector	tv_sens
vector	tv_sens2
vector	tv_speed
vector	tv_normal_mur
vector	tv_new_sight
vector	tv_hand_pos
vector	tv_HS_sight 
vector	tv_HS_bank

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	v_zdm_pos = Cv_Kong_zdm_pos
	COL_ColSetActivationSet(C_bit_zdm_pied, none)	
	DYN_FrictionVectorSet(Cv_NullVector)
	DYN_GravitySet(Cv_Kong_Gravity)

	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_commun_climb_impulsion) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_commun_climb_impulsion

	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_saute
	// CAMERA -----------------------------------------------------------------

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	f_time_start_etat = 0.0

	o_climb_0D_wp = nobody
	o_climb_1D_current_wp = nobody
	o_climb_1D_next_wp = nobody

	f_climb_impulsion_time = 0.0


	// HOT SPOT
//	if ( MATH_VecNullEpsilon( v_jump_force_sens))
//		v_jump_force_sens = v_joy_sight_normalized		// Permet de forcer le sens du saut et forcer le sens de detection de hot spot
	tv_normal_mur = v_climb_normale
	AI_Execute( "k_exec_check_hotspot")
	v_climb_normale = pop

	if ( !o_jump_hotspot)
	{


		if (i_dernier_etat == ETAT_commun_climb_slide)
		{
			v_climb_position = OBJ_PosGet()
			v_climb_position += v_climb_normale * 100.0
		}
		else
		{
			i_climb_ponderation_mode = Ci_PONDERATION_CLIMB_IMPULSION
			// Par defaut si aucun joy n'est précisé pendant le saut on cherche a se rattraper sur le mur ou on est accroché
			v_jump_last_joy_vector = -v_climb_normale
			v_climb_normale = tv_normal_mur
			AI_Execute("k_exec_climb_find_best_pos")	// Donner la vrai normale au mur pour cette detection
			v_climb_normale = -v_jump_last_joy_vector
		}

		f_climb_impulsion_duration = -1.0
		v_climb_impulsion_force = DYN_LIB_ImpulsionGet(OBJ_PosGet(), v_climb_position  - v_climb_hand_offset, Cv_Kong_Gravity, Cf_impulsion_max_X, Cf_impulsion_max_Z, f_climb_impulsion_duration)
		f_climb_impulsion_coef = MATH_VecNorm(v_climb_impulsion_force)
		v_climb_impulsion_dir = v_climb_impulsion_force / f_climb_impulsion_coef
		
		f_climb_impulsion_coef /= MATH_FloatBlend(Cf_impulsion_max_X, Cf_impulsion_max_Z, MATH_FloatMax(MATH_VecDotProduct(v_climb_impulsion_dir, Cv_VerticalVector), 0.0))
		f_climb_impulsion_coef *= 0.7

		if (i_dernier_etat >= ETAT_commun_climb_0D || (o_climb_0D_wp || o_climb_1D_current_wp))
		{
			tv_sens = v_climb_impulsion_force
			tv_sens.z = 0.0
			MATH_VecSetNormalize( tv_sens)
			tv_sens2 = tv_normal_mur
			tv_sens2.z = 0.0
			MATH_VecSetNormalize( tv_sens2)
			 
			if ( MATH_VecDotProduct( tv_sens, tv_sens2 ) > Cf_Cos45)
			{
				// Calcul de l angle a compenser en rotationpour sauter dans l orientation voulu
				// Malgré le fait que l anim tourne de 180°
				f_jump_angle_a_compenser = MATH_VecAngle( tv_sens2, tv_sens, Cv_VerticalVector)	
				
				if ( MATH_FloatSign( f_jump_angle_a_compenser) > 0)
					i_climb_jump_index = -1
				else
					i_climb_jump_index = 6
			}
			ACT_ActionSet(Ci_Kanim_impulsion + (i_climb_jump_index * 2))
			v_zdm_pos = cvector(0.0, 3.4, 0.0)
		}
		i_flag_auto_grab = faux
		i_flag_climb_impulsion_done = faux
	}
	else
	{
		
		tv_sens = v_climb_normale
		tv_sens.z = 0.0
		MATH_VecSetNormalize( tv_sens)
		tv_sens2 = -OBJ_SightGet()
		tv_sens2.z = 0.0
		MATH_VecSetNormalize( tv_sens2)
		 
		if ( MATH_VecDotProduct( tv_sens, tv_sens2 ) > Cf_Cos45)
		{
			// Calcul de l angle a compenser en rotationpour sauter dans l orientation voulu
			// Malgré le fait que l anim tourne de 180°
			f_jump_angle_a_compenser = MATH_VecAngle( tv_sens2, tv_sens, Cv_VerticalVector)	
			
			if ( MATH_FloatSign( f_jump_angle_a_compenser) > 0)
				i_climb_jump_index = -1
			else
				i_climb_jump_index = 6
			i_jump_force_anim_impulsion = Ci_Kanim_impulsion + (i_climb_jump_index * 2)
		}	

		i_flag_climb_impulsion_done = vrai			// Ne pas faire le saut local du Climb


//		i_flag_auto_grab = faux
//		i_jump_check_hotspot = vrai	// On peux enchainer les HOT SPOT
		
		f_time_collide_ground = 0.0 // Forcer un saut
		i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
		i_jump_force_no_orient_impulsion = vrai // Ne pas orienter pendant le saut
		v_jump_force_sens = v_climb_normale
		i_jump_check_hotspot = faux	// On peux enchainer les HOT SPOT
		f_jump_force_distance = 10.0
		f_jump_force_hauteur = -2.0 	// Saut a -1m au dessus du HS
	

		macro_change_etat("k_ETAT_JUMP")
	}
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ======================================================================
AI_Execute("k_exec_joy")

ti_flag_compression = vrai

//if (i_flag_climb_impulsion_done)
//	ti_flag_compression = faux
//else if (i_dernier_etat == ETAT_commun_climb_slide)
//	ti_flag_compression = faux
//else if (f_time_start_etat > f_climb_impulsion_coef)
//	ti_flag_compression = faux
//else if (MATH_VecDotProduct(v_bassin_speed - v_climb_speed, v_climb_impulsion_dir) >= 1.0 || f_bassin_tension > 3.0)
//	ti_flag_compression = faux
//
//if (ti_flag_compression)
//{
//	i_flag_climb_wall	= vrai
//
//	DYN_GravitySet(Cv_NullVector)
//	DYN_SpeedSetVector(Cv_NullVector)
//
//	returntrack
//}

if (i_dernier_etat >= ETAT_commun_climb_0D && (ACT_ActionGet() == Ci_Kanim_impulsion + (i_climb_jump_index * 2) && ! ACT_ActionFinished()))
//if (i_dernier_etat >= ETAT_commun_climb_0D && (ACT_ActionGet() == 78 && ! ACT_ActionFinished()))
{
   	DYN_GravitySet(Cv_NullVector)
//	DYN_SpeedSetVector(Cv_NullVector)
	if ( i_climb_jump_index == -1 ||  i_climb_jump_index == 6)
	{
		// Il faut réajuster l orientation du saut qui fait 180° normalement.
		OBJ_RotateLocalZ(  f_jump_angle_a_compenser * TIME_GetDt() / 0.350  )	 // 0.350 = durée de l anim
	}
	macro_correction_banking( OBJ_SightGet(), Cv_VerticalVector, 8.0)
	returntrack
}

if (!i_flag_climb_impulsion_done)
{
	i_flag_climb_wall	= vrai

	i_flag_climb_impulsion_done = vrai
	f_climb_impulsion_time = TIME_Get()

	// Speed pour le saut de KONG
	DYN_TractionSet(Cv_NullVector)
	DYN_StreamSet(Cv_NullVector)
	DYN_FrictionVectorSet(Cv_NullVector)
	DYN_GravitySet(Cv_Kong_Gravity)
	DYN_SpeedSetVector(v_climb_impulsion_force)

	// Orientation du saut
	v_jump_init_joy_vector  = v_climb_impulsion_force	
	ACT_ActionSet(Ci_Kanim_jump + (i_climb_jump_index * 2))

	if (o_climb_0D_wp || o_climb_1D_current_wp)
	{
		tf_coef = ACT_DurationGet(ACT_ActionGet(), 0)
		tf_coef /= f_climb_impulsion_duration - 0.05
		tf_coef *= ANI_FrequencyGet(0)
		
		ti_freq = tf_coef
		ANI_FrequencySet(0, ti_freq)
	}

//	returntrack
}

AI_Execute("k_exec_climb_ray")

COL_ColSetActivationSet(C_bit_zdm_pied, none)	

if (f_time_start_etat)
{
	if (COL_CollideType(COL_C_Ground) && COL_NormalGet(COL_C_Ground).z > 0.0)
		macro_change_etat("k_ETAT_deplacement")

//	if ( o_jump_hotspot)
	if ( i_climb_jump_index == -1 || i_climb_jump_index == 6)
	{
		// Saut sur un HOT SPOT aller en jump) impulsion pour tout faire nikel
		// Une fois l'anim d impulsion terminée
//		if (ACT_ActionFinished())
//	 	{
			f_time_collide_ground = 0.0 // Forcer un saut
			i_jump_force_no_impulsion = vrai
			f_jump_force_distance = 10.0
			v_jump_force_sens = v_climb_normale
			i_jump_check_hotspot = vrai	// On peux enchainer les HOT SPOT
			macro_change_etat("k_ETAT_JUMP")
//		 }
	}
	else if ( o_climb_0D_wp || o_climb_1D_current_wp)
	{	
		COL_ColSetActivationSet(none, C_bit_zdm_pied)

//		i_flag_climb_IK[Ci_IK_main_gauche] = vrai
//		f_IK_speed[Ci_IK_main_gauche] = 1.0
//		v_IK_dest_pos[Ci_IK_main_gauche] = v_climb_position

		tv_hand_pos = OBJ_PosGet()
		tv_hand_pos += v_climb_hand_offset

 		if (tv_hand_pos.z < v_climb_position.z && MATH_VecDotProduct(DYN_SpeedGetVector(), DYN_GravityVectorGet()) >= 0.0)
		{	
			if (o_climb_0D_wp)
	 		{
		 		i_climb_0D_force_remonting = faux
		 		macro_change_etat("k_ETAT_climb_accroch_mur")
		 	}
//	
//			if (o_climb_1D_current_wp)
//				macro_change_etat("k_ETAT_commun_climb_1D")
		}
	}
	else if (i_dernier_etat == ETAT_commun_climb_slide)
	{
		DYN_FrictionVectorSet(cvector(2.0, 2.0, 0.0))
	}
	else
	{
		o_climb_0D_wp = nobody
		o_climb_1D_current_wp = nobody

//		macro_change_etat("k_ETAT_commun_climb_slide")
	}
}

ACT_ActionSet(Ci_Kanim_jump + (i_climb_jump_index * 2))

// COMPORTEMENT ================================================================
if (i_dernier_etat == ETAT_commun_climb_slide)
	tv_new_sight = v_climb_normale
else if (i_flag_climb_wall)
	tv_new_sight = -v_climb_normale
else if (i_dernier_etat >= ETAT_commun_climb_0D || (o_climb_0D_wp || o_climb_1D_current_wp))
	tv_new_sight = -v_climb_normale
else
{
	tv_new_sight = DYN_SpeedGetVector()
	tv_new_sight.z = 0.0
	tf_norm = MATH_VecNorm(tv_new_sight)

	if (tf_norm)
		tv_new_sight /= tf_norm
	else
		tv_new_sight = OBJ_SightGet()
}

//tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight, 6.0 * TIME_GetDt())
//OBJ_BankingGeneralSet(tv_new_sight, Cv_VerticalVector)
