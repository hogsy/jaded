#include "k_define.var"

int		ti_i
int		ti_tab_wall[20]
int		pi_STR
int		ti_flag

#ifndef _FINAL_

if( ! i_DBG_DISPLAY_WALLING )
	return

if ( @"univ" i_cheat_page == 3)
{
	// CORNER
	pi_STR = STR_CreateText( "Corner : ", cvector( 0.01,0.1,0.0), 0.0)
	i_WALLING_DBG_Corner = COL_CollideType( COL_C_Corner)
	if ( i_WALLING_DBG_Corner )
		STR_AppendText( pi_STR, "OUI")
	else
		STR_AppendText( pi_STR, "NON")

	// NB COLLISION
	pi_STR = STR_CreateText( "NB Collision: ", cvector( 0.01,0.2,0.0), 0.0)
	i_WALLING_DBG_nbRapport = COL_ReportsNumberAndRanksGet( &ti_tab_wall[0], 20, COL_C_Wall )
	STR_AppendInt( pi_STR, i_WALLING_DBG_nbRapport)

	// COL INFOS
	for ( ti_i = 0; ti_i < i_WALLING_DBG_nbRapport ; ti_i++ )
	{
		pi_STR = STR_CreateText( "Col Infos: ", cvector( 0.01, 0.3 + ( 0.1 * ti_i), 0.0), 0.0)	
		i_WALLING_DBG_Gmat[ti_i] = COL_GMAT_FlagsGet( COL_C_ReportIndex + ti_tab_wall[ti_i])
		v_WALLING_DBG_Position[ti_i] = COL_CollidedPointGet( COL_C_ReportIndex + ti_tab_wall[ti_i] )
		v_WALLING_DBG_Normal[ti_i] = COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[ti_i])
		
		ti_flag = COL_ReportFlagGet(COL_C_ReportIndex + ti_tab_wall[ti_i] )
		if( ti_flag & (  COL_C_Extra_Corner |  COL_C_Extra_ODE |  COL_C_Extra_SlipperyEdge)) // | COL_C_Corner | COL_C_Edge))
			STR_AppendText( pi_STR, "EXTRA + ")
		else
			STR_AppendText( pi_STR, "NORMAL + ")
		STR_AppendText( pi_STR, "GMAT: ")
		if ( i_WALLING_DBG_Gmat[ti_i] & Gmat_KK_Face_de_Walling)
			STR_AppendText( pi_STR, " WALLING")
		else if ( i_WALLING_DBG_Gmat[ti_i] & Gmat_KK_Force_Left)
			STR_AppendText( pi_STR, " FORCE RIGHT")
		else if ( i_WALLING_DBG_Gmat[ti_i] & Gmat_KK_Force_Right)
			STR_AppendText( pi_STR, " FORCE LEFT")		
		else
			STR_AppendText( pi_STR, " FREE")		
			
		// Rapport de collision Valide
		macro_render_Vector( v_WALLING_DBG_Position[ti_i], -v_WALLING_DBG_Normal[ti_i]* 2.0, 0xFF)	
	}
}

#endif

