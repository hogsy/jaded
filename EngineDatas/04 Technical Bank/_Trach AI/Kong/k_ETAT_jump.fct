#include"k_define.var"

#define	Cf_Jump_Length_stop			6.0
#define	Cf_Jump_Length_walk			10.0
#define	Cf_Jump_Length_run			16.0
#define	Cf_Jump_Length_walling		12.0
#define	Cf_Delai_Saut_en_chute		0.3

#define	Cf_Jump_Friction					0.5

int			ti_i
int			ti_capa
int			ti_flag_compute_action_duration
int			ti_freq
int			ti_flag_reception
int			ti_anim
int			ti_jump_en_chute
int			ti_GMAT
int			ti_action
float		ti_puissance
int			ti_REX_dodge
int			ti_report					
int			ti_ground

float		tf_coef
float		tf_dot
float		tf_dot1
float		tf_dot2
float		tf_norm
float		tf_speed
float		tf_jump_length
float		tf_hauteur_mur
float		tf_normale_offset
float		tf_blend_speed
float		tf_hauteur_saut
float		tf_angle
float		tf_offset
float		tf_duree
float		tf_distance_DG
float		tf_delta 
float		tf_lbdt

object	to_collide_object
object	to_hand

vector	tv_speed
vector	tv_hand_pos
vector	tv_pos
vector	tv_ray_dir
vector	tv_temp
vector	tv_ray_normale
vector	tv_sens
vector 	tv_last_ground_pos  
vector	tv_vct
vector	tv_HS_bank
vector	tv_HS_sight
vector	tv_climb_position
vector	tv_edge_normal
vector	tv_axe
vector	tv_pos_zone 
vector	tv_zdm_speed
vector	tv_offset

message	tm_msg

#define AUTO_RATTRAPING									1
//#define JUMP_LIMITATION									1

//DBG_StartRaster( 0,"Jump")
					
// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

	// DEFAULT POUR LES SAUTS SUIVANTS
	i_walling_force_no_detection = faux
	i_jump_force_anim_impulsion = 0
	i_jump_force_no_orient_impulsion = faux
	i_jump_force_zdm_impulsion = vrai
	i_jump_force_anim_cycl = 0
	i_jump_check_hotspot = vrai
	i_jump_check_hotspot_fight = faux
	v_jump_force_sens = Cv_NullVector
	f_jump_force_distance = 0.0
	f_jump_force_hauteur = 0.0
	f_jump_force_amplitude = 0.0
	i_jump_force_keep_Z_speed=faux
	i_jump_force_chute = faux
	v_jump_force_chute_orient = Cv_NullVector
	i_jump_force_accroch = faux
	v_jump_force_pos = Cv_NullVector
	i_jump_autorise_accroch = vrai
	i_jump_auto_rattraping	= faux
	i_jump_to_grab = faux
	i_jump_to_frappe = faux
	i_jump_force_no_clear_bat = faux
	i_jump_without_attack = faux
	DYN_FrictionVectorSet(Cv_NullVector)
	COL_ColSetActivationSet(C_bit_zdm_pied, none)
	v_zdm_pos = Cv_Kong_zdm_pos

	o_paf_actor_backup = nobody	// Interdiction de paffer cet acteur terminé
	// Mise a jour du Hot Spot
	// en cas de Swing on le conserve en memoire
	
//#define	HOTSPOT_Type_Horiz				0b00001
//#define	HOTSPOT_Type_Vert				0b00010
//#define	HOTSPOT_Type_Fight				0b00100
//#define	HOTSPOT_Type_Limit1_4			0b01000
//#define	HOTSPOT_Type_Fight1_2			0b10000

	o_jump_hotspot_last = o_jump_hotspot
//	if ( o_jump_hotspot && @o_jump_hotspot OBJ_CapaGet() & OBJ_Capa_4)
	if ( o_jump_hotspot && o_jump_hotspot.des_int1 &  HOTSPOT_Type_Fight)
	{
		// HOT SPOT de Combat aucune utilité de conserver le HotSpot on ne SWING pas dessus ...
		o_jump_hotspot = nobody
		o_jump_hotspot_last = nobody
	}
	i_flag_trample = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Kong_jump) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Kong_jump
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()

	// EXPLICATIONS
	// i_jump_force_no_impulsion = Ne pas faire d'anim de préparation de saut et d anim d impulsion: sauter DIRECT
	// i_jump_force_anim_impulsion = On désire cette anim pour faire l impulsion de Kong.
	// i_jump_force_no_orient_impulsion  = force aucune orientation pendant la phase d impulsion
	// i_jump_force_zdm_impulsion = permet de désactiver la ZDM pendant l impulsion( sert au saut/remonte quand on est accroché par les mains)
	// i_jump_force_anim_cycl = force cette anim pour le cycle du saut( et chute)
	// i_jump_check_hotspot = On désire tester les HOTSPOT pendant le saut
	// v_jump_force_sens = Sens du saut
	// f_jump_force_distance = Choisi la distance de l'impulsion
	// f_jump_force_amplitude = choisi l amplitude dans un saut manuel
	// f_jump_force_hauteur = Donne un Offset en Z sur la position destination(si ce ne est pas un HOTSPOT)
	// i_jump_force_keep_Z_speed = Oblige le saut a conserver la vitesse en Z courante pour calculer son impulsion
	// i_jump_force_chute = Force la chute
	// v_jump_force_chute_orient = Orientation pour la chute( et uniquement en chute)
	// f_time_collide_ground = delai de non collision avec le sol. elle entraine la chute au dessus d'une valeur ( Cf_delay_ground_col_tolerance)
	// i_jump_force_accroch = tenter d accrocher derriere le saut
	// i_jump_autorise_accroch = autorise a se raccrocher
	// v_jump_last_speed = vitesse de chute	
	// v_jump_force_pos = force le saut vers une position précise
	// i_jump_force_no_clear_bat = force a ne pas virer le tableau des rides ( bats)
	// i_jump_without_attack = interdit de faire le coup en saut
//	// GRRRRRRRRRRR les RECALAGES
//	// fini les vitesse en z erratique
//	tv_speed = DYN_SpeedGetVector()
//	tv_speed.z = MATH_FloatMin( tv_speed.z, 0.0)
//	DYN_SpeedSetVector( tv_speed)
//	// GRRRRRRRRRRR les RECALAGES

	// GRAB CLIENT ACCEPT
	ai_SRV_ENABLE[Ci_LNK_KKFINISH_ON_KONG] = faux
	
	// Faire se décrocher les petits acteurs sur le dos
	RIDE_Clear_Link_Bat( faux) // Decrocher tout sauf les bats
	if ( i_Grab_Torse_Actor && ! i_Grab_Torse_ANN)
	{
		ao_CL_GRABKONG[0] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], faux, "k_exec_grab_object_param", nofunc, nofunc)
		i_GrabKong_MainBloquee = -1
		i_Grab_Torse_Actor = 0
		i_Grab_Torse_Main = -1
	}


	
	f_time_start_etat = 0.0

	// Saut classique avec tout les calculs : effacer les données précédentes.
	if ( ACT_ActionGet( ) == Ci_Kanim_se_raccroche)	
	{
		v_climb_normale = @o_climb_0D_wp OBJ_SightGet()			
		i_jump_autorise_accroch = faux		
	}
	else
		v_climb_normale = -OBJ_SightGet()			


	o_climb_0D_wp = nobody
	o_climb_1D_current_wp = nobody
	o_climb_1D_next_wp = nobody
	// Default
	v_jump_offset = OBJ_SightGet()

	i_flag_climb_impulsion_done = faux

	f_jump_friction = Cf_Jump_Friction 
	if( !MATH_FloatNullEpsilon(f_jump_force_distance))
	{
		f_jump_length = f_jump_force_distance
		f_jump_force_distance = 0.0
	}
	else if (i_joy_flag_dash)
	{
		f_jump_length = Cf_Jump_Length_run
	}
	else if (f_joy_norm)
	{
		f_jump_length = Cf_Jump_Length_walk
	}
	else
	{
		f_jump_length	 = Cf_Jump_Length_stop
	}

	f_climb_rotation_angle = 0.0


//	// Par défaut, Kong ne se rattrape pas au mur en chutant
//	i_jump_flag_rattraping_allowed = faux
	v_jump_last_speed = DYN_SpeedGetVector()
//	if( i_dernier_etat == ETAT_commun_climb_impulsion)
//	{
//		v_jump_force_chute_orient = Cv_NullVector				// On utilise le climb_normale pour l orient
//		ACT_ActionSet(Ci_Kanim_saute_cycl)
//	}	
//	else 
	if (f_time_collide_ground > Cf_delay_ground_col_tolerance || i_jump_force_chute)	
	{
		// Si c'est un paf qui fait tomber, Kong ne se ratrappe pas.
		i_jump_chute = vrai
		if ( i_jump_force_chute)
		{
			i_jump_force_chute = faux
			if ( i_jump_force_anim_cycl)
			{
				ti_anim = i_jump_force_anim_cycl
				i_jump_force_anim_cycl = 0
			}
			else
				ti_anim = Ci_Kanim_saute_chut_cycl
			// Kong ne se rattrape pas au mur en chutant
			i_jump_flag_ratraping_allowed = faux
			i_jump_flag_force_reception = faux
		}
		else if ( i_dernier_etat == ETAT_Kong_desequilibre)
		{
			ti_anim = Ci_Kanim_saute_chut_cycl
			// Kong ne se rattrape pas au mur en chutant
			i_jump_flag_ratraping_allowed = vrai
		}
		else
		{
			ti_anim = Ci_Kanim_saute_chut_cycl	
			tv_sens = -( OBJ_BankingGet() + OBJ_SightGet()) * Cf_1BySqrt2
			to_collide_object = COL_RayObject_Dist( OBJ_PosGet(), tv_sens, 2.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			if ( to_collide_object)
			{
				// chopper la normale du mur !!
				ti_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)
				if ( !( ti_GMAT  & Gmat_KK_Accrochage_interdit))
				{
					v_jump_normale_chute  = COL_RayObject_NormalGet()
					macro_render_Vector( COL_RayObject_PosGet(), v_jump_normale_chute * 2.0, 0xFF)
					if ( v_jump_normale_chute.z > v_jump_normale_chute.x)
						v_jump_normale_chute = Cv_NullVector
					v_climb_normale = -v_jump_normale_chute
				}
			}
			i_jump_flag_force_reception = faux
		}
	
		// En chute !!
		f_jump_friction = 2.0
		DYN_TractionSet(Cv_NullVector)
		DYN_StreamSet(Cv_NullVector)
		DYN_FrictionVectorSet(cvector( f_jump_friction, f_jump_friction, 0.0))
		DYN_GravitySet(Cv_Kong_Gravity)

		ACT_ActionSet(ti_anim)	
		
		f_jump_ground_col = 0.0
	}
	else
	{
		// Cas général : le joueur DEMANDE le saut.( au sol ou en walling)
		v_jump_force_chute_orient = Cv_NullVector				// On utilise le climb_normale pour l orient
		i_jump_chute = faux
		AI_Execute("k_exec_check_obstacle")	
		f_obstacle_dist -= 4.0

		if( i_dernier_etat == ETAT_Kong_accroch_mur)	
			i_jump_flag_force_reception = faux		// On en veux pas de gros amorti dans ce cas la.
		else
			i_jump_flag_force_reception = vrai
		// Kong ne se rattrape pas au mur en saut
		i_jump_flag_ratraping_allowed = faux

		if ( !i_jump_force_no_impulsion)
		{
			// Forcer l anim d implusion
			if ( !i_jump_force_anim_impulsion)
				i_jump_force_anim_impulsion = Ci_Kanim_saute_deb
			ACT_ActionSet(i_jump_force_anim_impulsion)
			if ( i_jump_force_anim_impulsion == Ci_Kanim_Colonne_Saut
			|| i_jump_force_anim_impulsion == Ci_Kanim_Colonne_SautG)
				DYN_GravitySet(Cv_NullVector)
		}
		DYN_FrictionVectorSet(Cv_NullVector)

		SND_RequestPlay(Ci_KSound_Impulsion)

		// HOT SPOT
		if ( MATH_VecNullEpsilon( v_jump_force_sens))
			v_jump_force_sens = v_joy_sight_normalized		// Permet de forcer le sens du saut et forcer le sens de detection de hot spot

		// TEST DU HOT SPOT NECESSAIRE POUR TROUVER L ORIENTATION A AVOIR POUR L IMPULSION
		AI_Execute( "k_exec_check_hotspot")
		v_climb_normale = pop
		v_climb_normale = -v_climb_normale 
		v_jump_offset	= -v_climb_normale
	}
	
	// Si C'est un saut voulu dans le vide Kong ne se ratrappe pas
//	if ( i_flag_trample)
//		i_jump_flag_ratraping_allowed = faux

	// Par defaut si aucun joy n'est précisé pendant le saut on cherche a se rattraper dans le sens du saut
	v_jump_last_joy_vector = OBJ_SightGet()
	
	i_jump_clean_freq = 0
	i_frappe_target_nb = 0			// Si l on fait un saut qui frappe, on met a 0 le nb des enemi deja frappé
	
	// CAMERA -----------------------------------------------------------------
	if ( o_jump_hotspot && o_jump_hotspot.des_int1 &  HOTSPOT_Type_Fight)
	{
		// HOPTSPOT DE FIGHT: PREVENIR
		@get_global i_kong_camera_status = Ci_Kcamera_saute
		tm_msg.msg_id = msg_id_KK_Fight_Jump		
		tm_msg.msg_sender = OBJ_Me()
		@o_jump_hotspot MSG_Send( tm_msg)
	}
	@get_global i_kong_camera_status = Ci_Kcamera_saute
		
	// CAMERA -----------------------------------------------------------------

	// Saut sur un ennemi pas de collision géré dans l'ennemi.
//	if ( o_jump_hotspot && o_jump_hotspot.des_int1 &  HOTSPOT_Type_Fight)
//		COL_UnCollidableAdd(o_jump_hotspot)

	if( o_jump_hotspot )
		RAGE_Maximise(Cf_Fury_Maximum_Swing)
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ======================================================================


ti_jump_en_chute = faux			// Pendant la chute on le peux pas ressauter par défaut
	
ti_flag_compute_action_duration = faux
//ti_flag_auto_recup = faux

tf_blend_speed = 8.0

AI_Execute("k_exec_joy")


COL_ColSetActivationSet(C_bit_zdm_pied, none)

ti_action = ACT_ActionGet()
// IMPULSION
if ( i_jump_force_no_impulsion || ti_action == i_jump_force_anim_impulsion)
{
	if ( !i_jump_force_zdm_impulsion)
		COL_ColSetActivationSet(none, C_bit_zdm_pied)

	// HOT SPOT
	if ( o_jump_hotspot)
	{
		// LE saut est fait avec un HOT SPOT
		// MISE a JOUR de la normale pendant le déplacement du a l impulsion
		v_climb_normale = OBJ_PosGet() - @o_jump_hotspot OBJ_PosGet()
		v_climb_normale.z = 0.0
		MATH_VecSetNormalize( v_climb_normale)
		v_jump_offset	= -v_climb_normale
	}

	if ( ACT_ActionFinished() || i_jump_force_no_impulsion)
	{
		i_jump_force_no_impulsion = faux
		i_jump_force_no_orient_impulsion = faux	// Lors du prochain saut il faudra s orienter
		tf_hauteur_saut = 0.1
		OBJ_HierarchyReset()
		if ( i_jump_force_anim_impulsion != Ci_Kanim_saute_chute_paf)
		{
			i_climb_ponderation_mode = Ci_PONDERATION_JUMP_IMPULSION
			// Ds le best pos est effectué la recherche de hot spot
			AI_Execute("k_exec_climb_find_best_pos")	
	
			// HCOIX DU TYPE DE SAUT : SUR UN POINT PRECIS OU PAS?
	 		if (o_climb_0D_wp						// Saut sur WP OD
			|| ( o_jump_hotspot && o_jump_hotspot.des_desflags &  DSF_HotSpot_info_en_int1))
			{
				AI_Execute("k_exec_jump_OD_ani_offset_set")
			}
			else
			{
				AI_Execute("k_exec_jump_free_ani_offset_set")
			}
			v_jump_last_speed = v_climb_impulsion_force
		}
		else
		{
			// CAS DU PAF COLONNE !!!!!!!!!!!!!!!
			// Impulsion + Chute !!
			DYN_SpeedSetVector( OBJ_SightGet() * 20.0)
			i_jump_chute = vrai
			// Kong ne se rattrape pas au mur en chutant
			i_jump_flag_ratraping_allowed = faux
			i_jump_flag_force_reception = faux
			// En chute !!
			f_jump_friction = 2.0
			DYN_TractionSet(Cv_NullVector)
			DYN_StreamSet(Cv_NullVector)
			DYN_FrictionVectorSet(cvector( f_jump_friction, f_jump_friction, 0.0))
			DYN_GravitySet(Cv_Kong_Gravity)
			ACT_ActionSet( i_jump_force_anim_cycl)
		}
	}
	else //if ( COL_CollideType( COL_C_Ground + COL_C_SlipperyEdge))
	{
		tv_speed = DYN_SpeedGetVector()
		if ( tv_speed.z <= 0.0)
			tv_speed.z = 0.0
		DYN_SpeedSetVector(  tv_speed )
	}
}
// SAUT AVEC POINT PRECIS DETECTE
else if ((o_climb_0D_wp 
|| o_climb_1D_current_wp)
|| ( o_jump_hotspot && o_jump_hotspot.des_int1 &  ( HOTSPOT_Type_Vert + HOTSPOT_Type_Horiz + HOTSPOT_Type_Colonne)))
{
	// ***********************************************
	// PHASE DE SAUT
	// SUR UN POINT PRECIS ( 0D 1D HS )
	// ***********************************************
	i_in_jump = vrai

	if ( i_jump_clean_freq && !ACT_ActionIsTransition())
		ANI_FrequencySet(0, i_jump_clean_freq)

	ti_jump_en_chute = vrai

	v_zdm_pos = cvector(0.0, 3.4, 0.0)

	COL_ColSetActivationSet(none, C_bit_zdm_pied)

	tv_hand_pos = v_climb_position
	tv_hand_pos -= v_climb_hand_offset

	tv_pos = OBJ_PosGet()

//	if (i_flag_auto_grab)
//	{
//		tf_blend_speed = 4.0
//	
//		tf_coef = OBJ_PosGet().z - tv_hand_pos.z
//		tf_coef *= 0.5
//
//		tv_pos.x = MATH_FloatBlend(tv_hand_pos.x, tv_pos.x, tf_coef)
//		tv_pos.y = MATH_FloatBlend(tv_hand_pos.y, tv_pos.y, tf_coef)
//		OBJ_PosSet(tv_pos)
//		
//		if (i_flag_just_Action)
//		{
//			OBJ_BankingGeneralSet(v_climb_ground_pos - OBJ_PosGet(), Cv_VerticalVector)
//			OBJ_PosSet(v_climb_ground_pos + (OBJ_SightGet() * 4.0))
//			macro_change_etat("k_ETAT_main")
//		}
//	}

	
	tv_hand_pos = tv_pos
	tv_hand_pos += v_climb_hand_offset
 	if (tv_hand_pos.z <= v_climb_position.z && MATH_VecDotProduct(DYN_SpeedGetVector(), DYN_GravityVectorGet()) >= 0.0)
	{
	
		if (o_climb_0D_wp)
		{
			i_climb_0D_force_blend_banking = faux				// Accroch normal, banking bon
			SND_RequestPlay(Ci_KSound_Accroche)
 			macro_change_etat("k_ETAT_accroch_mur")
 		}

		if ( o_jump_hotspot)
		{
			if ( o_jump_hotspot.des_int1 &  HOTSPOT_Type_Horiz)
				macro_change_etat("k_ETAT_SwingPillar")
			else if ( o_jump_hotspot.des_int1 &  HOTSPOT_Type_Vert)
				macro_change_etat("k_ETAT_SwingArch")
			else if ( o_jump_hotspot.des_int1 &  HOTSPOT_Type_Colonne)
			{
				SND_RequestPlay(Ci_KSound_Accroche)	
				o_colonne = @o_jump_hotspot OBJ_HierarchyGet()
				COUP_CHANGE_To_Pillar(o_colonne, Ci_Kanim_Colonne_Reception)
				o_jump_hotspot = nobody
				macro_change_etat("k_ETAT_main")
			}
			else
			{
				ACT_ActionSet( Ci_Kanim_saute_ptt_amorti)
				macro_change_etat("k_ETAT_main")
			}
		}

	}
	
	tf_blend_speed = 16.0
}
// SAUT SANS POINT PRECIS DETECTE
else
{
	// ***********************************************
	// PHASE DE SAUT
	// SUR CAS GENERAL( PAS DE PT DESTINATION)
	// ***********************************************
	i_in_jump = vrai
	ti_action = ti_action
	switch(ti_action)
	{
		// FIN DE SAUT ================================================
		case Ci_Kanim_saute_chute_paf_g_recep :		// PAF EN WALLING/COLONNE 
		case Ci_Kanim_saute_chute_paf_recep :		// PAF EN WALLING/COLONNE 
		case Ci_Kanim_coup_bas_fin : 
			i_in_jump = 2	// Reception
			// CAMERA -----------------------------------------------------------------
			@get_global i_kong_camera_status = Ci_Kcamera_reception
			// CAMERA -----------------------------------------------------------------
			Proc_KK_Impact_Sol2()

			if ( ACT_ActionFinished())
				macro_change_etat("k_ETAT_main")
			break	
		// FIN DE SAUT AVEC DYNA ======================================
		case Ci_Kanim_saute_ptt_amorti:
		case Ci_Kanim_saute_fin : 
			i_in_jump = 2	// Reception			
			Proc_KK_SFX_Impact_Sol()
			// Interdire a cette anim de reception(chute) d avoir une vitesse en Z positive
			tv_speed = DYN_SpeedGetVector()
			if ( tv_speed.z > 0)
			{
				tv_speed.z = 0.0
				DYN_SpeedSetVector( tv_speed)
			}
			
			
			if (f_time_collide_ground > Cf_delay_ground_col_tolerance)	
			{
				i_jump_flag_ratraping_allowed = vrai
				i_jump_flag_force_reception = faux
			
				DYN_TractionSet(Cv_NullVector)
				DYN_StreamSet(Cv_NullVector)
				DYN_FrictionVectorSet( cvector( 3.0, 3.0, 0.0))
				DYN_GravitySet(Cv_Kong_Gravity)
		
				ACT_ActionSet(Ci_Kanim_saute_cycl)
			}
			else
			{
				// CAMERA -----------------------------------------------------------------
				@get_global i_kong_camera_status = Ci_Kcamera_reception
				// CAMERA -----------------------------------------------------------------
		
				if (ACT_ActionFinished())	
				{
					// EMPECHER L AUTO WALK A La RECEPTION
					i_flag_trample = faux
					f_time_auto_walk = 0.0 // NE pas remarcher automatiquement apres une réception de saut
					macro_change_etat("k_ETAT_main")
				}
				else
				{
//					// Lancer une roulade
//					if (  i_flag_just_Action && BUFFER_Zone_Interrupt())
//						macro_change_etat( "k_ETAT_fracasse")
					tf_coef = DYN_SpeedGet()
					tf_coef = 7.0 - MATH_FloatMin(tf_coef * 0.2, 6.0)
					DYN_FrictionVectorSet(cvector(tf_coef, tf_coef, 0.0))
				}
		
				break
			}
		
		// SPECIFIQUE CYCL SAUT STANDARD  =========================================
//		case Ci_Kanim_Walling_SautD  :
//		case Ci_Kanim_Walling_SautG  :
		case Ci_Kanim_saute_chute_paf :
		case Ci_Kanim_saute_chute_paf_chute :
//			if ( ACT_ActionFinished())
//				ACT_ActionSet( Ci_Kanim_saute_chut_cycl)
		case 180 :
		case 56 :
		case Ci_Kanim_saute_chut_cycl :
		case Ci_Kanim_saute_cycl :
			// TEST DE WALLING
			if (  i_flag_just_coup && ! i_jump_without_attack)
			{
				STATS_IncAttack()		// jump frappe
				i_jump_to_frappe = vrai
				ACT_ActionSet( Ci_Kanim_coup_bas_cycl)
			}
						
			// TEST TEST TEST BOUTON CHANGE ATTITUDE	
		case Ci_Kanim_saute_chutte :	
		case Ci_Kanim_saute_accroche :
	
			// CAMERA -----------------------------------------------------------------
			@get_global i_kong_camera_status = Ci_Kcamera_saute
			// CAMERA -----------------------------------------------------------------

//#ifdef AUTO_RATTRAPING

 			if (i_jump_flag_ratraping_allowed)
 			{
 				i_jump_auto_rattraping = vrai
 				i_jump_flag_ratraping_allowed = faux
 			
 				if (JUMP_BigJump())
 				{	
					// ON TOMBE  => RECHERCHE DE FACE POUR SE RATTRAPER
					tv_ray_dir = v_climb_ground_pos - OBJ_PosGet()
					tv_ray_dir.z = 0.0
					tf_norm = MATH_VecNorm(tv_ray_dir)
					
					if (tf_norm)
					{
						tv_ray_dir /= tf_norm
						tv_sens = COL_ZonePosGet( C_zdm_pied)
						tv_sens -= v_last_ground_pos
						tv_sens.z = 0.0
						MATH_VecSetNorm(tv_sens,0.1)
						if ( JUMP_Detect_Raccroch( tv_sens) )
						{
							// Kong va se raccrocher
							JUMP_Se_Raccroch()
						}
					}
				}
			}
	
		// DETECTION COLLISION LORS DES CYCLES DE SAUT ================================
		case Ci_Kanim_coup_bas_cycl :

//			Test_Walling
			if ( WALLING_Test_Valid())																			
				macro_change_etat("k_ETAT_walling")

			// PAFFEr LEs MURS
			if ( COL_CollideType( COL_C_Wall))
			{
				ti_puissance = Cf_DMG_Normal
				to_collide_object = COL_BestWallGaoGet( OBJ_SightGet(), &ti_report)
				if ( to_collide_object && @to_collide_object AI_IsModel(get_KI_Decor_Path))
					EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_collide_object, -1, ti_puissance, OBJ_SightGet(), OBJ_PosGet())
			}
			
			ti_flag_reception = faux

			// REPOUSSER LES BATS
			Proc_KK_PAF_Repulse()

			// DETECTER L ESQUIVE
			if ( !o_jump_hotspot || !(o_jump_hotspot.des_int1 & HOTSPOT_Type_Fight) 
			|| ( ! @o_jump_hotspot AI_IsModel(get_PNJ_KTREX_Path) || !@o_jump_hotspot KT_Proc_Dodges()))
				ti_REX_dodge = faux
			else
				ti_REX_dodge = vrai

			// PAF SUR REX OU NE GRANDE CHUTE
			if( ( v_jump_last_speed.z < -30.0
			||( o_jump_hotspot && (o_jump_hotspot.des_int1 & HOTSPOT_Type_Fight))))
			{
				if (v_jump_last_speed.z <= 0.0)
				{
					f_slow_speed = MATH_FloatBlend(f_slow_speed, 0.6, 6.0 * TIME_GetDt())
					@get_global f_game_speed = f_slow_speed
				}
				if( !ti_REX_dodge)
				{
					COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 4.0))
					COL_ZoneSizeSet( C_zde_fight, cvector( 4.0, 4.0, 4.0))
					AI_Execute( "k_exec_zdf_zdc")
					COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 2.0))
					COL_ZoneSizeSet( C_zde_fight, Cf_ZDE_SizeFight)

					if ( ARR_ObjSearch( &ao_frappe_target[0], i_frappe_target_nb, o_jump_hotspot) != -1)
					{
						SND_RequestPlay(Ci_KSound_Reception)
						if ( i_jump_to_grab)
							macro_change_etat( "k_ETAT_fracasse")
						else
							ti_flag_reception = vrai
					}
				}
			}
			
			if (v_jump_last_speed.z <= 0.5 || f_time_start_etat > 0.5)
			{
//				ti_flag_reception = faux
//				DBG_TraceVector(DYN_SpeedGetVector())
//				DBG_TraceEOL()
				ti_ground = faux
				if (COL_CollideType(COL_C_Ground))
				{
					ti_ground = vrai
					f_jump_ground_col +=TIME_GetDt()
				}
				else
					f_jump_ground_col = 0.0
				if ( COL_CollideType( COL_C_Ground + COL_C_SlipperyEdge))
				{
					tv_offset = OBJ_PosGet() - COL_CollidedPointGet( COL_C_Ground) 
					if ( tv_offset.z < - COL_ZoneSizeGet(C_zdm_pied) * ( 1 - Cf_Cos30))
					{
						ti_ground = faux
						if ( DYN_SpeedGetVector().z > -12.0)
						{
							v_jump_last_speed = DYN_SpeedGetVector()
							v_jump_last_speed.z = -12.0
							DYN_SpeedSetVector(v_jump_last_speed)
						}
					}
				}
				if (ti_ground)
				{
					if ( i_nb_gound_col >= 2 || f_jump_ground_col > 0.5)
					{
						ti_flag_reception = vrai
						ti_puissance = Cf_DMG_Normal
						if ( ! ti_REX_dodge )
						{
							EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_PAF_KK_Fort + C_PAF_KK_Ecrasement, OBJ_Me(), Cf_EVENT_Duree_1Trame, COL_ObjectGet(COL_C_Ground), -1, ti_puissance, OBJ_SightGet(), OBJ_PosGet())
//							if( Proc_KK_EstUnEnnemiDeKong(COL_ObjectGet(COL_C_Ground) ) )
//								STATS_IncAttack()
						}
					}
//					else if ( COL_CollideType( COL_C_Ground + COL_C_SlipperyEdge))
//					{
//						//	CAS DE MERDE LES COLISIONS VONT FINTER A MORT POUR FAIRe GLISSER KK
//						DYN_SpeedSetVector(v_jump_last_speed + cvector( 0.0, 0.0, -20.0))
//					}
//					else
//						DYN_SpeedSetVector(v_jump_last_speed)
				}
				// ENTRAINE DES CAS ERRATIQUES

				COL_ODEKeepNext()
				if (COL_CollideType(COL_C_Extra_ODE)) // && COL_NormalGet(COL_C_Ground).z > 0.0)
				{
//					ti_flag_reception = vrai
					COL_ODEKeepNext()
					to_collide_object = COL_ObjectGet(COL_C_Extra_ODE)
					ti_puissance = Cf_DMG_Normal
					if ( ! ti_REX_dodge )
						EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_PAF_KK_Fort + C_PAF_KK_Ecrasement, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_collide_object, -1, ti_puissance, OBJ_SightGet(), OBJ_PosGet())
//						if( Proc_KK_EstUnEnnemiDeKong(to_collide_object) )
//							STATS_IncAttack()
				}

				if (ti_flag_reception && f_time_collide_ground < Cf_delay_ground_col_tolerance)
				{
					// Reception
					f_time_collide_ground = 0 		// Le sol est touché
					// CAMERA -----------------------------------------------------------------
					@get_global i_kong_camera_status = Ci_Kcamera_reception
					// CAMERA -----------------------------------------------------------------
//					SND_RequestPlay(Ci_KSound_Reception)
					i_GFX_reception = vrai				
					if ( !i_jump_force_no_clear_bat)
						RIDE_Clear_Link_Bat(1)		// Virer les bats
					else	if ( RIDE_Get_Actor_Nb() && ! MATH_VecNullEpsilon(v_walling_normal))
					{
						v_add_speed = v_walling_normal * 30.0
						f_coef_recul = 0.0
					}

					if ( i_jump_to_grab)
					{
						SND_RequestPlay(Ci_KSound_Reception)
						Proc_KK_Rumble_Fort()
						macro_change_etat( "k_ETAT_fracasse")						
					}
					else if ( i_jump_to_frappe)
					{
						// Fin Coup au SOL
						ACT_ActionSet( Ci_Kanim_coup_bas_fin)						
						LIBGFX_ShakeCam( 0.05, 35.0, 0.0, 0.0, 0.15, 0.99)
						Proc_KK_Rumble_Fort()
					}
					else if ( ACT_ActionGet() == Ci_Kanim_saute_chute_paf_chute)
					{
						LIBGFX_ShakeCam( 0.05, 35.0, 0.0, 0.0, 0.15, 0.99)
						Proc_KK_Rumble_Fort()
						if ( ACT_ActionFinished())
						{
							ACT_ActionSet( Ci_Kanim_saute_chute_paf_recep)
						}
						else
							ACT_ActionSet(Ci_Kanim_saute_chute_paf_g_recep)
						f_coef_recul = 0.0
						v_add_speed = OBJ_SightGet() * 3.0
					}
					else if ( i_jump_flag_force_reception || v_jump_last_speed.z < -25.0)
					{
						// Amorti
						ACT_ActionSet(Ci_Kanim_saute_fin)
						LIBGFX_ShakeCam( 0.05, 35.0, 0.0, 0.0, 0.15, 0.99)
						Proc_KK_Rumble_Fort()
					}
					else
					{
						// Petit amorti
						Proc_KK_Rumble_Moyen()
						ACT_ActionSet(Ci_Kanim_saute_ptt_amorti)
					}
				}
				else
				{
					v_jump_last_speed = DYN_SpeedGetVector()
				}
			}
			else
				v_jump_last_speed = DYN_SpeedGetVector()
	
			break
			
		default:
	}
}

// COMPORTEMENT ================================================================



// ***********************************************************************************************************************************************************
// ORIENTATION
// ***********************************************************************************************************************************************************
if (f_climb_rotation_angle)
{
	tf_angle = f_climb_rotation_angle / f_climb_impulsion_duration
	OBJ_RotateGlobalZ(tf_angle * TIME_GetDt())
//	OBJ_BankingGeneralSet( OBJ_SightGet(), MATH_VecBlendRotate( OBJ_BankingGet(),  Cv_VerticalVector, 8.0 * TIME_GetDt()))
	tv_pos = OBJ_PosGet() + (OBJ_BankingGet() * COL_ZoneSizeGet(C_zdm_pied))
	OBJ_Rotate_FromToBlend( OBJ_BankingGet(), Cv_VerticalVector, 8.0 * TIME_GetDt())
	OBJ_PosSet( tv_pos - (OBJ_BankingGet() * COL_ZoneSizeGet(C_zdm_pied)))

}
else if ( !i_jump_force_no_orient_impulsion)
{
	ti_action = ACT_ActionGet() 
	if ( o_jump_hotspot && ti_action == Ci_Kanim_saute_deb)
	{
		// Saut qui s'oriente vers le HS
		tv_sens = @o_jump_hotspot OBJ_PosGet() - OBJ_PosGet()
	}
	else if ( !MATH_VecNullEpsilon( v_jump_force_chute_orient ))
	{
		tv_sens = v_jump_force_chute_orient
	}
	else
	{
		tv_sens = -v_climb_normale
	}
	if ( !MATH_VecNullEpsilon( tv_sens))
		MATH_VecSetHorzNormalize( tv_sens)
	else 
		tv_sens = OBJ_SightGet()
//	OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), tv_sens, tf_blend_speed * TIME_GetDt())
//	, MATH_VecBlendRotate( OBJ_BankingGet(),  Cv_VerticalVector, 2.8 * TIME_GetDt()))	
	tv_pos = OBJ_PosGet() + (OBJ_BankingGet() * COL_ZoneSizeGet(C_zdm_pied))
	tv_axe = OBJ_BankingGet( ) 
	DBG_RenderVector( OBJ_PosGet(),tv_axe * 5.0, color_bleu)
	OBJ_Rotate_FromToBlend( MATH_VecGlobalToLocal( OBJ_BankingGet()) , MATH_VecGlobalToLocal( Cv_VerticalVector), 2.8 * TIME_GetDt())
	OBJ_PosSet( tv_pos - (OBJ_BankingGet() * COL_ZoneSizeGet(C_zdm_pied)))
	OBJ_BankingGeneralSet( MATH_VecBlendRotate(OBJ_SightGet(), tv_sens, tf_blend_speed * TIME_GetDt()), OBJ_BankingGet())
	
}




// ***********************************************************************************************************************************************************
// SAUT ET REMONTE PENDANT L AUTO RATRAPING
// ***********************************************************************************************************************************************************
//// Saut si Bouton et DASH ou PAS FIGHT
//if ( i_flag_just_Action && ti_jump_en_chute)
//if ( ti_jump_en_chute && i_jump_auto_rattraping)
//{
//	if( f_joy_norm)
//	{
//		tf_dot = MATH_VecDotProduct( v_joy_sight,- @o_climb_0D_wp OBJ_SightGet())
//		if ( tf_dot < -Cf_Cos80)
//		{
//			// Remonte rapide
//			macro_change_etat("k_ETAT_climb_remonte_rapide")
//		}
//	}
//}


// ANALYZE BISS
// ICI le flag jump est bon
AI_Execute("k_exec_detect_paf")
if ( o_paf_actor && i_in_jump == 2)
{
	// Refuser les paf en saut.
	PAF_Test_ChangeEtatValid(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}
