
vector	tv_pied
vector	tv_axis
vector	tv_fct_axis
vector	tv_from_pied_to_bm
vector	tv_temp_blend_axis 
vector	tv_cross

float		tf_fct_speed
float		tf_coef

tf_coef = pop
tf_fct_speed = pop
tv_fct_axis = pop

if ( MATH_VecNullEpsilon( tv_fct_axis))
	return
// Orientation autour des pieds -------------------------------------
tv_pied = MATH_VecBlend( @ao_IK_bones[0][2] OBJ_PosGet(), @ao_IK_bones[1][2] OBJ_PosGet(), tf_coef ) 
tv_pied.z = OBJ_PosGet().z
tv_from_pied_to_bm = OBJ_PosGet() - tv_pied

//DBG_RenderVector(tv_pied, tv_fct_axis*10, color_vert)

//DBG_RenderVector(tv_pied, tv_from_pied_to_bm*10, color_rouge)
//DBG_RenderSphere(tv_pied, 1.0, color_rouge)

if ( MATH_FloatNullEpsilon(f_coup_orient_sens_forceed) || MATH_VecDotProduct( OBJ_SightGet(), tv_fct_axis) >0.0)
	tv_axis = MATH_VecBlendRotate(OBJ_SightGet(), tv_fct_axis, tf_fct_speed * TIME_GetDt())
else
{
	tv_cross = MATH_VecCrossProduct(OBJ_SightGet(), tv_fct_axis)
	if ( tv_cross.z * f_coup_orient_sens_forceed <= 0.0)
		tv_axis = MATH_VecBlendRotate(OBJ_SightGet(), tv_fct_axis, tf_fct_speed * TIME_GetDt()) // Le sens est bon
	else
	{
		// Le Blend fait tourner dans le mauvais sens
		tv_temp_blend_axis = MATH_VecCrossProduct( OBJ_SightGet(), tv_cross)
		tv_axis = MATH_VecBlendRotate(OBJ_SightGet(), tv_temp_blend_axis, tf_fct_speed * TIME_GetDt() * 2.0)
	}
}
//tv_axis = MATH_VecBlendRotate(tv_from_pied_to_bm, tv_fct_axis, tf_fct_speed * TIME_GetDt())
tv_axis.z = 0
MATH_VecSetNormalize(tv_axis)

//DBG_RenderVector(tv_pied, tv_axis*10, color_jaune)

tv_from_pied_to_bm = MATH_VecGlobalToLocal(tv_from_pied_to_bm)
OBJ_Rotate_FromTo(cvector(0,-1,0), MATH_VecGlobalToLocal(tv_axis))
tv_from_pied_to_bm = MATH_VecLocalToGlobal(tv_from_pied_to_bm)

OBJ_PosSet( tv_pied +  tv_from_pied_to_bm )
// Orientation autour des pieds -------------------------------------	
