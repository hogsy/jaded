#include "k_define.var"


// RECHERCHE S4IL Y A UN POINT D ACCROCHE EN SAUT



#define	Cf_Lray_racroch_mur		8.0
#define	Cf_Lray_racroch_mur_decal	1.5
#define	Cf_offset_main_accroch	0.5		// Tolerance en Z d accroch des mains( suposées a hauteur du LRay)
#define	Cv_Offset_Lray_Detection	cvector(0.0, 0.0, 6.0)

int			ti_i
int			ti_k
int			ti_index
int			ti_nb_link
int			ti_best_jump_anim_index
int			ti_GMAT

float		tf_dot_axis
float		tf_norm
float		tf_axis_norm
float		tf_link_length
float		tf_dot_product
float		tf_best_ponderation
float		tf_cos_angle
float		tf_jump_duration
float		tf_X_dot
float		tf_Z_dot
float		tf_altitude
float		tf_hauteur_mur

object	to_ray

vector	tv_hand_pos
vector	tv_dest_pos
vector	tv_joy_dir
vector	tv_me_to_dest_pos
vector	tv_current_to_next_wp
vector	tv_link_axis
vector	tv_dest_normale
vector	tv_plan_normale
vector	tv_temp
vector	tv_reception_offset
vector	tv_offset
vector	tv_ray_normale
vector	tv_ray_dir
vector	tv_intersec_dest_pos
vector	tv_intersec_normale
vector	tv_sens
vector	tv_normale_sol 
vector	tv_dest_pos2

#define DBG_DISPLAY_INFO						1

if (o_climb_0D_wp)
	return
else if (o_climb_1D_current_wp)
	return

if (f_climb_impulsion_time && TIME_Elapsed(f_climb_impulsion_time, 0.2))
{
	o_climb_0D_last_wp = nobody
	o_climb_1D_last_current_wp = nobody
	o_climb_1D_last_next_wp = nobody
}

i_climb_jump_index = -1

tf_best_ponderation = Cf_Infinit
tf_jump_duration = 0.0 // On ne veut pas calculer la durée du saut, là on s'en fout...

tv_hand_pos = OBJ_PosGet()

if (i_climb_ponderation_mode == Ci_PONDERATION_JUMP_SLIDE)
{
	tv_hand_pos += v_climb_hand_offset

	f_joy_norm = 0.0 
	
	tv_joy_dir = DYN_SpeedGetVector()
	tf_norm = DYN_SpeedGet()

	if (tf_norm)	
	{
		tv_joy_dir /= tf_norm
		tv_plan_normale = MATH_VecCrossProduct(tv_joy_dir, OBJ_HorizonGet())
		tv_plan_normale = MATH_VecCrossProduct(tv_plan_normale, tv_joy_dir)
	}
	else
	{
		tv_joy_dir = OBJ_SightGet()
		tv_plan_normale = OBJ_HorizonGet()
	}
}
else if (i_climb_ponderation_mode == Ci_PONDERATION_JUMP_IMPULSION)
{
	tf_cos_angle = Cf_Cos80

//	tv_joy_dir = v_joy_sight_normalized
	// HOT SPOT
	AI_Execute( "k_exec_check_hotspot")
	tv_joy_dir = pop
	// o_jump_hotspot
	tv_plan_normale = MATH_VecCrossProduct(tv_joy_dir, Cv_VerticalVector)
}

#ifdef DBG_DISPLAY_INFO
macro_render_Vector(tv_hand_pos, tv_joy_dir * 10.0, color_vert)
macro_render_Vector(tv_hand_pos, tv_plan_normale * 10.0, color_rouge)
macro_render_Cone(tv_hand_pos, tv_joy_dir * 10.0, Cf_PiBy6, 0x20808080)
#endif



// **************************************************************
// SI NECESSAIRE, ON RECHERCHE LA CORNICHE
// **************************************************************

if (o_climb_0D_wp == nobody && o_climb_1D_current_wp == nobody)
{
	
	// TEST DE PHASE DESCENDANTE
	tv_sens = OBJ_PosGet()
	tv_sens += v_climb_hand_offset
	tv_sens -= v_last_hand_pos 
	if ( tv_sens.z < 0)
	{

		// Calcul de l orientation du LRAY principâl selon les cas
		// Si le joy n'est pas défini, par défaut on conserve l'orientation du dernier LRAY ou le sight s'il n a jamais était défni
		if (i_climb_ponderation_mode == Ci_PONDERATION_CLIMB_SLIDE)	
		{
			// Pas sur que meme ds le cas des non généré il faut qu'1 seul LRAY
			if ( !i_WP_generated)
				tv_ray_dir = -v_climb_normale
			else
				tv_ray_dir = v_joy_sight_normalized
			if (@get_global f_joy_norm)
				v_jump_last_joy_vector = tv_ray_dir 
			else
				tv_ray_dir  = v_jump_last_joy_vector
		}
		else if (@get_global f_joy_norm)
		{
			tv_ray_dir = v_joy_sight_normalized
			v_jump_last_joy_vector = tv_ray_dir 
		}
		else
			tv_ray_dir  = v_jump_last_joy_vector
		
		// 4 lancés de rayon orthogonaux
		for (ti_i = 0; ti_i < 4; ti_i++)
		{
			
			macro_render_Vector( ( OBJ_PosGet() + Cv_Offset_Lray_Detection) -(tv_ray_dir * Cf_Lray_racroch_mur_decal), tv_ray_dir* Cf_Lray_racroch_mur, color_blanc)
	 
			to_ray = COL_RayObject_Dist( ( OBJ_PosGet() + Cv_Offset_Lray_Detection) - ( tv_ray_dir * Cf_Lray_racroch_mur_decal), tv_ray_dir, Cf_Lray_racroch_mur, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			if ( to_ray)
			{
				// Un mur de ce coté			
				ti_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)
				if ( !( ti_GMAT  & Gmat_KK_Accrochage_interdit))
				{
					// ACCROCHAGE PERMIS	
					tv_ray_normale = COL_RayObject_NormalGet()
		#ifdef DBG_DISPLAY_INFO
					macro_render_Vector(OBJ_PosGet(), COL_RayObject_PosGet() - OBJ_PosGet(), color_cyan)
		#endif
		
					if (tv_ray_normale.z < Cf_Kong_Angle_Mur_sol && tv_ray_normale.z > -Cf_Kong_Angle_Mur_sol)
					{
						// REGARDER SI L ON POURRA REMONTER AU DESSUS
						tv_dest_pos = COL_TipTopPointGet(Cv_VerticalVector, Cf_largeur_Kong, faux, vrai, faux, vrai)
						tv_ray_normale = COL_RayObject_NormalGet()
						tv_normale_sol = COL_RayObject_EdgeNormalGet()		// Normale du sol !!
						if ( tv_normale_sol.z < Cf_Kong_Angle_Mur_sol)
							break		// C'est un mur ou un sol inversé !!
							
						// REGARDER SI L ON A ASSEZ DE PROFONDEUR POUR S ACCROCHER
						tv_dest_pos2 = COL_TipTopPointGet(-Cv_VerticalVector, Cf_largeur_Kong, faux, vrai, faux, vrai)
						if ( tv_dest_pos.z - tv_dest_pos2.z < Cf_Hauteur_Mini_Accroch )
						 	break		// Le sol est trop proche
						
		#ifdef DBG_DISPLAY_INFO
						macro_render_Vector(tv_dest_pos, tv_ray_normale, color_rouge)	
		#endif	
						@o_climb_target_wp OBJ_PosSet(tv_dest_pos)
						@o_climb_target_wp OBJ_SightGeneralSet(-tv_ray_normale, Cv_VerticalVector)
						tv_reception_offset = @o_climb_target_wp MATH_VecLocalToGlobal(av_climb_hand_offset[6][Ci_Climb_Offset_Jump])
			
						switch(i_climb_ponderation_mode)
						{
							case Ci_PONDERATION_JUMP_SLIDE :
			
								// TEST DES MAINS PROCHE en Z du point d accroch
								tv_hand_pos = OBJ_PosGet() + Cv_Offset_Lray_Detection
								if (MATH_AbsFloat( tv_hand_pos.z - tv_dest_pos.z) < Cf_offset_main_accroch)
								{
									// Joy dans le sens de la corniche a attraper : validé !!
									v_climb_position = tv_dest_pos	
									v_climb_normale = tv_ray_normale
									v_climb_hand_offset = tv_reception_offset
								
									i_climb_jump_index = 0
									o_climb_0D_wp = o_climb_target_wp
									o_climb_0D_Wall = to_ray
								}
								// STEPH VIOLENT
								break
						}
					}
				}
			}
	#ifdef DBG_DISPLAY_INFO
			else
			{
				macro_render_Vector(OBJ_PosGet() - tv_ray_dir, tv_ray_dir * 10.0, color_cyan)
			}
	#endif		
	
			// A PART EN SAUT ON NE FAIT QU'UN LANCER DE RAYON
			if (o_climb_0D_wp 
			|| ( i_climb_ponderation_mode != Ci_PONDERATION_JUMP_SLIDE 
			&& i_climb_ponderation_mode != Ci_PONDERATION_CLIMB_SLIDE))
				break
	
			switch(ti_i)
			{
				case 0 :
					// DROITE
					tv_ray_dir = MATH_VecCrossProduct(tv_ray_dir, Cv_VerticalVector)
					break
				
				case 1 :
					// GAUCHE
					tv_ray_dir *= -1.0
					break
	
				case 2 :
					// DERRIERE SI PAS DE JOY
	//				if (@get_global f_joy_norm)
						ti_i = 4
	//				else
	//					tv_ray_dir = MATH_VecCrossProduct(Cv_VerticalVector, tv_ray_dir)
					break
			}
						
		}
	}
	if (o_climb_0D_wp == nobody && o_climb_1D_current_wp == nobody)
	{
		v_climb_position = tv_hand_pos
		if( !i_WP_generated)
			tv_joy_dir -= MATH_VecDotProduct(tv_joy_dir, OBJ_SightGet()) * OBJ_SightGet()
		v_climb_position += tv_joy_dir * 100.0

		if (i_climb_jump_index == -1)
		{
			// ON RECHERCHE LA MEILLEURE POSITION DE SAUT
			tf_X_dot	= MATH_VecDotProduct(tv_joy_dir, OBJ_HorizonGet())
			tf_Z_dot	= MATH_VecDotProduct(tv_joy_dir, OBJ_BankingGet())
		
			if (tf_Z_dot > Cf_Cos30)
				ti_best_jump_anim_index = 0									// VERS LE HAUT
			else if (tf_Z_dot >= -Cf_Cos80)
			{	if (tf_X_dot > 0.0)	ti_best_jump_anim_index = 1		// VERS EN HAUT A GAUCHE
				else ti_best_jump_anim_index = 2}							// VERS EN HAUT A DROITE
			else if (tf_Z_dot > -Cf_Cos30)
			{	if (tf_X_dot > 0.0) 	ti_best_jump_anim_index = 4		// VERS EN BAS A GAUCHE
				else ti_best_jump_anim_index = 5}							// VERS EN BAS A DROITE
			else
				ti_best_jump_anim_index = 3									// VERS LE BAS
		
			i_climb_jump_index = ti_best_jump_anim_index
		}
	}
}