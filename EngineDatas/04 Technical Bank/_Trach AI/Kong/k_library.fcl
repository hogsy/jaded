#include"k_define.var"
Include_UltraProcedure_Header

procedure_local void RAGE_Increase();
procedure_local object HOTSPOT_Detect( vector pv_sens, int pi_fight_HS);
procedure_local void COUP_CHANGE_To_Pillar( object po_pillar , int pi_anim);
procedure_local int RIDE_Get_Actor_Nb();
procedure_local void DASH_O_FIGHT_ACTOR_Validate(object to_fight_actor_old);
procedure_local void Proc_KK_SFX_Ring( vector pv_pos, vector pv_normal);
procedure_local void Proc_KK_SFX_Splash( vector pv_pos, vector pv_normal);
procedure_local void FINISH_Reset_Count( int	pi_val );

// Init MECA
procedure_local void Proc_KK_DynOn()
{
	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces + DYN_C_SlipOnGroundEdge + DYN_C_HorizontalGrounds + DYN_C_VectorFriction + DYN_C_GlobalFriction + DYN_C_SkipFrictionWhenSpeedFromAnim, none)
	DYN_GravitySet(Cv_Kong_Gravity)
	DYN_MaxStepSet(Cf_max_step)
	ODE_Enable(vrai)
}

procedure_local void Proc_KK_Rumble_Fort()
{
	IO_PafSet( 100, 12)
}

procedure_local void Proc_KK_Rumble_Moyen()
{
	IO_PafSet( 100, 8)
}


procedure_local int Proc_KongFight_TargetBestSightGet( vector pv_pos, byref vector pv_axis, float pf_cos, float pf_dist_min, float pf_dist, byref object po_gao, int pi_dont_chose_gao, float pf_prio_min, float pf_prio_max, int pi_bit)
{
   // ----------------------------------------------------------------
   // In :      	Pos
   // 			Axis du joy (By REF) modifié par la fonction si on a une reorientation
   //			Cos de l'angle du cone
   // 			Distance du cone
   // 			Perso qu'on Fight (By REF) (o_fight_actor)
   //			Prio Min
   //			Prio Max
   //			Bit
   // Out :   	Indice dans le tableau de l'élement selectionné
   //           	Axis modifié (si target)
   // 			Gao modifié (si target)
   // ----------------------------------------------------------------         

    vector		tv_pos, tv_cross, tv_pos_best, tv_kamera_horizon, tv_axis_N,v
    int			ti_loop, ti_nbr_of_item, ti_item_best, ti_trace
    float		tf_dist, tf_dot, tf_kamera_dot, pf_volume, tf_prio
    float		tf_dot_best, tf_dot_pond, tf_dot_pond_best
    object	to_kamera, po_obj, po_target
   	
   	// ETRE PLUS TOLERENT SUR LES COTES DE LA KAMERA -----------------------------------
	tv_axis_N = MATH_VecNormalize(pv_axis)

//	to_kamera = VIEW_GetObject(0)
//	tv_kamera_horizon = @to_kamera OBJ_HorizonGet()
//	tf_kamera_dot = MATH_AbsFloat(MATH_VecDotProduct(tv_kamera_horizon, tv_axis_N))	// de 0.0 à 1.0
//	tf_kamera_dot /= 3.0		// 0.0 à 0.33
//	tf_kamera_dot +=1.0		// 1.0 à 1.33
//	pf_cos *= tf_kamera_dot
//	pf_cos = MATH_FloatMin(pf_cos, 1.0)		// ne pas dépasser 1.0 !!!
	
	// PARCOURS DES ELEMENTS TARGETTABLES -------------------------------------------------------
	ti_nbr_of_item = @get_global i_KongFight_TargetAddNbrOfItem
	tf_dot_pond_best = -Cf_Infinit
	ti_item_best = -1
	for (ti_loop = 0; ti_loop < ti_nbr_of_item; ti_loop++)
	{
		// Test de Prio
		ti_trace = faux
		po_target = @get_global o_KongFight_TargetAddGao[ti_loop]
		if ( @po_target AI_IsModel(get_PNJ_KBats_path) && ( ! @po_target KBC_IsABigBat() || @po_target KBC_IsGrabbingAnn() ) )
			continue		// empêcher de viser une bat qui grabbe ann
		tf_prio = @get_global f_KongFight_TargetAddPrio[ti_loop]
		if( tf_prio >= pf_prio_min && tf_prio <= pf_prio_max )
		{
			// Test d affichage
			#ifndef _FINAL_
			if( i_DBG_TRACE_TARGET )
			{
				if( tf_prio == C_AIDE_AU_TIR_Prio_GrabAnn )
					ti_trace = vrai
				if( ti_trace )
				{
					DBG_TraceObject(po_target)
					DBG_TraceString("a la prio GRAB ANN")
					DBG_TraceEOL()
				}
			}
			#endif
			
			if( (pi_bit & C_AIDE_AU_TIR_Bit_Only_On_Screen)
				&& tf_prio != C_AIDE_AU_TIR_Prio_GrabAnn
				&& tf_prio != C_AIDE_AU_TIR_Prio_AttackAnn )
			{
				// On Screen (sauf pour Attack Ann et Grab Ann
				pf_volume = @get_global f_KongFight_TargetAddSize[ti_loop]
				v = VIEW_3dWorldTo2d( 0, @get_global v_KongFight_TargetAddPos[ti_loop ] )
				if ( (v.z < 0) || ( (v.x <= 0 || v.x >= 1) || (v.y <= 0 || v.y >= 1 ) ) )
				{
					#ifndef _FINAL_
					if( ti_trace )
					{
						DBG_TraceObject(po_target)
						DBG_TraceString("est hors écran")
						DBG_TraceEOL()
					}
					#endif
					continue
				}
			}
			// Test de Distance
			tf_dist = MATH_LIB_ZoneInCone(pv_pos, pv_axis, pf_cos, pf_dist, @get_global v_KongFight_TargetAddPos[ti_loop], @get_global f_KongFight_TargetAddSize[ti_loop], vrai, tf_dot, 0, 0)
			if( tf_dist > pf_dist_min || ( tf_prio == C_AIDE_AU_TIR_Prio_GrabAnn && tf_dist > 3.0 ) )
			{
				// C'est OK dans le Cone (dist diminuée pour Grab Ann)
				tf_dot_pond = tf_dot - (tf_dist / 10)
				if ( pi_bit & C_AIDE_AU_TIR_Bit_Use_Prio)
					tf_dot_pond += tf_prio / 10
				if (tf_dot_pond > tf_dot_pond_best)
				{
					tf_dot_best = MATH_FloatMax(tf_dot, pf_cos)
					tf_dot_pond_best = tf_dot_pond
					ti_item_best = ti_loop
					tv_pos_best = @get_global v_KongFight_TargetAddPos[ti_loop]
					#ifndef _FINAL_
					if( ti_trace )
					{
						DBG_TraceObject(po_target)
						DBG_TraceString(" est temporairement le best...")
						DBG_TraceEOL()
					}
					#endif
				}
			}
			else
			{
				#ifndef _FINAL_
				if( ti_trace )
				{
					DBG_TraceObject(po_target)
					DBG_TraceString(" : dist trop proche : ")
					DBG_TraceFloat(tf_dist)
					DBG_TraceString(" < ")
					DBG_TraceFloat(pf_dist_min)
					DBG_TraceEOL()
				}
				#endif
			}
		}
	}
	// INIT SELECTED TARGET ------------------------------------------------------------------------------------
    if (ti_item_best != -1)
    {
	    tv_cross = MATH_VecCrossProduct(pv_axis, Cv_VerticalVector)
        tf_dot_best = MATH_FloatLimit(tf_dot_best, -1.0, 1.0)
        pv_axis = MATH_VecRotate(pv_axis, Cv_VerticalVector, MATH_ACos(tf_dot_best) * -MATH_FloatSign(MATH_VecDotProduct(tv_cross,tv_pos_best-pv_pos)) )
		po_gao = @get_global o_KongFight_TargetAddGao[ti_item_best]
		#ifndef _FINAL_
		if( i_DBG_TRACE_TARGET )
		{
			DBG_TraceString("SELECTED GAO = ")
			DBG_TraceObject(po_gao)
			DBG_TraceEOL()
		}
		#endif
	}
    return	ti_item_best
}

// Retourne vrai si l'acteur est un ennemi assez resistant pour déclencher les FX 
procedure_local int Proc_KK_PafHimTriggersFX(object to_actor)
{
	messageid		tmid_life
	int					ti_life_test

	ti_life_test = faux
	tmid_life = EVENT_LIFE_MSGID_Get(to_actor)
	if( to_actor && @to_actor OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) )
	{
		if( @to_actor AI_IsModel(get_PNJ_KTREX_Path) )
			ti_life_test = vrai
		if( @to_actor AI_IsModel(get_PNJ_KBats_path) && @to_actor KBC_IsABigBat() )				// BIG BAT
			ti_life_test = vrai
		if( @to_actor AI_IsModel(get_PNJ_Scolo_Path) && @to_actor Proc_KK_BigScolo() )		// BIG SCOLO
			ti_life_test = vrai
	}
	if( ti_life_test && MSG_GlobalIsValid(tmid_life) && EVENT_LIFE_CurLifeGet(tmid_life) > 0.0 )
		return vrai
	else
		return faux
}

procedure_local void Proc_KK_Send_Paf( int EVT_func_Filter, int EVT_func_Type, object EVT_func_Pere, float EVT_func_DureeDeVie, object EVT_func_Target, int EVT_func_Canal, float EVT_func_Puissance, vector EVT_func_Sens, vector EVT_func_position)
{
	messageid		tmid_life
	if( mi_PaffedODEThisSwing )
		return		// je viens de détruire une structure ODE donc je ne paffe pas les autres persos...
	if( i_etat_courant != ETAT_Kong_desequilibre )		// RAGE ET FX : ne pas compter les pafs envoyés de dos pendant qu'on prend un paf
	{
		// RAGE
		tmid_life = EVENT_LIFE_MSGID_Get(EVT_func_Target)
		if( MSG_GlobalIsValid(tmid_life) && EVENT_LIFE_CurLifeGet(tmid_life) > 0.0 )
		{
			 RAGE_Increase()		// la rage (ou la furie) n'augmente que si le perso paffé est vivant
		}
		
		// FX
		if( Proc_KK_PafHimTriggersFX(EVT_func_Target) )
		{
			// BLUR EFFECT
			if( EVT_func_Type & ( C_PAF_KK_Moyen | C_PAF_KK_Fort ) )
				@get_global Proc_AE_ZoomSmoothCenterSet( 2.5, @o_tete[0] OBJ_PosGet() - @get_Kamera OBJ_PosGet() )
			
			// SHAKE KAM ---------------------------------------------------
			//fracasse				LIBGFX_CheckCam( 0.09, 35.0, 0.0, 0.0, 0.15, 1.1)
			//jump reception		LIBGFX_CheckCam( 0.05, 35.0, 0.0, 0.0, 0.15, 1.1)
			//swing arch			LIBGFX_CheckCam( 0.05, 35.0, 0.0, 0.0, 0.15, 1.1)
			//paf ecrasement		LIBGFX_CheckCam( 0.05, 35.0, 0.0, 0.0, 0.15, 1.1)
			if( EVT_func_Type & C_PAF_KK_Fort )
				LIBGFX_ShakeCam( 0.075, 35.0, 0.0, 0.0, 0.15, 1.1)
			else if( EVT_func_Type & C_PAF_KK_Ecrasement )
				LIBGFX_ShakeCam( 0.05, 35.0, 0.0, 0.0, 0.15, 1.1)
			else if( EVT_func_Type & C_PAF_KK_Moyen )
				LIBGFX_ShakeCam( 0.025, 35.0, 0.0, 0.0, 0.15, 1.1)
		}
	}
	
	// RUMBLE
	if( Proc_KK_PafHimTriggersFX(EVT_func_Target) )
		Proc_KK_Rumble_Fort()
	
	EVENT_AddEventPafCanal( EVT_func_Filter, EVT_func_Type, EVT_func_Pere, EVT_func_DureeDeVie, EVT_func_Target, EVT_func_Canal, EVT_func_Puissance, EVT_func_Sens, EVT_func_position)
//	if( Proc_KK_EstUnEnnemiDeKong(EVT_func_Target) )
//		STATS_IncAttack()
}


procedure_local int	Proc_KK_Corner()
{
	int	ti_nbr 
	int	ti_ii
	int	ti_valid
	int to_col1
	int	ti_Gmat
	int	ti_flag
	int	mti_tab_wall[20]
	object	mto_col

	if ( !COL_CollideType(COL_C_Corner))
		return 0
	ti_nbr = COL_ReportsNumberAndRanksGet( &mti_tab_wall[0], 20, COL_C_Wall )
	if( ti_nbr )
	{
		// Recup du rapoort de colision 
		ti_valid = 0
		ti_ii = 0
		while ( ti_ii < ti_nbr )
		{
			mto_col = COL_ObjectGet( COL_C_ReportIndex + mti_tab_wall[ti_ii] )
			if ( mto_col && @mto_col OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_AI))
				return 0
			ti_flag = COL_ReportFlagGet(COL_C_ReportIndex + mti_tab_wall[ti_ii] )
			if( ti_flag & (  COL_C_Extra_Corner |  COL_C_Extra_ODE |  COL_C_Extra_SlipperyEdge)) // | COL_C_Corner | COL_C_Edge))
			{
				// Face a la con : on oublie
				ti_ii = ti_ii
			}
			else
			{	
				ti_Gmat = COL_GMAT_FlagsGet( COL_C_ReportIndex + mti_tab_wall[ti_ii])
				// Walling interdit par le GMAT de cette face		
				if ( !( ti_Gmat & Gmat_KK_Face_de_Walling))
				{
					if ( ti_Gmat & Gmat_KK_Crossable_Walling)
						ti_ii = ti_ii // Face de walling mais avec bit traversable en walling : on l oublie
//					else if ( ti_Gmat & Gmat_KK_Cross_All_But_Kong_And_Raptors)
//						return 0
//					else if ( ti_Gmat & Gmat_KK_Cross_All_But_Kong_Only)
//						return 0
					else
						return 0
				}
//				else if ( ti_Gmat & Gmat_Walling_interdit)
//					return 0
				else if ( ti_Gmat & Gmat_KK_Face_de_Walling)
					ti_valid = 1	// QD CORNER et Walling interdit étaient accepté
			}
			ti_ii++
		}
//		if ( ti_ii == ti_nbr)
		if ( !ti_valid) 			// QD CORNER et Walling interdit étaient accepté
			return 0
		else
			return 1
	}	
	else
		return 0	
}

procedure_local void COUP_CHANGE_To_Return( );

procedure_local void RAGE_Launch_Action(int pi_action)
{
	if ( pi_action)
		ACT_ActionSet(pi_action)
	COUP_CHANGE_To_Return()
}


procedure_local void RAGE_Launch(int pi_action)
{
	RAGE_Launch_Action(pi_action)
	f_fury_charge = 1.0	// VALEUR SEUIL DE DECLANCHEMENT FURY
//	f_fury_afx_coef = 0.0
	if( EVENT_LIFE_Est_Blesse(ID_LIFE) )
		f_time_fury = Cf_Fury_Duration_Bleeding
	else
		f_time_fury = Cf_Fury_Duration_Normal
	f_time_fury += Cf_Fury_Init_Bonus_Anim		// durée de l'anim pendant laquelle on ne profite pas de la furie
	i_fury_on = vrai
	mid_fury = EVENT_AddEventFury( OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_SightGet(), f_fury_puissance, f_fury_angle, Ci_KK_Fury_Type_Roar)
}

procedure_local void RAGE_Launch_Reward(object po_gao)
{
	if( po_gao && ! Proc_KK_Get_BIG_NMI_Count(po_gao)
	&&( ( @po_gao AI_IsModel(get_PNJ_KTREX_Path) && @po_gao KT_Proc_IsRewardForKONG())
		|| ( @po_gao AI_IsModel(get_PNJ_Scolo_Path) && @po_gao Proc_KS_Scolo_Launch_Reward())
		|| ( @po_gao AI_IsModel(get_PNJ_KBats_path) && @po_gao KBC_Launch_Reward()) )
	)
	{
		i_request_txt_forced = GeneKon_C_reward_roar
		RAGE_Launch_Action( Ci_Kanim_Intimid_FinishFurieReward)		// Lance l'action mais pas l'effet Fury
		EVENT_LIFE_CurLifeSet(ID_LIFE, EVENT_LIFE_MaxLifeGet(ID_LIFE))
		FINISH_Reset_Count( -1)
	}
	else
	{
		RAGE_Launch_Action( Ci_Kanim_Intimid_FinishFurieCri)			// Lance l'action mais pas l'effet Fury
		if ( ! Proc_KK_Get_BIG_NMI_Count(po_gao))
		{
			EVENT_LIFE_CurLifeSet(ID_LIFE, EVENT_LIFE_MaxLifeGet(ID_LIFE))
			FINISH_Reset_Count( -1)
		}
	}
}

procedure_local void RAGE_Maximise(float tf_max)
{
	f_time_fury = MATH_FloatMin(f_time_fury, tf_max)
}

procedure_local void RAGE_Increase()
{
	messageid	tmid_msgid
	if( ! i_fury_increased_this_action )
	{
		i_fury_increased_this_action = vrai
		if ( f_time_fury)
		{
			f_time_fury += Cf_Fury_Increasing_Time						// Le temps de fury augmente
			if( EVENT_LIFE_Est_Blesse(ID_LIFE) )
				f_time_fury = MATH_FloatMin(f_time_fury, Cf_Fury_Duration_Bleeding)
			else
				f_time_fury = MATH_FloatMin(f_time_fury, Cf_Fury_Duration_Normal)
		}
		else
		{
			f_fury_charge += Cf_Rage_Increasing_Factor				// Cas général de monté de jauge de rage
			if ( i_blesse_on)
				f_fury_charge += Cf_Rage_Increasing_Factor			// Kong blessé, la jauge monte plus vite
			tmid_msgid = EVENT_LIFE_MSGID_Get( ao_frappe_target[i_frappe_target_nb])
			if ( MSG_GlobalIsValid( tmid_msgid) && EVENT_LIFE_Est_Blesse( tmid_msgid))
				f_fury_charge += Cf_Rage_Increasing_Factor			// Cible blessée, la jauge monte plus vite
			if ( MSG_GlobalIsValid( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT])
			&& LNK_KKGrabObject_TypeGet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT]) & Ci_KKGrabObject_Porte_Epaule)
				f_fury_charge += Cf_Rage_Increasing_Factor			// Kong a Ann, la jauge monte plus vite
			if ( ( i_frappe_coup != Ci_Frappe_Ga_Coup_3 && i_frappe_coup != Ci_Frappe_Dr_Coup_3 ) && f_fury_charge > Cf_Fury_Cap)
				f_fury_charge = Cf_Fury_Cap - Cf_Rage_Increasing_Factor
		}
	}
}

procedure_local object	WALLING_DETECT_LIANE()
{
	int			mti_i
	object	mto_liane
	vector	tv_axe
	
	for( mti_i = 0; mti_i < @get_list_manager i_KK_Liane_nb; mti_i++)
	{
		// Parcours des Lianes
		mto_liane = @get_list_manager ao_KK_Liane_wp[mti_i]	          
		if ( COL_Pivot_BVCollide( mto_liane) 
		&& ( COL_ObjectGet( COL_C_Wall) || i_etat_courant == ETAT_Kong_walling))
		{
			tv_axe = COL_ZonePosGet(C_zdm_pied) - @mto_liane OBJ_PosGet()
			tv_axe.z = 0.0
			if ( MATH_AbsFloat( MATH_VecDotProduct( @mto_liane OBJ_HorizonGet( ), tv_axe)) < MATH_FloatMax( 1.0, @mto_liane OBJ_ScaleGet().x * 0.2) 
			&& MATH_AbsFloat( MATH_VecDotProduct( @mto_liane OBJ_SightGet( ), tv_axe)) < ( COL_ZoneSizeGet(C_zdm_pied) + 1.0))
			{
				// On est a 1m de la liane : valide
				return( mto_liane)
			}
		}
	}
	return nobody
}

procedure_local int	WALLING_Test_Valid()
{																													
	int			mti_col, mti_walling_grimper, mti_nbr, mti_i, mti_tab_wall[20], mti_Gmat, mti_walling_allowed, ti_collision_valide
	int			ti_i, ti_nbr, ti_Gmat, ti_flag
	int			ti_tab_wall[20]
	float		pf_dot_max, pf_dot
	vector	mtv_sol, tv_walling_normal	, mtv_sight																																	
	object	mto_col, mto_liane
	object	to_col1, to_col2
	
	// DETECTION CORNER																				
	if ( !i_walling_force_no_detection)																			
	{
		mti_walling_grimper = faux	

		if ( COL_CollideType(COL_C_Ground))
			mtv_sight = v_joy_sight														
		else
			mtv_sight = OBJ_SightGet()

		o_walling_liane = WALLING_DETECT_LIANE()																												
		if ( o_walling_liane && glob_joynorm_get)
		{
			ti_nbr = COL_ReportsNumberAndRanksGet( &mti_tab_wall[0], 20, COL_C_Wall )
			// Recup du rapoort de colision 
			ti_i = 0
			while ( ti_i < ti_nbr )
			{
				mto_col = COL_ObjectGet( COL_C_ReportIndex + mti_tab_wall[ti_i] )
				if ( mto_col && @mto_col OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_AI))
				{
					ti_i++	// Mur IA pas valide
					continue
				}
				ti_flag = COL_ReportFlagGet(COL_C_ReportIndex + mti_tab_wall[ti_i] )
				if( ti_flag & (  COL_C_Extra_Corner |  COL_C_Extra_ODE |  COL_C_Extra_SlipperyEdge))
				{
					ti_i++
					continue
				}
				else
				{	
					ti_Gmat = COL_GMAT_FlagsGet( COL_C_ReportIndex + mti_tab_wall[ti_i])
					// Walling interdit par le GMAT de cette face		
					if ( ti_Gmat & Gmat_KK_Face_de_Walling)
					{
						mti_walling_grimper = vrai	
						break
					}
				}
				ti_i++
			}
		}

		if ( COL_CollideType(COL_C_Corner))		
		{	
			if ( ! mti_walling_grimper && !Proc_KK_Corner())														
				return 0
			tv_walling_normal = COL_NormalGet( COL_C_Corner)	
			tv_walling_normal.z = 0								
			if ( MATH_FloatNullEpsilon( glob_joynorm_get))
				mtv_sight= tv_walling_normal // -OBJ_BankingGet()																
			if ( MATH_VecDotProduct( -tv_walling_normal, mtv_sight) > 0.0)					
				mti_walling_grimper = vrai																		
		}
		

		ti_collision_valide = faux
//		if  ( ! COL_CollideType(COL_C_SlipperyEdge))
		{
			to_col1 = COL_BestWallGaoGet( mtv_sight, &mti_col)
			if  ( f_time_collide_ground > Cf_delay_ground_col_tolerance && to_col1 )
				ti_collision_valide = vrai
//			else
//			{
//				DBG_TraceString("WALLING CANCEL : no wall while jumping")
//				DBG_TraceEOL()
//			}
			if ( !ti_collision_valide)
			{
				to_col2 = COL_BestAngleWallGaoGet( mtv_sight, Cf_Cos70, &mti_col)
				if ( to_col2 && (COL_GMAT_FlagsGet( COL_C_ReportIndex + mti_col) & Gmat_KK_Crossable_Walling))
				{
					// Et merde la face la plus dans l axe est traversable...se tapper tous les rapport de col pour en chercher une falide.
					i_WALLING_DBG_nbRapport = COL_ReportsNumberAndRanksGet( &ti_tab_wall[0], 20, COL_C_Wall )
					// COL INFOS
					pf_dot_max = 1.0
					for ( ti_i = 0; ti_i < i_WALLING_DBG_nbRapport ; ti_i++ )
					{
						pf_dot = MATH_VecDotProduct( COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[ti_i] ), mtv_sight)
						if ( pf_dot < pf_dot_max 
						&& !(COL_GMAT_FlagsGet( COL_C_ReportIndex + ti_tab_wall[ti_i]) & Gmat_KK_Crossable_Walling)
						&& !(COL_ReportFlagGet( COL_C_ReportIndex + ti_tab_wall[ti_i]) & COL_C_Corner))
						{
							pf_dot_max = pf_dot
							mti_col = ti_tab_wall[ti_i]
						}
					}
				}
				if  ( ( i_flag_trample_old || i_dash_for_walling || ! MATH_FloatNullEpsilon(glob_joynorm_get) )
				&& to_col2 )
					ti_collision_valide = vrai					
			}
		}
		
		if ( ti_collision_valide)
		{
			mto_col = COL_ObjectGet( COL_C_Wall)
			if ( mto_col && @mto_col OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_Anims))
				return 0
			mti_Gmat = COL_GMAT_FlagsGet( COL_C_ReportIndex + mti_col) 				
			if ( COL_CollideType(COL_C_Corner) 
			|| ( mti_Gmat & Gmat_KK_Face_de_Walling)
			|| ( mti_walling_grimper && o_walling_liane) )		// Si liane on oublie le Walling interdit
			{														
				v_walling_normal = COL_NormalGet( COL_C_ReportIndex + mti_col)					
				if ( MATH_VecNullEpsilon( v_walling_normal))
					return 0
					
				// DETECTION SPECIALE APRES WALLING													
				mti_walling_allowed = faux																			
				if ( TIME_Elapsed( f_walling_quit, 0.2))
					mti_walling_allowed = vrai
				else
					mti_walling_allowed = mti_walling_allowed
					
				if ( mti_walling_allowed && MATH_VecDotProduct( mtv_sight, -v_walling_normal) >= Cf_Cos90)
				{ 
					// Bon Orientation // au mur																		
					mtv_sol = COL_TipTopPointGet( Cv_VerticalVector, 0.0, faux, faux, faux, vrai)	
					if ( !MATH_VecNullEpsilon(mtv_sol) // && mtv_sol.z > (OBJ_PosGet().z + 8.0) 
					&& (ACT_ActionGet() == Ci_Kanim_saute_cycl || ( f_walling_speed_in > 8.0 
					|| ( mti_walling_allowed || mti_walling_grimper)))	)
					{	
						// Il y a assez de mur pour la montée au dessus de la hauteur mini de Walling	
						return 1	
					}
				}
			}
		}
	}
	return 0		
}

procedure_local vector WALLING_Force_Sens( int pi_force_sens, vector pv_joy_sens)
{
	float		tf_inversion
	vector	tv_temp1
	vector	tv_temp2
	vector	tv_joy
	// Limitation du sens de deplacement
	tv_joy = pv_joy_sens
	if ( pi_force_sens)
	{
		if ( pi_force_sens == 1)
		{
			// Force gauche
			if ( MATH_VecDotProduct( MATH_VecCrossProduct( Cv_VerticalVector, v_walling_normal), pv_joy_sens) < 0.0)
				tv_joy = Cv_NullVector			// Le joueur ne doit pas aller a gauche					
		}	
		else if ( pi_force_sens == 2)
		{
			// Force droite
			if ( MATH_VecDotProduct( MATH_VecCrossProduct( Cv_VerticalVector, v_walling_normal), pv_joy_sens) > 0.0)
				tv_joy = Cv_NullVector			// Le joueur ne doit pas aller a droite									
		}	
		else
		{
			// Interdit Droite et Gauche
			tv_joy = Cv_NullVector
		}		
	}
	return tv_joy
}

//procedure_local void Genere_ODE_Punch( vector plv_pos, vector plv_sens)
//{
//	if ( o_ODE_Punch)
//	{	
//		@o_ODE_Punch OBJ_PosSet( plv_pos ) //OBJ_PosGet() - (OBJ_SightGet() * 1.5)+ cvector( 0.0, 0.0, 1.0))
//		@o_ODE_Punch ODE_Setv( 0, plv_sens) // (OBJ_SightGet() + (OBJ_BankingGet() * 0.5)) * 20.0)
//		@o_ODE_Punch ODE_Enable( vrai)
//		v_ODE_Punch_init_pos = OBJ_PosGet()
//	}
//}

procedure_local vector	K_Target_Assist()
{
	vector	tv_1
	vector	tv_2
	if ( glob_joynorm_get)
		v_frappe_sight = v_joy_sight
	else
		v_frappe_sight = v_look_direction
	if ( MATH_VecDotProduct( v_look_direction, v_frappe_sight) > 0.0)
		v_frappe_sight = v_look_direction
		
	if ( o_fight_actor)
	{
		tv_2 = @o_fight_actor COL_ZonePosGet( C_zde_corps) - OBJ_PosGet()
		MATH_VecSetHorzNormalize( tv_2 )
		DBG_RenderVector( OBJ_PosGet(), tv_2, color_bleu)
		if ( @o_fight_actor COL_HasZone( C_bit_zde_tete) )
		{
			tv_1 = @o_fight_actor COL_ZonePosGet( C_zde_tete) - OBJ_PosGet()
			MATH_VecSetHorzNormalize( tv_1 )
			DBG_RenderVector( OBJ_PosGet(), tv_1, color_vert)
			if ( MATH_VecDotProduct( v_frappe_sight, tv_1) > MATH_VecDotProduct( v_frappe_sight, tv_2))
				v_frappe_sight = tv_1
			else
				v_frappe_sight = tv_2
		}
		else if ( MATH_VecDotProduct( v_frappe_sight, tv_2) > 0.0)
			v_frappe_sight = tv_2

	}
	return v_frappe_sight
}

procedure_local void v_SetupFaillureJump(vector pv_jumpDir)
{
	f_time_collide_ground = 0.0 												// Forcer un saut
	i_jump_force_keep_Z_speed = faux										// Conserver la Vitesse en Z
	f_jump_force_distance = 1.0												// Distance Saut
	i_jump_force_no_impulsion = vrai										// On ne desire pas une anim d impulsion
	i_jump_force_anim_cycl = 56
	i_jump_check_hotspot = faux												// On peux enchainer les HOT SPOT
	i_jump_check_hotspot_fight = faux										// On peux enchainer sur un ennemi
	i_jump_force_accroch = faux												// On peux essayer d accrocher le mur
	DYN_SpeedSetVector( pv_jumpDir )
	DBG_RenderVector(OBJ_PosGet(),pv_jumpDir,color_cyan)
}



procedure_ultra int	LIb_Kong_Attack( object po_object)
{
	vector	pv_sens
	if ( ! OBJ_CapaTest( Capa_Anim_d_Attaque) )
		return (faux)	// Pas d attaque
	pv_sens = @po_object OBJ_PosGet() - OBJ_PosGet()
	pv_sens.z = 0.0
	if ( MATH_VecNorm( pv_sens) > 9.0)
		return (faux)	//Trop Loin
	pv_sens = MATH_VecNormalize( pv_sens)
	if ( MATH_VecDotProduct( OBJ_SightGet(), pv_sens) < 0.0)
		return (faux)	//Pas dans l axe
	return ( vrai)

}

// ---------------------------------------------------------------------
// 						BUFFER & COUP
// ---------------------------------------------------------------------

// LE BOUTON EST IL MEMO
procedure_local int KBUFFER_Buffered( int pi_button)
{
	int		pi_capa
	pi_capa = faux
	switch ( pi_button)
	{
		case C_Button_All :
			if ( i_buffer_X || i_buffer_T || i_buffer_C || i_buffer_Grab)
				pi_capa = vrai
			else
				pi_capa = faux
			break
		case	C_Button_Action :
			if ( RIDE_Get_Actor_Nb() < 2)
				pi_capa = i_buffer_X
			else
				pi_capa = faux
			break
		case	C_Button_Repulse :
			pi_capa = i_buffer_T
			break
		case	C_Button_Coup :
			pi_capa = i_buffer_C
			break
		case	C_Button_Grab :
			pi_capa = i_buffer_Grab
			break
	}
	return pi_capa 
}

// LE BOUTON PEUX IL ETRE MEMO
procedure_local int KBUFFER_Zone_CanBuffer( int	pi_button)
{
	int		pi_capa
	switch ( pi_button)
	{
		case	C_Button_Action :
			pi_capa = Capa_Buffer_X
			break
		case	C_Button_Repulse :
			pi_capa = Capa_Buffer_T
			break
		case	C_Button_Coup :
			pi_capa = Capa_Buffer_C
			break
		case 	C_Button_Grab :
			pi_capa = Capa_Buffer_C
	}
	return ( OBJ_CapaTest( pi_capa))
}

// LE COUP PEUX IL ETRE INTERROMPU PAR UNE MEMO
procedure_local int	KBUFFER_Zone_Interrupt()
{
	return( OBJ_CapaTest( Capa_Buffer_Interrupt))
}

// DELETE ALL BUFFERS
procedure_local void KBUFFER_DEL_ALL()
{
	i_buffer_T = faux
	i_buffer_X = faux
	i_buffer_C = faux	
	i_buffer_Grab = faux
}

// MEMORISE TOUS LES COUPS
procedure_local void KBUFFER_All()
{
	if ( i_flag_just_Rage && KBUFFER_Zone_CanBuffer(C_Button_Repulse))
	{
		KBUFFER_DEL_ALL()
		i_buffer_T = vrai
	}
	if ( i_flag_just_Action && KBUFFER_Zone_CanBuffer(C_Button_Action))
	{
		KBUFFER_DEL_ALL()
		i_buffer_X = vrai
	}
	if ( i_flag_just_coup && KBUFFER_Zone_CanBuffer(C_Button_Coup))
	{
		KBUFFER_DEL_ALL()
		i_buffer_C = vrai
	}
	if ( i_flag_just_grab && KBUFFER_Zone_CanBuffer(C_Button_Grab))
	{
		KBUFFER_DEL_ALL()
		i_buffer_Grab = vrai
	}
		
}

// INIT HIT : ORIENT
procedure_local void COUP_INIT_Orient()
{
	object		to_fight_actor
	v_frappe_sight = v_joy_sight
	to_fight_actor = nobody
	Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, Cf_Cos45, 0.0,  8.0, to_fight_actor, faux, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)	// POUR KONG A LANCER AVANT CHAQUE COUP.
	DASH_O_FIGHT_ACTOR_Validate( to_fight_actor)
	f_coup_orient_blend_current = 0.0
}

// GIVE THE MODE
procedure_local int COUP_MODE()
{
	return i_coup_mode
}

// RESET MODE
procedure_local void COUP_MODE_DEL()
{
	i_coup_mode = 0
}

// SET MDOE
procedure_local void COUP_Set_Mode( int pi_coup)
{
	i_coup_mode = pi_coup
	v_pos_ODEPunch_coup = OBJ_PosGet()
	// INITS
	switch ( i_coup_mode)
	{
		case C_Mode_Fury :
			FURY_INIT
		default:
		COUP_INIT_Orient()	
	}
	KBUFFER_DEL_ALL()
	// returntrack
}

// ORIENT HIT
procedure_local void COUP_Orient( float pf_speed, float pf_coef_pied, float pf_sens)
{
	i_coup_orient = vrai
	f_coup_orient_blend_max = pf_speed
	f_coef_pied_d_appui = pf_coef_pied
	f_coup_orient_sens_forceed = pf_sens
}

// NEXT HIT  IS Combo 1
procedure_local void COUP_CHANGE_To_Combo1( int pi_frame)
{
	vector	pv_look
	vector	pv_ortho
	STATS_IncAttack()
	mi_PaffedODEThisSwing = faux	// flag qui indique qu'on a déjà paffé une struct ODE qui empeche de paffer + pour l'attaque en cours...
	i_paf_afx_done = faux
	i_frappe_phase_before_zde_fight = vrai
	i_fury_increased_this_action = faux
	if ( i_look_do_sight_ennemi_old)
		pv_look = v_look_direction
	else
		pv_look = OBJ_SightGet()
	pv_ortho.x = -v_look_sens_epaule.y
	pv_ortho.y = v_look_sens_epaule.x
	pv_ortho.z = 0.0
	if ( MATH_VecDotProduct( v_joy_sight, pv_ortho) > Cf_Cos60)
	{
		COUP_Orient( 3.0, 1.0, 0.0)
		ACT_ActionSet(Ci_Kanim_coup_C_1)		// En face
	}
	else if ( MATH_VecDotProduct( v_joy_sight, -v_look_sens_epaule ) < 0)
	{
		if ( i_Grab_Torse_ANN )
		{
			COUP_Orient( 5.0, 1.0, 0.0)
			ACT_ActionSet(Ci_Kanim_coup_C_1)		// Ann
		}
		else
		{
			COUP_Orient( 5.0, 1.0, 1.0)
			ACT_ActionSet(Ci_Kanim_frappeDr)
		}
	}
	else
	{
		COUP_Orient( 5.0, 0.0, -1.0)
		ACT_ActionSet(Ci_Kanim_frappeGa)
	}
	if ( pi_frame > 0)
		ANI_CurrentFrameSet(0,pi_frame)
 	COUP_Set_Mode( C_Mode_Combo1)
}

// NEXT HIT  IS Combo 2
procedure_local void COUP_CHANGE_To_Combo2(  int pi_frame)
{
	STATS_IncAttack()
	mi_PaffedODEThisSwing = faux	// flag qui indique qu'on a déjà paffé une struct ODE qui empeche de paffer + pour l'attaque en cours...
	i_paf_afx_done = faux
	i_frappe_phase_before_zde_fight = vrai
	i_fury_increased_this_action = faux
	ACT_ActionSet(Ci_Kanim_coup_C_2)
	if ( pi_frame > 0)
		ANI_CurrentFrameSet(0,pi_frame)
	COUP_Orient( 2.0, 0.0, 0.0)
	COUP_Set_Mode( C_Mode_Combo2)
}
// NEXT HIT  IS Combo3
procedure_local void COUP_CHANGE_To_Combo3( )
{
	STATS_IncAttack()
	mi_PaffedODEThisSwing = faux	// flag qui indique qu'on a déjà paffé une struct ODE qui empeche de paffer + pour l'attaque en cours...
	i_paf_afx_done = faux
	i_fury_increased_this_action = faux
	i_frappe_phase_before_zde_fight = vrai
	i_frappe_impact = faux
	ACT_ActionSet(Ci_Kanim_coup_T_3)
	COUP_Orient( 2.0, 0.0, 0.0)
	COUP_Set_Mode( C_Mode_Combo3)
}
// NEXT HIT  IS Repulse
procedure_local void COUP_CHANGE_To_Repulse( )
{
	STATS_IncAttack()
	mi_PaffedODEThisSwing = faux	// flag qui indique qu'on a déjà paffé une struct ODE qui empeche de paffer + pour l'attaque en cours...
	i_paf_afx_done = faux
	i_fury_increased_this_action = faux
	i_frappe_phase_before_zde_fight = vrai
	ACT_ActionSet(Ci_Kanim_coup_T_1)
	COUP_Orient( 2.0, 0.5, 0.0)
	COUP_Set_Mode( C_Mode_Repulse)
}
// NEXT HIT  IS Fury
procedure_local void COUP_CHANGE_To_Fury( )
{
	f_rumble_power = 50.0
	ACT_ActionSet(Ci_Kanim_coup_T_2)
	COUP_Orient( 0.0, 0.5, 0.0)
	COUP_Set_Mode( C_Mode_Fury)
}
// NEXT HIT  IS DASH ATTACK
procedure_local void COUP_CHANGE_To_DashAttack( )
{
	STATS_IncAttack()
	mi_PaffedODEThisSwing = faux	// flag qui indique qu'on a déjà paffé une struct ODE qui empeche de paffer + pour l'attaque en cours...
	i_paf_afx_done = faux
	i_fury_increased_this_action = faux
	i_frappe_phase_before_zde_fight = vrai
	COUP_Orient( 0.0, 0.5, 0.0)
	if ( i_Grab_Torse_ANN)
	{
		ACT_ActionSet(Ci_Kanim_coup_C_1)		// Ann dans la main ce coup est limité
		 COUP_Set_Mode( C_Mode_Combo1)
	}
	else
	{
		ACT_ActionSet(Ci_Kanim_Dash_Attack)
		COUP_Set_Mode( C_Mode_Dash_Attack)
	}
}
// NEXT HIT  IS DASH ATTACK
procedure_local void COUP_CHANGE_To_Return( )
{
	mi_PaffedODEThisSwing = faux	// flag qui indique qu'on a déjà paffé une struct ODE qui empeche de paffer + pour l'attaque en cours...
	i_paf_afx_done = faux
	i_fury_increased_this_action = faux
	i_frappe_phase_before_zde_fight = vrai
	switch( COUP_MODE())
	{
		case C_Mode_Combo1 :
			switch ( ACT_ActionGet())
			{
				case Ci_Kanim_coup_C_1 :
					ACT_ActionSet(Ci_Kanim_coup_C_1_Fin)
					break
				case Ci_Kanim_frappeDr  :
					ACT_ActionSet(Ci_Kanim_frappeDr_Fin)
					break
				case Ci_Kanim_frappeGa  :
					ACT_ActionSet(Ci_Kanim_frappeGa_Fin)
					break
			}
			break
		case C_Mode_Combo2 :
			ACT_ActionSet(Ci_Kanim_coup_C_2_Fin)
			break
		case C_Mode_Fury :
			ACT_ActionSet(Ci_Kanim_Intimid_Furie)
			break
		case C_Mode_Repulse :
			ACT_ActionSet(Ci_Kanim_Attente)
			break
	}
	COUP_Orient( 0.0, 0.5,
	 0.0)
	COUP_Set_Mode( C_Mode_Retour)
}


procedure_local void DASH_O_FIGHT_ACTOR_Validate(object to_fight_actor_old)
{
	int		ti_fight_actor_cur
	
	ti_fight_actor_cur = ARR_ObjSearch(&ao_fight_actor_list[0],i_fight_actor_nbr, to_fight_actor_old)
	if (ti_fight_actor_cur != -1)
	{
		// L'actor est present dans la liste (J'update vraiment le o_fight_actor & ses dependances)
		i_fight_actor_cur = ti_fight_actor_cur
		o_fight_actor = to_fight_actor_old
	}
}


// NEXT HIT  IS DASH
procedure_local void COUP_CHANGE_To_Dash( )
{
	int 		pi_coup
	int			pi_test
	int			pi_anim
	int			pi_dash_vers_wall
	int			pi_wall_gmat
	vector	pv_axis
	vector	pv_vector
	object	po_wall
	object	to_fight_actor, to_target
	float		pf_wall_detect_dist

	if ( ! o_fight_actor)
		HOTSPOT_Detect( Cv_NullVector, faux)
	else
	{	 
		if ( (OBJ_PosGet().z - @o_fight_actor OBJ_PosGet().z) > 4.0 )
			HOTSPOT_Detect( Cv_NullVector, vrai)
		else	
			HOTSPOT_Detect( Cv_NullVector, faux)
	}

	if ( o_jump_hotspot)
		return

	AI_Execute("k_exec_check_colonnes")
	if( o_colonne)
	{	
		COUP_CHANGE_To_Pillar( o_colonne, Ci_Kanim_Colonne_Grimpe)
		return
	}
	
	pi_coup = C_Mode_Dash
	o_esquive_actor = nobody
	pf_wall_detect_dist = 5.0
	
	// TEST LRAY pour dash vers mur wallable
	pi_dash_vers_wall = faux
//	if ( !o_fight_actor  || ! @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Tank"))
	{
	
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_joy_sight_normalized * pf_wall_detect_dist, color_rouge)
		po_wall = COL_RayObject_Dist((OBJ_PosGet() + Cv_VerticalVector), v_joy_sight_normalized, pf_wall_detect_dist, all, OBJ_C_IdentityFlag_AI, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
		if( po_wall )
		{
			// je détecte un mur 
			pi_wall_gmat = COL_GMAT_FlagsGet(COL_C_Ray)
			if( pi_wall_gmat & Gmat_KK_Face_de_Walling )
			{
				// c'est un mur wallable
				pf_wall_detect_dist = MATH_VecDotProduct(COL_RayObject_PosGet() - (OBJ_PosGet() + Cv_VerticalVector), glob_joyvector_get_normalized)
				if ( o_fight_actor)
				{
					pv_axis = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
					pv_axis.z = 0.0
					pv_axis = MATH_VecNormalize( pv_axis)
				}
				else
					pv_axis = - v_dash_for_walling_axis
				if( MATH_VecDotProduct(v_dash_for_walling_axis, pv_axis) < Cf_Cos45 )
				{
					// mon ennemi n'est pas entre le mur et moi
					pi_dash_vers_wall = vrai
					pi_anim = Ci_Kanim_dash
					i_dash_for_walling = vrai
					v_dash_for_walling_axis = glob_joyvector_get_normalized
					o_dash_for_walling_actor = o_fight_actor
					if( o_dash_for_walling_actor )
						COL_UnCollidableAdd(o_dash_for_walling_actor)	// ne pas me retrouver bloquer par REX
				}
			}
			else if ( !( pi_wall_gmat & Gmat_KK_Accrochage_interdit))
			{
						
				if (	MATH_AbsFloat(COL_RayObject_NormalGet().z) < Cf_Kong_Angle_Mur_sol && !(@po_wall OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_AI))
				{
					// J'ai un Obstacle et c'est un Mur (normale)
				
//					macro_render_Vector_define(tv_start_pos, tv_collision_point - tv_start_pos, color_blanc, DBG_RENDER_OBSTACLE)
				
				
					v_obstacle_top_point  = COL_TipTopPointGet(Cv_VerticalVector, 3.5, faux, vrai, faux, vrai)			// C'est HAUT ?
					
					// TEST DE TOP POINT AVEC SOL DERRIERE ===================================
					if( COL_RayObject_EdgeNormalGet().z > Cf_Kong_Angle_Mur_sol)
						f_hauteur_obstacle = v_obstacle_top_point.z
					else
						f_hauteur_obstacle = Cf_Infinit		// Le tiptop chie et indique je ne sais trop quoi
					// TEST DE TOP POINT AVEC SOL DERRIERE ===================================
					
					f_hauteur_obstacle -= OBJ_PosGet().z																					// Hauteur de l'obstacle = le haut du mur - ma position.
				}
		

				if (f_hauteur_obstacle > Cf_Hauteur_Mur_Accroch_Auto + 1.0)
				{
					// TROP HAUT
					pi_dash_vers_wall = vrai
					if ( o_colonne && COL_ObjectGet( COL_C_Wall) == o_colonne)
					{
						COUP_CHANGE_To_Pillar( o_colonne, Ci_Kanim_Colonne_Grimpe)
						return
					}
				}
				else if (f_hauteur_obstacle > 1.9)
				{
					pi_dash_vers_wall = vrai
					pi_anim = Ci_Kanim_dash
					v_dash_direction = v_joy_sight_normalized
					Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_dash_direction, Cf_Cos30, 0.0, 20.0, to_fight_actor, faux, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)	// POUR KONG A LANCER AVANT CHAQUE COUP
					DASH_O_FIGHT_ACTOR_Validate( to_fight_actor)
				}
			}
		}
	}
		
	to_fight_actor = nobody
	if( ! pi_dash_vers_wall )
	{
		if( o_fight_actor 		// i_look_do_sight_ennemi_old && 															// Je regarde qq'un qui est mon fight actor.
		&& ( ( @o_fight_actor AI_IsModel(get_PNJ_KTREX_Path) && @o_fight_actor KT_Proc_canBeDodged())		// TREX
		|| ( @o_fight_actor AI_IsModel(get_PNJ_KBats_path) && @o_fight_actor KBC_Proc_canBeDodged())		// BIG BAT
		|| ( @o_fight_actor AI_IsModel(get_PNJ_Scolo_Path) && @o_fight_actor Proc_KK_Scolo_canBeDodged())	// BIG SCOLO
		|| ( @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Tank"))													// TANK
		|| ( @o_fight_actor AI_IsModel("PNJ_Predators/PNJ_Poursuite_NY"))										// LUX KI TUE
		|| @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Car")  
		|| @o_fight_actor AI_IsModel(get_PNJ_Triceratops_path) ) )
		{
			if ( ! @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Tank"))
				pv_axis = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
			else
			{
				to_target = @"PNJ_Pacifique/PNJ_Tank"o_fight_actor o_tourelle
				pv_axis = @to_target OBJ_PosGet() - OBJ_PosGet()
			}
			pv_axis.z = 0.0
			v_depl_esquive = MATH_VecNormalize(pv_axis)
			pv_vector = MATH_VecCrossProduct(v_depl_esquive,Cv_VerticalVector)
			
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, pv_vector, color_vert)
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_depl_esquive, color_jaune)
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, glob_joyvector_get_normalized * 5, color_cyan)

			// Dash To Grab TEST
			// LE DASH GRAB
			if ( MATH_VecDotProduct(v_depl_esquive, v_joy_sight_normalized) < -Cf_Cos70)
			{
				pi_anim = Ci_Kanim_dash
				v_dash_direction = v_joy_sight_normalized
			}
//			else if ( @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Tank"))
//			{
//				// TEST TROP POURRI JE PREFERE DUPLIQUER LE CODE
//				if( ! @o_fight_actor Proc_KK_Tank_canBeDodged())
//				{
//					pi_anim = Ci_Kanim_dash
//					v_dash_direction = v_joy_sight_normalized
//					Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_dash_direction, Cf_Cos30, 0.0, 20.0, to_fight_actor, faux, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)	// POUR KONG A LANCER AVANT CHAQUE COUP
//					DASH_O_FIGHT_ACTOR_Validate( to_fight_actor)
//				}
//				else if (MATH_VecDotProduct(pv_vector, v_joy_sight_normalized) > 0)
//				{
//					// Esquiver vers la Droite de l'ecran
//					pi_coup = C_Mode_Esquive		// Dash special en fight : esquive
//					pi_anim= Ci_Kanim_esquiveD
//					o_esquive_actor = o_fight_actor
//					v_esquive_to_actor = @o_esquive_actor OBJ_PosGet() - OBJ_PosGet()
//					v_esquive_to_actor.z = 0.0
//				}
//				else	if (MATH_VecDotProduct(pv_vector, v_joy_sight_normalized) < 0)
//				{
//					pi_coup = C_Mode_Esquive		// Dash special en fight : esquive
//					pi_anim= Ci_Kanim_esquiveG
//					o_esquive_actor = o_fight_actor
//					v_esquive_to_actor = @o_esquive_actor OBJ_PosGet() - OBJ_PosGet()
//					v_esquive_to_actor.z = 0.0
//				}				
//			}
			else if ( ( ( MATH_VecDotProduct(pv_axis,pv_axis) > 196.0 || @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Car") || @o_fight_actor AI_IsModel("PNJ_Pacifique/PNJ_Tank"))
			&& MATH_VecDotProduct(v_depl_esquive, v_joy_sight_normalized) > Cf_Cos30)
			|| MATH_FloatNullEpsilon(glob_joynorm_get))
			{
				pi_anim = Ci_Kanim_dash
				v_dash_direction = v_joy_sight_normalized
				Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_dash_direction, Cf_Cos30, 0.0, 20.0, to_fight_actor, faux, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)	// POUR KONG A LANCER AVANT CHAQUE COUP
				DASH_O_FIGHT_ACTOR_Validate( to_fight_actor)
			}
			else if (MATH_VecDotProduct(pv_vector, v_joy_sight_normalized) > 0)
			{
				// Esquiver vers la Droite de l'ecran
				pi_coup = C_Mode_Esquive		// Dash special en fight : esquive
				pi_anim= Ci_Kanim_esquiveD
				o_esquive_actor = o_fight_actor
				v_esquive_to_actor = @o_esquive_actor OBJ_PosGet() - OBJ_PosGet()
				v_esquive_to_actor.z = 0.0
			}
			else	if (MATH_VecDotProduct(pv_vector, v_joy_sight_normalized) < 0)
			{
				pi_coup = C_Mode_Esquive		// Dash special en fight : esquive
				pi_anim= Ci_Kanim_esquiveG
				o_esquive_actor = o_fight_actor
				v_esquive_to_actor = @o_esquive_actor OBJ_PosGet() - OBJ_PosGet()
				v_esquive_to_actor.z = 0.0
			}
			f_depl_esquive_speed = 0.0
		}
		else
		{
			pi_anim = Ci_Kanim_dash //Ci_Kanim_NewDashTest				// 
			v_dash_direction = v_joy_sight_normalized
			Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_dash_direction, Cf_Cos30, 0.0, 20.0, to_fight_actor, faux, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)	// POUR KONG A LANCER AVANT CHAQUE COUP.
			DASH_O_FIGHT_ACTOR_Validate( to_fight_actor)
		}
	}
	ACT_ActionSet( pi_anim + Ci_ActionSet_Force_FrameZero + Ci_ActionSet_Force_SameAction)
	COUP_Orient( 0.0, 0.5, 0.0)
	COUP_Set_Mode( pi_coup)
	
//	if( ACT_ActionGet() == Ci_Kanim_dash)
		f_time_dash_init = 0.0
	return
}

// NEXT HIT IS KILL GRABBED THING
procedure_local void COUP_CHANGE_To_KILL()
{
	STATS_IncAttack()
	i_GrabKong_ModeKill_PafSend = faux
	ACT_ActionSet(Ci_Kanim_Kill_Bat)
	COUP_Orient( 0.0, 0.5, 0.0)
	COUP_Set_Mode( C_Mode_Kill)
	LNK_GrabKong_ActionSet(amid_CL_LIAISON_ID_GRABKONG[i_Grab_Torse_Main], Ci_GrabKong_ModeKill)
}

// NEXT MOVE IS PILLAR CLIMB
procedure_local void Proc_KK_Pillar_Set_Axe()
{
	float		pf_dot_S,pf_dot_H
	if ( o_colonne.des_int1 & 1)
	{
		v_colonne_best_axe = -@o_colonne OBJ_SightGet()
		return
	}
	v_colonne_pos_init = OBJ_PosGet() 
	pf_dot_S = MATH_VecDotProduct( @o_colonne OBJ_SightGet(), v_colonne_pos_init - @o_colonne OBJ_PosGet())
	pf_dot_H = MATH_VecDotProduct( @o_colonne OBJ_HorizonGet(), v_colonne_pos_init - @o_colonne OBJ_PosGet())
	if ( MATH_AbsFloat(pf_dot_S) > MATH_AbsFloat(pf_dot_H))
	{
		if ( pf_dot_S > 0.0)
			v_colonne_best_axe = @o_colonne OBJ_SightGet()
		else
			v_colonne_best_axe = - @o_colonne OBJ_SightGet()
	}
	else
	{
		if ( pf_dot_H < 0.0)
			v_colonne_best_axe = - @o_colonne OBJ_HorizonGet()
		else
			v_colonne_best_axe = @o_colonne OBJ_HorizonGet()
	}
}
procedure_local void COUP_CHANGE_To_Pillar( object po_pillar , int pi_anim)
{
	vector	pv_dest
	float		tf_dist
	object	to_bone
	
	ACT_ActionSet(pi_anim)

	COUP_Orient( 0.0, 0.5, 0.0)
	COUP_Set_Mode( C_Mode_Pillar)	
	o_colonne = po_pillar
	pv_dest = @o_colonne OBJ_PosGet() - OBJ_PosGet()
	pv_dest.z = 0.0
	tf_dist = MATH_VecNorm(pv_dest) - 4.21 // Avancée de l animp
	Proc_KK_Pillar_Set_Axe()
	pv_dest = @o_colonne OBJ_PosGet() + (v_colonne_best_axe * tf_dist)
	v_colonne_pos_end = pv_dest
}

// CLEAN ALL BUFFERS
procedure_local void COUP_END()
{
	mi_PaffedODEThisSwing = faux
	i_paf_afx_done = faux
	i_fury_increased_this_action = faux
	i_frappe_phase_before_zde_fight = vrai
	KBUFFER_DEL_ALL()	
	COUP_MODE_DEL()
}

// CANCEL DEFAULT MODE
procedure_local void COUP_Cancel_Mouvment( )
{
	i_coup_retourne = vrai
}

// IS DEFAULT MODE CANCELED
procedure_local int COUP_Canceled_Mouvment()
{
	return ( i_coup_retourne)
}

// IS PUNCH ORIENTED
procedure_local int	COUP_Oriented()
{
	if ( MATH_FloatNullEpsilon(f_coup_orient_blend_max))
		return 0
	else
		return 1
//	return ( i_coup_orient)
}

// CAN NMI DETECTION BE PERFORMED
procedure_local int COUP_TryToHit( )
{
	object	to_gao
	if( OBJ_CapaTest(Capa_ZDE_Fight_ON) )
		return vrai
	
	if( i_etat_courant == ETAT_Kong_depl_souche )
	{
		to_gao = ao_CL_GRABKONG[i_GrabKong_MainActionGrab]
		if( to_gao && @to_gao AI_IsModel(get_PNJ_Scolo_Path) )
		{
			switch( ACT_ActionGet() )
			{
				case Ci_Kanim_souche_frappe_droite :
				case Ci_Kanim_souche_frappe_gauche :
				case Ci_Kanim_souche_frappe_face :
					return vrai
					break
					
				default:
					return faux
					break
			}
		}
	}
	return faux
}


// IN:		Position, Axe a la bonne norme.
// OUT:	Position du point (Cv_NullVector = Pas de point de saut trouvé)
procedure vector WALLING_GetAnotherWall( vector tv_pos, vector tv_axis, int ti_from_wall )
{
	object	to_gao
	vector	tv_pos_return 
	int			ti_gmat
		
	tv_pos_return = Cv_NullVector
	
//	COL_SpecificCrossableSet( Gmat_KK_Crossable_Default )
	COL_SpecificCrossableSet( Gmat_KK_Cross_All_But_Ann | Gmat_KK_Cross_All_But_Camera)
	to_gao = COL_RayObject_Vector(tv_pos, tv_axis, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet)
	if (to_gao)
	{
		// On a touché un obstacle
		ti_gmat = COL_GMAT_FlagsGet( COL_C_Ray)
		if ( (ti_gmat & Gmat_KK_Face_de_Walling)
		&& ( ti_from_wall && !(ti_gmat & (Gmat_KK_Force_Left + Gmat_KK_Force_Right)))
		|| ! ti_from_wall)
		{
			tv_pos_return = COL_RayObject_PosGet()		// Le mur n'est pas interdit, Je retourne donc cette position de saut
			DBG_RenderVector( tv_pos, tv_pos_return - tv_pos, color_cyan)
		}
	}
	return tv_pos_return 
}


procedure_local object HOTSPOT_Detect( vector pv_sens, int pi_fight_HS)
{
	// TEST DE HOTSPOT POUR SAUTER
	v_jump_force_sens = pv_sens
	i_jump_check_hotspot_fight = pi_fight_HS	// Enchainer sur un ennemi ??
	AI_Execute( "k_exec_check_hotspot")
	i_jump_check_hotspot_fight = faux	// On remet le defaut
	v_jump_force_sens = pop
	return o_jump_hotspot
}

procedure_local int JUMP_Check_chute( int pi_check_HS)
{
	vector tv_vector
	
	if (f_time_collide_ground > Cf_delay_ground_col_tolerance) // && TIME_Elapsed(f_walling_quit, 0.5))
	{
		
		i_reflex_anim = Ci_Kanim_dash
	
		if ( COUP_MODE() == C_Mode_Dash	&& pi_check_HS)
		{
			i_jump_check_hotspot_fight = vrai	// On peux enchainer les HOT SPOT
			AI_Execute( "k_exec_check_hotspot")
			tv_vector = pop
			i_jump_check_hotspot_fight = faux	// On peux enchainer les HOT SPOT
		}
	
		if ( o_jump_hotspot && !@o_jump_hotspot OBJ_CapaTest( OBJ_Capa_4))
		{
			i_flag_auto_grab = faux
//			i_jump_force_no_impulsion = vrai
			f_time_collide_ground = 0.0 				// pas de chute
			f_jump_force_distance = 10.0
			v_jump_force_sens = tv_vector			// Sens du Saut
			i_jump_check_hotspot = vrai	// On peux enchainer les HOT SPOT
			return vrai
		}
		else
		{
			v_jump_force_chute_orient = OBJ_SightGet()
			i_jump_check_hotspot = faux	// On peux enchainer les HOT SPOT
			return vrai
		}
	}
	return faux
}

procedure_local int JUMP_BigJump()
{
	float	pf_duree
	int		ti_GMAT
	pf_duree = 1.0
	if ( ! DYN_LIB_Test_Trajectory(OBJ_PosGet(), DYN_SpeedGetVector(), DYN_GravityVectorGet(), DYN_FrictionVectorGet(), pf_duree, 10, -11.5))
		return vrai
	else
	{
		// COLMAP TOUCHE
		ti_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)
		if ( ( ti_GMAT  & Gmat_KK_Face_de_Walling)
		&& ( ti_GMAT  & Gmat_KK_Accrochage_interdit))
			return vrai	// Forcer le racrochage
		else
			return faux
	}
}


procedure_local int	JUMP_Detect_Raccroch( vector pv_sens)
{
	vector	tv_last_ground_pos 
	vector	tv_pos
	int			ti_GMAT
	
	tv_last_ground_pos  = v_last_ground_pos - pv_sens
	// Astuce pour ne pas effectuer le LRay sur une arrete au cas ou le dernier point de col est sur une arrete
	// reculer de 10cms et monter de 20cms(au as ou on est sur un sol pentu <60°)
	macro_render_Vector( tv_last_ground_pos, pv_sens, 0xFF00)
	macro_render_Vector( tv_last_ground_pos + cvector(0.0,0.0,0.2), -Cv_VerticalVector , 0xFF0000)
	if (COL_RayObject_Vector( tv_last_ground_pos + cvector(0.0,0.0,0.2), -Cv_VerticalVector, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
	{
		tv_pos = COL_RayObject_PosGet()
		macro_render_Vector( tv_pos - cvector( 0.5, 0.0, 0.0),cvector( 1.0, 0.0, 0.0),color_rouge) 
		macro_render_Vector( tv_pos - cvector( 0.0, 0.5, 0.0),cvector( 0.0, 1.0, 0.0),color_rouge) 
		v_climb_position = COL_TipTopPointGet(pv_sens, Cf_largeur_Kong, faux, vrai, faux, vrai)
		v_climb_normale = COL_RayObject_EdgeNormalGet()	
		if ( !MATH_VecNullEpsilon( v_climb_normale - COL_RayObject_NormalGet()))
		{
			// sol sans face descendante apres	
			tv_last_ground_pos = v_climb_position + (v_climb_normale * 0.5)	// Point 50cmplus loin ds le sens de la normale
			tv_last_ground_pos -= cvector( 0.0, 0.0, 0.1) // Point 10cms plus bas
			macro_render_Vector( tv_last_ground_pos, -v_climb_normale * 3.0, 0xFF00)
			if (COL_RayObject_Dist( tv_last_ground_pos, -v_climb_normale, 3.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
			{
				ti_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)
				if ( !( ti_GMAT  & Gmat_KK_Accrochage_interdit))
				{
					v_climb_normale = COL_RayObject_NormalGet()
					return vrai
				}
			}
		}
		macro_render_Vector( v_climb_position, v_climb_normale * 2.0, 0xFF00)
	}
	return faux
}

procedure_local void JUMP_Se_Raccroch()
{
	vector	tv_pos
	
	@get_global i_kong_camera_status = Ci_Kcamera_accroch

	i_climb_jump_index = 3
	ACT_ActionSet( Ci_Kanim_se_raccroche)
	
	@o_climb_target_wp OBJ_PosSet(v_climb_position)
	@o_climb_target_wp OBJ_SightGeneralSet(-v_climb_normale, Cv_VerticalVector)
	v_climb_hand_offset = @o_climb_target_wp MATH_VecLocalToGlobal(av_climb_hand_offset[i_climb_jump_index][Ci_Climb_Offset_Jump])

	macro_render_Vector(v_climb_position, -v_climb_hand_offset, color_jaune)	

	o_climb_0D_wp = o_climb_target_wp

	i_flag_auto_grab = vrai
	COL_ColSetActivationSet(none, C_bit_zdm_pied)
	
	// RALENTIR LA CHUTE
	DYN_GravitySet(cvector(0.0, 0.0, -30.0))
	
	tv_pos = v_climb_position	
	tv_pos -= v_climb_hand_offset

	f_climb_impulsion_duration = DYN_LIB_Time_To_Reach_Z(DYN_SpeedGetVector(), DYN_GravityVectorGet(), tv_pos.z - OBJ_PosGet().z, faux)	
	v_climb_impulsion_force = DYN_LIB_ImpulsionGet_Friction(OBJ_PosGet(), v_climb_position - v_climb_hand_offset, DYN_GravityVectorGet(), Cf_Kong_Air_Friction, f_climb_impulsion_duration, faux, 0.0)	
	DYN_SpeedSetVector(v_climb_impulsion_force)

	f_climb_rotation_angle = MATH_VecAngle(OBJ_SightGet(), -v_climb_normale, Cv_VerticalVector)
}

procedure_local int RIDE_Get_Actor_Nb()
{
	return i_rider_nb
}

procedure_local void RIDE_Set_Actor_Nb()
{
	int			ti_i, ti_nb
	ti_nb = 0
	for (ti_i = 0; ti_i < Ci_Ride_Client_Nb; ti_i++)
	{
		if ( ao_bone_rider[ti_i])
			ti_nb ++
	}
	i_rider_nb = ti_nb	
}

procedure_local void RIDE_Propose_Link()
{
	int		ti_i
	if ( ! i_ride_just_clear )
	{
		for (ti_i = 0; ti_i < Ci_Ride_Client_Nb; ti_i++)
		{
			ao_bone_rider[ti_i] = LNK_ServeurGet(Ci_LNK_RIDE_DINO, amid_bone_rider_LNK_ID[ti_i], vrai, nofunc, nofunc)
		}
	}
	RIDE_Set_Actor_Nb()		// Update Ride Actor Nb
}

procedure_local void RIDE_Clear_Link_Bat( int pi_mode)
{
	int		ti_i
	i_ride_just_clear = vrai
	for (ti_i = 0; ti_i < Ci_Ride_Client_Nb; ti_i++)
	{ 
		if ( pi_mode || !ao_bone_rider[ti_i] || !@ao_bone_rider[ti_i] AI_IsModel( get_PNJ_KBats_path))
			ao_bone_rider[ti_i] = LNK_ServeurGet(Ci_LNK_RIDE_DINO, amid_bone_rider_LNK_ID[ti_i], faux, nofunc, nofunc)
	}
	RIDE_Set_Actor_Nb()		// Update Ride Actor Nb
}

procedure_local void RIDE_Clear_Link_For_Finished(object to_model_gao)
{
	int		ti_i
	i_ride_just_clear = vrai
	for (ti_i = 0; ti_i < Ci_Ride_Client_Nb; ti_i++)
	{ 
		if ( ao_bone_rider[ti_i])
		{
			switch ( LNK_Finish_FinisherTypeGet(mid_finish_LNK_ID))
			{
				case Ci_GrabKong_Finished_BigScolo :
					if ( to_model_gao && ao_bone_rider[ti_i] != to_model_gao)
						ao_bone_rider[ti_i] = LNK_ServeurGet(Ci_LNK_RIDE_DINO, amid_bone_rider_LNK_ID[ti_i], faux, nofunc, nofunc)
					break
				default:
					if ( to_model_gao && ! @ao_bone_rider[ti_i] AI_HaveSameModel(to_model_gao) )
						ao_bone_rider[ti_i] = LNK_ServeurGet(Ci_LNK_RIDE_DINO, amid_bone_rider_LNK_ID[ti_i], faux, nofunc, nofunc)
					break
			}
		}
	}
	RIDE_Set_Actor_Nb()		// Update Ride Actor Nb
}

procedure_local object RIDE_Get_Actor( byref int pi_ind)
{
	object	to_ride_actor
	int			ti_i
	pi_ind = -1
	to_ride_actor = nobody
	for (ti_i = 0; ti_i < Ci_Ride_Client_Nb; ti_i++)
	{
		if ( ao_bone_rider[ti_i])
		{
			pi_ind = ti_i
			return ao_bone_rider[ti_i]
		}
	}
	return nobody
}

procedure_local void RIDE_Del_Actor( int	pi_ind)
{
	ao_bone_rider[pi_ind] = LNK_ServeurGet(Ci_LNK_RIDE_DINO, amid_bone_rider_LNK_ID[pi_ind], faux, nofunc, nofunc)
	RIDE_Set_Actor_Nb()		// Update Ride Actor Nb
}

procedure_local 	void	SWEEP_Change_To_Sweep( vector pv_derape, vector pv_axe, vector pv_grab, int pi_lance, int pi_sweep_lance)
{
	vector	pv_temp
	SND_GRAB_STOP
	if ( pi_sweep_lance)
		LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_SweepLance)
	else
		LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Sweep)
	v_GrabKong_speed_derape = pv_derape 
	v_GrabKong_speed_grab = pv_grab			// La Vitesse de sweep en depend
	v_GrabKong_axe = pv_axe		// Axe de départ du mode rotation
	if ( !pi_lance)
	{
		f_GrabKong_rot_sign = MATH_FloatSign(MATH_VecDotProduct( v_GrabKong_axe, v_joy_sight))
		v_GrabKong_axe *= f_GrabKong_rot_sign
	}
	pv_temp = MATH_VecCrossProduct( OBJ_SightGet(), v_GrabKong_axe)
	f_GrabKong_wheel = pv_temp.z
	i_GrabKong_Positionnement_Attrape = 0
	if ( pi_lance)
	{
		i_GrabKong_sweep_degagement = vrai
		i_GrabKong_Throw = faux
	}
}	

procedure_local void SWEEP_LAnce_Choix_Anim( vector	pv_sens)
{
	float	tf_dot
	tf_dot = MATH_VecDotProduct(  LNK_GrabKong_AncrageVectorGet(  amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]), @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet())
	if ( tf_dot > Cf_Cos5)
	{
		// Face
		if ( MATH_VecDotProduct( pv_sens, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet()) > 0 )
		{
			ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
			v_frappe_sight= -OBJ_HorizonGet()
		}
		else
		{
			ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
			v_frappe_sight= OBJ_HorizonGet()
		}
	}
	else if ( tf_dot < -Cf_Cos5)
	{
		// queue 
		if ( MATH_VecDotProduct( pv_sens, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet()) < 0 )
		{
			ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
			v_frappe_sight= -OBJ_HorizonGet()
		}
		else
		{
			ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
			v_frappe_sight= OBJ_HorizonGet()
		}
	}
	else
	{
		// cote
		if ( MATH_VecDotProduct( pv_sens, @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet()
		* MATH_VecDotProduct( @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet(), OBJ_HorizonGet())) < 0 )
		{
			ACT_ActionSet( Ci_Kanim_Lache_D )	// Jeter
			v_frappe_sight= -OBJ_HorizonGet()
		}
		else
		{
			ACT_ActionSet( Ci_Kanim_Lache_G )	// Jeter
			v_frappe_sight= OBJ_HorizonGet()
		}
	}
}

procedure_local void	SWEEP_Change_To_Lance( vector	pv_force, int pi_finIK, int pi_choix_anim, int pi_choix_target)
{
	float	tf_dot
//	STATS_IncAttack()
	if ( pi_choix_target && !o_Throw_Target)
	{
		o_Throw_Target = nobody
		i_Throw_Target = Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), pv_force, Cf_Cos45, 0.0, 20.0, o_Throw_Target, vrai, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)
	}
	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Lance)
	LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], pv_force)
	if ( o_Throw_Target)
	{
		DBG_RenderVector( OBJ_PosGet(), pv_force, color_bleu)
		LNK_GrabKong_LanceObjectSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], o_Throw_Target)	// Cible precisee
		LNK_GrabKong_LanceTargetSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], i_Throw_Target)	// Cible precise
		pv_force = 	@o_Throw_Target OBJ_PosGet() - OBJ_PosGet()
		pv_force.z = 0.0
		if ( !MATH_VecNullEpsilon(pv_force))
			MATH_VecSetNormalize(pv_force)
	}
	if ( pi_choix_anim)
		SWEEP_LAnce_Choix_Anim(pv_force)
	LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
	
	if ( pi_finIK)
	{
		if ( i_GrabKong_MainBloquee != -1)
		{
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = nobody	// FIN IK
			i_GrabKong_MainBloquee = -1
		}
		else
		{
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = nobody	// FIN IK
			i_GrabKong_MainBloquee = -1
		}	
		i_IK_end = vrai
	}
}					

procedure_local void SWEEP_Change_To_Frappe( int pi_cote )
{
	STATS_IncAttack()
	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  Ci_GrabKong_Frappe)	
//	switch ( pi_cote)
//	{
//		case 0 :
			ACT_ActionSet( Ci_Kanim_GrabTT_Frappe )
//			break
//		case 1:
//			ACT_ActionSet(Ci_Kanim_Flanc_CoupG)
//			break
//		case 2:
//			ACT_ActionSet(Ci_Kanim_Flanc_CoupD)
//			break
//	}
	LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  ACT_ActionGet())
}



// FINISH COUP DE DENT
procedure_local void SWEEP_Change_To_MashSePlace( int pi_cote )
{
	STATS_IncAttack()	// stats tentative de finish
	i_IK_end = vrai
	f_time_start_etat = 0.0
	v_finish_pos_init = OBJ_PosGet()
	switch ( pi_cote)
	{
		case 0 :
			ACT_ActionSet(Ci_Kanim_Mord_Deb)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_FinishSePlace )
			break
		case 1:
			ACT_ActionSet(Ci_Kanim_Flanc_Deb)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashSePlace )
			break
		case 2:
			ACT_ActionSet(Ci_Kanim_Flanc_Deb + 10)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashSePlace)
			break
	}	
	LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
}
procedure_local void SWEEP_Change_To_Mash( int pi_cote )
{
	switch ( pi_cote)
	{
		case 0 :
			ACT_ActionSet(Ci_Kanim_Mord_Chall)
			i_request_txt_forced = GeneKon_C_mashing_bite
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_FinishDeb )
			break
		case 1:
			ACT_ActionSet(Ci_Kanim_Flanc_Chall)
			i_request_txt_forced = GeneKon_C_mashing_lift
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashDeb )
			break
		case 2:
			ACT_ActionSet(Ci_Kanim_Flanc_Chall + 10)
			i_request_txt_forced = GeneKon_C_mashing_lift
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashDeb)
			break
	}		
	LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
	f_time_start_etat = 0.0
	i_finish_init = vrai
	RUMBLE_INIT
}
procedure_local void SWEEP_Change_To_MashGagne( int pi_cote)
{
	switch ( pi_cote)
	{
		case 0 :
			ACT_ActionSet(Ci_Kanim_Mord_Win)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_FinishGagne )
			break
		case 1 :
//			i_request_txt_forced = GeneKon_C_mashing_lift_trex_win
//			if ( i_GrabKong_Mash_with_X)
//			{
//				i_request_txt_forced = GeneKon_C_mashing_lift_trex_win
				ACT_ActionSet(Ci_Kanim_Flanc_crashATerre)
				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashCoup)	
//			}
//			else
//			{
//				ACT_ActionSet(Ci_Kanim_Flanc_Win)
//				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashGagne )
//			}
			break
		case 2 :
//			if ( i_GrabKong_Mash_with_X)
//			{
//				i_request_txt_forced = GeneKon_C_mashing_lift_trex_win
				ACT_ActionSet(Ci_Kanim_Flanc_crashATerre+10)
				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashCoup)	
//			}
//			else
//			{
//				ACT_ActionSet(Ci_Kanim_Flanc_Win + 10)
//				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashGagne)
//			}
			break
	}		
	LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
}
procedure_local void SWEEP_Change_To_MashPerdu( int pi_cote)
{
	switch ( pi_cote)
	{
		case 0 :
			ACT_ActionSet(Ci_Kanim_Mord_Lose)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_FinishPerdu)	
			break
		case 1 :
			ACT_ActionSet(Ci_Kanim_Flanc_Lose)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashPerdu )
			break
		case 2 :
			ACT_ActionSet(Ci_Kanim_Flanc_Lose + 10)
			LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], Ci_GrabKong_Flanc_MashPerdu)
			break
	}		
	LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  ACT_ActionGet())
}

procedure_local int SWEEP_Fin_ActionMash( int pi_frame_fin_grab, int pi_cam, int pi_reward)
{
	if ( ANI_CurrentFrameGet(0) > pi_frame_fin_grab)
		SND_GRAB_STOP
	if ( pi_cam != -1)
		@get_Kamera Proc_Kam_FinishMode_Set( pi_cam, OBJ_Me())	// Parametres pour le moment, le type de Finish et le perso de reference de ce finish (en principe KONG)
	else
		@get_global i_kong_camera_status = Ci_Kcamera_deplacement

	if ( ACT_ActionFinished())
	{
		if ( pi_reward)
			RAGE_Launch_Reward(ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
		i_exit_mode = vrai
		return 1
	}
	else
		return 0
}
procedure_local object SWEEP_Aide_Au_Tir( float pf_min, float pf_max, float pf_cos, vector pv_sens_lance)
{
	int 			ti_aide_tir_best_trex 
	int				ti_aide_tir_cur_trex
	int 			ti_rank
	float			tf_aide_tir_best
	object		to_actor
	messageid 	tmid_NMI
	vector		tv_sens
	float			tf_norm
	float			tf_dot
	
	ti_aide_tir_best_trex = faux
	tf_aide_tir_best = -1.0
	o_Throw_Target = nobody
	
	ti_rank = -1
	for( 
		tmid_NMI = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank);
		MSG_GlobalIsValid( tmid_NMI);
		tmid_NMI = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank) )
	{
		to_actor = MSG_GlobalGetSender( tmid_NMI)
		if( to_actor == ao_CL_GRABKONG[i_GrabKong_MainActionGrab] )
			continue
		
		tv_sens = @to_actor OBJ_PosGet() - OBJ_PosGet()
		tv_sens.z = 0.0
		tf_norm = MATH_VecNorm(tv_sens )
		if( ( tf_norm >= pf_min ) && ( tf_norm <= pf_max ) )
		{
			// Ennemi pas trop proche et pas trop loin
			tv_sens /= tf_norm
			tf_dot = MATH_VecDotProduct( pv_sens_lance, tv_sens)
			if ( tf_dot > pf_cos )
			{
				// Ennemi dans l'angle
				ti_aide_tir_cur_trex = faux
				if( @to_actor AI_IsModel(get_PNJ_KTREX_Path) )
					ti_aide_tir_cur_trex = vrai
				
				if( ( ti_aide_tir_cur_trex && ! ti_aide_tir_best_trex )			// c'est un TREX et mon meilleur n'est pas un TREX
					|| ( tf_dot > tf_aide_tir_best && ( ti_aide_tir_cur_trex || ! ti_aide_tir_best_trex ) ) )	// l'angle est meilleur et (c'est un TREX ou mon meilleur n'est pas un TREX)
				{
					ti_aide_tir_best_trex = ti_aide_tir_cur_trex
					tf_aide_tir_best = tf_dot
					
					v_frappe_sight = tv_sens
					o_Throw_Target = to_actor
				}
			}
		}
	}
	return o_Throw_Target
}


// GIVE THE MODE
procedure_local int SWEEP_MODE()
{
	return i_coup_mode
}

// RESET MODE
procedure_local void SWEEP_MODE_DEL()
{
	i_coup_mode = 0
}

procedure_local void SWEEP_Choix_Anim( int	pi_depl)
{
	float	tf_dot
	int		pi_cote
	tf_dot = MATH_VecDotProduct( OBJ_SightGet(), @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] OBJ_SightGet())
	if ( tf_dot < -Cf_Cos45)
		pi_cote = 0			// FACE
	else if ( MATH_VecDotProduct( OBJ_HorizonGet(), @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] OBJ_SightGet()) < 0.0)
		pi_cote = 1			// DROITE?
	else
		pi_cote = 2			// GAUCHE?

	if ( pi_depl)
	{
		switch( pi_cote)
		{
			case 0 :
				ACT_ActionSet(Ci_Kanim_GrabTT_att)
				break
			case 1 :
				ACT_ActionSet( Ci_Kanim_GrabTT_tireG)
				break
			case 2 :						
				ACT_ActionSet( Ci_Kanim_GrabTT_tireD)
				break
		}
	}
	else
	{
		switch( pi_cote)
		{
			case 0 :
				ACT_ActionSet(Ci_Kanim_GrabTT_att)
				break
			case 1 :
				ACT_ActionSet( Ci_Kanim_GrabTT_tireG_Att)
				break
			case 2 :
				ACT_ActionSet( Ci_Kanim_GrabTT_tireD_Att)
				break
		}	
	}
}
	

procedure_local int SWEEP_Init_choix_Grab_Ou_Lance()
{
	i_flag_just_throw = faux
	// KONG n'a pas l'intention de poser ANN
	if( i_Grab_Torse_Main != -1 )
	{
		// Jeter ce qu'il y a dans la main choisie
		i_GrabKong_MainActionGrab = i_Grab_Torse_Main
		i_flag_just_grab = faux			// KONG n'a pas le droit de grabber autre chose s'il tient déjà quelque chose dans la main
		i_flag_just_throw = vrai		// KONG jète le raptor
	}
	else if( i_GrabKong_Souche )
	{
		// lancer du tronc
		i_flag_just_grab = faux
		i_flag_just_throw = vrai
	}
	else
		i_flag_just_grab = vrai
	return i_flag_just_grab
}


procedure_local int GRAB_ANN_Propose()
{
	if ( i_GrabAnn_Tested)
		return faux
	if( ! @get_global i_Player_is_Kong )
		return faux		// ne pas rammaser Jack par erreur en plein combat IA
	v_frappe_sight = v_joy_sight_normalized		// Orientation
	i_GrabKong_Type = Ci_GrabKong_Type_Petit
	v_grab_object_pos = OBJ_PosGet() + OBJ_SightGet()		// Position du point de grab demandé
	ao_CL[Ci_LNK_KKGRAB_OBJECT] = LNK_ClientGet(Ci_LNK_KKGRAB_OBJECT, amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], vrai, "k_exec_grab_object_param", nofunc, "k_exec_grab_object_init")		
	if ( ao_CL[Ci_LNK_KKGRAB_OBJECT])
		return vrai
	else
		return faux
}

procedure_local int	GRAB_Propose( int	pi_TYPE)
{
	i_GrabKong_Type = pi_TYPE
	v_grab_object_pos = OBJ_PosGet() + ( v_joy_sight * 4.0)				// Position du point de grab demandé
	ao_CL_GRABKONG[0] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[0], vrai, "k_exec_grab_object_param", nofunc, nofunc)
	if ( ao_CL[Ci_LNK_KKGRAB_OBJECT])
		return vrai
	else
		return faux
}		
	
procedure_local	int SWEEP_Init_Grab()
{
	object	to_rider
	object	to_bone
	object	to_tete
	int			ti_type
	int			ti_ind
	vector	tv_sens
	vector	tv_sight
	float		tf_dot3
	vector	tv_joy
	
	i_GrabKong_orient = faux												// Par defaut pas d orientation
	i_GrabKong_attrape_jete = Ci_Attrape								// On GRAB
	i_GrabKong_positionnement_fini = faux							// passe a vrai quand les anims de placemetn se fini
	// Tenter d'attraper devant lui
	v_frappe_sight = v_joy_sight_normalized							// Orientation
	o_Throw_Target = nobody
	Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, Cf_Cos45, 0.0, 20.0, o_Throw_Target, vrai, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)

	f_coef_pied_d_appui = i_GrabKong_MainActionGrab			// Coef pied d'appui pour rotation pied
	
	// Ann pas grabbable essayer d attraper autre chose
	i_GrabKong_Type = Ci_GrabKong_Type_Gros	+ Ci_GrabKong_Type_Mashing			
	i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
	// Calcul de la position du point de grab demandé
	if ( i_look_do_sight_ennemi_old && o_fight_actor )
	{
		// KONG regarde un ennemi
		DBG_RenderVector(OBJ_PosGet(), v_joy_sight * 3, color_vert)
		tv_sens = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
		MATH_VecSetHorzNormalize(tv_sens)
		v_grab_object_pos = OBJ_PosGet() + ( tv_sens * 4.0)		// Joy pas a l'opposé de l'ennemi : position calculée dans l'axe de l'ennemi
	}
	else
		v_grab_object_pos = OBJ_PosGet() + (v_joy_sight * 4.0)		// Position calculée dans l'axe du joy
	
	DBG_RenderVector(OBJ_PosGet(), v_grab_object_pos - OBJ_PosGet(), color_blanc)
	

	to_rider = RIDE_Get_Actor( ti_ind)											// As Ton un truc sur le dos
	if( to_rider)
	{
		i_GrabKong_Type = Ci_GrabKong_Type_Petit
		i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
		ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ThisClientGet( to_rider, Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)		
		if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
		RIDE_Del_Actor(ti_ind)
	}
	else if ( o_scolo_actor)
	{
		i_GrabKong_Type = Ci_GrabKong_Type_Petit
		i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
		ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ThisClientGet(o_scolo_actor, Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)
	}
	else if ( o_GrabKong_Dash_Target && @o_GrabKong_Dash_Target AI_IsModel(get_PNJ_KTREX_Path) 
	&& @o_GrabKong_Dash_Target KT_Proc_Dodges())
	{
		o_GrabKong_Dash_Target = nobody
		i_GrabKong_Dash = faux
	}
	else if ( ! ao_CL_GRABKONG[0] && ! ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
	{
//		// ADD FAIT CHIER
//		if ( GRAB_ANN_Propose())
//			i_GrabKong_grabAnnAccepte = vrai
//		else
//			i_GrabKong_grabAnnAccepte = faux

		// ADD FAIT CHIER
		f_GrabKong_Dash_Dist = Cf_Infinit
		i_GrabKong_Type = Ci_GrabKong_Type_Gros	+ Ci_GrabKong_Type_Mashing			
		i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
		ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", "k_exec_selection_grab", nofunc)
	}

	if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
	{
		// J'attrape un objet fixe
		to_bone = nobody
		ti_type = LNK_GrabKong_TypeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])
		if ( ti_type & Ci_GrabKong_Type_Petit)
		{
			// J'attrape un object léger
			i_flag_grab_raptor_en_cours = vrai
			if( to_rider || o_scolo_actor)
			{
				// kong grabe depuis son dos pour jeter, on n'active encore pas l'IK du bras
				ACT_ActionSet( Ci_Kanim_AttrapeDos_D + i_GrabKong_MainActionGrab) 
			}
			else
			{
				// l'IK du bras activée
				i_Grab_Torse_Main = i_GrabKong_MainActionGrab
				ACT_ActionSet( Ci_Kanim_Attrape_D + i_GrabKong_MainActionGrab)		// Attraper
			}
		}
//		else if ( ti_type & Ci_GrabKong_Type_Souche)
//		{
//			// J'attrape une souche
//			i_GrabKong_Souche = vrai		// Rajout par FRED
//			// souche
//			i_flag_positionne_souche = vrai
//			// Lancer l anim d attrape mais rien a chopper
//			ACT_ActionSet( Ci_Kanim_Attrape_D + i_GrabKong_MainActionGrab)		// Attraper
//			v_frappe_sight = LNK_GrabKong_LanceVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) - OBJ_PosGet()		
//		}
		else if ( ti_type & Ci_GrabKong_Type_Gros)
		{
			i_GrabKong_cote = (ti_type & Ci_GrabKong_Type_Special)				// Grab mode special
			i_GrabKong_MainBloquee = i_GrabKong_MainActionGrab
			// Choix du mode : Kong CHARGE ou c'est le TREX ?
			if ( i_GrabKong_cote) 
			{
				f_GrabKong_BlendPosInit = 5.0
				tv_sens =  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet() - OBJ_PosGet() 
				MATH_VecSetHorzNormalize( tv_sens)
				if( ti_type & Ci_GrabKong_Type_Droit)
					i_GrabKong_Sens_cote = 2
				else
					i_GrabKong_Sens_cote = 1
				SWEEP_Change_To_MashSePlace( i_GrabKong_Sens_cote)
			}
			else
			{	
				f_GrabKong_BlendPosInit = 1.5
				LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  Ci_GrabKong_Attrape)
				ACT_ActionSet( Ci_Kanim_Grab_recal) 
				LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  1)
			}
			LNK_GrabBoneSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], ANI_CanalObjectGet( Anim_Canal_MainDroite))
			LNK_GrabKong_ArmSizeSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], 2.0)
			to_tete = @ao_CL_GRABKONG[i_GrabKong_MainActionGrab] ANI_CanalObjectGet( Anim_Canal_Tete)
			tv_sight = @to_tete OBJ_PosGet() - OBJ_PosGet()
			MATH_VecSetHorzNormalize( tv_sight)
			v_frappe_sight = tv_sight
			// Grab sur une grosse cible
			o_GrabKong_Target = ao_CL_GRABKONG[i_GrabKong_MainBloquee]		// Acteur tenu en respet
			i_IK_end = vrai		// L IK s active seulement pendant le placmeent	
			f_grab_blend_main = 0.0							// Blend de la position de la main : entre la position del  anim et celle de l IK)
			v_GrabKong_init_grab = OBJ_PosGet()		// Position de depard du grab pour un blend de position
			v_GrabKong_speed_grab = LNK_GrabKong_SpeedVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])
			f_GrabKong_speed_grab_min = Cf_charge_Kong_speed_min
			i_GrabKong_mode = 1
			f_time_start_etat = 0.0
			// recherche du vecteur d offset entre la position idéale d encrage et Kong
			tv_sens = OBJ_PosGet() - @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet()
			tv_sens -= LNK_GrabKong_AncrageVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) * LNK_GrabKong_NeckSizeGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab])
			tv_sens.z = 0.0
			v_Grab_Kong_Offset_init = tv_sens	// vecteur differentiel de position initial
		}
		else
			return ti_type
	}
//	else if ( !ao_CL[Ci_LNK_KKGRAB_OBJECT] && ! i_GrabKong_Dash)
	else if ( ! i_Grab_Torse_ANN && ! i_GrabKong_Dash)		/////////// KING KONG 2 //////////// on peut attrapper avec ANN sur l'épaule
	{
		// Lancer l anim d attrape mais rien a chopper
		i_GrabKong_raptor_test = vrai
		ACT_ActionSet( (Ci_Kanim_Attrape_D + i_GrabKong_MainActionGrab) | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_FrameZero)		// Attraper
	}
	return 0
}		

procedure_local int SWEEP_Check_Lance( int pi_test_lance_anim)
{
	vector	tv_temp
	vector	tv_temp2
	vector	tv_sens_KT
	vector	tv_posA
	vector	tv_posB
	float		tf_dot, tf_dot2
	
	Sweep_pre_calculs
	if ( i_GrabKong_sweep_Throw)
	{	
		if( i_GrabKong_force_sweep)
			return vrai
		else
			return faux
	}
	else if ( (MATH_VecDotProduct( tv_temp, v_GrabKong_axe ) > tf_dot 
	&& MATH_VecDotProduct( v_GrabKong_axe, tv_temp2 ) > tf_dot 
	&& ( !pi_test_lance_anim || !i_GrabKong_Lance_Anim))
	|| (i_GrabKong_force_sweep && pi_test_lance_anim))	// Juste a l init on le test
		return vrai
	else
		return faux
}

procedure_local void SWEEP_Change_To_LanceOrSweep()
{
	vector	tv_temp
	vector	tv_temp2
	vector	tv_speed
	vector	tv_sens
	vector	tv_posA
	vector	tv_posB
	float		tf_dot
	float		tf_dot2
	float		tf_dot3
	int			ti_force_ejection_sweep
	int			ti_force_sweep
	
	// Tenter de jeter
	i_GrabKong_mode = 0
	i_GrabKong_orient  = faux

	//  LACHER PRISE
	i_GrabKong_attrape_jete = Ci_Repousse
	i_GrabKong_MainActionGrab = i_GrabKong_MainBloquee
	
	// -----------------------------------------------------------------------------------------
	// CHOIX DE L ANIM D'EJECTION et de la FORCE d EJECTION
	// -----------------------------------------------------------------------------------------
	
	// Test de la validite de l angle d ejection en swing !!
	tv_temp = v_joy_sight
	tv_temp.z = 0.0																						// force de lancé de Kong
	tv_speed = LNK_GrabKong_SpeedVectorGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee])	// vitesse du TREX
	if (  MATH_VecNullEpsilon(tv_speed))
		tv_speed = OBJ_SightGet()
	else
		MATH_VecSetNormalize( tv_speed)
	// Formule de cumulation de force

	i_GrabKong_Lance_Anim = 0		// Par defaut on jete direct dans avoir a caler des anims
	v_joy_grab_lance_TREX = glob_joyvector_get * 100.0

	// DEGAGEMENT EN MODE ARRET(  NON SWEEP)
	// De Face : anim en fonction du Joy
	// Anim

	i_GrabKong_Throw = faux
	v_GrabKong_init_grab = OBJ_PosGet()		// Positiond ou debute le blend de position
	i_IK_end = vrai
	LNK_GrabKong_ActionSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], Ci_GrabKong_Lance_SePositionne)
	LNK_GrabKong_LanceVectorSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee], v_joy_sight)	// Memorisation
	tf_dot = MATH_VecDotProduct( v_joy_sight,  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_HorizonGet())
	tf_dot2 = MATH_VecDotProduct( v_joy_sight,  @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet())

	// ON LANCE TOUJOURS DE LA MEME FACON !!!	
	ti_force_ejection_sweep = vrai		// Forcer le sweep sauf si on projete
//			if ( MATH_VecDotProduct(  LNK_GrabKong_AncrageVectorGet(  amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]), @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet()) < Cf_Cos5)
//			MODE SPECIAL SPEC 2 : PROJECTION

	if ( !MATH_FloatNullEpsilon(f_joy_norm))
		tv_speed = v_joy_sight * Cf_Force_Jete
	else
		tv_speed = @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_SightGet() * Cf_Force_Jete


	v_GrabKong_axe = MATH_VecNormalize( tv_speed)
	f_GrabKong_rot_sign = MATH_FloatSign(MATH_VecDotProduct( v_GrabKong_axe, OBJ_HorizonGet()))


//	Sweep_pre_calculs
//	if (( MATH_VecDotProduct( tv_temp, v_GrabKong_axe ) > tf_dot 
//	&& MATH_VecDotProduct( v_GrabKong_axe, tv_temp2 ) > tf_dot 
//	&& !i_GrabKong_Lance_Anim)
//	|| ti_force_sweep)
	i_GrabKong_sweep_Throw = faux		// Par defaut on ne force pas, c'est le resutlat
	if ( SWEEP_Check_Lance(1))
	{
		// KONG LANCE LE TREX VERS LUI MEME : SWEEP POUR DEGAGER KE TREX SUR LE COTE
		if ( i_GrabKong_force_sweep)
			i_GrabKong_sweep_Throw = vrai
		else
			i_GrabKong_sweep_Throw = faux
		SWEEP_Change_To_Sweep( Cv_NullVector, MATH_VecNormalize( tv_speed), MATH_VecNormalize( tv_speed) * 20.0, vrai,vrai)
		return

	}
	else
	{
		DBG_RenderCircle( OBJ_PosGet(), 2.5, Cv_VerticalVector, color_rouge)
		DBG_RenderVector( @ao_CL_GRABKONG[i_GrabKong_MainBloquee] OBJ_PosGet(), tv_speed, color_vert)
		v_frappe_speed = Cv_NullVector
	}


	// DEGAGEMENT EN SWEEP

	if ( !i_GrabKong_Lance_Anim)
	{
		// Force additionelle de lancé
		if ( MATH_VecNullEpsilon( v_frappe_sight))
			tv_speed = cvector( 0, 0, 666)
		o_Throw_Target = nobody			
		SWEEP_Change_To_Lance( tv_speed, vrai, vrai, vrai)
		f_coef_pied_d_appui = i_GrabKong_MainActionGrab						// Coef pied d'appui pour rotation pied
	}
	else
	{
		if ( ti_force_ejection_sweep )
		{
			// choix de l anim de l ancé du TREX
			SWEEP_LAnce_Choix_Anim( v_joy_sight)
		}
		LNK_GrabKong_AnimJeteSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  i_GrabKong_Lance_Anim)
	}
}


// SOUND
procedure_local void Proc_KK_SND_CHEST_Play()
{
	if (i_sound_chest == -1)
	{
		i_sound_chest = SND_Request(4,C_SND_Request_3DSound)
		SND_Play(i_sound_chest)
		f_sound_volume_B = 1.0
	}
}

procedure_local void Proc_KK_SND_CHEST_Stop()
{
	if (i_sound_chest != -1)
	{
		SND_FlagSet(i_sound_chest, C_SND_Request_DestroyWhenFinished)
		SND_Stop(i_sound_chest)
		i_sound_chest = -1
	}
}

procedure_local void Proc_KK_PAF_Repulse()
{
	int		ti_i
	int		ti_collision_nb
	vector	tv_sens
	object	tao_zde_zde_list[20]

	COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 2.0))
	COL_ZoneSizeSet( C_zde_fight, cvector( 4.0, 4.0, 4.0))
	ti_collision_nb = COL_ZDE_ZDEListGet( &tao_zde_zde_list[0], C_zde_fight, C_zde_tete, all, none, Ci_Filter_IdentityFlag)
	for (ti_i = 0; ti_i < ti_collision_nb; ti_i++)
	{
		tv_sens = @tao_zde_zde_list[ti_i] OBJ_PosGet() - COL_ZonePosGet( C_zde_fight)
		EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_PAF_KK_Faible, OBJ_Me(), Cf_EVENT_Duree_1Trame, tao_zde_zde_list[ti_i], -1, 0.0, tv_sens, COL_ZonePosGet( C_zde_fight))
//		if( Proc_KK_EstUnEnnemiDeKong(tao_zde_zde_list[ti_i]) )
//			STATS_IncAttack()
	}
	if( COL_CollideType( COL_C_Wall))
	{
		tao_zde_zde_list[0] = COL_ObjectGet( COL_C_Wall)
		if ( @tao_zde_zde_list[0] OBJ_FlagsIdentityGet()  & OBJ_C_IdentityFlag_AI)
		{
			tv_sens = @tao_zde_zde_list[0] OBJ_PosGet() - COL_ZonePosGet( C_zde_fight)
			EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_PAF_KK_Faible, OBJ_Me(), Cf_EVENT_Duree_1Trame, tao_zde_zde_list[0], -1, 0.0, tv_sens, COL_ZonePosGet( C_zde_fight))
//			if( Proc_KK_EstUnEnnemiDeKong(tao_zde_zde_list[0]) )
//				STATS_IncAttack()
		}
	}
}


procedure_local void Proc_KK_RumbleGrowWithPower( float pf_speed_up) //  float pf_speed_down, float pf_mini)
{
	if ( i_flag_just_Rage_Any_Button)
	{
		f_rumble_power += pf_speed_up * TIME_GetDt() // speed up
		f_rumble_time_press = TIME_Get()
	}
	else if ( TIME_Elapsed( f_rumble_time_press, 0.4))		// Delai
		f_rumble_power = MATH_FloatMax( 50, f_rumble_power - ( 80.0 * TIME_GetDt())) // speed down
	IO_PafSet( f_rumble_power,1)
}


procedure_local void Proc_KK_SFX_Impact_Mur()
{
	vector tv_pos
	vector tv_normal
	int i_soundID
	int i_displayTexture
	object to_epauleGauche
	object to_doigtG1 
	object Impact_GFX_Path 

	Impact_GFX_Path = get_Impact_GFX_path
	if(Impact_GFX_Path)
	{
		to_epauleGauche	= ANI_CanalObjectGet( Anim_Canal_EpauleGauche) 
		to_doigtG1			= ANI_CanalObjectGet( Anim_Canal_DoigtG1)	
		if( @Impact_GFX_Path Proc_KK_TestWall( @to_epauleGauche OBJ_PosGet(), @to_doigtG1 OBJ_PosGet(), tv_pos,  tv_normal,  i_soundID, i_displayTexture))
		{	
			@Impact_GFX_Path Proc_KK_SFXADD(SFX_ID_ImpactOnWall, tv_pos, tv_normal, i_soundID, i_displayTexture, Cv_NullVector)
		}	
	}
}

procedure_local void Proc_KK_SFX_Impact_Sol()
{
//	vector tv_pos1
//	vector tv_normal
//	int         i_soundID
//	int         i_displayTexture
//	object   to_Cou
//	object   Impact_GFX_Path  
//
//	Impact_GFX_Path    = get_Impact_GFX_path
//	if(Impact_GFX_Path)
//	{
//		to_Cou = ANI_CanalObjectGet( Anim_Canal_Cou) 
//		if( @Impact_GFX_Path Proc_KK_TestGround(@to_Cou OBJ_PosGet() , tv_pos1,  tv_normal,  i_soundID, i_displayTexture) )			
//		{         
////			Proc_KK_SFX_Ring( tv_pos1, tv_normal)
//			Proc_KK_SFX_Splash( tv_pos1, tv_normal)
//		}                                   	
//	}

	vector tv_pos
	vector tv_normal
	int i_soundID
	object   to_Cou
	object to_doigtG1 

	to_Cou = COL_RayObject_Vector( OBJ_PosGet() + cvector( 0.0, 0.0, 0.5), -Cv_VerticalVector , all, none, 0, COL_C_Ray_on_visuel )
	if ( TIME_Elapsed( f_SFX_time_PAF_Ground, 0.9)
	&&  to_Cou)
	{
		f_SFX_time_PAF_Ground = TIME_Get()
		i_soundID = COL_RayObject_SoundGet()	
		if ( i_soundID == 4)
			Proc_KK_SFX_Splash( OBJ_PosGet(), Cv_VerticalVector) 	
		else
			Proc_KK_SFX_Ring( OBJ_PosGet(), Cv_VerticalVector)
	}

}

procedure_local void Proc_KK_Impact_Sol2()
{
	vector tv_pos
	vector tv_normal
	int i_soundID
	object   to_Cou
	object to_doigtG1 

	to_doigtG1	= ANI_CanalObjectGet( Anim_Canal_DoigtD1)
	              // @to_doigtG1 OBJ_PosGet()
	to_Cou = COL_RayObject_Vector( v_IK_bone_last_valid_pos[2], -Cv_VerticalVector , all, none, 0, COL_C_Ray_on_visuel )
	if ( TIME_Elapsed( f_SFX_time_PAF_Ground, 0.9)
	&&  to_Cou)
	{
		f_SFX_time_PAF_Ground = TIME_Get()
		i_soundID = COL_RayObject_SoundGet()	
		if ( i_soundID == 4)
			Proc_KK_SFX_Splash( v_IK_bone_last_valid_pos[2], Cv_VerticalVector) 	
		else
			Proc_KK_SFX_Ring( v_IK_bone_last_valid_pos[2], Cv_VerticalVector)
	}
}

procedure_local void Proc_KK_DashImpact(int i_type)
{
	vector 	tv_pos1
	vector 	tv_normal
	int         i_soundID
	int         i_displayTexture
	object   	o_torso
	object   	Impact_GFX_Path  
	vector 	tv_collidedPoint 	

	o_torso= ANI_CanalObjectGet( Anim_Canal_Torse) 
	switch(i_type)
	{
		case 1: // FALL DOS
			tv_collidedPoint = @o_torso OBJ_PosGet() + (@o_torso OBJ_SightGet()*1.5)
			break
		case 2 : // FALL DROITE
			tv_collidedPoint = @o_torso OBJ_PosGet() - (@o_torso OBJ_HorizonGet()*1.5)
			break
		case 3 : // FALL GAUCHE
			tv_collidedPoint = @o_torso OBJ_PosGet() + (@o_torso OBJ_HorizonGet()*1.5)
			break
		case 4 : // DASH ATTACK ON WALL
			tv_collidedPoint  = COL_CollidedPointGet(COL_C_Wall)
			break
	}
	Impact_GFX_Path    = get_Impact_GFX_path
	if(Impact_GFX_Path)
	{
		
		if(tv_collidedPoint == Cv_NullVector)
			tv_collidedPoint = @o_torso OBJ_PosGet() + (@o_torso OBJ_SightGet()*1.5)
		if( @get_Impact_GFX_path Proc_KK_TestThrowImpact(@o_torso OBJ_PosGet(), tv_collidedPoint, tv_pos1, tv_normal, i_soundID, i_displayTexture))//Proc_KK_TestThrowImpact			
		{           
			OBJ_CapaSet(Capa_Fall_On_Ground_PAF, none)
			i_paf_fall_on_ground_done = vrai
			if ( i_soundID == 4)
				Proc_KK_SFX_Splash( tv_pos1, tv_normal)
			else
				Proc_KK_SFX_Ring( tv_pos1, tv_normal)
		}                                   	
	}
}

procedure_local void	PAF_Test_ChangeEtatValid(byref function fct)
{																																	
	object		mto_tete
	
	fct = nofunc
	
	if( i_paf_type & C_PAF_KK_Exit_Colmap )
	{
		// Translation ajoutée
		v_exit_colmap_add_speed = v_paf_dir
	}
	else if ( ! (i_paf_type & (C_PAF_KK_Faible | C_PAF_KK_Micro) ) )
	{
		// LACHER GRAB PRINCIPAL
		if ( i_GrabKong_MainBloquee != -1 )
		{
			ao_CL_GRABKONG[i_GrabKong_MainBloquee] = LNK_ClientGet( Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee],  faux, nofunc, nofunc, nofunc)
			i_GrabKong_MainBloquee = -1			
			if ( o_GrabKong_Target)									
				AI_CBDel( o_GrabKong_Target, CallBack_After_Blend, "k_exec_Ik_GrabKong")					
			o_GrabKong_Target = nobody
		}		

		// TEST LACHER SOUCHE
		if( i_GrabKong_Souche && (i_paf_type & C_PAF_KK_Fort))
		{
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ClientGet( Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  faux, "k_exec_grab_object_param", nofunc, nofunc)
			i_GrabKong_Souche = faux
		}
		
		// TEST LACHER RAPTOR
		if( i_Grab_Torse_Actor && ! i_Grab_Torse_ANN )
		{
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ClientGet( Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab],  faux, "k_exec_grab_object_param", nofunc, nofunc)
			i_Grab_Torse_Actor = faux
		}	
	}

	// PAFS QUI DEMANDENT UN CHANGEMENT D'ETAT
	if( i_paf_type & (C_PAF_KK_Fort | C_PAF_KK_Moyen | C_PAF_KK_Faible | C_PAF_KK_Digwazai ) ) // | C_PAF_KK_Javelin) )
	{
		if ( o_colonne)
		{
			if( @get_global i_Player_is_Kong )		// ne pas décrocher si on joue l'indigène
			{
			 	i_jump_force_chute = faux
				i_jump_force_anim_cycl = Ci_Kanim_saute_chute_paf_chute
				i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
				i_jump_force_anim_impulsion = Ci_Kanim_saute_chute_paf
				i_jump_force_no_orient_impulsion = vrai
				v_jump_force_chute_orient = Cv_NullVector
				f_jump_force_amplitude = 1.5 // Saut cloche
				i_jump_force_zdm_impulsion = faux
				i_jump_check_hotspot = faux	// Rien detecté, tester apres l impulsion
				i_jump_check_hotspot_fight = faux	// On peux enchainer sur un ennemi
				f_jump_force_hauteur = 2.0 	// Saut a l opposé du mur
				i_walling_action_impulsion_before_jump = vrai // pas rétablir la gravité
				v_jump_force_sens = -OBJ_SightGet()
				fct = "k_ETAT_jump"
			}
		}
		else if ( EVENT_LIFE_CurLifeGet(ID_LIFE) < -50)
		{
			fct = "k_ETAT_mort"
			i_mode_mort = Ci_Kcamera_saut_mort_digwazai
		}
		else if ( i_etat_courant != ETAT_Kong_swing_arch || ! ( i_paf_type & C_PAF_KK_Faible))
			fct = "k_ETAT_paf"
	}
}





procedure_local void Proc_KK_Impact_FootSteps(float f_global_time_local, float f_delay_hand_run_SFX_local, float f_delay_foot_run_SFX_local, int i_SFX_ID_ImpactOnLeftFoot, int i_SFX_ID_ImpactOnRightFoot, int i_SFX_ID_ImpactOnLeftHand, int i_SFX_ID_ImpactOnRightHand, int is_Walking, int i_type)
{
	
	object o_Jambe 
	object o_Foot
	vector tv_pos1
	vector tv_normal1
	vector v_foot
	int i_soundID
	int i_displayTexture
	
	//WALKING
	if(i_type==2)
	{
		//o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_Ventre)
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_DoigtD1) //ANI_CanalObjectGet( Anim_Canal_PiedDroit)  
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_MainDroite)//ANI_CanalObjectGet(Anim_Canal_JambeDroite)  Anim_Canal_Ventre
	
		i_displayTexture = faux
		
		if(@get_Impact_GFX_path Proc_KK_TestFoot(@o_Jambe  OBJ_PosGet() , @o_Foot OBJ_PosGet(), tv_pos1, tv_normal1, i_soundID, i_displayTexture )) //@o_Foot OBJ_PosGet()
		{
			if(f_global_time_local - f_start_walkD_SFX_time >= f_delay_hand_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnLeftFoot, @o_Foot OBJ_PosGet() , tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkD_SFX_time = TIME_Get()
			}
		}	
	
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_DoigtG1)//ANI_CanalObjectGet( Anim_Canal_PiedGauche)
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_MainGauche)//ANI_CanalObjectGet(Anim_Canal_JambeGauche)
		
		if(@get_Impact_GFX_path Proc_KK_TestFoot(@o_Jambe  OBJ_PosGet() , @o_Foot OBJ_PosGet() , tv_pos1, tv_normal1, i_soundID, i_displayTexture)) //@o_Foot OBJ_PosGet()
		{
			if(f_global_time_local - f_start_walkG_SFX_time >= f_delay_hand_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnRightFoot, @o_Foot OBJ_PosGet() , tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkG_SFX_time = TIME_Get()
			}
		}	
		if(is_Walking)
			i_displayTexture = faux
		else
			i_displayTexture = vrai
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_PiedDroit)  
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_JambeDroite)
	
		if(@get_Impact_GFX_path Proc_KK_TestFoot(@o_Jambe OBJ_PosGet() , @o_Foot OBJ_PosGet(), tv_pos1, tv_normal1, i_soundID, i_displayTexture ))
		{
			if(f_global_time_local - f_start_walkD1_SFX_time >= f_delay_foot_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnLeftHand ,tv_pos1, tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkD1_SFX_time = TIME_Get()
			}
		}	
	
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_PiedGauche)
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_JambeGauche)
		
		if(@get_Impact_GFX_path Proc_KK_TestFoot(@o_Jambe OBJ_PosGet() , @o_Foot OBJ_PosGet(), tv_pos1, tv_normal1, i_soundID, i_displayTexture))
		{
			if(f_global_time_local - f_start_walkG1_SFX_time >= f_delay_foot_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnRightHand, tv_pos1, tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkG1_SFX_time = TIME_Get()
			}
		}	
	}
	//WALLING COURSE
	if(i_type == 0)
	{
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_DoigtD1)//ANI_CanalObjectGet(Anim_Canal_JambeDroite)  Anim_Canal_Ventre
		v_foot		= @o_Jambe OBJ_PosGet() - @o_Jambe OBJ_HorizonGet()
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_MainDroite)
	
		i_displayTexture = faux
		
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe  OBJ_PosGet() , v_foot, tv_pos1, tv_normal1, i_soundID, i_displayTexture )) //@o_Foot OBJ_PosGet()
		{
			if(f_global_time_local - f_start_walkD_SFX_time >= f_delay_hand_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnLeftFoot, @o_Foot OBJ_PosGet(), tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkD_SFX_time = TIME_Get()
			}
		}	
		
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_DoigtG1)//ANI_CanalObjectGet(Anim_Canal_JambeGauche)
		v_foot		= @o_Jambe OBJ_PosGet() - @o_Jambe OBJ_HorizonGet()
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_MainGauche)
		
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe  OBJ_PosGet() , v_foot , tv_pos1, tv_normal1, i_soundID, i_displayTexture)) //@o_Foot OBJ_PosGet()
		{
			if(f_global_time_local - f_start_walkG_SFX_time >= f_delay_hand_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnRightFoot, @o_Foot OBJ_PosGet() , tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkG_SFX_time = TIME_Get()
			}
		}	
		if(is_Walking)
			i_displayTexture = faux
		else
			i_displayTexture = vrai
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_PiedDroit)
		v_foot		= @o_Jambe OBJ_PosGet() + @o_Jambe OBJ_SightGet() 
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_PiedDroit)
	
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe OBJ_PosGet() , v_foot, tv_pos1, tv_normal1, i_soundID, i_displayTexture ))
		{
			if(f_global_time_local - f_start_walkD1_SFX_time >= f_delay_foot_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnLeftHand, @o_Foot OBJ_PosGet(), tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkD1_SFX_time = TIME_Get()
			}
		}	
		
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_PiedGauche)
		v_foot		= @o_Jambe OBJ_PosGet() + @o_Jambe OBJ_BankingGet() 
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_PiedGauche)
		
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe OBJ_PosGet() , v_foot, tv_pos1, tv_normal1, i_soundID, i_displayTexture))
		{
			if(f_global_time_local - f_start_walkG1_SFX_time >= f_delay_foot_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnRightHand, @o_Foot OBJ_PosGet() , tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkG1_SFX_time = TIME_Get()
			}
		}	
	}
	
	//WALLING DERAPE
	if(i_type == 1)
	{
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_DoigtD1)//ANI_CanalObjectGet(Anim_Canal_JambeDroite)  Anim_Canal_Ventre
		v_foot		= @o_Jambe OBJ_PosGet() - @o_Jambe OBJ_HorizonGet()
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_MainDroite)
	
		i_displayTexture = faux
		
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe  OBJ_PosGet() , v_foot, tv_pos1, tv_normal1, i_soundID, i_displayTexture )) //@o_Foot OBJ_PosGet()
		{
			if(f_global_time_local - f_start_walkD_SFX_time >= f_delay_hand_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnLeftFoot, @o_Foot OBJ_PosGet(), tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkD_SFX_time = TIME_Get()
			}
		}	
		
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_DoigtG1)//ANI_CanalObjectGet(Anim_Canal_JambeGauche)
		v_foot		= @o_Jambe OBJ_PosGet() + @o_Jambe OBJ_HorizonGet()
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_MainGauche)
		
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe  OBJ_PosGet() , v_foot , tv_pos1, tv_normal1, i_soundID, i_displayTexture)) //@o_Foot OBJ_PosGet()
		{
			if(f_global_time_local - f_start_walkG_SFX_time >= f_delay_hand_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnRightFoot, @o_Foot OBJ_PosGet() , tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkG_SFX_time = TIME_Get()
			}
		}	
		if(is_Walking)
			i_displayTexture = faux
		else
			i_displayTexture = vrai
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_PiedDroit)
		v_foot		= @o_Jambe OBJ_PosGet() + @o_Jambe OBJ_SightGet() 
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_PiedDroit)
	
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe OBJ_PosGet() , v_foot, tv_pos1, tv_normal1, i_soundID, i_displayTexture ))
		{
			if(f_global_time_local - f_start_walkD1_SFX_time >= f_delay_foot_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnLeftHand, tv_pos1, tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkD1_SFX_time = TIME_Get()
			}
		}	
		
		o_Jambe  	= ANI_CanalObjectGet(Anim_Canal_PiedGauche)
		v_foot		= @o_Jambe OBJ_PosGet() + @o_Jambe OBJ_SightGet()
		o_Foot 		= ANI_CanalObjectGet( Anim_Canal_PiedGauche)
		
		if(@get_Impact_GFX_path Proc_KK_TestImpact(@o_Jambe OBJ_PosGet() , v_foot, tv_pos1, tv_normal1, i_soundID, i_displayTexture))
		{
			if(f_global_time_local - f_start_walkG1_SFX_time >= f_delay_foot_run_SFX_local)
			{
				@get_Impact_GFX_path Proc_KK_SFXADD(i_SFX_ID_ImpactOnRightHand, tv_pos1 , tv_normal1, i_soundID, i_displayTexture, OBJ_SightGet())	
				f_start_walkG1_SFX_time = TIME_Get()
			}
		}	
	}
}


procedure_local void KONG_Test_ZDE_ZDE( int ti_zde1, int ti_zde2, vector tv_sens, int ti_flag_tue_grab_torse_actor, int ti_force_paf_repousse )
{
	int						ti_collision_nb
	int						ti_i
	int						ti_coup3
	int						ti_ind
	float					ti_puissance
	object				tao_zde_zde_list[50]
	object				to_tete
	object				to_temp_tracable
	object				to_gao
	int						ti_k
	int						ti_ride
	messageid			tmid_visibility
	messageid			tmid_msgid
	int						ti_visibility_type
	int						ti_paf_allowed
	int						ti_target_is_trex
	int						ti_paf_type
	vector				tv_pos
	vector				tv_pos_kong
	vector				tv_pos_nmi
	float					tf_ride_coef
	
	if ( i_GrabKong_Souche)
		to_gao = ao_CL_GRABKONG[i_GrabKong_MainActionGrab]
	else
		to_gao = OBJ_Me()
	if ( !to_gao)
		return		// Souche destroy while hitting
	
	ti_collision_nb = @to_gao COL_ZDE_ZDEListGet( &tao_zde_zde_list[0], ti_zde1, ti_zde2, all, none, Ci_Filter_IdentityFlag)
	for (ti_i = 0; ti_i < ti_collision_nb; ti_i++)
	{
		ti_target_is_trex = faux
		ti_paf_allowed = vrai
		to_temp_tracable = tao_zde_zde_list[ti_i]
		
		tv_pos_kong = COL_ZonePosGet(ti_zde1)
		tv_pos_nmi = @to_temp_tracable COL_ZonePosGet(ti_zde2)
		tv_pos = (tv_pos_kong + tv_pos_nmi) / 2.0
//		tv_pos = tv_pos_nmi
//		to_gao = ANI_CanalObjectGet(Anim_Canal_MainGauche)
//		tv_pos = @to_gao OBJ_PosGet()
//		DBG_RenderVector(tv_pos_kong, Cv_VerticalVector, color_jaune)
//		DBG_RenderVector(tv_pos_nmi, Cv_VerticalVector, color_bleu)
//		DBG_RenderVector(tv_pos, Cv_VerticalVector, color_vert)
		tv_pos += (3.0 * tv_sens)
//		DBG_RenderVector(tv_pos, Cv_VerticalVector, color_rouge)
		
		ti_ind = ARR_ObjSearch( &ao_frappe_target[0], i_frappe_target_nb, to_temp_tracable)
		if( to_temp_tracable == OBJ_Me() )
			continue
		if( to_temp_tracable == o_Joueur )
			continue
		if( to_temp_tracable == AI_MainActorGet(C_ID_Joueur) )		//////////// KING KONG 2 ///////////////
			continue
		if ( ti_ind == -1 )	// je n'ai pas encore paffé cet acteur
		{
			// PAF RESTRICTIONS --------------------------------------------------------------------------------------------------------------
			
			// Ne pas paffer en reculant l'acteur qui vient de me paffer
			if( to_temp_tracable == o_paf_actor_backup )
				continue
			
			// Ne pas paffer ce type d'nmi quand je recule à cause d'un paf que j'ai reçu
			if( i_frappe_coup == Ci_Frappe_Avec_Corps 
			&& @to_temp_tracable OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI)
			&& ( @to_temp_tracable AI_IsModel(get_PNJ_Scolo_Path) 
					|| @to_temp_tracable AI_IsModel(get_PNJ_KRaptor_path)
					|| @to_temp_tracable AI_IsModel(get_PNJ_KBats_path)
					|| @to_temp_tracable AI_IsModel(get_PNJ_KNative_path) ) )
				continue
			
			// Restrictions spécifiques au TREX
			if( @to_temp_tracable OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) && @to_temp_tracable AI_IsModel(get_PNJ_KTREX_Path) )
			{
				// Ne pas paffer REX qui dodge ma dash attack
				if ( COUP_MODE() ==C_Mode_Dash_Attack && @to_temp_tracable KT_Proc_Dodges() )
					continue
				// Ne pas paffer REX qui va de toute façon refuser mon paf (pour ne pas déclencher les FX)
				if( @to_temp_tracable KT_Proc_RefusePaf() )
					continue
			}
			
			// Ne pas paffer les raptors et les bats qui sont sur mon dos
			ti_ride = faux
			for (ti_k = 0; ti_k < Ci_Ride_Client_Nb; ti_k++)
			{
				if( ao_bone_rider[ti_k] == to_temp_tracable )
				{
					if( ! @to_temp_tracable AI_IsModel(get_PNJ_KBats_path) || @to_temp_tracable KBC_Proc_Get_Ride_Pos_Coef() > 0.9 )
					{
						ti_ride = vrai		// ce n'est pas une bat ou c'est une bat qui est bien agrippée -> je ne la paffe pas
						break
					}
				}
			}
			if( ti_ride )
				continue
			
			// Ne pas paffer le scolo qui me grabbe
			if( to_temp_tracable == o_scolo_actor )
				continue
			
			// PAF RESTRICTIONS --------------------------------------------------------------------------------------------------------------
			
			// Test type d'ennemi
			tmid_visibility = EVENT_FindEventPereTarget(C_EVENT_TYPE_Visibility, to_temp_tracable, nobody)
			if( MSG_GlobalIsValid(tmid_visibility) )
			{
				ti_visibility_type = EVENT_VisionIDGet(tmid_visibility)
				if( ti_visibility_type == C_ID_Tyranosaure )
					ti_target_is_trex = vrai
			}
			
			// Test paf en dashant
			if( ACT_ActionGet() == Ci_Kanim_dash && ti_target_is_trex )
				ti_paf_allowed = faux
			
			// Ne pas paffer l'ennemi que je grabbe à 1 main
			if( i_Grab_Torse_Main != -1 && to_temp_tracable == ao_CL_GRABKONG[i_Grab_Torse_Main] )
				ti_paf_allowed = faux
			
			if( ti_paf_allowed )
			{
				
				i_fight_paf = vrai
							
				if ( i_GrabKong_MainBloquee == -1 || ( ao_CL_GRABKONG[i_GrabKong_MainBloquee] != to_temp_tracable))
				{
					if( ! ti_force_paf_repousse )
					{
						// ne pas mémoriser l'acteur comme acteur paffé s'il prend un repousse, pour qu'il puisse prendre le vrai paf aussi
						ao_frappe_target[i_frappe_target_nb] = to_temp_tracable
						i_frappe_target_nb++
					}
					if ( ACT_ActionGet() == Ci_Kanim_coup_T_3)
						ti_coup3 = vrai
					else
						ti_coup3 = faux
					// CHARGE DE LA FURY	AUGMENTE AVEC LES COUPS REUSSI
					if( ti_force_paf_repousse )
					{
						if( ! ti_target_is_trex )
						{
							tv_sens = @to_temp_tracable OBJ_PosGet() - COL_ZonePosGet(C_zde_fight)
							tv_sens.z = 0.0
							if( MATH_VecNullToler(tv_sens, 0.1) )
								tv_sens = OBJ_SightGet()		// paf repousse lors d'un finish big scolo => Cv_NullVector
							else	
								MATH_VecSetNormalize(tv_sens)
							DBG_RenderVector(COL_ZonePosGet(C_zde_fight), tv_sens * 5, color_vert)
							Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_Faible + C_PAF_KK_Repousse, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, 0.0, tv_sens, tv_pos)
						}
					}
					else if ( i_GrabKong_Souche)
					{
						ti_paf_type = C_PAF_KK_Fort
						if ( i_reflex_anim == Ci_Kanim_souche_frappe_face)
							ti_paf_type += C_PAF_KK_Ecrasement
						ti_puissance  = Cf_DMG_Normal
						if( Proc_KK_RAGE_Test() )
							ti_puissance  += Cf_DMG_FuryAdd
						Proc_KK_Send_Paf( C_EVENT_FILTER_Object, ti_paf_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance , tv_sens, @ao_CL_GRABKONG[i_GrabKong_MainActionGrab]  COL_ZonePosGet( C_zde_fight))
						if( ti_target_is_trex )
							LNK_GrabKong_NbCoupSet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], LNK_GrabKong_NbCoupGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]) + 1)
					}
					else if( ACT_ActionGet() == Ci_Kanim_Dash_Attack)
					{
						ti_puissance  = Cf_DMG_Normal
						if( Proc_KK_RAGE_Test() )
							ti_puissance += Cf_DMG_FuryAdd
						Proc_KK_Send_Paf( C_EVENT_FILTER_Object,  C_PAF_KK_Fort, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance , OBJ_SightGet(), tv_pos)
					}
					else if( ACT_ActionGet() == Ci_Kanim_Walling_frappeG)
					{
						ti_puissance  = 0
						Proc_KK_Send_Paf( C_EVENT_FILTER_Object,  C_PAF_KK_Repousse, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance , OBJ_SightGet(), tv_pos)
					}
					else if( i_etat_courant == ETAT_Kong_jump )
					{
						if ( i_jump_to_grab || i_jump_to_frappe)
						{
							ti_puissance  = Cf_DMG_Normal * 3.0
							Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_Moyen + C_PAF_KK_Ecrasement, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance, OBJ_SightGet(), tv_pos)
						}
						else
						{
							ti_puissance  = Cf_DMG_Normal
							Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance, OBJ_SightGet(), tv_pos)
						}
					}
					else if ( i_etat_courant == ETAT_Kong_desequilibre)
					{
							ti_puissance  = Cf_DMG_Normal
							ti_paf_type = i_paf_recul_type
							Proc_KK_Send_Paf( C_EVENT_FILTER_Object, ti_paf_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance, OBJ_SightGet(), tv_pos)						
					}
					else if ( i_etat_courant == ETAT_Kong_swing_arch)
					{
							ti_puissance  = Cf_DMG_Normal
							ti_paf_type = C_PAF_KK_Moyen
							Proc_KK_Send_Paf( C_EVENT_FILTER_Object, ti_paf_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance, OBJ_SightGet(), tv_pos)						
					}
					else
					{
						ti_puissance = Cf_DMG_Normal
						
						if( ! MATH_FloatNullEpsilon(f_time_fury))
						{
							ti_paf_type = C_PAF_KK_Fort			// PAF FURY EST FORT
							ti_puissance  += Cf_DMG_FuryAdd
						}
						else
							ti_paf_type = C_PAF_KK_Moyen		// PAF NORMAL EST MOYEN
						
//						if (i_Grab_Torse_ANN)
//							ti_paf_type = C_PAF_KK_Faible + C_PAF_KK_Repousse
							
						if ( ti_coup3 )
							ti_paf_type |= C_PAF_KK_Ecrasement			// coup qui repousse
						else if ( ACT_ActionGet() == Ci_Kanim_coup_T_1)
							ti_paf_type = C_PAF_KK_Faible + C_PAF_KK_Repousse
						Proc_KK_Send_Paf( C_EVENT_FILTER_Object, ti_paf_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_temp_tracable, -1, ti_puissance, tv_sens, tv_pos)
					}
					
					// Tuer l'acteur grabbé dans la main
					if( ti_flag_tue_grab_torse_actor )
						Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_KiTue, OBJ_Me(), Cf_EVENT_Duree_1Trame, ao_CL_GRABKONG[i_Grab_Torse_Main], -1, 0.0, tv_sens, tv_pos)
				}
			}
		}
	}
}


procedure_local void Proc_KK_SFX_Walling( vector pv_pos , vector pv_normal) {
	int 		pi_GFX_Blood
	object	to_light_n_smoke_K
	
	if (WOR_GetKey() == 0xc101fedb || WOR_GetKey() == 0x28000105)
			return

	to_light_n_smoke_K = @get_global o_global_light_and_smoke_kanada

	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke_K , 1)					// met le materiau
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 8)															// Materiau 8
	GFX_Seti(pi_GFX_Blood, 13100, 30)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, 30) //0xFFFFFFFF)									// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.2)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 1.0)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.50)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.5)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.9)													// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.15)														// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.3)														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed

	if ( @get_global SFX_Fumee_Walk)
	{
		GFX_Seti(pi_GFX_Blood, 13103, 0x30000000 + @get_global SFX_Fumee_Walk)								// Color fase 0
		GFX_Seti(pi_GFX_Blood, 13104, 0x60000000 + @get_global SFX_Fumee_Walk)								// Color fase 1
	}
	else
	{
		GFX_Seti(pi_GFX_Blood, 13103, 0x30000000 + 0x00BAC8BB)								// Color fase 0
		GFX_Seti(pi_GFX_Blood, 13104, 0x60000000 + 0x00BAC8BB)								// Color fase 1
	}
	GFX_Seti(pi_GFX_Blood, 13105, Kcol)													// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 0.5)														// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 3)															// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -10.0)													// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, Cv_NullVector)										// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, pv_pos) 												// Creation Pos

	GFX_Setv(pi_GFX_Blood, 13201, cvector( -5.0, -5.0, -5.0))							// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, cvector( 5.0, 5.0, 5.0))								// Speed max

	if( ! to_light_n_smoke_K )
		return
	
	pi_GFX_Blood = GFX_Add(13)																// Create the boum
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke_K, 22) //19)	// met le materiau
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 3)															// Materiau 8
	GFX_Seti(pi_GFX_Blood, 13100, 3)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, 3) //0xFFFFFFFF)									// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.2)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 1.0)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.50)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.5)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.9)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.1)														// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.3)														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
	if ( @get_global SFX_Fumee_Walling)
	{
		GFX_Seti(pi_GFX_Blood, 13103, 0x40000000 + @get_global SFX_Fumee_Walling)	// Color fase 0
		GFX_Seti(pi_GFX_Blood, 13104, 0xF0000000 + @get_global SFX_Fumee_Walling)	// Color fase 1
	}
	else
	{
		GFX_Seti(pi_GFX_Blood, 13103, 0x40000000 + Kcol2)								// Color fase 0
		GFX_Seti(pi_GFX_Blood, 13104, 0xF0000000 + Kcol2)								// Color fase 1
	}
	GFX_Seti(pi_GFX_Blood, 13105, Kcol2)													// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 0.5)														// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 3)															// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, 0.0)													// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, -v_walling_banking * 4.0)									// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, pv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13201, cvector( -5.0, -5.0, -5.0))							// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, cvector( 5.0, 5.0, 5.0))								// Speed max
}




procedure_local void Proc_KK_SFX_Ring( vector pv_pos, vector pv_normal)
{
	int 		mi_GFX_Key
	vector	pv_temp
	object	to_light_n_smoke_K

	if (WOR_GetKey() == 0xc101fedb || WOR_GetKey() == 0x28000105)
		return
	
	to_light_n_smoke_K = @get_global o_global_light_and_smoke_kanada

	if( ! to_light_n_smoke_K )
		return
	
	mi_GFX_Key = GFX_Add( 13)
		
	GFX_FlagSet( mi_GFX_Key, 0 , 1)
	GFX_FlagSet( mi_GFX_Key, 2 , 1)
		
	GFX_MaterialSet( mi_GFX_Key, to_light_n_smoke_K, -1 )
	GFX_Seti( mi_GFX_Key, 13101, 1)
	
	GFX_Seti( mi_GFX_Key, 13102, 1)
	
	GFX_Seti( mi_GFX_Key, 13100, 50)
	GFX_Seti( mi_GFX_Key, 13106,  35)

	GFX_Setf( mi_GFX_Key, 13003, 0.7)
	GFX_Setf( mi_GFX_Key, 13004, 1.4)
	
	GFX_Setf( mi_GFX_Key, 13012, 0.7)
	
	GFX_Seti( mi_GFX_Key, 13107, 0)
	GFX_Setf( mi_GFX_Key, 13000, 1.0)
	GFX_Setf( mi_GFX_Key, 13001, 3.0)
	GFX_Setf( mi_GFX_Key, 13002, 0.01)	
		
	GFX_Setf( mi_GFX_Key, 13005, 0.1)
	GFX_Setf( mi_GFX_Key, 13006, 0.6)
	GFX_Setf( mi_GFX_Key, 13007, -3.0)
	
	GFX_Setv( mi_GFX_Key, 13203, cvector( 0.012,0.012,0.025))
	
	if ( @get_global SFX_Fumee_Impact_Sol)
	{
		GFX_Seti( mi_GFX_Key, 13103, 0x9D000000 + @get_global SFX_Fumee_Impact_Sol)
		GFX_Seti( mi_GFX_Key, 13104, 0x67000000 + @get_global SFX_Fumee_Impact_Sol)
		GFX_Seti( mi_GFX_Key, 13105, 0x00 + @get_global SFX_Fumee_Impact_Sol)
	}
	else
	{
		GFX_Seti( mi_GFX_Key, 13103, 0x9D93A99F)
		GFX_Seti( mi_GFX_Key, 13104, 0x6782A196)
		GFX_Seti( mi_GFX_Key, 13105, 0x00768D87)
	}
	GFX_Setf( mi_GFX_Key, 13009, -7.0)
	GFX_Setf( mi_GFX_Key, 13010, -9.0)
	
	GFX_Setf( mi_GFX_Key,  13011, -1000.0)
	
	GFX_Setv( mi_GFX_Key, 13200, pv_pos)
								
	GFX_Setv( mi_GFX_Key, 13201, Cv_NullVector )
	GFX_Setv( mi_GFX_Key, 13202, cvector(0.0,0.0, 0.1) )
	
	GFX_Setv( mi_GFX_Key, 13204, Cv_NullVector )
	
	GFX_Setv( mi_GFX_Key, 13205, Cv_NullVector )
	
	GFX_Setv( mi_GFX_Key, 13206, Cv_NullVector)
	
	if ( MATH_VecNull(pv_normal)
	||MATH_VecDotProduct( pv_normal, OBJ_BankingGet()) > Cf_Cos5)
	{
		GFX_Setv( mi_GFX_Key, 13207, OBJ_HorizonGet() )
		GFX_Setv( mi_GFX_Key, 13208, OBJ_SightGet() )
		GFX_Setv( mi_GFX_Key, 13209, 0.1* OBJ_BankingGet() )
	}
	else
	{
		pv_temp = MATH_VecCrossProduct( pv_normal, OBJ_HorizonGet()) 
		GFX_Setv( mi_GFX_Key, 13207, pv_temp)
		GFX_Setv( mi_GFX_Key, 13208, MATH_VecCrossProduct( pv_normal, pv_temp ))
		GFX_Setv( mi_GFX_Key, 13209, 0.1* pv_normal )		
	}
	
	// material rotation and scaling mods
	GFX_Seti( mi_GFX_Key, 13114, 0.0)
	
	GFX_Setf( mi_GFX_Key, 13013, 0.0)
	GFX_Setf( mi_GFX_Key, 13014, 0.0)
	GFX_Setf( mi_GFX_Key, 13015, 0.0)
	GFX_Setf( mi_GFX_Key, 13016, 0.0)
	
	GFX_Setf( mi_GFX_Key, 13008, 0.0)
}

procedure_local void Proc_KK_SFX_Splash( vector pv_pos, vector pv_normal)
{
	int 		mi_GFX_Key
	vector	pv_temp
	object	to_light_n_smoke_K
	
	to_light_n_smoke_K = @get_global o_global_light_and_smoke_kanada

	if( ! to_light_n_smoke_K )
		return
	
	mi_GFX_Key = GFX_Add( 13)
	
	GFX_MaterialSet( mi_GFX_Key, to_light_n_smoke_K, -1)
	GFX_FlagSet( mi_GFX_Key, 0 , 1)
	GFX_FlagSet( mi_GFX_Key, 2 , 1)
	GFX_Seti( mi_GFX_Key, 13101,17)
	GFX_Seti( mi_GFX_Key, 13102,13)
	GFX_Seti( mi_GFX_Key, 13100,40)	// 80
	GFX_Seti( mi_GFX_Key, 13106,40) // 80
	GFX_Setf( mi_GFX_Key, 13003,0.400000)	// duree de vie phase 1 // 0.5
	GFX_Setf( mi_GFX_Key, 13004,0.750000)	// duree de vie phase 2 // 2.0
	GFX_Setf( mi_GFX_Key, 13012,0.700000)
	GFX_Seti( mi_GFX_Key, 13107,0)
	GFX_Setf( mi_GFX_Key, 13000,0.250000)
	GFX_Setf( mi_GFX_Key, 13001,0.900000)
	GFX_Setf( mi_GFX_Key, 13002,0.010000)
	GFX_Setf( mi_GFX_Key, 13005,0.700000)
	GFX_Setf( mi_GFX_Key, 13006,1.200000)
	GFX_Setf( mi_GFX_Key, 13007,-5.000000)
	GFX_Setv( mi_GFX_Key, 13203,cvector(0.01500, 0.01500, 0.02500))
	GFX_Seti( mi_GFX_Key, 13103,0xFFC9CEBC)
	GFX_Seti( mi_GFX_Key, 13104,0xB9C7CEBC)
	GFX_Seti( mi_GFX_Key, 13105,0x00BBC8B0)
	GFX_Setf( mi_GFX_Key, 13009,-5.000000)
	GFX_Setf( mi_GFX_Key, 13010,-11.000000)
	GFX_Setf( mi_GFX_Key, 13011,-1000)
	GFX_Setv( mi_GFX_Key, 13200, pv_pos + cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13201,cvector(0.00000, 0.00000, -0.15000))
	GFX_Setv( mi_GFX_Key, 13202,cvector(0.00000, 0.00000, -0.35000))
	GFX_Setv( mi_GFX_Key, 13204,cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13205,cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13206,cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13207,0.150000 * OBJ_HorizonGet() )
	GFX_Setv( mi_GFX_Key, 13208,0.150000 * OBJ_SightGet() )
	GFX_Setv( mi_GFX_Key, 13209,0.100000  * OBJ_BankingGet())
	GFX_Seti( mi_GFX_Key, 13114,1)
	GFX_Setf( mi_GFX_Key, 13013,-1.000000)
	GFX_Setf( mi_GFX_Key, 13014,1.000000)
	GFX_Setf( mi_GFX_Key, 13015,-0.050000)
	GFX_Setf( mi_GFX_Key, 13016,0.050000)
	GFX_Setf( mi_GFX_Key, 13008,0.000000)
}

procedure_local	int COLONNE_Choix_Best_Axe()
{
	float pf_dot_S , pf_dot_H
	vector	tv_sight, tv_sens
	vector	tv_colonne_forget_axe 
	
	// choix de l axe corresponbdant au joy
	if ( o_colonne.des_int1 & 1)
	{
		v_colonne_best_axe = -@o_colonne OBJ_SightGet()
		return vrai
	}
	else if ( o_colonne.des_int1 & 2)
	{
		tv_colonne_forget_axe = -@o_colonne OBJ_SightGet()
	}
	else
		tv_colonne_forget_axe = Cv_NullVector
		
	if ( MATH_FloatNullEpsilon( f_joy_norm))
	{
		pf_dot_S = MATH_VecDotProduct( @o_colonne OBJ_SightGet(), v_colonne_best_axe)
		pf_dot_H = MATH_VecDotProduct( @o_colonne OBJ_HorizonGet(), v_colonne_best_axe)
	}
	else
	{
		pf_dot_S = MATH_VecDotProduct( @o_colonne OBJ_SightGet(), v_joy_sight)
		if ( pf_dot_S < 0 && !MATH_VecNullEpsilon(tv_colonne_forget_axe))
			pf_dot_S = 0.0
			
		pf_dot_H = MATH_VecDotProduct( @o_colonne OBJ_HorizonGet(), v_joy_sight)
	}
	
	if ( MATH_AbsFloat(pf_dot_S) > MATH_AbsFloat(pf_dot_H))
	{
		if ( pf_dot_S > 0.0)
			v_colonne_best_axe = @o_colonne OBJ_SightGet()
		else
			v_colonne_best_axe = - @o_colonne OBJ_SightGet()
	}
	else
	{
		if ( pf_dot_H < 0.0)
			v_colonne_best_axe = - @o_colonne OBJ_HorizonGet()
		else
			v_colonne_best_axe = @o_colonne OBJ_HorizonGet()
	}				

	tv_sens = OBJ_PosGet() - @o_colonne OBJ_PosGet()
	MATH_VecSetHorzNormalize(tv_sens)
	pf_dot_S = MATH_VecDotProduct(  v_colonne_best_axe, tv_sens )
	if ( pf_dot_S  < Cf_Cos45)
	{
		// Tourner pour aller dans le meilleur axe
		if ( MATH_VecDotProduct( @o_colonne OBJ_HorizonGet(), tv_sens ) > Cf_Cos45 
		&& !MATH_VecNullEpsilon(tv_colonne_forget_axe))
			ACT_ActionSet(Ci_Kanim_Colonne_TourneG)	// cas limité pas touner a 180° a travers le (-sight) interdit
		else if ( pf_dot_S < -Cf_Cos45 || MATH_VecCrossProduct( tv_sens, v_colonne_best_axe).z > 0)
			ACT_ActionSet(Ci_Kanim_Colonne_TourneD)
		else
			ACT_ActionSet(Ci_Kanim_Colonne_TourneG)				
		return faux

	}	
	else
		return vrai
}	

procedure_local 	void	COUP_SOUCHE_Set( int	pi_coup)
{
	if( pi_coup != -1 )
		STATS_IncAttack()		// inc pour tous les coups de souche sauf retour attente
	i_frappe_target_nb = 0
	i_frappe_coup = pi_coup
	if ( pi_coup != -1 && ao_CL_GRABKONG[i_GrabKong_MainActionGrab] )
		@ao_CL_GRABKONG[i_GrabKong_MainActionGrab] SND_RequestPlay(1)
	if( pi_coup == Ci_Kanim_souche_frappe_face )
		RIDE_Clear_Link_Bat(vrai)		// même les bats
}


procedure_local	int	COUP_SOUCHE_Get()
{
	return		i_frappe_coup
}

procedure_local void FINISH_Reset_Count( int	pi_val )
{
	int	ti_i
	if ( pi_val == -1)
	{		
		for ( ti_i = 0; ti_i < Ci_finished_max_count; ti_i++)	
			ai_finished_count[ti_i] = 0
	}
	else
		ai_finished_count[pi_val] = 0
}

procedure_local void Proc_KK_Death( int ti_death_mode )
{
	i_mode_mort = ti_death_mode
	SIG_Send(SIG_C_TYPE_MORT, OBJ_Me())
}

procedure_local void KK_AFX_Eclairs()
{
	i_paf_afx_eclair_phase = 1
}

procedure_local void KK_AFX_SlowMotion(int ti_force)
{
	if( ti_force || f_paf_afx_slow_motion_speed == 1.0 )
	{
		// force les FX ou teste si le FX n'est pas déjà en cours
		f_paf_afx_slow_motion_time = 0.0
		f_paf_afx_slow_motion_speed = 0.05
	}
}

procedure_local void KK_Exp_Set( int ti_exp )
{
	i_exp_current = ti_exp
	f_coef_retour = 1.0

	if (ti_exp<100)
		i_expdefault_current = ti_exp
		
	switch (ti_exp)
	{
		case Ci_Kexp_SourireGrand :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 5
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 1.0
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 10
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 1.0
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= -0.4
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.5
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 1.0
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 1.0
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break

		case Ci_Kexp_Combat :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 0.0
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 7
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 0.3
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 8
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 1.0
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= 0.15
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.1
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 0.2
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break

		case Ci_Kexp_Neutre :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 0.0
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 0
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 0.0
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= 0.0
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.0
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break

		case Ci_Kexp_Colere :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 7
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 0.75
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 8
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 0.75
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= 0.3
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.1
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 1.0
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break

		case Ci_Kexp_Sourire :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 5
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 1.0
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 9
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 0.75
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= -0.2
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.1
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 1.0
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break

		case Ci_Kexp_Peur :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 0.0
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 4
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 1.1
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 10
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 0.25
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= -0.8
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.1
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 0.15
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break

		case Ci_Kexp_Triste :
			ai_exp_target[Ci_Kexp_Canal_BoucheLips]= 6
			af_exp_factor[Ci_Kexp_Canal_BoucheLips]= 0.85
			ai_exp_target[Ci_Kexp_Canal_BoucheIntentions]= 0
			af_exp_factor[Ci_Kexp_Canal_BoucheIntentions]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Sourcils]= 9
			af_exp_factor[Ci_Kexp_Canal_Sourcils]= 1.0
			ai_exp_target[Ci_Kexp_Canal_PaupiereH]= 12					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereH]= 0.2
			ai_exp_target[Ci_Kexp_Canal_PaupiereB]= 13					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_PaupiereB]= 0.0
			ai_exp_target[Ci_Kexp_Canal_SourcilP]= 11					// Tjrs
			af_exp_factor[Ci_Kexp_Canal_SourcilP]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Nez]= 16							// Tjrs
			af_exp_factor[Ci_Kexp_Canal_Nez]= 0.0
			ai_exp_target[Ci_Kexp_Canal_Bouche]= 3						// Tjrs
			break


	}
}

procedure_local int	Proc_Mashing_advantage()
{
	int	pi_capa
	int	ti_prog
	
	switch( i_etat_courant)
	{
		case ETAT_Kong_finish :
			switch ( ACT_ActionGet())
			{
				case Ci_Kanim_Finish_SePlace :
				case Ci_Kanim_FinishBigBat_SePlace :
					return  1
				case Ci_Kanim_Finish_Deb :
				case Ci_Kanim_FinishBigBat_Deb :
					ti_prog = ANI_CurrentFrameGet(0) - i_finish_frame_last 
					if ( ti_prog >= 2)
						return  1
					else if ( ti_prog <= -2)
						return -1
					else
						return 0
					break
				default:
					i_finish_frame_last = 0
					return 0
			}	
			break
			
		case ETAT_Kong_finished :
			switch ( ACT_ActionGet())
			{
				// challenge
				case Ci_Kanim_FinishedRex_SePlace :
				case Ci_Kanim_FinishedBats_SePlace :
				case Ci_Kanim_FinishedRaptors_SePlace :
				case Ci_Kanim_FinishedScolos_SePlace :
				case Ci_Kanim_FinishBigScolo_SePlace :
					return  -1
					break
				case Ci_Kanim_FinishedRex_Deb :
				case Ci_Kanim_FinishedBats_Deb :
				case Ci_Kanim_FinishedRaptors_Deb :
				case Ci_Kanim_FinishedScolos_Deb :
				case Ci_Kanim_FinishBigScolo_Deb :
					ti_prog = ANI_CurrentFrameGet(0) - i_finish_frame_last 
					if ( ti_prog >= 2)
						return  -1
					else if ( ti_prog <= -2)
						return 1
					else
						return 0
					break
				default:
					i_finish_frame_last = 0
					return 0
			}
			break
			
		case ETAT_Kong_grab :
			if( i_GrabKong_MainBloquee != -1 && MSG_GlobalIsValid( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]))
			{
				switch ( LNK_GrabKong_ActionGet( amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainBloquee]))
				{
					case Ci_GrabKong_Flanc_MashSePlace :
					case Ci_GrabKong_FinishSePlace :
						return 1
						break
					case Ci_GrabKong_Flanc_MashDeb :
					case Ci_GrabKong_FinishDeb :
					if ( f_finish_force_kong > f_finish_force_rex)
						return 1
					else
						return -1
						break
					default:
						return 0
						break
				}	
			}
			else
				return 666
			break
			
		case ETAT_Kong_grab_mashing :
			return 1
		default:
			i_finish_frame_last = 0
			return 666
			break
	}
}


// GFX ====================================================================================
//procedure_local void Proc_KK_SFX_Paf_Particules(vector tv_pos, vector tv_paf_dir)
//{
//	int			pi_GFX_Blood
//	color 		materiau_color
//	vector	tv_lat2_axis, tv_lat_axis
//	object	to_light_n_smoke
//	
//	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
//	if( ! to_light_n_smoke )
//		return
//	
//	materiau_color = color_test
//	
//	tv_lat_axis = MATH_VecCrossProduct(tv_paf_dir, Cv_VerticalVector)
//	tv_lat2_axis = MATH_VecCrossProduct(tv_paf_dir, tv_lat_axis)
//	
//	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
//	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
//	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
//	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
//	GFX_Seti(pi_GFX_Blood, 13101, 23)														// Materiau N°
//	GFX_Seti(pi_GFX_Blood, 13100, 40)														// *Buffer number of sprite
//	GFX_Seti(pi_GFX_Blood, 13106, 30)														// *number of sprite to generate
//	GFX_Setf(pi_GFX_Blood, 13003, 0.05)														// Time fase 1
//	GFX_Setf(pi_GFX_Blood, 13004, 0.4)														// Time fase 2
//	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
//	GFX_Setf(pi_GFX_Blood, 13012, 0.0)														// Time random
//	GFX_Setf(pi_GFX_Blood, 13000, 0.1)														// Growing speed min
//	GFX_Setf(pi_GFX_Blood, 13001, 0.5)														// Growing speed max
//	GFX_Setf(pi_GFX_Blood, 13002, 0.0001)													// Friction Grow
//	GFX_Setf(pi_GFX_Blood, 13005, 0.3 )													// Creation size min
//	GFX_Setf(pi_GFX_Blood, 13006, 0.5 )														// Creation size max
//	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.02))							// friction speed
//	GFX_Seti(pi_GFX_Blood, 13103, 0x00000000 + materiau_color)					// Color fase 0
//	GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)					// Color fase 1
//	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
//	GFX_Setf(pi_GFX_Blood, 13009, 5)															// Norm speed min
//	GFX_Setf(pi_GFX_Blood, 13010, 10)														// Norm speed max
//	GFX_Setf(pi_GFX_Blood, 13007, -5.0)														// Gravity
//	GFX_Setf(pi_GFX_Blood, 13008, 0.0)														// generation rate
//	GFX_Setv(pi_GFX_Blood, 13204, tv_paf_dir)												// wind
//	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
//	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
//	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
//	GFX_Setv(pi_GFX_Blood, 13201, tv_paf_dir + (tv_lat_axis * 0.2) + (tv_lat2_axis * 0.2) )					// Speed min
//	GFX_Setv(pi_GFX_Blood, 13202, (tv_paf_dir * 5.0) - (tv_lat_axis * 1.2 ) - (tv_lat2_axis * 1.2 ) )											// Speed max
//}


procedure_local void Proc_KK_SFX_Paf_Particules(vector tv_pos, vector tv_wind, int ti_nbr)
{
	int			pi_GFX_Blood
	object	to_light_n_smoke
	int			materiau_color
	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
	if( ! to_light_n_smoke )
		return
	tv_wind *= -1.0		
	materiau_color = 0x00000000
	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 23)														// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13110, 22)														// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13100, ti_nbr)													// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, ti_nbr)													// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.5)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 0.8)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.75)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.0)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.0)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 1.0)													// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.25)														// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.5)														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.0))							// friction speed
	GFX_Seti(pi_GFX_Blood, 13103, 0xFF000000 + materiau_color)					// Color fase 0
	GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)					// Color fase 1
	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, 1.0)															// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, 5.0)															// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -5.0)															// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.001)														// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, Cv_NullVector)												// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13207, Cf_Paf_FX_width * OBJ_HorizonGet())		// Volume edge 1
	GFX_Setv(pi_GFX_Blood, 13208, Cf_Paf_FX_width * OBJ_SightGet())			// Volume edge 2
	GFX_Setv(pi_GFX_Blood, 13209, Cf_Paf_FX_width * OBJ_BankingGet())		// Volume edge 3
	DBG_RenderVector(tv_pos, OBJ_BankingGet() * 2,color_bleu)
	DBG_RenderVector(tv_pos, OBJ_HorizonGet() * 2,color_rouge)
	DBG_RenderVector(tv_pos, OBJ_SightGet() * 2,color_vert)
	GFX_Setv(pi_GFX_Blood, 13201, tv_wind + cvector(-1.0, -1.0, -0.4))										// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, tv_wind + cvector(1.0, 1.0, 1.0))										// Speed max
	// Rotation Aléatoire -----------------------------------------------------------------------------------------------------------------------------------------
	GFX_Seti(pi_GFX_Blood, 13114, 1)															// Rotation ON / OFF
	GFX_Setf(pi_GFX_Blood, 13013,-1.000000) 												// Rotation Aléatoire a la naissance Min
	GFX_Setf(pi_GFX_Blood, 13014,1.000000) 												// Rotation Aléatoire a la naissance Max
	GFX_Setf(pi_GFX_Blood, 13015,-0.350000) 												// Speed rotation Min
	GFX_Setf(pi_GFX_Blood, 13016,0.350000) 												// Speed rotation Maw
}

procedure_local	float SWEEP_Init_Lance_1_main( int	pi_choix_anim)
{
	vector	tv_sens_lance
	int			pi_type
	float		pf_dist_min, pf_dist_max, tf_angle
	
	i_Grab_Torse_Main = -1
	i_GrabKong_attrape_jete = Ci_Jete
	if(  f_joy_norm)
	{
		i_GrabKong_orient  = vrai
		v_frappe_sight = v_joy_sight
	}
	else
	{
		i_GrabKong_orient  = vrai
		v_frappe_sight = v_look_direction
	}
	
	if( ! ao_CL_GRABKONG[ 0] )
	{
		DBG_BreakPoint()
		i_etat_courant = -1
		return -1.0
	}
	if ( @ao_CL_GRABKONG[ 0] AI_IsModel( get_PNJ_KBats_path))
	{
		pi_type = 1
		pf_dist_min = 6.0
		pf_dist_max = 20.0
	}
	else if ( @ao_CL_GRABKONG[ 0] AI_IsModel( get_PNJ_KRaptor_path))
	{
		pi_type = 2
		pf_dist_min = 10.0
		pf_dist_max = 50.0
	}
	else
	{
		pi_type = 3
		pf_dist_min = 6.0
		pf_dist_max = 50.0
	}	
	
	// AIDE AU TIR
	o_Throw_Target = nobody
	
	#ifndef _FINAL_
	if( i_DBG_TRACE_TARGET )
	{
		DBG_TraceEOL()
		DBG_TraceString("=== SWEEP_Init_Lance_1_main ====")
		DBG_TraceEOL()
	}
	#endif
	
	// Prio a ceux qui attaquent Ann
	if ( pi_choix_anim)
		tf_angle = Cf_Cos60
	else
		tf_angle = Cf_Cos45
	i_Throw_Target = Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, tf_angle, pf_dist_min, pf_dist_max, o_Throw_Target, vrai, C_AIDE_AU_TIR_Prio_AttackAnn, C_AIDE_AU_TIR_Prio_GrabAnn, C_AIDE_AU_TIR_Bit_Only_On_Screen)
	
	// Sinon prendre ce qui reste
	if ( ! o_Throw_Target)
		i_Throw_Target = Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, tf_angle, pf_dist_min, pf_dist_max, o_Throw_Target, vrai, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Ennemi, C_AIDE_AU_TIR_Bit_Only_On_Screen)

	if ( pi_choix_anim)
	{
		if ( i_GrabKong_Souche)
		{
			i_GrabKong_orient  = vrai
			ACT_ActionSet( Ci_Kanim_souche_lance)	// Lancer
			f_coef_pied_d_appui = 0.5							// Coef pied d'appui pour rotation pied
		}		
		else
		{
			//  1 seule main d occupée il faudra s orienter en jetant
			i_GrabKong_orient  = vrai
			i_GrabKong_MainActionGrab = 0
			if ( o_Throw_Target && @o_Throw_Target AI_IsModel(get_PNJ_KTREX_Path))
			{ 
				if ( pi_type != 3 )
					ACT_ActionSet( Ci_Kanim_Jete_D)		// Lance 1m sur cible TREX( i.e. donne a manger)
				else
					ACT_ActionSet( Ci_Kanim_Jete_Tendu)	// Lance a 100% de puissance
			}
			else if ( pi_type == 2 )
				ACT_ActionSet( Ci_Kanim_Jete_2M)										// Lancer Raptor 2m
			else
				ACT_ActionSet( Ci_Kanim_Jete_Tendu)									// Lancer tendu
			f_coef_pied_d_appui = i_GrabKong_MainActionGrab						// Coef pied d'appui pour rotation pied
		}
	}
	v_frappe_speed = DYN_SpeedGetVector()										// Conserver un peu de vitesse de deplacemetn quand on lance
	return		pf_dist_min
}


procedure_local void PAF_Filtre_Rouge()
{
	if( @get_global i_Player_is_Kong )
	{
		f_gladiator_AFX_coef = 1.0
		@get_global Proc_AE_ColorBalanceSet(MATH_FloatBlend(@get_global Proc_AE_ColorBalance1Get(), f_gladiator_colorbalance1 * f_gladiator_AFX_coef, 5.0 * TIME_GetDt()), f_gladiator_colorbalance2)
		@get_global Proc_AE_RemanenceSet(MATH_FloatBlend(@get_global Proc_AE_RemanenceGet(), f_gladiator_remanance * f_gladiator_AFX_coef, 5.0 * TIME_GetDt()))
		@get_global Proc_AE_BlackAndWhiteSet(MATH_FloatBlend(@get_global Proc_AE_BlackAndWhiteGet(), f_gladiator_blacknwhite * f_gladiator_AFX_coef, 5.0 * TIME_GetDt()))
		f_paf_afx_slow_motion_speed = 0.75
	}
}


procedure_local void Proc_KK_LacherIndigene()
{
	if( i_flag_just_pose_JACK && ao_CL[Ci_LNK_KKGRAB_OBJECT] )
	{
		i_flag_just_grab = faux		// je pas tenter un grab quand je lache Jack
		i_Grab_Torse_ANN = faux
		i_Grab_Torse_Actor = faux
		i_Grab_Torse_Main = -1
		ao_CL[Ci_LNK_KKGRAB_OBJECT] = LNK_ClientGet(Ci_LNK_KKGRAB_OBJECT, amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], faux, nofunc, nofunc, nofunc)
	}
	i_flag_just_pose_JACK = faux		// anti loop
}

procedure_local void Proc_KK_PrendreIndigene()
{
	if( i_flag_just_grab_JACK && ! ao_CL[Ci_LNK_KKGRAB_OBJECT] )
	{
		i_flag_just_grab = faux		// je pas tenter un grab quand j'attrappe Jack
		if( o_Joueur )
		{
			v_grab_object_pos = @o_Joueur OBJ_PosGet()
			ao_CL[Ci_LNK_KKGRAB_OBJECT] = LNK_ClientGet(Ci_LNK_KKGRAB_OBJECT, amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], vrai, "k_exec_grab_object_param", nofunc, "k_exec_grab_object_init")
			if( ao_CL[Ci_LNK_KKGRAB_OBJECT] )
			{
				LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT],  ANI_CanalObjectGet(Anim_Canal_Snap_Ann) )
				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Porte_Epaule)
				i_Grab_Torse_ANN = faux
				i_Grab_Torse_Actor = faux
				i_Grab_Torse_Main = -1
			}
		}
	}
	i_flag_just_grab_JACK = faux		// anti loop
}

