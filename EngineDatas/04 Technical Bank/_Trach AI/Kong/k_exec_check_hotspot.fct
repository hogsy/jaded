#include "k_define.var"

#define	Cf_coef_rapport_altitude_longueur		1.0
//  A LA RECHERCHE D UN HOTSPOT

int 		ti_i
int			ti_good_nb
int			ti_good_fight_nb
int			ti_str
int			ti_capa

float		tf_z
float		tf_dist2
float		tf_dot1
float		tf_dot2
float		tf_dist_max
float		tf_dot

vector	tv_sens
vector	tv_JOY
vector	tv_pos 
vector	tv_axe
vector	tv_dest_pos
vector	tv_sight

object	to_hotspot
object	to_ray_col
object	tao_hotspot_good[20]
object	tao_hotspot_good_fight[20]


// Sens du saut : sens forcé ou sens du joy ???
if ( !MATH_VecNullEpsilon(v_jump_force_sens))
{
	tv_JOY = v_jump_force_sens
}
else
	tv_JOY = v_joy_sight_normalized

if( ( i_hotspot_mode && !f_joy_norm))
{
	// EN mode manuel il faut avoir le joy orienté pour detecter un HS
	// On nne désire pas tester les HOT SPOT
	push(tv_JOY)
	return
}
else if ( o_jump_hotspot)
{
	// Le HOTSPOT a déja été détecté pendant l impulsion
	tv_JOY = @o_jump_hotspot OBJ_PosGet() - OBJ_PosGet()
	tv_JOY.z = 0.0
	MATH_VecSetNormalize( tv_JOY)
	// Nouveau Joy car Kong s'est déplacé pendat l impulsion
	push(tv_JOY)	
	return
}

ti_good_nb = 0
ti_good_fight_nb = 0
for( ti_i = 0; ti_i < @get_list_manager i_hotspot_nb; ti_i++)
{
	// Parcours des hotspots
	to_hotspot = @get_list_manager ao_hotspot[ti_i]
	if ( !(@to_hotspot OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Active))
		continue
	if ( @to_hotspot OBJ_CapaGet() & Capa_HS_Inactif)
		continue
		
	ti_capa = to_hotspot.des_int1
	tv_sens = @to_hotspot OBJ_PosGet() - OBJ_PosGet()
	tf_z = tv_sens.z
	tv_sens.z = 0.0
	tf_dist2 = MATH_VecDotProduct( tv_sens, tv_sens) 


	if ( o_jump_hotspot_last)
	{
		// On VIENS d un SWING
		switch ( ti_capa)
		{
			case 128 : //HOTSPOT_Type_Saut :
				tf_dist_max = 30.0
				break
			case 4 : //HOTSPOT_Type_Fight :
				tf_dist_max = 30.0
				break
			default:	// Swing
				tf_dist_max = 20.0
		}
		
	}
	else
		tf_dist_max = 25.0
	
	tf_dist_max += (MATH_FloatLimit( 0.0, -tf_z * 0.25, 10.0) )	// POur chaque metre au dessus je peux sauter du coef plus loin

	if ( ti_capa & HOTSPOT_Type_Vert && ! MATH_FloatNullEpsilon( to_hotspot.des_float1))
		tf_dist_max = to_hotspot.des_float1 

	tf_dist_max *= tf_dist_max

	if ( o_jump_hotspot_last != to_hotspot 					// Ne pas detecter le HS que l on quitte
	&& (	ti_capa & HOTSPOT_Type_Fight					// HS pour fight 
	&& i_jump_check_hotspot_fight								// Teste t on les HS de Fight
	&& tf_z < -2.0														// Le HS dois etre a plus de 2m au dessous
	&& tf_z > -30.0													// Le HS ne dois pas etre a plus de 30m au dessous
	&& tf_dist2 > 9.0 												// Le HS doit etre plus loin que 3m
	&& tf_dist2< tf_dist_max	)									// Le HS doit etre a moins de 30m
	|| ( i_jump_check_hotspot										// Teste t on les HS classiques
	&& ti_capa &  HOTSPOT_Type_Colonne					// HS de colonne
	&& tf_z < 10.0														// Le HS ne dois pas etre a plus de 10m au dessus
	&& tf_z > -17.0													// Le HS ne dois pas etre a plus de 15m au dessous	
	&& tf_dist2 > 36.0 												// Le HS doit etre plus loin que 6m
	&& tf_dist2 < tf_dist_max	)									// Le HS doit etre a moins de 25m
	|| 	( i_jump_check_hotspot									// Teste t on les HS classiques
	&& !(ti_capa & (HOTSPOT_Type_Fight + HOTSPOT_Type_Colonne))					// HS pas pour le fight ni colonne
	&& tf_z < 15.0														// Le HS ne dois pas etre a plus de 12m au dessus
	&& tf_z > -17.0													// Le HS ne dois pas etre a plus de 15m au dessous	
	&& tf_dist2 > 36.0 												// Le HS doit etre plus loin que 6m
	&& tf_dist2 < tf_dist_max	)									// Le HS doit etre a moins de 25m
	)
	{
		// HOTSPOT a plus de 30m et moins de 3m sont ignorés
//		DBG_TraceString(" dist:")
//		DBG_TraceFloat(MATH_FloatSqrt(tf_dist2))
//		DBG_TraceString(" distmax:")
//		DBG_TraceFloat(MATH_FloatSqrt(tf_dist_max))
//		DBG_TraceString(" z:")
//		DBG_TraceFloat(tf_z)
//		DBG_TraceString(" Test:")
//		DBG_TraceInt(i_jump_check_hotspot_fight)
//		DBG_TraceString(" old OS:")
//		DBG_TraceObject(o_jump_hotspot_last)
//		DBG_TraceEOL()	 
		tv_sight = @to_hotspot OBJ_SightGet()
		tv_sight.z = 0.0
		if( !(ti_capa & (HOTSPOT_Type_Saut + HOTSPOT_Type_Foce_Sens)) || MATH_VecDotProduct( tv_sens, tv_sight) > 0.0)
		{
			// Un HOT SPOT dans l axe de 'lecture' du saut ( le joy doit aller dans le sens du sight sinon le HotSpot est pas valide
			tv_sens = MATH_VecNormalize( tv_sens)
			DBG_RenderVector( OBJ_PosGet(),tv_sens * 5.0, color_bleu)
			DBG_RenderVector( OBJ_PosGet(),tv_JOY * 5.0, color_vert)
			tf_dot = MATH_VecDotProduct( tv_sens, tv_JOY)
			if ( tf_dot  > Cf_Cos60 && ( !i_hotspot_mode || MATH_VecDotProduct( tv_sens, v_joy_sight_normalized) > Cf_Cos45 ))
			{
				// Un HOT SPOT dans l axe du joy
				// Test validité d HOT SPOT  Swing vertical				

				if( ti_capa & (HOTSPOT_Type_Limit1_4))
				{
					// Il y a des restriction au mouvement de Swing
					tv_axe = OBJ_PosGet() - @to_hotspot OBJ_PosGet()
					tv_axe.z = 0.0
					tf_dot1 = MATH_VecDotProduct( tv_axe, @to_hotspot OBJ_SightGet())
					tf_dot2 = MATH_VecDotProduct( tv_axe, -@to_hotspot OBJ_HorizonGet())
					if ( tf_dot1 <=  0.0 && tf_dot2 <=  0.0)
					{
						// On est dans le ¼ 3
						to_hotspot  = nobody
					}
				}
		
				if ( to_hotspot)
				{		
					tv_pos = OBJ_PosGet() + (OBJ_BankingGet() * 2.0)
					if ( ti_capa & HOTSPOT_Type_Fight)
						tv_dest_pos = @to_hotspot COL_ZonePosGet( C_zde_corps) 
					else
						tv_dest_pos = @to_hotspot OBJ_PosGet() 
					macro_render_Vector( tv_pos, tv_dest_pos - tv_pos , 0xFF00FF)		
					COL_SpecificCrossableSet( Gmat_KK_Crossable_Default)	
					to_ray_col = COL_RayObject_Vector( tv_pos , tv_dest_pos - tv_pos, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet)		
					if ( !to_ray_col || to_ray_col == to_hotspot )
					{
						if ( ti_capa & HOTSPOT_Type_Fight)
						{
							tao_hotspot_good_fight[ti_good_fight_nb] = to_hotspot
							ti_good_fight_nb++
						}
						else
						{
							tao_hotspot_good[ti_good_nb] = to_hotspot
							ti_good_nb++
						}
						macro_render_Vector( @to_hotspot OBJ_PosGet(), Cv_VerticalVector * 20.0, 0xFF00FF)			
					}
				}
			}
		}
	}
}

// HOTSPOT DE FIGHT PRIORITATIRES
if ( ti_good_fight_nb)
{
	// Choisir le meilleur HOTSPOT
 	ti_i = ARR_ObjBestSight( &tao_hotspot_good_fight[0], ti_good_fight_nb, OBJ_PosGet(), v_joy_sight_normalized, 20)
	tv_JOY = @tao_hotspot_good_fight[ti_i] OBJ_PosGet() - OBJ_PosGet()
	tv_JOY.z = 0.0
	MATH_VecSetNormalize( tv_JOY)
	o_jump_hotspot = tao_hotspot_good_fight[ti_i]
}
else
{

	// HOTSPOT CLASSIQUE
	if ( ti_good_nb)
	{
		// Choisir le meilleur HOTSPOT
	 	ti_i = ARR_ObjBestSight( &tao_hotspot_good[0], ti_good_nb, OBJ_PosGet(), v_joy_sight_normalized, 20)
		tv_JOY = @tao_hotspot_good[ti_i] OBJ_PosGet() - OBJ_PosGet()
		tv_JOY.z = 0.0
		MATH_VecSetNormalize( tv_JOY)
		o_jump_hotspot = tao_hotspot_good[ti_i]
		DBG_TraceObject( o_jump_hotspot)
		DBG_TraceEOL()
	}
	else
		o_jump_hotspot = nobody
}

if ( i_etat_courant == ETAT_Kong_jump)
	v_jump_force_sens = tv_JOY
push(tv_JOY)