#include"k_define.var"

#define	Cf_Force_Plaquage							20.0
#define	Cf_Force_Deplacement						12.0
#define	Cf_Delai_Decroch							0.2
#define	Cf_Walling_Lim_Influence_Vitesse_Z 	15.0
#define	Cf_Wall_Incidence_Ratio_Norm_Limit	3.0
#define	Cf_Jump_Longe_Mur_distance			18.0
#define	Cf_RunningJumpAngleFromNormal		45.0		// angle bw jump direction and wall normal in degrees (validity in [0,90])

#define	Ci_Nb_Bat_Limit_Climb					3

int			ti_nb_normal
int			ti_in

int			ti_report
int			ti_trop_haut
int			ti_Gmat
int			ti_force_sens
int			ti_walling_stop_joy
int			ti_waling_interdit_detected
int			ti_walling_action 

int			ti_tab_wall[50]
int			ti_tab_GMAT[50]
int			ti_nbr
int			ti_i, ti_j
int			ti_fall
int			ti_saut_vers_normale
int			ti_trop_bas
int			ti_GMAT_CUMUL

float		tf_rotation_speed
float		tf_dot, tf_dot2
float		tf_dot_max
float		tf_speed
float		tf_blend_speed
float		tf_gravity_speed
float		tf_lim
float		tf_angle
float		tf_speedZ
float		tf_inversion
float		tf_offset_bas

vector	tv_temp
vector	tv_speed
vector	tv_sight
vector	tv_traction 
vector	tv_joy_axis
vector	tv_joy 
vector	tv_sight_axis 
vector	tv_sol, tv_sol2
vector	tv_normal
vector	tv_gravity
vector	tv_walling_normal
vector	tv_walling_tan
vector	tv_sens_detect_hotspot
vector	tv_axe
vector	tv_axe2
vector	tv_axe3
vector	tv_temp1
vector	tv_temp2
vector	tv_normal_edge[5]
vector	tv_edge
vector	tv_best_normal_joy
vector	tv_normal_sol
vector	tv_saut_mur_detect_pos

object	to_obstacle
object	to_col

message	tm_msg

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	i_walling_fumee = faux						// Fin de la fumée de merde
	f_walling_quit = TIME_Get()
	i_jump_flag_ratraping_allowed = faux	//CKong ne touchait plus le sol pendant le walling il n'a pas droit a l auto ratrapping
	if ( i_walling_action_impulsion_before_jump)
		i_walling_action_impulsion_before_jump = 0	// nim d impulsion avant le saut
	else
		DYN_GravitySet(Cv_Kong_Gravity)		// Dans le cas de l anim de saut Imposé, on ne veux pas de gravité a l impulsion
	v_last_zdm_walling_pos	= COL_ZonePosGet(C_zdm_pied)
	f_time_zdm_walling = 1.0 // forcer a modifier le test de BackFace car le banking va se réorienter et peux entrainer la zdm dans une colmap
	

	tf_dot = MATH_VecDotProduct( v_walling_horizon, OBJ_SightGet())
	if ( MATH_AbsFloat(tf_dot) > 0.2 ) //ACT_ActionGet() != Ci_Kanim_Walling_derape)
		v_walling_horizon *= MATH_FloatSign( tf_dot)	// PLan du mur horizontal ds le sens du deplacement
	else
		v_walling_horizon  = Cv_NullVector

	DYN_FlagsSet( none, DYN_C_NeverDynamicHierarchy)
	o_walling_liane = nobody
	// CYCLE DERAPAGE
	if ( i_SND_walling_derape != -1)
	{
		SND_Stop(	i_SND_walling_derape)
		i_SND_walling_derape = -1
	}
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Kong_walling) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Kong_walling

	// GRAB CLIENT ACCEPT
	ai_SRV_ENABLE[Ci_LNK_KKFINISH_ON_KONG] = faux

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()


	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_walling		// VINCE
	// CAMERA -----------------------------------------------------------------
	

	// Sortie d accroch on oublie le joy histoire que KK descende
	if ( i_dernier_etat == ETAT_Kong_accroch_mur )
		i_walling_forget_joy = vrai
	else
		i_walling_forget_joy = faux
		
	OBJ_HierarchyReset()
	DYN_FlagsSet( DYN_C_NeverDynamicHierarchy, none)

	// SOUND
	SND_RequestPlay(26)
	COL_CrossableSet( Gmat_KK_Crossable_Walling, none)
	
	DYN_GravitySet( Cv_NullVector)
	DYN_FrictionVectorSet( cvector( 1.0, 1.0, 0.0))
	
	v_walling_horizon = MATH_VecCrossProduct( v_walling_normal, Cv_VerticalVector)
	MATH_VecSetNormalize(v_walling_horizon)
	v_walling_banking = MATH_VecCrossProduct( v_walling_horizon, v_walling_normal)	// Plan du mur vers le haut
	if (COL_GMatReportGet(Gmat_KK_Crossable_Walling) == -1)	
		v_walling_horizon *= MATH_FloatSign( MATH_VecDotProduct( v_walling_horizon, DYN_SpeedGetVector()))	// PLan du mur horizontal ds le sens du deplacement
	else
		v_walling_horizon *= MATH_FloatSign( MATH_VecDotProduct( v_walling_horizon, v_joy_sight))	// PLan du mur horizontal ds le sens du deplacement


	// Conservation de l angle d incidence sur le mur:
	tv_speed = OBJ_SightGet()
	tf_speed = MATH_FloatLimit( f_reflex_speed_old, 13.0, 20.0)


	// SPEED INIT	
	i_walling_entree_saut = faux
	if ( COL_CollideType(COL_C_Ground))
	{
		// Entrée en Walling avec appuis sur le sol !!
		if ( MATH_VecDotProduct( v_joy_sight, -v_walling_normal ) > Cf_Cos45)
			v_walling_axe_incidence = v_walling_banking  * 2.0
		else
			v_walling_axe_incidence = (v_walling_banking + v_walling_horizon) * 1.5
		v_walling_speed = cvector( 0.0, 0.0, 1.0)
    		f_time_start_etat = 0.0
	}
	else if ( i_dernier_etat == ETAT_Kong_accroch_mur  )
	{
		v_walling_axe_incidence = Cv_NullVector // cvector( 0.0, 0.0, -1.0)
		f_time_start_etat = 0.0
	}
	else
	{
		// Entrée en Walling en saut
		Proc_KK_Rumble_Fort()
		v_walling_axe_incidence = Cv_NullVector
		v_walling_speed = cvector( 0.0, 0.0, -1) // Kong va monter
		f_time_start_etat = 0.5
		f_walling_need_reception = 0.0
		i_walling_entree_saut = vrai
	}
	v_walling_gravity = Cv_NullVector
	v_walling_liane_pos = Cv_NullVector

	i_flag_trample = faux
	i_flag_just_Action = faux		// ne pas sauter tout de suite
	i_dash_for_walling = faux
	
	i_request_txt_forced = GeneKon_C_breath_run_stop
//	RAGE_Maximise(Cf_Fury_Maximum_Walling)
}
else						
{
	f_time_start_etat += TIME_GetDt()
}
f_global_time = TIME_Get()

// ANALYSE ============================================================================

// RIDE SERVEUR : ACCROCHAGE DES RAPTORS
RIDE_Propose_Link()

// Detection du décrochage du mur: fin de collision ou sol trop proche en vitesse descendante.
if ( !COL_CollideType( COL_C_Wall))
	f_walling_time_decroche+= TIME_GetDt()
else
	f_walling_time_decroche = 0.0

tf_offset_bas = 0.0
if( v_walling_speed.z <= 0.0 || f_walling_time_decroche >Cf_Delai_Decroch)
{
	if ( !MATH_FloatNullEpsilon( f_walling_time_decroche))
	{
		// Pas de collision avec le mur...hum LRAY de sauvegarde
		to_col = COL_RayObject_Dist( COL_ZonePosGet( C_zdm_pied), -v_walling_normal, 4.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
		DBG_RenderVector( COL_ZonePosGet( C_zdm_pied), -v_walling_normal * 4.0, color_bleu)
	}
	macro_render_Vector( OBJ_PosGet() + v_walling_normal, -v_walling_normal * 1.5, color_rouge)
	tv_sol = COL_TipTopPointGet( -Cv_VerticalVector, 0.0, faux, faux, faux, vrai)
	v_walling_ground = tv_sol
	macro_render_Vector( tv_sol , v_walling_normal * 4.0, color_rose)
	ti_trop_bas = faux
	tf_lim = 6.0 //4.5 // 2.5 + ( MATH_Ve( OBJ_SightGet(),v_walling_banking) * 1.5) 
	if ( tv_sol.z + tf_lim > OBJ_PosGet().z)
	{
		tf_offset_bas = OBJ_PosGet().z - tv_sol.z
		tv_normal_sol = COL_RayObject_EdgeNormalGet()
		macro_render_Vector( tv_sol , tv_normal_sol * 4.0, color_cyan)
		if ( tv_normal_sol.z > Cf_Kong_Angle_Mur_sol)
			ti_trop_bas = vrai
		else
		{
			i_walling_stop = vrai
			if ( RIDE_Get_Actor_Nb() > 1)
			{
				i_mode_mort = Ci_Kcamera_saut_mort_chute
				macro_change_etat("k_ETAT_mort")
			}
		}
	}	
	else
		i_walling_stop = faux
	
	
	if ( COL_CollideType(COL_C_Ground)  || f_walling_time_decroche > Cf_Delai_Decroch || ti_trop_bas)
	{
		// trop bas : chutter
		tv_sight = OBJ_SightGet()
		tv_sight .z = 0.0
		if ( MATH_VecNullToler( tv_sight, 0.2 ))
			tv_sight = -OBJ_BankingGet()			// Regarder vers le mur
//		f_time_collide_ground = Cf_delay_ground_col_tolerance + 1.0		// Forcer une chute
		i_jump_force_chute = vrai
		v_jump_force_chute_orient = tv_sight
		f_jump_force_distance = 0.0
		v_jump_force_sens = (v_walling_normal * 0.5 )+  v_walling_horizon 
		if (COL_CrossableGet() & Gmat_KK_Crossable_Walling)
		{
			if (COL_GMatReportGet(Gmat_KK_Crossable_Walling) != -1)
			{
				tv_sight = COL_NormalGet( COL_C_ReportIndex + COL_GMatReportGet(Gmat_KK_Crossable_Walling))
				v_jump_force_chute_orient = tv_sight
				f_jump_force_distance = 0.0
				v_jump_force_sens = (v_walling_normal * 0.5 )+  tv_sight
				MATH_VecSetNorm( v_jump_force_sens, DYN_SpeedGet())
				DYN_SpeedSetVector( v_jump_force_sens)
			}
		}
		
		DBG_TraceString("WALLING : décroch car trop bas")
		DBG_TraceEOL()
		i_jump_force_no_clear_bat = vrai	// Laisser les bats rider
		WALLING_DETECT_LIANE()
		i_jump_force_no_impulsion = faux
		i_walling_force_no_detection = vrai
		i_jump_check_hotspot = faux	// On peux detecter un HOT SPOT
		i_jump_autorise_accroch	= faux	// On décroche, on ne s accroche pas.
		macro_change_etat("k_ETAT_jump")
	}
}


// UN PAF FERA DECROCHER DU MUR
AI_Execute("k_exec_detect_paf")
if ( o_paf_actor)
{
	DBG_TraceString("WALLING : décroch car PAF")
	DBG_TraceEOL()

	DYN_SpeedSetVector(v_walling_normal * 10.0)
 	i_jump_force_chute = vrai
	i_jump_force_anim_cycl = Ci_Kanim_saute_chute_paf
	i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
	i_jump_force_no_orient_impulsion = faux
	v_jump_force_chute_orient = -v_walling_normal
	f_jump_force_amplitude = 1.5 // Saut cloche
	i_walling_force_no_detection = vrai
	i_jump_check_hotspot = faux	// Rien detecté, tester apres l impulsion
	i_jump_check_hotspot_fight = faux	// On peux enchainer sur un ennemi
	f_jump_force_hauteur = 2.0 	// Saut a l opposé du mur
	o_paf_actor_backup = o_paf_actor
	macro_change_etat("k_ETAT_jump")	

}
	
// APPEL DE TOUTES LES COLLISIONS
ti_GMAT_CUMUL = 0
ti_nbr = COL_ReportsNumberAndRanksGet( &ti_tab_wall[0], 50, COL_C_Wall )
ti_i = 0
for ( ti_i = 0; ti_i < ti_nbr; ti_i++ )
{	
	ti_tab_GMAT[ti_i] = COL_GMAT_FlagsGet( COL_C_ReportIndex + ti_tab_wall[ti_i])
	ti_GMAT_CUMUL |= ti_tab_GMAT[ti_i]
}

// *****	LANCER UN SAUT	*****
if ( ti_nbr && i_flag_just_Action && ! RIDE_Get_Actor_Nb()	// si 0 collision 0 saut
&& ti_GMAT_CUMUL & Gmat_KK_Face_de_Walling 
&& ti_GMAT_CUMUL != Gmat_KK_Accrochage_interdit)
{
	// CHOIX DE L ORIENTATION ET DE L ANIM DU SAUT SELON LES CAS
	if ( i_walling_corner || i_walling_liane)
	{
		// Saut a partir d un CORNER
		// Saut dans le sens de la normale
		ti_saut_vers_normale = vrai
		f_jump_force_distance = Cf_Jump_Longe_Mur_distance	* 1.0	// Longueur du saut : saut sans elan
		if ( i_walling_liane && f_joy_norm)
			v_jump_force_sens = MATH_VecInCone( v_joy_sight, v_walling_corner_normal, Cf_1Degre * 80.0, 0)
		else
			v_jump_force_sens = v_walling_corner_normal												// Orientation du saut
		i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_impulDemiD	
	}
	else
	{
		v_walling_horizon *= MATH_FloatSign(MATH_VecDotProduct( v_walling_horizon, v_joy_sight))
		tv_axe2 = MATH_VecBlendRotate(v_walling_normal,v_walling_horizon,Cf_RunningJumpAngleFromNormal / 90.0)
		MATH_VecSetHorzNormalize(tv_axe2)
		f_jump_force_distance = Cf_Jump_Longe_Mur_distance		// Longeur du saut
		v_jump_force_sens = tv_axe2
		if ( MATH_AbsFloat(MATH_VecDotProduct( v_walling_horizon, OBJ_SightGet())) < 0.2 )
			i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_impulDemiD
		else 
		{
			v_walling_horizon *= MATH_FloatSign(MATH_VecDotProduct( v_walling_horizon, OBJ_SightGet()))
			if ( MATH_VecCrossProduct( MATH_VecBlendRotate(v_walling_normal,v_walling_horizon,Cf_RunningJumpAngleFromNormal / 90.0), v_walling_normal).z > 0)
				i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_ImpulsionG
			else
				i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_ImpulsionD
		}
		tv_sens_detect_hotspot = tv_axe2
	}


	// SAUT NECESSITANT UN TEST DE HOTSPOT
	if ( !MATH_VecNullEpsilon( v_jump_force_sens))
	{
//		v_jump_force_sens = v_joy_sight
//		i_jump_check_hotspot_fight = vrai	// On peux enchainer sur un ennemi
//		AI_Execute( "k_exec_check_hotspot")
//		i_jump_check_hotspot_fight = faux	// On remet le defaut
//		v_jump_force_sens = pop
		tv_sens_detect_hotspot = v_jump_force_sens
		HOTSPOT_Detect( tv_sens_detect_hotspot, vrai)
 		if ( o_jump_hotspot)
		{
			
			// HOPTSPOT
			DBG_TraceString("WALLING : décroch car saut")
			DBG_TraceEOL()

			f_time_collide_ground = 0.0 // Forcer un saut
			i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
			i_jump_force_no_orient_impulsion = vrai // Ne pas orienter pendant le saut
			if ( i_walling_action_impulsion_before_jump == Ci_Kanim_Walling_impulDemiD)
			{
				tv_temp = @o_jump_hotspot OBJ_PosGet() - OBJ_PosGet()
				tv_temp.z = 0.0
				if ( MATH_VecDotProduct( OBJ_HorizonGet(), tv_temp) > 0 )
					i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_impulDemiG
			}	
			i_jump_force_anim_impulsion = i_walling_action_impulsion_before_jump
			i_jump_check_hotspot = faux	// On peux enchainer les HOT SPOT
			f_jump_force_hauteur = -2.0 	// Saut a -1m au dessus du HS
			f_jump_force_amplitude = 0.0 
			OBJ_HierarchySet(COL_ObjectGet( COL_C_Wall))		// si le mur bouge
			macro_change_etat("k_ETAT_jump")
		}
		else
		{
			// TESTER S IL Y A UN MUR EN FACE POUR WALLER
			if( ti_GMAT_CUMUL & Gmat_KK_Walling_JumpHotSpotOnly)
			{
				tv_sens_detect_hotspot = WALLING_GetAnotherWall( OBJ_PosGet() + v_walling_normal, tv_sens_detect_hotspot * 20.0 * Cf_Sqrt2, vrai)
				if ( !MATH_VecNullEpsilon( tv_sens_detect_hotspot))				
				{
					i_jump_without_attack = vrai	// Saut précis : interdit le coup
					v_jump_force_sens = tv_sens_detect_hotspot - OBJ_PosGet()
//					v_jump_force_pos = tv_sens_detect_hotspot - cvector( 0.0, 0.0, 3.45)
					f_jump_force_distance = MATH_VecNorm( v_jump_force_sens) // Distance
					v_jump_force_sens /= f_jump_force_distance
					if ( i_walling_action_impulsion_before_jump == Ci_Kanim_Walling_impulDemiD)
					{
						tv_temp = v_jump_force_sens
						tv_temp.z = 0.0
						if ( MATH_VecDotProduct( OBJ_HorizonGet(), tv_temp) > 0 )
							i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_impulDemiG
					}	
					f_jump_force_distance -= 5.0
					i_jump_to_frappe = faux
					i_jump_to_grab = faux
				}
			}
			else
			{
				v_jump_force_sens = tv_sens_detect_hotspot
				f_jump_force_distance = 10.0
			}
			if ( !MATH_VecNullEpsilon( tv_sens_detect_hotspot))
			{
				// SAUT N AYANT PAS DETECTE de HOTSPOT : saut normal
				DBG_TraceString("WALLING : décroch car saut")
				DBG_TraceEOL()
			
				f_time_collide_ground = 0.0 // Forcer un saut
				i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
				if ( i_walling_action_impulsion_before_jump == Ci_Kanim_Walling_impulDemiD)
				{
					if ( MATH_VecDotProduct( OBJ_HorizonGet(), tv_sens_detect_hotspot) > 0 )
						i_walling_action_impulsion_before_jump = Ci_Kanim_Walling_impulDemiG
				}	
				i_jump_force_anim_impulsion = i_walling_action_impulsion_before_jump
				i_jump_force_no_orient_impulsion = vrai
				f_jump_force_amplitude = 1.5 // Saut cloche
				i_jump_check_hotspot = vrai	// Rien detecté, tester apres l impulsion
				i_jump_check_hotspot_fight = vrai	// On peux enchainer sur un ennemi
				f_jump_force_hauteur = 2.0 	// Saut a l opposé du mur
				OBJ_HierarchySet(COL_ObjectGet( COL_C_Wall))		// si le mur bouge
				macro_change_etat("k_ETAT_jump")	
	
			}			
		}
	}

}

// CONSERVATION DE LA DERNIERE NORMALE SI IL N Y A PAS DE COLLISION CETTE TRAME( on reste en walling qques trames qd meme)
tv_axe = v_walling_horizon 
tv_axe -= v_walling_normal
to_obstacle = COL_BestWallGaoGet( tv_axe, &ti_report)
if ( !to_obstacle)
{
	// Pas de mur bien orienté

	// Cherche un mur en collision meme s'il n est pas dans l axe demandé par le best wall
	tv_walling_normal = COL_NormalGet( COL_C_Wall)
	if ( MATH_VecNullEpsilon(tv_walling_normal ))
	{
		// Pas de collision du tout garder l ancienne normale
		tv_walling_normal = v_walling_normal	
	}
}
else
	tv_walling_normal = COL_NormalGet( COL_C_ReportIndex + ti_report)

AI_Execute("k_DBG_WALLING")

//TOUS LES RAPPORTS DE COLLISIONS SONT NECESSAIRES POUR LES DIVERS CAS DE WALLING
ti_trop_haut= faux	// Detection que Kong arrive en haut du mur et Kong ne peux plus monter c'est un surplomb
ti_walling_stop_joy = faux		// FAce de walling interdit avec un joueur qui tente d aller dessus
ti_waling_interdit_detected = faux			// On a detecté une face de walling interdit
tv_best_normal_joy = Cv_NullVector		// Normale la plus adaptée au JOY
tf_dot_max = -1									// Dot product permettant de trouver la meilleure normal

//ti_nbr = COL_ReportsNumberAndRanksGet( &ti_tab_wall[0], 50, COL_C_Wall )
if( ti_nbr )
{
	// Recup du rapoort de colision en suprimant les Edges
	tv_walling_normal = Cv_NullVector
	ti_i = 0
	while ( ti_i < ti_nbr )
	{	

		ti_Gmat = COL_GMAT_FlagsGet( COL_C_ReportIndex + ti_tab_wall[ti_i])
		if ( ti_Gmat & Gmat_KK_Force_Left)
			ti_force_sens = 1		// Force le joueur a se deplacer vers la gauche
		else if ( ti_Gmat & Gmat_KK_Force_Right)
			ti_force_sens = 2		// Force le joueur a se deplacer vers la droite
		else
			ti_force_sens = 0		// Deplacement du joueur libre 

		tv_normal = COL_NormalGet( COL_C_ReportIndex + ti_tab_wall[ti_i])							// normale du mur
		to_col = COL_ObjectGet(COL_C_ReportIndex + ti_tab_wall[ti_i])
	

		if( (COL_ReportFlagGet(COL_C_ReportIndex + ti_tab_wall[ti_i] ) & COL_C_Corner) 
		|| @to_col OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims)
		|| (COL_GMAT_FlagsGet( COL_C_ReportIndex + ti_tab_wall[ti_i]) & Gmat_KK_Crossable_Walling))
		{
			
			// Avant supression tester ceci cependant
			if ( @to_col OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI)
			&&( ! ( ti_Gmat & Gmat_KK_Face_de_Walling) && !o_walling_liane))
			{
				if (  tf_dot > 0.0)
					ti_walling_stop_joy = vrai
				ti_waling_interdit_detected = vrai		
			}
	

			// suppression des normales des murs "pas vraiment" en collision et des arrêtes
			ti_tab_wall[ti_i] = ti_tab_wall[ti_nbr-1]
			ti_nbr--
		}
		else 
		{
			// Rapport de collision Valide
//			macro_render_Vector( COL_CollidedPointGet( COL_C_ReportIndex + ti_tab_wall[ti_i] ), -tv_normal * 2.0, 0xFF)
	
			// Choix de la meilleure normale par rapport au joy
			tf_dot = MATH_VecDotProduct( v_joy_sight, -tv_normal)
			if ( tf_dot  > tf_dot_max && (ti_Gmat & Gmat_KK_Face_de_Walling))
			{
				// Meilleure normale
				tf_dot_max = tf_dot
				tv_best_normal_joy = tv_normal
			}
	
			// Walling interdit par le GMAT de cette face : sauter si on est pas en corner		
			if ( !( ti_Gmat & Gmat_KK_Face_de_Walling) 
			&& !o_walling_liane)
			{
//				ti_fall = vrai				
//				if ( Proc_KK_Corner()  || f_time_start_etat < 0.5)
//				{
//					ti_fall = faux
//				}
//				if( ti_fall && !(COL_ReportFlagGet(COL_C_ReportIndex + ti_tab_wall[ti_i] ) & COL_C_Edge)) // On décroche que si on est sur une face pas un EDGE
//				{	
//					// BLINDAGE SERT EN ENTREE DANS UN CORNER AVEC UN COTE WALLING INTERDIT
//					{
//						i_jump_force_chute = vrai
//						tv_sight = OBJ_SightGet()
//						tv_sight .z = 0.0
//						if ( MATH_VecNullToler( tv_sight, 0.2 ))
//							tv_sight = -OBJ_BankingGet()			// Regarder vers le mur
//						v_jump_force_chute_orient = tv_sight 
//						f_jump_force_distance = 0.0
//						v_jump_force_sens = (v_walling_normal * 0.5 )+  v_walling_horizon 
//		     			i_jump_force_no_impulsion = faux
//						i_jump_check_hotspot = faux	// On peux detecter un HOT SPOT
//						macro_change_etat("k_ETAT_jump")			// COLMAP WALL INTERDIT: SAUTER
//					}
//				}
				
				// NEW LAW : WALLING INTERDIT : STOP MOVE
				if (  tf_dot > 0.0)
				{
					macro_render_Vector( OBJ_PosGet(), -tv_normal * 2.0, 0xFF00)
					ti_walling_stop_joy = vrai
				}
				ti_waling_interdit_detected = vrai
			}


		
			// Detection si Kong arrive en haut du mur( Sol a 2m au dessus)
			if ( !ti_trop_haut && (ti_Gmat & Gmat_KK_Face_de_Walling))
			{
				to_col = COL_RayObject_Dist( COL_ZonePosGet( C_zdm_pied), -tv_normal, 4.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
				DBG_RenderVector( COL_ZonePosGet( C_zdm_pied), -tv_normal * 4.0, color_bleu)
				if ( to_col)
				{
					// Le Lancé de rayon touche bien un mur
					tv_sol = COL_TipTopPointGet( Cv_VerticalVector, 0.0, faux, vrai, faux, vrai)
					if ( tv_sol.z < (OBJ_PosGet().z + 4.98)
					&& ! i_walling_forget_joy )
					{
						// Il y a un sol a moins de 5m au dessus
						tv_edge = COL_RayObject_EdgeNormalGet()
						DBG_RenderVector( tv_sol,tv_edge , color_rouge)
						if ( tv_edge.z > Cf_Kong_Angle_Mur_sol
						&& MATH_VecDotProduct( v_walling_normal, v_joy_sight) < 0.0)
						{
							// Le sol est un sol sur lequel on peux s'accrocher
							tv_sol2 = COL_TipTopPointGet( -Cv_VerticalVector, 0.0, faux, vrai, faux, vrai)
							if(  tv_sol.z - tv_sol2.z > 9.0)
							{
							
								// Ce bout de code permet de passer d'une position horizontal a une position verticale de BM sans saute d'anim et d'orientation
								object	to_bassin
								vector		tv_bassin_pos 
								vector		tv_bassin_sight
								vector		tv_bassin_banking							
								to_bassin = ANI_CanalObjectGet(Anim_Canal_Bassin)										// Os du bassin
								tv_bassin_pos = @to_bassin OBJ_PosGet()														// Recup la position et l'orientation du bassin
								tv_bassin_sight = @to_bassin OBJ_SightGet()													// pour la restaurer apres la rotation de BM
								tv_bassin_banking = @to_bassin OBJ_BankingGet()											// Le but c'est que le bassin soit a la position avant le Flash (stock matrix) pour que le blend soit ok
								OBJ_BankingGeneralSet( -OBJ_BankingGet(), OBJ_SightGet() )							// Inverse Banking et Sight (reorientation de la BM du perso)
								@to_bassin OBJ_PosSet(tv_bassin_pos)															// On restore la positionet l'orientation,
								@to_bassin OBJ_BankingGeneralSet(tv_bassin_sight, tv_bassin_banking)			// Le bassin est a nouveau correctement placé et orienté
								ANI_StockMatrix()																						// On Flash alors la Matrice (orientation de la BM et du Bassin OK)
								ACT_ActionSet(Ci_Kanim_climb_attente)															// Lance l'anim 
						
								v_zdm_pos = Cv_Kong_zdm_pos																	// On ajuste la position de la ZDM (optionnel)
								v_old_zdm_pos = v_zdm_pos																			// On ajuste la position de la ZDM (optionnel)
								COL_ZonePosSet(C_zdm_pied, Cv_Kong_zdm_pos)											// On ajuste la position de la ZDM (optionnel)
	
								@o_climb_target_wp OBJ_PosSet( tv_sol)														// Definition du WP d accroch
								@o_climb_target_wp OBJ_BankingGeneralSet( -tv_normal, tv_edge)						// Orientation
								o_climb_0D_wp	= o_climb_target_wp															// WP d accroch
								o_climb_0D_Wall = to_col																				// Mur d'accroch			
								v_climb_normale = tv_normal																			// Normale d accroch
								v_climb_position = tv_sol																				// position d accroch
								i_climb_0D_force_blend_banking = vrai															// Kong aura besoin d un blend de banking
								i_climb_0D_GMAT = ti_Gmat 																		// GMAT de la face
								macro_change_etat("k_ETAT_accroch_mur")	 										
							}
						}
						else if ( tv_sol.z < (OBJ_PosGet().z + 3.0 ))
						{
							// Le sol est un surplomb ne pas monter plus haut
							ti_trop_haut= vrai
						}
					}	
				}		
			}
			
			if ( (ti_Gmat & Gmat_KK_Face_de_Walling))
			{
				tv_walling_normal += tv_normal		// Normale modifié en fonction des rapports acceptables
				ti_i++			// Rapport suivant
			}
			else
			{
				// suppression des normales interdites
				ti_waling_interdit_detected = vrai
				ti_tab_wall[ti_i] = ti_tab_wall[ti_nbr-1]
				ti_nbr--
			}
			
		}
	}
	if ( ti_nbr)
		tv_walling_normal /= ti_nbr						// Moyenne des normales en fonction de toutes les collisions acceptables.
	else
		tv_walling_normal = v_walling_normal
}

// BLINDAGE SERT EN ENTREE DANS UN CORNER AVEC UN COTE WALLING INTERDIT
if ( ti_nbr != 1)
	i_walling_nb_col = 0


// DETECTION D UN CORNER POUR PASSER EN MODE GRIMPE VERTICAL
i_walling_grimper = faux
// Methode Corner
if ( COL_CollideType(COL_C_Corner) && ! ti_waling_interdit_detected && COL_GMatReportGet(Gmat_KK_Crossable_Walling) == -1)
{
	// Collision avec un CORNER
	i_walling_corner = vrai
	tv_walling_normal = COL_NormalGet( COL_C_Corner)

	v_walling_corner_normal  = tv_walling_normal
	if ( f_joy_norm)
		tv_sight = v_joy_sight
	else
		tv_sight = -OBJ_BankingGet()
	// Vers ou veux aller le joueur

	if ( !MATH_VecNullEpsilon( tv_best_normal_joy))
	{
		tv_walling_tan = MATH_VecCrossProduct( tv_best_normal_joy, Cv_VerticalVector)
		MATH_VecSetNormalize(tv_walling_tan)
		tv_walling_tan *= MATH_FloatSign( MATH_VecDotProduct( tv_walling_tan, v_walling_corner_normal))	// Plan du mur horizontal quipermet de sortir du corner
		tf_dot = MATH_VecDotProduct( tv_walling_tan, tv_sight)
	}
	else
	{
		DBG_TraceString("Best normal null")
		DBG_TraceEOL()
		tf_dot = 0
	}
	tf_dot2 = MATH_VecDotProduct( tv_walling_normal, tv_sight) 
	if ( tf_dot  < Cf_Cos45 || tf_dot2 > Cf_Cos15)
	{
		// Le jouer va vers le corner
		if ( RIDE_Get_Actor_Nb() < Ci_Nb_Bat_Limit_Climb)
			i_walling_grimper = vrai	
		else
			i_walling_grimper = faux	
	}
	else
	{
		// Joy sur le cote
		// Le joueur veux QUITER LE CORNERING :choix de la normale qu'il va utiliser pour en sortir
		i_walling_grimper = faux
		tv_walling_normal = tv_best_normal_joy												// Utilisation de la meilleure normale
		DBG_RenderVector( OBJ_PosGet(), tv_walling_normal , color_bleu)
	}
}
else
{
	i_walling_corner = faux
	i_walling_grimper = faux
}



o_walling_liane = WALLING_DETECT_LIANE()

if( o_walling_liane)
{ 
	// LIANE
	i_walling_liane = vrai
	tv_walling_normal = @o_walling_liane OBJ_SightGet()
	v_walling_corner_normal  = tv_walling_normal
	if ( f_joy_norm)
		tv_sight = v_joy_sight
	else
		tv_sight = -OBJ_BankingGet()	

	tf_dot2 = MATH_VecDotProduct( tv_walling_normal, tv_sight) 
	if ( tf_dot2  < -Cf_Cos45 || tf_dot2 > Cf_Cos45)
	{
		// Le jouer va vers le corner
		if ( RIDE_Get_Actor_Nb() < Ci_Nb_Bat_Limit_Climb)
			i_walling_grimper = vrai	
		else
		{
			i_walling_grimper = faux
			ti_force_sens = 0
			if ( o_walling_liane.des_int1 & 1)		
				ti_force_sens += 1		// Force le joueur a se deplacer vers la gauche car aller a droite interdit
			if ( o_walling_liane.des_int1 & 2)
				ti_force_sens += 2		// Force le joueur a se deplacer vers la droite car aller a gauche interdit
		}
	}
	else
	{
		// Joy sur le cote
		// Le joueur veux QUITER LE CORNERING :choix de la normale qu'il va utiliser pour en sortir
		ti_force_sens = 0
		if ( o_walling_liane.des_int1 & 1)		
			ti_force_sens += 1		// Force le joueur a se deplacer vers la gauche car aller a droite interdit
		if ( o_walling_liane.des_int1 & 2)
			ti_force_sens += 2		// Force le joueur a se deplacer vers la droite car aller a gauche interdit

		i_walling_grimper = faux
		tv_walling_normal = tv_best_normal_joy												// Utilisation de la meilleure normale
		if ( MATH_VecNullEpsilon(tv_best_normal_joy))
		{
			// Angle trop OUVERT : Décrocher du Walling
			DBG_TraceString("WALLING : décroch car liane et pas de bonne normale")
			DBG_TraceEOL()
			f_jump_force_distance = 5.0
			v_jump_force_sens = -OBJ_BankingGet()					
			tv_temp1 = v_jump_force_sens
			tv_temp1.z = 0.0
			if ( MATH_VecNullEpsilon(tv_temp1))
				v_jump_force_sens = -OBJ_SightGet()
			DYN_SpeedSetVector( v_jump_force_sens)		// Forcer la chute dans le sens du mur
			i_jump_force_chute = vrai
			v_jump_force_chute_orient = v_jump_force_sens		// Orientation de Kong pendant le saut
			macro_change_etat("k_ETAT_jump")	
		}
		DBG_RenderVector( OBJ_PosGet(), tv_walling_normal , color_bleu)
	}
}
else
{
	i_walling_liane = faux
	if ( !i_walling_corner)
		i_walling_grimper = faux
}

// DETECTION DES SLIPPERY EDGE POUR DECROCHAGE SI ANGLE TROP GRAND
if ( !ti_waling_interdit_detected && COL_CollideType( COL_C_SlipperyEdge) && !o_walling_liane
&& COL_GMatReportGet(Gmat_KK_Crossable_Walling) == -1)
{
	// Slippery edge
	ti_nb_normal  = COL_EdgeBothNormalGet( &tv_normal_edge[0])
	if( ti_nb_normal > 1)
	{
		tv_walling_normal = Cv_NullVector
		for( ti_i = 0; ti_i < ti_nb_normal; ti_i++)
		{
			macro_render_Vector( OBJ_PosGet(), tv_normal_edge[ ti_i] * 3.0, 0xFF)
 			tf_dot= MATH_VecDotProduct( v_walling_normal, tv_normal_edge[ ti_i])
			if ( tf_dot <= Cf_Cos85)
			{
//				tf_dot = MATH_VecCrossProduct( v_walling_normal, tv_normal_edge[ ti_i]).z
				tf_dot = MATH_VecDotProduct( v_walling_normal, tv_normal_edge[ ti_i])				
				if ( tf_dot < Cf_Cos85 )
				{
					// Angle trop OUVERT : Décrocher du Walling
					f_jump_force_distance = 5.0
					v_jump_force_sens = v_walling_horizon					
					v_jump_force_sens = DYN_SpeedGetVector() - ( v_walling_normal * MATH_VecDotProduct( v_walling_normal, DYN_SpeedGetVector()))

					// NEW NEW
					v_jump_force_sens = (v_walling_horizon  * 2.0)+ v_walling_normal


					if ( i_walling_entree_saut && f_time_start_etat < 0.75)
					{
						v_jump_force_sens = -OBJ_SightGet()
						v_jump_force_chute_orient = OBJ_SightGet()
						MATH_VecSetNorm(  v_jump_force_sens , 10.0)
					}
					else
					{
						v_jump_force_chute_orient = v_jump_force_sens		// Orientation de Kong pendant le saut
						MATH_VecSetNorm(  v_jump_force_sens , DYN_SpeedGet())
						DYN_SpeedSetVector( v_jump_force_sens)		// Forcer la chute dans le sens du mur 
					}

					DBG_TraceString("WALLING : décroch car slippery EDGE")
					DBG_TraceEOL()

					i_jump_force_chute = vrai
					macro_change_etat("k_ETAT_jump")
				}
			}
			tv_walling_normal += tv_normal_edge[ ti_i]
		}
		tv_walling_normal  /= ti_nb_normal
	}
}

//if ( MATH_VecNullEpsilon(tv_walling_normal))
//	DBG_Error("Normale de Walling nule !!")
//
// COMPORTEMENT ============================================================================

//// CAMERA -----------------------------------------------------------------
//@get_global i_kong_camera_status = Ci_Kcamera_walling
//// CAMERA -----------------------------------------------------------------


f_ride_paf_time = 0.0		// Pas de paf de scolo sur le delai dans ce mode



// REPERE DU MUR DE WALLING
if ( !MATH_VecNullEpsilon( tv_walling_normal))
	v_walling_normal = tv_walling_normal
else
{
	v_walling_normal = tv_best_normal_joy			// Blindage pour le cas du corner Echec( en effet une collision qui ne trouve pas de solution annonce Corner dans le rapport de collisionpas
	DBG_TraceString("Corner Echec")
	if ( MATH_VecNullEpsilon( v_walling_normal ))
	{
		v_walling_normal = OBJ_BankingGet()
		DBG_TraceString(" + Normale Nulle !!")
	}
	DBG_TraceEOL()
		
}
v_walling_normal = MATH_VecNormalize(v_walling_normal)
v_walling_horizon = MATH_VecCrossProduct( v_walling_normal, Cv_VerticalVector)
MATH_VecSetNormalize(v_walling_horizon)
v_walling_banking = MATH_VecCrossProduct( v_walling_horizon, v_walling_normal)	// Plan du mur vers le haut
if ( i_walling_corner || i_walling_liane)
	v_walling_horizon *= MATH_FloatSign( MATH_VecDotProduct( v_walling_horizon, v_joy_sight))	// PLan du mur horizontal ds le sens du deplacement
else
	v_walling_horizon *= MATH_FloatSign( MATH_VecDotProduct( v_walling_horizon, DYN_SpeedGetVector()))	// PLan du mur horizontal ds le sens du deplacement

// Normale horizontale
tv_walling_normal = v_walling_normal
tv_walling_normal.z = 0.0
MATH_VecSetNormalize(tv_walling_normal)

// ACTION JOY ET ORIENTATION
if ( i_walling_forget_joy && f_time_start_etat > 0.25)
{
	i_walling_forget_joy = faux
	v_walling_gravity = cvector( 0.0, 0.0, DYN_SpeedGetVector().z)
}



	// DEPLACEMENT
	i_walling_fumee = vrai
	//calcul du joy 
	if ( ( ( ACT_ActionGet() == Ci_Kanim_Walling_Stop && ANI_CurrentFrameGet(0) < 58)
	|| ACT_ActionGet() == Ci_Kanim_Walling_StopRapide)
	&& ( ! i_walling_entree_saut  || f_time_start_etat > 0.75) )
		tv_joy = Cv_NullVector
	else 
	if ( f_joy_norm)
	{
		if ( i_walling_grimper ) //|| i_walling_stop)
		{
			// Joy en mode grimpe: monter uniquement
			
			if( i_walling_liane)
			{
				v_walling_banking = @o_walling_liane OBJ_BankingGet()
				v_walling_horizon =  @o_walling_liane OBJ_HorizonGet()
			}
			if ( i_walling_forget_joy)
				tv_joy = Cv_NullVector
			else if ( MATH_VecDotProduct( v_joy_sight, v_walling_normal) > Cf_Cos30)
				tv_joy = Cv_NullVector
			else if ( MATH_VecDotProduct( v_joy_sight, v_walling_normal) < 0 
			|| i_walling_stop 
			|| RIDE_Get_Actor_Nb() >= Ci_Nb_Bat_Limit_Climb
			|| f_walling_frein >= 7.0)
			{
				if ( i_walling_stop  
				|| RIDE_Get_Actor_Nb() >= Ci_Nb_Bat_Limit_Climb 
				|| f_walling_frein >= 7.0)
					tv_joy = WALLING_Force_Sens( ti_force_sens, v_joy_sight)
				else
					tv_joy = v_walling_banking
			}
			else
				tv_joy = Cv_NullVector
		}
		else
		{
			// Joy en Walling: il est remis ds le plan du mur
			if ( !ti_trop_haut)
			{
				tv_joy = ( v_walling_horizon * MATH_VecDotProduct( v_joy_sight, v_walling_horizon )) 
				- ( v_walling_banking * MATH_VecDotProduct( v_joy_sight, tv_walling_normal))
			}
			else
			{
				tv_joy = ( v_walling_horizon * MATH_VecDotProduct( v_joy_sight, v_walling_horizon )) 
			}		

			// Limitation du sens de deplacement

			tv_joy = WALLING_Force_Sens( ti_force_sens, v_joy_sight)


			if ( i_walling_liane && MATH_VecNullEpsilon( tv_joy))
			{
				i_walling_grimper = vrai
				v_walling_banking = @o_walling_liane OBJ_BankingGet()
				v_walling_horizon =  @o_walling_liane OBJ_HorizonGet()
				tv_joy = v_walling_banking 
			}	
			else
			{
				// Choix du comportement en fonction de la position du joy dans le cercle de déplacement		
				tf_dot = MATH_VecDotProduct( tv_joy, v_walling_banking)
				tf_dot2 = MATH_VecDotProduct( tv_joy, v_walling_horizon)
				if ( tf_dot < 0.0)
				{
					tf_speed = MATH_VecDotProduct( -OBJ_SightGet(), v_walling_banking)
					if ( MATH_AbsFloat(tf_speed ) > 0.95 && tf_dot < -Cf_Cos45)
						tv_joy = Cv_NullVector				// Stop
					else	if ( tf_dot2 > 0.0)
							tv_joy =  v_walling_horizon		// Avancer
					else
					{
						// ½ tour
						tv_joy = - v_walling_horizon
						v_walling_horizon = -v_walling_horizon
					}					
				}
				else
				{
					if ( tf_dot2 > 0.0)
						tv_joy =  v_walling_horizon				// Avancer
					else if ( tf_dot2 < -Cf_Cos45)
					{
						// ½ tour
						tv_joy = - v_walling_horizon
						v_walling_horizon = -v_walling_horizon
					}			
					else
						tv_joy = Cv_NullVector						// Stop
				}
			}
		}
	}
	else
		tv_joy = Cv_NullVector


//	if ( i_walling_forget_joy)
//		tv_joy = Cv_NullVector
	// SON SON SON SON SON
	tf_speedZ = -DYN_SpeedGetVector().z / 10.0
	if ( tf_speedZ > 0.0)
	{
		if ( i_SND_walling_derape == -1)
		{
			i_SND_walling_derape = SND_Request( 12, C_SND_Request_DestroyWhenFinished+C_SND_Request_3DSound)
			SND_PlayLooped(i_SND_walling_derape , -1)
		}
		SND_InsertVarSet( i_SND_walling_derape, 10, tf_speedZ)
	}
	else
	{
		if ( i_SND_walling_derape != -1)
		{
			SND_Stop(	i_SND_walling_derape)
			i_SND_walling_derape = -1
		}		
	}
	// SON SON SON SON SON
	
	// choix du comportement en fonction du joy	
//	if ( f_walling_need_reception < 0.4)
//	{
//		f_walling_need_reception += TIME_GetDt()
//		ACT_ActionSet(Ci_Kanim_Walling_Stop)
//		tf_gravity_speed = 0.0//f_walling_gravity
//		tv_sight_axis = v_walling_banking		// sight
//		tv_joy_axis = Cv_NullVector			// joy vers mur
//		tf_rotation_speed = 1.0
//		tf_blend_speed = 1.0
//	}
//	else
	ti_walling_action = -1
	if ( i_flag_just_grab || i_flag_just_Rage_Any_Button
	|| (ACT_ActionGet() == Ci_Kanim_Walling_frappeG && !ACT_ActionFinished()))
	{
		ti_walling_action = Ci_Kanim_Walling_frappeG
		tf_gravity_speed = 10.0//f_walling_gravity
		tv_sight_axis = v_walling_banking		// sight
		tv_joy_axis = Cv_NullVector			// joy vers mur
		tf_rotation_speed = 4.0
		tf_blend_speed = 4.0
		if ( RIDE_Get_Actor_Nb() && COUP_TryToHit( ))
			RIDE_Clear_Link_Bat(1)
	}
	else if( ! MATH_VecNullEpsilon( tv_joy) )
	{
		// DEPLACEMENT
		if ( f_time_start_etat < 0.4)
			tf_rotation_speed = 4.0		// 
		else
			tf_rotation_speed = 2.0
		tf_blend_speed = 3.0
	
		if (f_joy_norm)
			tv_joy = glob_joyvector_get
		else
			tv_joy = OBJ_SightGet()
	
		tf_dot = MATH_VecDotProduct( v_walling_normal, tv_joy)
	
		tv_joy_axis = v_walling_horizon + ( v_walling_banking	* 0.30) // * tf_dot ))		//Joy fixe en deplacement walling: courbes toujours identiques.
		tv_sight_axis = v_walling_horizon - cvector( 0.0, 0.0, MATH_FloatMin( 0.0, DYN_SpeedGetVector().z) * 0.05)

		// Entre 2 mur monté verticale
	
		i_walling_nb_bat = RIDE_Get_Actor_Nb()

		if ( i_walling_grimper )
		{
			if ( ti_trop_haut || i_walling_trop_haut)
			{
				ti_walling_action = Ci_Kanim_Walling_StopAtt
				tf_gravity_speed = 0.0				
			}
			else if ( ! MATH_FloatNullEpsilon( f_walling_frein) && f_walling_frein < 7.0)
			{
				ti_walling_action = Ci_Kanim_Walling_cornerD
				ANI_FrequencySet(0, MATH_FloatBlend( 64.0,1.0, (f_walling_frein / 5.0)))
				tf_gravity_speed = 0.0
			}
			else if ( MATH_FloatNullEpsilon( f_walling_frein) && i_walling_nb_bat < Ci_Nb_Bat_Limit_Climb)
			{
				ti_walling_action = Ci_Kanim_Walling_cornerD
				if ( i_walling_nb_bat)
					ANI_FrequencySet(0,ACT_FrequencyGet( Ci_Kanim_Walling_cornerD,0) * 0.5)
				tf_gravity_speed = 0.0
			}
			else
			{
				ti_walling_action = Ci_Kanim_Walling_derape
				tf_gravity_speed = f_walling_gravity
			}			
		}
		else if ( MATH_VecDotProduct( MATH_VecCrossProduct( v_walling_horizon, v_walling_banking), v_walling_normal) > 0)
		{
			tf_gravity_speed = f_walling_gravity
			ti_walling_action = Ci_Kanim_Walling_courseG
		}
		else
		{
			tf_gravity_speed = f_walling_gravity
			ti_walling_action = Ci_Kanim_Walling_courseD
		}
			
		if ( ACT_ActionGet() == Ci_Kanim_Walling_frappeG)
		{
			tv_joy_axis = Cv_NullVector			// joy vers mur
		}
		else if ( i_walling_grimper)
		{
			// Entre 2 mur monté verticale
			tv_joy_axis = v_walling_banking 	// monter
			if ( MATH_FloatNullEpsilon(f_walling_frein) )
				tv_joy_axis *= 0.45 / ( i_walling_nb_bat + 1)
			else
				tv_joy_axis *= 0.45 / ( f_walling_frein + 1)

			tv_sight_axis = v_walling_banking
			if ( i_walling_nb_bat < Ci_Nb_Bat_Limit_Climb
			&& f_walling_frein < 7.0)
				v_walling_gravity = Cv_NullVector 
			else if( i_walling_nb_bat)
				tf_gravity_speed = f_walling_gravity * i_walling_nb_bat
			else
				tf_gravity_speed = f_walling_gravity * 6.0
		}
	}
	else
	{
		// ARRET
		if ( i_walling_stop)
		{
			// Arret immediat
			v_walling_gravity = Cv_NullVector
			tf_gravity_speed = 0.0
			tf_blend_speed = 100000.0
			tv_sight_axis = v_walling_banking
			switch ( ACT_ActionGet())
			{
				case Ci_Kanim_Walling_courseG :
				case Ci_Kanim_Walling_courseD :
				case Ci_Kanim_Walling_derape :
					f_walling_speed_z = v_walling_speed.z
					DYN_SpeedSetVector(Cv_NullVector)
					if ( DYN_SpeedGetVector().z < -15.0 )
						ti_walling_action = Ci_Kanim_Walling_StopRapide
					else
						ti_walling_action = Ci_Kanim_Walling_Stop
					break 
				case Ci_Kanim_Walling_Stop :
				case Ci_Kanim_Walling_StopRapide :
					if (ACT_ActionFinished())
						ti_walling_action = Ci_Kanim_Walling_StopAtt
					break
				case Ci_Kanim_Walling_StopAtt :
				default:
					ti_walling_action = Ci_Kanim_Walling_StopAtt
			}

		}
		else if ( i_walling_grimper)
		{
			// Grimper entre 2 murs
			if ( f_time_start_etat > 0.25)
				tf_blend_speed = 10.0
			else
				tf_blend_speed = 2.5
			tf_gravity_speed = f_walling_gravity
			tv_sight_axis = v_walling_banking
			ti_walling_action = Ci_Kanim_Walling_derape
		}
		else 
		{
			// glissade normale sans joy
			tf_blend_speed = 2.5
//			if (!MATH_FloatNullEpsilon(f_walling_gravity))
//				tf_gravity_speed = f_walling_gravity
//			else
				tf_gravity_speed = f_walling_gravity // 50		
			tv_sight_axis = v_walling_banking
			ti_walling_action = Ci_Kanim_Walling_derape
		}
		tf_rotation_speed = 3.0
		tv_joy_axis = Cv_NullVector
	}


if ( f_walling_need_reception < 0.15)
{
	f_walling_need_reception += TIME_GetDt()
	ACT_ActionSet(Ci_Kanim_Walling_Stop)
}
else if ( ti_walling_action != -1)
	ACT_ActionSet(ti_walling_action)
	
// DETECTER SI KONG PEUT PAFFER
if ( COUP_TryToHit( ))
{
	COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 4.0))
	COL_ZoneSizeSet( C_zde_fight, cvector( 4.0, 4.0, 4.0))
	AI_Execute( "k_exec_zdf_zdc")
	COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 2.0))
	COL_ZoneSizeSet( C_zde_fight, Cf_ZDE_SizeFight)
}
else
	i_frappe_target_nb = 0



// MOUVEMENT	
if ( f_time_start_etat > 0.9)
	v_walling_gravity += cvector( 0.0, 0.0, -tf_gravity_speed * TIME_GetDt())

if ( i_walling_forget_joy)
	tv_joy_axis = -v_walling_banking //Cv_NullVector
if ( ti_walling_stop_joy)
{
	tv_joy_axis = Cv_NullVector
	tf_blend_speed = 80.0
}

v_walling_axe_incidence = MATH_VecBlend( v_walling_axe_incidence, tv_joy_axis, tf_blend_speed * TIME_GetDt())

if ( i_walling_liane && i_walling_grimper)
{
	tv_temp = OBJ_PosGet() - @o_walling_liane OBJ_PosGet()
	if ( MATH_AbsFloat(MATH_VecDotProduct( @o_walling_liane OBJ_HorizonGet(), tv_temp)) > MATH_FloatMax( 1.0, @o_walling_liane OBJ_ScaleGet().x * 0.2))
	{
		tv_traction = @o_walling_liane OBJ_PosGet() - (@o_walling_liane OBJ_SightGet() * 2.0)
		tv_traction += @o_walling_liane OBJ_BankingGet() * MATH_VecDotProduct( @o_walling_liane OBJ_BankingGet(), tv_temp)
		tv_traction -= OBJ_PosGet()
		v_walling_liane_pos = Cv_NullVector
	}
	else if ( MATH_VecNullEpsilon( v_walling_liane_pos))
	{
		v_walling_liane_pos = @o_walling_liane OBJ_PosGet() + ( @o_walling_liane OBJ_HorizonGet() * MATH_VecDotProduct( @o_walling_liane OBJ_HorizonGet(), tv_temp))
		tv_traction = - @o_walling_liane OBJ_SightGet() * 2.0
	}
	else
	{
		tv_traction = v_walling_liane_pos - (@o_walling_liane OBJ_SightGet() * 2.0)
		tv_traction += @o_walling_liane OBJ_BankingGet() * MATH_VecDotProduct( @o_walling_liane OBJ_BankingGet(), OBJ_PosGet() - v_walling_liane_pos)
		tv_traction -= OBJ_PosGet()		
	}
	tv_traction.z = 0.0
	// TRICHE TRICHE
	OBJ_PosSet( OBJ_PosGet() + (tv_traction * TIME_GetDt() ))
	MATH_VecSetNorm( tv_traction, Cf_Force_Plaquage)
	v_walling_pos = OBJ_PosGet()
}
else
{
	tv_traction = -v_walling_normal * Cf_Force_Plaquage
	v_walling_liane_pos = Cv_NullVector
}

tv_traction.z = 0.0
tv_traction += v_walling_axe_incidence * Cf_Force_Deplacement
tv_traction += v_walling_gravity
if ( ti_trop_haut || RIDE_Get_Actor_Nb() >= Ci_Nb_Bat_Limit_Climb)
	tv_traction.z = MATH_FloatMin( 0.0,tv_traction.z)
else if ( i_walling_stop)
{
//	if ( ACT_ActionGet() == Ci_Kanim_Walling_Stop || ACT_ActionGet() == Ci_Kanim_Walling_StopRapide)
//	{
//		tv_traction = -v_walling_normal * Cf_Force_Plaquage		// Garder Kong plaqué contre la colmap
//		tv_traction.z =  0.0
//		tv_traction += DYN_SpeedGetVector()				// Speed de l anim
//	}
//	else
	if ( ACT_ActionGet() == Ci_Kanim_Walling_Stop || ACT_ActionGet() == Ci_Kanim_Walling_StopRapide)
	{
		if ( tf_offset_bas < 2.0)
			tv_traction.z = MATH_FloatMax( 0.0,tv_traction.z)
		else
		{
			tv_traction.z = ((0.25 * tf_offset_bas) - 0.5) * f_walling_speed_z
		}
	}
	else
		tv_traction.z = MATH_FloatMax( 0.0,tv_traction.z)
	
}
DYN_SpeedSetVector( tv_traction )
v_walling_speed = tv_traction
tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_sight_axis, tf_rotation_speed * TIME_GetDt())
macro_correction_banking( tv_sight, v_walling_normal, 3.0)
macro_render_Vector( OBJ_PosGet(), v_walling_normal * 8.0, color_rouge)

f_walling_frein = 0.0
i_walling_stop = faux	