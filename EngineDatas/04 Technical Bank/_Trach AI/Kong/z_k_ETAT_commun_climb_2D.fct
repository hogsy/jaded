#include"k_define.var"

float		tf_dot_X
float		tf_dot_Y
float		tf_norm
float		tf_joy_norm

vector	tv_joy_dir
vector	tv_new_sight
vector	tv_X
vector	tv_Y
vector	tv_pos
vector	tv_temp

#define	Cf_climb_2D_speed						5.0

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

	v_zdm_pos = Cv_Kong_zdm_pos
	DYN_GravitySet(Cv_Kong_Gravity)

	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_commun_climb_2D) 
{
	i_etat_courant = ETAT_commun_climb_2D

	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_grab_grimpe
	// CAMERA -----------------------------------------------------------------

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	ACT_ActionSet(Ci_Kanim_climb_accroche)
	DYN_GravitySet(Cv_NullVector)	

	v_zdm_pos = cvector(0.0, 3.4, 0.0)

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ======================================================================
AI_Execute("k_exec_joy")

if (! i_flag_grab)
	macro_change_etat("k_ETAT_commun_climb_slide")

if (i_flag_just_jump)
	macro_change_etat("k_ETAT_commun_climb_impulsion")

// COMPORTEMENT ================================================================
if (ACT_ActionGet() == Ci_Kanim_climb_accroche && ACT_ActionFinished())
	ACT_ActionSet(Ci_Kanim_climb_attente)

AI_Execute("k_exec_climb_ray")

if (COL_CollideType(COL_C_Wall))
{
	v_climb_position = COL_CollidedPointGet(COL_C_Wall)

	tv_temp = OBJ_PosGet() - v_climb_position
	MATH_VecSetHorzNormalize(tv_temp)
	
	v_climb_normale = MATH_VecBlendRotate(v_climb_normale, tv_temp, 4.0 * TIME_GetDt())
}
else if (i_flag_climb_wall)
{
	tv_pos = MATH_VecBlendRotate(OBJ_PosGet() - v_climb_position, v_climb_normale * 3.0, 4.0 * TIME_GetDt())
	tv_pos += v_climb_position
	OBJ_PosSet(tv_pos)
}

tv_X = MATH_VecCrossProduct(v_climb_normale, Cv_VerticalVector)
tv_Y = Cv_VerticalVector // MATH_VecCrossProduct(tv_X, v_climb_normale)

tv_joy_dir = @get_global v_joy_camera_normalized_Z
tf_joy_norm = @get_global f_joy_norm

if (tf_joy_norm)
{
	tf_dot_X	= MATH_VecDotProduct(tv_joy_dir, tv_X)
	tf_dot_Y	= MATH_VecDotProduct(tv_joy_dir, tv_Y)

	if (MATH_AbsFloat(tf_dot_X) > MATH_AbsFloat(tf_dot_Y))
	{
		if (tf_dot_X > 0.0)
			ACT_ActionSet(Ci_Kanim_climb_left)
		else
			ACT_ActionSet(Ci_Kanim_climb_right)
	}
	else
	{
		if (tf_dot_Y > 0.0)
			ACT_ActionSet(Ci_Kanim_climb_up)
		else
			ACT_ActionSet(Ci_Kanim_climb_down)
	}
	
	v_climb_speed = tv_Y * tf_dot_Y
	v_climb_speed += tv_X * tf_dot_X
	v_climb_speed *= DYN_SpeedGet()
	DYN_SpeedSetVector(v_climb_speed)	
}
else
{
	ACT_ActionSet(Ci_Kanim_climb_attente)	

	DYN_SpeedSetVector(Cv_NullVector)
}

tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), - v_climb_normale, 6.0 * TIME_GetDt())
OBJ_BankingGeneralSet(tv_new_sight, Cv_VerticalVector)