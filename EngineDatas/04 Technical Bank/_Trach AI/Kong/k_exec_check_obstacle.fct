#include "k_define.var"

#define DBG_RENDER_OBSTACLE		vrai

int				ti_bw

float			tf_z


int				ti_ID_Colmap
float			tf_speed
float			tf_zone_size

vector		tv_ray
vector		tv_speed_dir
vector		tv_start_pos
vector		tv_collision_point
vector		tv_collision_normale
vector		tv_collision_normale_sol
vector		tv_top_point
vector		tv_offset
vector		tv_start_to_collision_point

object		to_obstacle
object		to_col

f_delay_before_collision = Cf_Infinit

v_obstacle_normale = Cv_NullVector

switch(ACT_ActionGet())
{
	case Ci_Kanim_saute_3M :
	case Ci_Kanim_saute_5M :
		return
	default:
}

//return


// Some Inits
f_hauteur_obstacle = 0.0										// Par defaut on ne touche pas d'obstacle donc pas de hauteur.
i_obstacle_GMAT = 0											// Type du GMAT de l'obstacle.

tf_zone_size = COL_ZoneSizeGet(C_zdm_pied)		// Taille de la ZDM
tv_collision_normale_sol = Cv_VerticalVector			// Vertical vector as a default

to_obstacle = nobody											// Par defaut pas d'obstacle a franchir

tf_speed = DYN_SpeedGet()									// Distance du LR en fonction de la vitesse
tf_speed *= 0.3
tf_speed += tf_zone_size

tv_start_pos = COL_ZonePosGet(C_zdm_pied)			// Position debut de LR
tv_start_pos.z = OBJ_PosGet().z + 1.0

//if (i_etat_courant == ETAT_jump) 
//{
//	tv_speed_dir = OBJ_SightGet()
//
//	tf_speed = 4.0
//}
//else if ( !MATH_FloatNullEpsilon(tf_speed))
//{
//	tv_speed_dir = DYN_SpeedGetVector() / tf_speed
//
//	tf_speed *= 0.3
//	tf_speed += tf_zone_size
//}
//else if (COL_CollideType(COL_C_Wall))
//{
//	to_col = COL_ObjectGet(COL_C_Wall)
//	if ( @to_col OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_ODE)
//		return
//	tf_speed = 20.0
//	tv_speed_dir = -COL_NormalGet( COL_C_Wall)
//}
//else
//{
//	return
//}
tv_speed_dir = OBJ_SightGet()

// Test dans la direction du Joy si le Joy est dans l'axe du regard
//if ( MATH_VecDotProduct(v_joy_sight_normalized, v_look_direction) > Cf_Cos45 )
{
	// Le JOY est + ou - dans la direction du regard de Kong
	if ( COL_BestAngleWallGaoGet(v_joy_sight_normalized, Cf_Cos45, &ti_bw) && i_dernier_etat != ETAT_Kong_walling )
	{
		// Collision au CONTACT du decors
		to_obstacle = COL_ObjectGet(COL_C_ReportIndex + ti_bw)
		if ( @to_obstacle OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_ODE)
			to_obstacle = nobody		// ODE Cancel this Collision
		else
		{
			// Ce n'est pas un objet ODE donc je le prend
			ti_ID_Colmap = COL_GMAT_IDGet( COL_C_ReportIndex + ti_bw)
			tv_collision_point = COL_CollidedPointGet(COL_C_ReportIndex + ti_bw)
			tv_collision_normale = tv_start_pos - tv_collision_point
			MATH_VecSetHorzNormalize(tv_collision_normale)
			to_obstacle = COL_RayObject_Dist(tv_start_pos, -tv_collision_normale, tf_zone_size + 1.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
		}
	}
	else
	{
		// Collision a DISTANCE du decors (DANS L'axe DU JOY)
//		to_obstacle = COL_RayObject_Dist(tv_start_pos, tv_speed_dir, tf_speed, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable) 
		to_obstacle = COL_RayObject_Dist(tv_start_pos, v_joy_sight_normalized, tf_speed, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable) 
		if (to_obstacle)
		{
			if ( @to_obstacle OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_ODE)
				to_obstacle = nobody		// ODE Cancel this Collision
			else
			{
				// Ce n'est pas un objet ODE donc je le prend
				ti_ID_Colmap = COL_GMAT_IDGet( COL_C_Wall)
				tv_collision_point = COL_RayObject_PosGet()
				tv_collision_normale = COL_RayObject_NormalGet()
			}
		}
	}
}

if (to_obstacle && MATH_AbsFloat(tv_collision_normale.z) < Cf_Kong_Angle_Mur_sol) // && !(@to_obstacle OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_AI))
{
	// J'ai un Obstacle et c'est un Mur (normale)

	macro_render_Vector_define(tv_start_pos, tv_collision_point - tv_start_pos, color_blanc, DBG_RENDER_OBSTACLE)

	i_obstacle_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)															// GMAT de l'obstacle a franchir

	tv_top_point = COL_TipTopPointGet(Cv_VerticalVector, tf_zone_size + 0.5, faux, vrai, faux, vrai)			// C'est HAUT ?
	v_obstacle_top_point = tv_top_point
	
	// TEST DE TOP POINT AVEC SOL DERRIERE ===================================
	tv_collision_normale_sol = COL_RayObject_EdgeNormalGet()
	if( tv_collision_normale_sol.z > Cf_Kong_Angle_Mur_sol)
		f_hauteur_obstacle = tv_top_point.z
	else
		f_hauteur_obstacle = Cf_Infinit		// Le tiptop chie et indique je ne sais trop quoi
	// TEST DE TOP POINT AVEC SOL DERRIERE ===================================
	
	f_hauteur_obstacle -= OBJ_PosGet().z																					// Hauteur de l'obstacle = le haut du mur - ma position.

	macro_render_Vector_define(tv_top_point, tv_collision_normale, color_rouge, DBG_RENDER_OBSTACLE)

	if (f_hauteur_obstacle < Cf_max_step)
	{
		// L'Obstacle va etre absorbé par le MaxStep de la ZDM
		f_hauteur_obstacle = 0.0
		return
	}

	// CALCUL DU DELAI AVANT LA COLLISION
	tv_start_to_collision_point	= tv_collision_point - tv_start_pos
	tv_start_to_collision_point.z = 0.0

	f_obstacle_dist = MATH_VecDotProduct(tv_start_to_collision_point, -tv_collision_normale)
	tf_speed /= MATH_VecDotProduct(tv_speed_dir, -tv_collision_normale)

	f_delay_before_collision = f_obstacle_dist
	f_delay_before_collision -= tf_zone_size
	f_delay_before_collision /= tf_speed

	v_obstacle_normale = tv_collision_normale
	v_obstacle_normale_sol = tv_collision_normale_sol
	v_obstacle_dest_pos = tv_top_point
	v_obstacle_dest_pos -= v_obstacle_normale * (tf_zone_size * 0.5)
	tv_collision_point = tv_top_point - OBJ_PosGet()
	tv_collision_point.z = 0.0
	f_obstacle_dist_true = MATH_VecNorm( tv_collision_point)
}














