#include "k_define.var"

int			ti_GMAT
int			ti_flag_compute_action_duration
int			ti_freq

float		tf_hauteur_mur
float		tf_hauteur_saut
float		tf_coef

vector	tv_temp
vector	tv_pos
vector	tv_ray_normale
vector	tv_climb_position
vector	tv_edge_normal




object tto_ledgeWP 				// the waypoint kong will grip with his hand (ex: o_climb_0D_wp) 
int	ttb_adjustWP					// will compute where the corner is and set to_ledgeWP to it with same banking as wall
vector ttv_floorDir			// the direction on the floor above the ledging (ex: v_climb_sol)
vector ttv_wallNormal		// normal to the wall in front of kong (ex: v_climb_normale)
float ttf_wallInclineAng	// angle of the wall relative to vertical (negative means devers)
vector ttv_climbHandOffset		// distance from kong's pos to ledgeWP (ex: v_climb_hand_offset)
vector ttv_wallOffset		// offset to add to kong's position because of wall incline (ex: v_climb_wall_offset)
vector ttv_wallBanking	// banking used by rotx


			// SAUT MANUEL ==================================================================================================================

			// Sauter dans le sens de la pente
			// DANGER : quadn Kong est en pente descendante cela fait un saut super tendu c'est trop moche
//			tv_temp = MATH_VecCrossProduct(v_jump_offset, v_last_banking)
//			tv_temp = MATH_VecCrossProduct(v_last_banking, tv_temp)
//			MATH_VecSetNormalize(tv_temp)
			// SAUT a l horizontal car le saut vers le bas et vers le haut ne rendent pas bien du tout
			tv_temp = v_jump_offset
			MATH_VecSetNormalize(tv_temp)
 

			v_climb_position = OBJ_PosGet()
			v_climb_position += tv_temp * f_jump_length
			macro_render_Vector(OBJ_PosGet(), tv_temp * f_jump_length, color_cyan)

//			if ( !MATH_VecNullEpsilon(v_jump_force_pos))
//			{
//				v_climb_position = v_jump_force_pos
//				v_climb_hand_offset = Cv_NullVector
//			}
//			else 
			if ( i_jump_force_accroch)
			{
				if ( RAY_LIB_Steph_Ray( OBJ_PosGet() + Cv_VerticalVector, tv_temp * ( f_jump_length + 6.0)))
				{
					// ON TOUCHE UN MUR ===========================================================================================================
					ti_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)
					if ( !( ti_GMAT & Gmat_KK_Accrochage_interdit))
					{
						// Accrochage autorisé
						ti_flag_compute_action_duration = vrai
		
						tv_ray_normale = COL_RayObject_NormalGet()
						v_climb_position = COL_RayObject_PosGet()
						tv_pos = v_climb_position // BAKCUP
						if (tv_ray_normale.z < Cf_Kong_Angle_Mur_sol && tv_ray_normale.z > -Cf_Kong_Angle_Mur_sol)
						{
							// c'est bien un MUR
							v_climb_normale = COL_RayObject_NormalGet()
							if ( MATH_VecNullEpsilon( v_climb_normale))
								DBG_Error("Normale nule : problème")
							// TEST DE TOP POINT AVEC SOL DERRIERE
							tv_climb_position = COL_TipTopPointGet(Cv_VerticalVector, Cf_largeur_Kong, faux, vrai, faux, vrai)
							tv_edge_normal =COL_RayObject_EdgeNormalGet()
							if( tv_edge_normal.z > Cf_Kong_Angle_Mur_sol)
								v_climb_position = tv_climb_position							// Le tiptop arrive bien sur un SOL
							
							macro_render_Vector(v_climb_position, v_climb_normale * 5.0, color_cyan)	
						
							@o_climb_target_wp OBJ_PosSet(v_climb_position)
							@o_climb_target_wp OBJ_SightGeneralSet(-v_climb_normale, Cv_VerticalVector)
							v_climb_hand_offset = @o_climb_target_wp MATH_VecLocalToGlobal(av_climb_hand_offset[6][Ci_Climb_Offset_Jump])
			
							tf_hauteur_mur = v_climb_position.z
							tf_hauteur_mur -= OBJ_PosGet().z
		
							if (tf_hauteur_mur >= Cf_Hauteur_Mini_Accroch && tf_hauteur_mur <= 12.0)
							{
								i_climb_jump_index = 6
								o_climb_0D_wp = o_climb_target_wp
							}
							else if ( tf_hauteur_mur < Cf_Hauteur_Mini_Accroch )
							{
								tv_pos = v_climb_position
							
								v_climb_position = OBJ_PosGet()
								v_climb_position += v_jump_offset * f_jump_length
								v_climb_position.z = tv_pos.z
							}
							else
							{
								v_climb_position = OBJ_PosGet()
								v_climb_position += tv_temp * f_jump_length
							}
						}
					}
				}
				v_climb_normale = -tv_temp
			}
			f_climb_impulsion_duration = 0.0


			if (o_climb_0D_wp)
			{
				ti_flag_compute_action_duration	 = vrai

				if ( f_jump_force_amplitude)
					tf_hauteur_saut = f_jump_force_amplitude
				else
					tf_hauteur_saut = 1.5
								
				macro_render_Vector(v_climb_position,  - v_climb_hand_offset, color_jaune)	
				COL_ColSetActivationSet(none, C_bit_zdm_pied)
				v_climb_impulsion_force = DYN_LIB_ImpulsionGet_Friction(OBJ_PosGet(), v_climb_position - v_climb_hand_offset, Cv_Kong_Gravity, f_jump_friction, f_climb_impulsion_duration, faux, tf_hauteur_saut)

				v_zdm_pos = cvector(0.0, 3.4, 0.0)

				// CHOIX DE L ANIM DE SAUT DANS LE CAS D UN SAUT QUI ACCROCHE UN 0D
				if (i_climb_jump_index == 6)
					ACT_ActionSet(Ci_Kanim_saute_accroche)	
				else
					ACT_ActionSet(Ci_Kanim_jump + (i_climb_jump_index * 2))
			}
			else
			{
				tv_temp = v_climb_position
				tv_temp -= OBJ_PosGet()

				// Hauteur de saut forcée
				if ( !MATH_FloatNullEpsilon(f_jump_force_hauteur))
				{
					v_climb_position += cvector( 0.0, 0.0, f_jump_force_hauteur)	// Hauteur de saut forcé vers le haut dans le cas général(mur vetical)
					v_walling_banking = Cv_NullVector
					f_jump_force_hauteur = 0.0
				}
				if ( f_jump_force_amplitude)
					tf_hauteur_saut = f_jump_force_amplitude
				else
					tf_hauteur_saut = 1.5
				if ( o_jump_hotspot && o_jump_hotspot.des_int1 &  HOTSPOT_Type_Fight)
				{
					v_climb_position = @o_jump_hotspot OBJ_PosGet()	// Saut précis qui passe PAR le HS
					tf_hauteur_saut = 0.0
				}

				if ( i_jump_force_keep_Z_speed)		// Saut a conservation de la vitesse Z
				{
					v_climb_impulsion_force = DYN_LIB_Impulsion_Dir_Friction(OBJ_PosGet(), v_climb_position - v_climb_hand_offset,  Cv_Kong_Gravity, f_jump_friction, f_climb_impulsion_duration, faux, MATH_VecNormalize( DYN_SpeedGetVector()), 10)
					macro_render_Vector(OBJ_PosGet() + v_climb_impulsion_force, - v_climb_impulsion_force, color_blanc)
//					f_climb_impulsion_duration = DYN_LIB_Time_To_Reach_Z(DYN_SpeedGetVector(), Cv_Kong_Gravity, tv_temp.z, faux)
//					if ( f_climb_impulsion_duration < 0.2)
//						f_climb_impulsion_duration  = 0.0
				}
				else
//				{
					f_climb_impulsion_duration  = 0.0	
					v_climb_impulsion_force = DYN_LIB_ImpulsionGet_Friction(OBJ_PosGet(), v_climb_position, Cv_Kong_Gravity, f_jump_friction, f_climb_impulsion_duration, faux, tf_hauteur_saut)
					macro_render_Vector(OBJ_PosGet() + v_climb_impulsion_force, - v_climb_impulsion_force, color_blanc)
//				}


				// CHOIX DE L ANIM DE SAUT DANS LE CAS D UN SAUT SANS RIEN A ACCROCHER
				if ( i_jump_force_anim_cycl)
				{
					ACT_ActionSet( i_jump_force_anim_cycl)
					i_jump_force_anim_cycl = 0
				}
				else
				{
					if ( i_jump_to_frappe)
						ACT_ActionSet(Ci_Kanim_coup_bas_cycl)
					else if ( i_jump_to_grab)
						ACT_ActionSet(Ci_Kanim_saute_cycl)
					else
						ACT_ActionSet(Ci_Kanim_saute_cycl)
				}
			}

			if (ti_flag_compute_action_duration)
			{
				tf_coef = ACT_DurationGet(ACT_ActionGet(), 0)
				tf_coef /= f_climb_impulsion_duration - 0.05
				tf_coef *= ANI_FrequencyGet(0)
				
				ti_freq = MATH_FloatLimit( tf_coef, 1, 254)
				ANI_FrequencySet(0, ti_freq)
			}

			f_climb_impulsion_coef = MATH_VecNorm(v_climb_impulsion_force)
			v_climb_impulsion_dir = v_climb_impulsion_force / f_climb_impulsion_coef
			
			f_climb_impulsion_coef /= MATH_FloatBlend(Cf_impulsion_max_X, Cf_impulsion_max_Z, MATH_FloatMax(MATH_VecDotProduct(v_climb_impulsion_dir, Cv_VerticalVector), 0.0))
			f_climb_impulsion_coef *= 0.7

			i_flag_climb_impulsion_done = vrai
			f_climb_impulsion_time = TIME_Get()
		
			DYN_TractionSet(Cv_NullVector)
			DYN_StreamSet(Cv_NullVector)
			DYN_FrictionVectorSet(cvector(f_jump_friction, f_jump_friction, 0.0))
			DYN_GravitySet(Cv_Kong_Gravity)
			DYN_SpeedSetVector(v_climb_impulsion_force)

//			macro_render_Vector(OBJ_PosGet(), v_climb_impulsion_force, color_jaune)