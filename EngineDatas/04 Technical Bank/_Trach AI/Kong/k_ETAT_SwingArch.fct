#include	"k_define.var"

int			ti_freq 
int			ti_child_nb 
int			ti_int
int			ti_int1

float        tf_dot
float		tf_norm_speed
float		tf_angle
float		tf_cos_angle

vector	tv_force_T 
vector	tv_force_TT
vector	tv_force_G
vector	tv_sens_detect_hotspot

vector	tv_pos
vector	tv_pos_old 
vector	tv_pos_HS 

vector	tv_speed_cumul
vector	tv_main
vector	tv_main_apres 

object	to_main_D
object	to_main_G
object	to_bone

int			ti_action_finished
int			ti_can_jump
int			ti_can_memo_jump
int			ti_can_control_sight


vector	tv_swingDirCur
vector	tv_swingDirTgt

#define Ci_FrameAtHalfTurnStart	15
#define Cf_SwingDirBlendSpeed		5.0		// the speed at which kong's sight gets blended with the exit direction (the wp's sight or -sight)


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	COL_ColSetActivationSet(C_bit_zdm_pied, none)	
	DYN_GravitySet(Cv_Kong_Gravity)
	COL_GeoColMapPosSet( 0, cvector( 0.0, 0.0, 2.8))
	OBJ_HierarchyReset()
	OBJ_CapaSet( Capa_Swing_Detect_StartEnd, none)			// Kong décroche
	o_jump_hotspot = nobody
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Kong_swing_arch) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Kong_swing_arch

	i_flag_just_jump_swing = faux
	
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_saut_swing_arch
	@get_global v_kong_camera_vector =  v_climb_normale
	// GRAB CLIENT ACCEPT
	ai_SRV_ENABLE[Ci_LNK_KKFINISH_ON_KONG] = faux

	COL_ColSetActivationSet(none, C_bit_zdm_pied)
	OBJ_CapaSet( Capa_Swing_Detect_StartEnd, none)			// Kong accroche
	
	DYN_GravitySet(Cv_NullVector)	
	DYN_TractionSet(Cv_NullVector)
	DYN_StreamSet(Cv_NullVector)
	
	// Debuter directement a DT
	ACT_ActionSet(Ci_Kanim_Swing_Hor_Balance)
	
	COL_GeoColMapPosSet( 0, cvector( 0.0, 0.0, -1.0))
	o_swing_reference_sol = @o_jump_hotspot OBJ_HierarchyGet()
	OBJ_HierarchySet( o_jump_hotspot)

	v_swing_sight =  @o_jump_hotspot OBJ_SightGet() * MATH_FloatSign( MATH_VecDotProduct(  @o_jump_hotspot OBJ_SightGet(), OBJ_SightGet()))
	v_swing_kong_sight = OBJ_SightGet()
	
	Proc_KK_Rumble_Fort()
	LIBGFX_ShakeCam( 0.05, 35.0, 0.0, 0.0, 0.15, 0.99)	// Rumble Cam
	SND_RequestPlay(Ci_KSound_Accroche)	
	f_time_start_etat = 0.0
	f_time_start_blend = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
	f_time_start_blend += TIME_GetDt()
}


// ANALYSE ======================================================================
AI_Execute("k_exec_detect_paf")
if ( o_paf_actor)
{
	PAF_Test_ChangeEtatValid(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}
 
AI_Execute("k_exec_joy")
					

// COMPORTEMENT ================================================================


// -----------------------------------
// Gestion des FLAGS
// -----------------------------------

if (ACT_ActionFinished())
	ti_action_finished = vrai
else
	ti_action_finished = faux

ti_can_jump = faux
ti_can_memo_jump = faux
ti_can_control_sight = faux

tf_dot = MATH_VecDotProduct(OBJ_SightGet(),@o_jump_hotspot OBJ_SightGet())
ti_int1 = o_jump_hotspot.des_int1
if ( ( tf_dot > 0 && (! (ti_int1 & HOTSPOT_Type_NonVertInterdit)) ) || ( tf_dot <= 0 && (! ( ti_int1 & HOTSPOT_Type_VertInterdit)) ) )
{
    switch (ACT_ActionGet())
    {
        case Ci_Kanim_Swing_Hor_Balance_DemiT :
			if (ANI_CurrentFrameGet(0)< Ci_FrameAtHalfTurnStart)
			{
				ti_can_jump = vrai
				ti_can_memo_jump = vrai
			}
			if ( ti_int1 & HOTSPOT_Type_Arch1Shot)
			i_flag_just_jump_swing = vrai
            break
   
        case Ci_Kanim_Swing_Hor_Balance :
            if (ti_action_finished)
            {
				ti_can_jump = vrai
				if ( ti_int1 & HOTSPOT_Type_Arch1Shot)
					i_flag_just_jump_swing = vrai
	        }
            ti_can_memo_jump = vrai
            ti_can_control_sight = vrai
    }
}

// -----------------------------------
// Gestion du SAUT
// -----------------------------------

// Memorisation du Flag de Saut !
if ( ti_can_memo_jump &&( i_flag_just_Action || i_flag_just_Rage_Any_Button))
{
	i_flag_just_jump_swing = vrai					
}


// Saut ?
if (ti_can_jump && i_flag_just_jump_swing)
{
	// Saut demandé au JOY
	tv_sens_detect_hotspot = WALLING_GetAnotherWall( OBJ_PosGet(), v_swing_sight * 20.0, faux)
	if ( !MATH_VecNullEpsilon( tv_sens_detect_hotspot))				
	{
		i_jump_without_attack = vrai	// Saut précis : interdit le coup
		v_jump_force_sens = tv_sens_detect_hotspot - OBJ_PosGet()
		v_jump_force_pos = tv_sens_detect_hotspot - cvector( 0.0, 0.0, 3.45)
		f_jump_force_distance = MATH_VecNorm( v_jump_force_sens) // Distance
		v_jump_force_sens /= f_jump_force_distance
		f_jump_force_distance -= 5.0
		i_jump_force_keep_Z_speed = vrai
		i_jump_to_frappe = faux
		i_jump_to_grab = faux
	}
	else
	{
		i_jump_force_keep_Z_speed = vrai										// Conserver la Vitesse en Z
		f_jump_force_distance = 8.0												// Distance Saut
	}
		f_time_collide_ground = 0.0 												// Forcer un saut
		i_jump_force_no_impulsion = vrai										// On ne desire pas une anim d impulsion
		i_jump_force_anim_cycl = 56
		i_jump_check_hotspot = vrai												// On peux enchainer les HOT SPOT
		i_jump_check_hotspot_fight = vrai										// On peux enchainer sur un ennemi
		i_jump_force_accroch = vrai												// On peux essayer d accrocher le mur

		tv_swingDirTgt = MATH_VecBlendRotate(v_swing_sight, Cv_VerticalVector, 0.45)
		DYN_SpeedSetVector( tv_swingDirTgt )

	DBG_RenderVector(OBJ_PosGet(),tv_swingDirTgt,color_cyan)
	macro_change_etat("k_ETAT_jump")		
}

// ----------------------------------------
// Gestion des ANIMATIONS
// ----------------------------------------
if (ti_action_finished)
{
	if (ACT_ActionGet() == Ci_Kanim_Swing_Hor_Balance_DemiT)
	{
		ACT_ActionSet(Ci_Kanim_Swing_Hor_Balance)
		v_swing_sight =  @o_jump_hotspot OBJ_SightGet() * MATH_FloatSign( MATH_VecDotProduct(  @o_jump_hotspot OBJ_SightGet(), OBJ_SightGet()))
		v_swing_kong_sight = OBJ_SightGet()
		i_frappe_target_nb = 0		// On peux refrapper le meme acteur en partant dans l autre sens.
		f_time_start_blend = 0.0
	}
	else
		ACT_ActionSet(Ci_Kanim_Swing_Hor_Balance_DemiT)
}


// COLLISON ZDE ZDE PENDANT LE SWING
	to_main_D = ANI_CanalObjectGet(Anim_Canal_PiedDroit)
	to_main_G = ANI_CanalObjectGet(Anim_Canal_PiedGauche)
	COL_ZonePosSet( C_zde_fight, MATH_VecGlobalToLocal( (( @to_main_D OBJ_PosGet() + @to_main_G OBJ_PosGet()) * 0.5) - OBJ_PosGet()))
	COL_ZoneSizeSet( C_zde_fight, cvector( 3.0, 3.0, 3.0))
	AI_Execute( "k_exec_zdf_zdc")
	COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 2.0))
	COL_ZoneSizeSet( C_zde_fight, Cf_ZDE_SizeFight)

// -----------------------------------------------------------------------------------------------------------------------------
// Orientation pendant le Swing dans l'axe du joy limité dans le cone du sight du HotSpot
// -----------------------------------------------------------------------------------------------------------------------------
to_main_G = o_bras[Ci_kong_bras_gauche][0]

// Position du point d accroche
tv_main = @to_main_G OBJ_PosGet()
tv_main += @to_main_G MATH_VecLocalToGlobal(Cv_KONG_Offset_Creux_MainGauche_Std)

// Orientation
tv_swingDirCur = OBJ_SightGet()		// where we are
if (ti_can_control_sight)
	tv_swingDirTgt = v_swing_sight		// where we want to be
else
	tv_swingDirTgt = tv_swingDirCur		// where we want to be (Same as where we are)
	
v_jump_force_sens  = MATH_VecBlendRotate( tv_swingDirCur, tv_swingDirTgt , Cf_SwingDirBlendSpeed * TIME_GetDt())
OBJ_Rotate_FromTo( MATH_VecGlobalToLocal(tv_swingDirCur), MATH_VecGlobalToLocal( v_jump_force_sens ))

if ( f_time_start_etat < 1.5)
	OBJ_BankingGeneralSet( OBJ_SightGet(),  MATH_VecBlendRotate( OBJ_BankingGet(), @o_jump_hotspot OBJ_BankingGet(), 6.0 * TIME_GetDt() ))
else
	OBJ_BankingGeneralSet( OBJ_SightGet(),  MATH_VecBlendRotate( OBJ_BankingGet(), Cv_VerticalVector, 6.0 * TIME_GetDt() ))

// Position du point d accroche
tv_main_apres = @to_main_G OBJ_PosGet()
tv_main_apres += @to_main_G MATH_VecLocalToGlobal(Cv_KONG_Offset_Creux_MainGauche_Std)

// Positionement de Kong pour que le point d accroche soit conservé
OBJ_PosSet( OBJ_PosGet() + (tv_main - tv_main_apres))
// -----------------------------------------------------------------------------------------------------------------------------