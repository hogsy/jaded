#include"k_define.var"

int			ti_loop
int			ti_look_do_sight_ennemi
int			ti_lookZ_Head
int			ti_look_limit
int			ti_test

float		tf_look_speed
float		tf_look_angle
float		tf_look_last_angleH_single
float		tf_orig_look_angle 

object	to_look_actor
object	to_brasD
object	to_brasG
object	to_tete

vector	tv_look_direction_backup
vector	tv_ennemi_axis
vector	tv_headaxis
vector	tv_axis1
vector	tv_axis2
vector	tv_temp

if ( ! i_DBG_TETE_ON )
	return

// Angle axe de regard & visée du perso ====================================
tv_look_direction_backup = v_look_direction

to_tete = ANI_CanalObjectGet(Anim_Canal_Tete)


//if( ! @get_global i_Player_is_Kong )
//{
//	if( @get_global i_Player_on_KK_Shoulder )
//	{
//		// INDY SUR L'EPAULE		
//	//	v_look_position = @o_Joueur OBJ_PosGet() 
//	//	v_look_position -= 1.0 * @o_Joueur OBJ_HorizonGet()
//	//	v_look_position += Cv_VerticalVector
//	//	v_look_direction = v_look_position - @to_tete OBJ_PosGet()
//
//	//	v_look_direction = OBJ_SightGet()
//		v_look_direction = MATH_VecCrossProduct(OBJ_HorizonGet(), v_last_banking)
//	//	v_look_direction = OBJ_SightGet()
//	//	v_look_direction.z = -2.0
//		MATH_VecSetNormalize(v_look_direction)
//		v_look_position = OBJ_PosGet() + (v_look_direction * 20)
//		f_look_angleH = 0.0
//		f_look_angleH_blend = 0.0
//		goto DEBUT_IK
//	}
//	else
//	{
//		// INDY AU SOL
//		if( ! o_fight_actor )
//		{
//			v_look_position = @o_Joueur OBJ_PosGet()
//			v_look_direction = v_look_position - @to_tete OBJ_PosGet()
//			f_look_angleH = 0.0
//			f_look_angleH_blend = 0.0
//			goto DEBUT_IK
//		}
//	}
//}


// Vitesse de rotation par defaut
tf_look_speed = 5.0
to_look_actor = nobody

v_look_position = Cv_NullVector 													// Je regarde rien

ti_lookZ_Head = faux
ti_look_limit = faux
// INFOS DEBUG ====================================================
#ifndef _FINAL_
if( @"univ" i_cheat_page == 2 )
	Str_DisplayTextOnce("\cff00\Je regarde :", cvector(0,0.65,0))	
#endif
	
if( OBJ_CapaTest(Capa_Force_Regard_Sight) )
{
	// Force le regarde dans le Sight.
	#ifndef _FINAL_
	if( @"univ" i_cheat_page == 2 )
		Str_DisplayTextOnce(" sight forcé par capa", cvector(0,0.7,0))	
	#endif

	OBJ_CapaSet(none, Capa_Force_Regard_Sight)
	v_look_direction = OBJ_SightGet()
	v_look_position = OBJ_PosGet() + (10.0 * v_look_direction)
	ti_lookZ_Head = vrai
}
else if( ! @get_global i_Player_is_Kong 
		&& ! @get_global i_Player_on_KK_Shoulder 
		&& ! o_fight_actor )
{
	// INDY au sol
	to_look_actor = o_Joueur
	goto LOOK_ACTOR
}
else if( ! ACT_CustomBitTest(0b00000100) || ! i_look_enable )
{
	// L'anim n'autorise pas le controle de la tete donc on regarde le Sight.
	#ifndef _FINAL_
	if( @"univ" i_cheat_page == 2 )
		Str_DisplayTextOnce(" \cff\ INTERDIT", cvector(0,0.7,0))	
	#endif

		v_look_direction = OBJ_SightGet()
	ti_lookZ_Head = vrai
}
else
{
	if ( ! TIME_Elapsed(f_look_ennemi_time, 0.5) )
	{
		// Delay avant de regarder a nouveau l'ennemi
		ti_look_do_sight_ennemi = faux
		ti_lookZ_Head = vrai
	}
	else if (o_fight_actor && !i_joy_flag_dash)
	{
		ti_look_limit = vrai

		// J'ai un fight actor
		ti_look_do_sight_ennemi = vrai
		tv_ennemi_axis = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
		v_look_position = @o_fight_actor OBJ_PosGet()				// Je regarde là
		if ( MATH_VecNullEpsilon( tv_ennemi_axis))
			tv_ennemi_axis = OBJ_SightGet()
		MATH_VecSetNorm(tv_ennemi_axis, 1.0)
		
		if (ACT_ActionGet() == Ci_Kanim_Attente || (ACT_ActionIsTransition() && ACT_ActionGetTransition() == Ci_Kanim_Attente))
			ti_test = faux
		else
			ti_test = vrai
		
		if ( ti_test && MATH_VecDotProduct(OBJ_SightGet(), tv_ennemi_axis) < -Cf_Cos45) //70)
		{
			// Je suis orienté a l'opposé de l'ennemi, apres n seconde je le regarde plus.
			if ( f_joy_norm )
			{
				if (TIME_Elapsed(f_look_ennemi_not_time, 0.25) )
					ti_look_do_sight_ennemi = faux
				else
					ti_look_do_sight_ennemi = vrai
			}
			else
				ti_look_do_sight_ennemi = i_look_do_sight_ennemi_old
		}
		else
		{
			// Je suis dans le reste du camenbert et je regarde l'ennemi
			ti_look_do_sight_ennemi = vrai
			f_look_ennemi_not_time = TIME_Get()
		}
	}
	else
	{
		// Je ne suis pas en fight donc je regarde pas l'ennemi mais devant moi.
		ti_look_do_sight_ennemi = faux
	}
		
	// Si je passe de target a non target, je reset la vitesse de rotation (acceleration)
	if (	ti_look_do_sight_ennemi != i_look_do_sight_ennemi_old)
		f_look_angleH_blend = 0
	i_look_do_sight_ennemi_old = ti_look_do_sight_ennemi
	if (to_look_actor)
	{
		// JE REGARDE DANS L'AXE D'UN ACTEUR QQONQUE
		LOOK_ACTOR:
		
//		v_look_position = @to_look_actor OBJ_PosGet()
////		v_look_direction = MATH_VecNormalize(@to_look_actor OBJ_PosGet() - OBJ_PosGet())
//		tv_temp = @to_look_actor OBJ_PosGet() - OBJ_PosGet()
//		if( ! MATH_VecNullToler(tv_temp, 0.1) )
//			v_look_direction = MATH_VecNormalize(tv_temp)
//		else
//			v_look_direction = OBJ_SightGet()
//		if (MATH_VecDotProduct(OBJ_HorizonGet(),v_look_direction)>0)
//			v_look_direction = OBJ_SightGet()
//		v_look_direction = MATH_VecBlend(v_look_direction, OBJ_SightGet(), 0.5)
//
//		f_look_coef_cul = MATH_FloatBlend(f_look_coef_cul, 2.0, 5.0*TIME_GetDt())
//		tf_look_speed = 4
//		ti_look_limit = vrai

		// VINC --------------------------------------
		ti_lookZ_Head = vrai	
		tv_temp = @to_look_actor OBJ_PosGet() - OBJ_PosGet()
		if( ! MATH_VecNullToler(tv_temp, 0.1) )
			v_look_direction = MATH_VecNormalize(tv_temp)
		else
			v_look_direction = OBJ_SightGet()
		v_look_position = @to_look_actor OBJ_PosGet()
		if (f_joy_norm)
			f_look_coef_cul = MATH_FloatBlend(f_look_coef_cul, 2.0, 5.0*TIME_GetDt())
		tf_look_speed = 8.0
		ti_look_limit = vrai
		// VINC --------------------------------------
		
		#ifndef _FINAL_
		if( @"univ" i_cheat_page == 2 )
			Str_DisplayGaoOnce(to_look_actor, cvector(0,0.7,0))
		#endif
	}
	else if ( ti_look_do_sight_ennemi )
	{
		// JE REGARDE DANS l'AXE DE MON FIGHT ACTOR
//		v_look_direction = MATH_VecNormalize(@o_fight_actor OBJ_PosGet() - OBJ_PosGet()
		tv_temp = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
		if( ! MATH_VecNullToler(tv_temp, 0.1) )
			v_look_direction = MATH_VecNormalize(tv_temp)
		else
			v_look_direction = OBJ_SightGet()
		v_look_position = @o_fight_actor OBJ_PosGet()
		if (f_joy_norm)
			f_look_coef_cul = MATH_FloatBlend(f_look_coef_cul, 2.0, 5.0*TIME_GetDt())
		tf_look_speed = 8.0
		ti_look_limit = vrai
		#ifndef _FINAL_
		if( @"univ" i_cheat_page == 2 )
			Str_DisplayGaoOnce(o_fight_actor, cvector(0,0.7,0))
		#endif
	}
	else
	{
		if (f_joy_norm)
		{
			// JE REGARDE DANS L'AXE DU JOY
			v_look_direction = glob_joyvector_get_normalized
			ti_lookZ_Head = vrai
			f_look_coef_cul = MATH_FloatBlend(f_look_coef_cul, 0.0, 5.0*TIME_GetDt())
			ti_look_limit = vrai
			#ifndef _FINAL_
			if( @"univ" i_cheat_page == 2 )
				Str_DisplayTextOnce("le Joy", cvector(0,0.7,0))
			#endif
		}
		else if (i_joy_flag_dash)
		{
			// JE REGARDE DANS L'AXE DU SIGHT (DASH)
			v_look_direction = OBJ_SightGet()
			ti_lookZ_Head = vrai
			f_look_coef_cul = MATH_FloatBlend(f_look_coef_cul, 0.0, 5.0*TIME_GetDt())
			#ifndef _FINAL_
			if( @"univ" i_cheat_page == 2 )
				Str_DisplayTextOnce("le sight( charge)", cvector(0,0.7,0))
			#endif
		}
		else
		{
			// JE REGARDE DANS L'AXE PRECEDANT
			v_look_direction = MATH_VecInCone(v_look_direction, OBJ_SightGet(),Cf_1Degre* 80, 0)
			#ifndef _FINAL_
			if( @"univ" i_cheat_page == 2 )
				Str_DisplayTextOnce("sans joy", cvector(0,0.7,0))
			#endif
		}
	}
}

// Angle axe de regard & visée du perso ====================================

//v_look_direction.z = 0
v_look_direction = (OBJ_SightGet() * MATH_VecDotProduct( OBJ_SightGet(), v_look_direction)) + (OBJ_HorizonGet() * MATH_VecDotProduct( v_look_direction , OBJ_HorizonGet()))


DEBUT_IK:
if ( MATH_VecNullToler(v_look_direction, 0.01) )
	v_look_direction = OBJ_SightGet()
tf_look_angle = MATH_VecAngle(OBJ_SightGet(), v_look_direction, Cv_VerticalVector)

// ON CHANGE DE COTE
if (MATH_AbsFloat(tf_look_angle) > (Cf_1Degre*120) && (MATH_FloatSign(f_look_angle_old) != MATH_FloatSign(tf_look_angle)) )
{
	// On passe de deux angles opposé donc on cree une acceleration
	f_look_angleH_blend = 0
	f_look_ennemi_time = TIME_Get()
}
                                                                                  
tv_headaxis = (OBJ_SightGet() * MATH_VecDotProduct( OBJ_SightGet(), @o_tete[0] OBJ_BankingGet())) + (OBJ_HorizonGet() * MATH_VecDotProduct( @o_tete[0] OBJ_BankingGet(), OBJ_HorizonGet()))
tf_orig_look_angle = MATH_VecAngle(OBJ_SightGet(), tv_headaxis, OBJ_BankingGet() )
//tf_orig_look_angle = MATH_VecAngle(tv_axis1, tv_axis2, Cv_VerticalVector )

//Str_DisplayFloatOnce( tf_orig_look_angle, cvector(0,0.8,0) )
//Str_DisplayFloatOnce( tf_look_angle, cvector(0.1,0.8,0) )

// FRED STUFF
if ( ti_look_limit && MATH_FloatSign(tf_orig_look_angle) == MATH_FloatSign(tf_look_angle) )
	tf_look_angle -= tf_orig_look_angle

f_look_angle_old = tf_look_angle

// Blend et Blend2Blend sur les angles
f_look_angleH_blend  = MATH_FloatBlend(f_look_angleH_blend, tf_look_speed, 5.0 * TIME_GetDt())
f_look_angleH = MATH_FloatBlend(f_look_angleH, tf_look_angle, f_look_angleH_blend * TIME_GetDt())
tf_look_last_angleH_single = f_look_angleH / (4.0 + f_look_coef_cul)

//Str_DisplayFloatOnce( f_look_angleH, cvector(0,0.85,0) )

// Rotations
for (ti_loop = 0; ti_loop< 4 ; ti_loop++)
	@o_tete[ti_loop] OBJ_RotateGlobalZ(tf_look_last_angleH_single)
@o_tete[4] OBJ_RotateGlobalZ(tf_look_last_angleH_single * f_look_coef_cul)

@o_tete[0] OBJ_RotateLocalZ(tf_look_last_angleH_single * 0.8)

if (ti_lookZ_Head)
	tv_look_direction_backup = @o_tete[0] OBJ_BankingGet()

tf_look_angle = MATH_VecAngle(@o_tete[0] OBJ_BankingGet(), tv_look_direction_backup, @o_tete[0] OBJ_HorizonGet())
f_look_angleV = MATH_FloatBlend(f_look_angleV, tf_look_angle, f_look_angleH_blend * TIME_GetDt())

@o_tete[0] OBJ_RotateLocalX(f_look_angleV*0.6)
@o_tete[1] OBJ_RotateLocalX(f_look_angleV*0.2)

if (o_look_cine)
{
	vector tv_axis 
	tv_axis = @o_look_cine OBJ_PosGet() - @o_tete[0] OBJ_PosGet()
	@o_tete[0] OBJ_BankingSet(tv_axis)
	o_look_cine = nobody
}

to_brasD = ANI_CanalObjectGet(Anim_Canal_BrasDroit)
to_brasG = ANI_CanalObjectGet(Anim_Canal_BrasGauche)

@to_brasD OBJ_PosSet( @to_brasD OBJ_PosGet() + (@to_brasD OBJ_HorizonGet() * MATH_FloatMin(0,tf_look_last_angleH_single*2.0)) )
@to_brasG OBJ_PosSet ( @to_brasG OBJ_PosGet() + (@to_brasG OBJ_HorizonGet() * MATH_FloatMax(0,tf_look_last_angleH_single*2.0)) )

//v_look_sens_epaule = -@o_tete[0] OBJ_HorizonGet()
v_look_sens_epaule = @to_brasD OBJ_PosGet() - @to_brasG OBJ_PosGet()
v_pos_centre_epaules = @to_brasG OBJ_PosGet() + (v_look_sens_epaule / 2)
MATH_VecSetHorzNormalize(v_look_sens_epaule)

if ( MATH_VecNull(v_look_position) )
	v_look_position = OBJ_PosGet() + (v_look_direction * 20)
	
//DBG_RenderSphere(v_look_position, 1, color_rouge)

// BACKUP POS TETE (POUR LES PAFS)
v_head_pos = @o_tete[0] OBJ_PosGet()
//DBG_RenderVector(v_head_pos - (2 * OBJ_BankingGet()), OBJ_BankingGet() * 4, color_bleu)
//DBG_RenderVector(v_head_pos - (2 * OBJ_HorizonGet()), OBJ_HorizonGet() * 4, color_rouge)
//DBG_RenderVector(v_head_pos - (2 * OBJ_SightGet()), OBJ_SightGet() * 4, color_vert)


DBG_RenderVector(@to_tete OBJ_PosGet(), Proc_KK_LookDirectionGet() * 5, color_cyan)

