#include"k_define.var"

int			ti_i
int			ti_nb_link

float		tf_speed
float		tf_dot_product
float		tf_norm
float		tf_joy_norm
float		tf_hand_dist
float		tf_ponderation
float		tf_best_ponderation
float		tf_best_link_length
float		tf_X
float		tf_Y

vector	tv_joy_dir
vector	tv_pos
vector	tv_new_sight
vector	tv_current_to_next_wp
vector	tv_best_link_axis
vector	tv_plan_normale
vector	tv_last_climb_position

object	to_bassin
object	to_collide_object
object	to_hand
object	to_next_wp
object	to_best_next_wp

#define	Cf_tolerance								4.0
#define	Cf_climb_1D_speed						8.0


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

	v_zdm_pos = Cv_Kong_zdm_pos
	DYN_GravitySet(Cv_Kong_Gravity)

	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_commun_climb_1D) 
{
	i_etat_courant = ETAT_commun_climb_1D

	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_grab_grimpe
	// CAMERA -----------------------------------------------------------------

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	ACT_ActionSet(Ci_Kanim_climb_accroche)
	DYN_GravitySet(Cv_NullVector)	
	v_zdm_pos = cvector(0.0, 3.4, 0.0)

	i_inertia_allowed = vrai
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ======================================t================================
AI_Execute("k_exec_joy")
n_climb_1D =  @o_climb_1D_current_wp WAY_NetOfObj()

//if (! i_flag_grab || WAY_LinkCapaGet(n_climb_1D, o_climb_1D_current_wp, o_climb_1D_next_wp) & Capa_prise_HS)
if (WAY_LinkCapaGet(n_climb_1D, o_climb_1D_current_wp, o_climb_1D_next_wp) & Capa_prise_HS)
{
	o_climb_1D_last_current_wp = nobody
	o_climb_1D_last_next_wp	= nobody
	macro_change_etat("k_ETAT_commun_climb_slide")
}

if (i_flag_just_jump)
	macro_change_etat("k_ETAT_commun_climb_impulsion")

o_climb_1D_last_current_wp = o_climb_1D_current_wp
o_climb_1D_last_next_wp = o_climb_1D_next_wp

// COMPORTEMENT ================================================================
tv_last_climb_position = v_climb_position

AI_Execute("k_exec_climb_ray")

v_climb_normale = MATH_VecBlendRotate(- @o_climb_1D_current_wp OBJ_SightGet(), - @o_climb_1D_next_wp OBJ_SightGet(), f_climb_1D_axis_dist / f_climb_1D_axis_length)
v_climb_speed = Cv_NullVector

if (ACT_ActionGet() == Ci_Kanim_climb_accroche)
{
//	i_flag_climb_IK[Ci_IK_main_gauche] = vrai
//	v_IK_dest_pos[Ci_IK_main_gauche] = v_climb_position
//	v_IK_dest_pos[Ci_IK_main_gauche] -= OBJ_SightGet() * 0.5
//	v_IK_dest_pos[Ci_IK_main_gauche] += OBJ_HorizonGet() * 0.5
//	
//	i_flag_climb_IK[Ci_IK_main_droite] = vrai
//	v_IK_dest_pos[Ci_IK_main_droite] = v_climb_position
//	v_IK_dest_pos[Ci_IK_main_droite] -= OBJ_SightGet() * 0.5
//	v_IK_dest_pos[Ci_IK_main_droite] -= OBJ_HorizonGet() * 0.5
		
	if (ACT_ActionFinished())
		ACT_ActionSet(Ci_Kanim_climb_attente)
}
else if (@get_global f_joy_norm && f_time_start_etat > 0.3)
{
	tv_joy_dir = @get_global v_joy_camera_normalized_Z
	tv_plan_normale = MATH_VecCrossProduct(tv_joy_dir, v_climb_normale)
	tv_joy_dir = MATH_VecCrossProduct(v_climb_normale, tv_plan_normale)
	MATH_VecSetNormalize(tv_joy_dir)

	tf_best_ponderation	= Cf_Infinit

	if (f_climb_1D_axis_dist < Cf_tolerance)
	{
		DBG_RenderSphere(@o_climb_1D_current_wp OBJ_PosGet(), Cf_tolerance, 0x800000FF)
	
		ti_nb_link = WAY_GetNumLinks(n_climb_1D, o_climb_1D_current_wp)

		for (ti_i = 0; ti_i <	ti_nb_link; ti_i++)
		{
			to_next_wp = 	WAY_NetNextWP(n_climb_1D, o_climb_1D_current_wp, 6, ti_i)
			
			tf_norm = WAY_LinkWeightGet(n_climb_1D, o_climb_1D_current_wp, to_next_wp)
	
			tv_current_to_next_wp = @to_next_wp OBJ_PosGet() - @o_climb_1D_current_wp OBJ_PosGet()
			tv_current_to_next_wp /= tf_norm
			
			tf_dot_product = MATH_VecDotProduct(tv_joy_dir, tv_current_to_next_wp)	
	
			tf_ponderation = - tf_dot_product
	
			if (o_climb_1D_next_wp == nobody || tf_ponderation < tf_best_ponderation)
			{
				tf_best_ponderation = tf_ponderation

				to_best_next_wp = to_next_wp
				tf_best_link_length = tf_norm
				tv_best_link_axis = tv_current_to_next_wp
			}
		}
	}
	else
	{
		to_best_next_wp = o_climb_1D_next_wp
		tv_best_link_axis = v_climb_1D_axis
	}

	// BON ON A LE MEILLEUR AXE DE DEPLACEMENT
	if (to_best_next_wp != o_climb_1D_next_wp)
	{
		// CHOIX DE L'ANIM		
		tf_X = MATH_VecDotProduct(-v_climb_1D_axis, OBJ_HorizonGet())
		tf_Y = MATH_VecDotProduct(-v_climb_1D_axis, Cv_VerticalVector)

		if (MATH_AbsFloat(tf_X) > MATH_AbsFloat(tf_Y))
		{
			if (tf_X > 0.0)
				ACT_ActionSet(Ci_Kanim_climb_left)
			else
				ACT_ActionSet(Ci_Kanim_climb_right)
		}
		else
		{
			if (tf_Y > 0.0)
				ACT_ActionSet(Ci_Kanim_climb_up)
			else
				ACT_ActionSet(Ci_Kanim_climb_down)
		}
		
		tf_speed = DYN_SpeedGet() // * MATH_AbsFloat(tf_dot_product)

		f_climb_1D_axis_dist -= TIME_GetDt() * tf_speed
		if (f_climb_1D_axis_dist < 0.0)
		{
			// ON CHANGE DE LIEN
			f_climb_1D_axis_dist *= -1.0
			o_climb_1D_next_wp = to_best_next_wp
			f_climb_1D_axis_length = tf_best_link_length
			v_climb_1D_axis = tv_best_link_axis
		}
	}
	else
	{
		tf_dot_product = MATH_VecDotProduct(tv_joy_dir, v_climb_1D_axis)
		
		if (MATH_AbsFloat(tf_dot_product) > Cf_Cos60)
		{
			if (tf_dot_product > 0.0)
			{
				// CHOIX DE L'ANIM		
				tf_X = MATH_VecDotProduct(tv_best_link_axis, OBJ_HorizonGet())
				tf_Y = MATH_VecDotProduct(tv_best_link_axis, Cv_VerticalVector)
		
				if (MATH_AbsFloat(tf_X) > MATH_AbsFloat(tf_Y))
				{
					if (tf_X > 0.0)
						ACT_ActionSet(Ci_Kanim_climb_left)
					else
						ACT_ActionSet(Ci_Kanim_climb_right)
				}
				else
				{
					if (tf_Y > 0.0)
						ACT_ActionSet(Ci_Kanim_climb_up)
					else
						ACT_ActionSet(Ci_Kanim_climb_down)
				}
			
				tf_speed = DYN_SpeedGet() // * MATH_AbsFloat(tf_dot_product)
				
				f_climb_1D_axis_dist += TIME_GetDt() * tf_speed
			}
			else if (f_climb_1D_axis_dist)
			{
				// CHOIX DE L'ANIM		
				tf_X = MATH_VecDotProduct(-tv_best_link_axis, OBJ_HorizonGet())
				tf_Y = MATH_VecDotProduct(-tv_best_link_axis, Cv_VerticalVector)
		
				if (MATH_AbsFloat(tf_X) > MATH_AbsFloat(tf_Y))
				{
					if (tf_X > 0.0)
						ACT_ActionSet(Ci_Kanim_climb_left)
					else
						ACT_ActionSet(Ci_Kanim_climb_right)
				}
				else
				{
					if (tf_Y > 0.0)
						ACT_ActionSet(Ci_Kanim_climb_up)
					else
						ACT_ActionSet(Ci_Kanim_climb_down)
				}

				tf_speed = DYN_SpeedGet() // * MATH_AbsFloat(tf_dot_product)

				f_climb_1D_axis_dist -= MATH_FloatMin(f_climb_1D_axis_dist, TIME_GetDt() * tf_speed)
			}
			else
			{
				ACT_ActionSet(Ci_Kanim_climb_attente)
			}
		}
	}

	
	// ON SE POSITIONNE TOUJOURS SUR LA PREMIERE MOITIE DU LIEN POUR QUE LE CURRENT WP SOIT LE PLUS PRES
	if (f_climb_1D_axis_dist > f_climb_1D_axis_length * 0.5)
	{
		f_climb_1D_axis_dist = f_climb_1D_axis_length - f_climb_1D_axis_dist
		
		v_climb_1D_axis	*= -1.0

		to_next_wp = o_climb_1D_current_wp
		o_climb_1D_current_wp = o_climb_1D_next_wp
		o_climb_1D_next_wp = to_next_wp
	}
}
else
{
	ACT_ActionSet(Ci_Kanim_climb_attente)
}

v_climb_position = @o_climb_1D_current_wp OBJ_PosGet()
v_climb_position += f_climb_1D_axis_dist * v_climb_1D_axis

v_climb_speed = (v_climb_position - tv_last_climb_position) / TIME_GetDt()

v_climb_normale = MATH_VecBlendRotate(- @o_climb_1D_current_wp OBJ_SightGet(), - @o_climb_1D_next_wp OBJ_SightGet(), f_climb_1D_axis_dist / f_climb_1D_axis_length)

@o_climb_target_wp OBJ_PosSet(v_climb_position)
@o_climb_target_wp OBJ_SightGeneralSet(-v_climb_normale, Cv_VerticalVector)

v_climb_hand_offset = @o_climb_target_wp MATH_VecLocalToGlobal(cvector(0.0, 0.0, 5.0))

tv_pos = v_climb_position
tv_pos -= v_climb_hand_offset

tv_pos = MATH_VecBlend(OBJ_PosGet(), tv_pos, 4.0 * TIME_GetDt())
OBJ_PosSet(tv_pos)

tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), - v_climb_normale, 6.0 * TIME_GetDt())
//OBJ_SightGeneralSet(tv_new_sight, Cv_VerticalVector)
OBJ_BankingGeneralSet(tv_new_sight, Cv_VerticalVector)

DYN_SpeedSetVector(Cv_NullVector)