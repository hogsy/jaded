#include"k_define.var"

int				ti_int
int				ti_anim
int				ti_oriente
int				ti_id
int				ti_i
int				ti_col
int				ti_flag_mur
int				ti_nbr 
int				ti_tab_wall[10]
int				ti_cote
int				ti_GMAT
int				ti_ind
float			ti_puissance
int				ti_colon_orient 
int				ti_flag_corner
int				ti_test
int				ti_colonne_attente
int				ti_test_esquive
int				ti_pose_main
int				ti_collision_nb

float			taf_sign	[10]
float			tf_dot
float			tf_rotation_speed
float			tf_z
float			pf_dot_S
float			pf_dot_H
float			tf_coef
float			tf_speed
float			tf_pente_modifier
float			tf_pente_coef
float			tf_dot_product
float			tf_normale_offset
float			tf_aide_orient
float			tf_esquive_speed_norm

vector		tv_cul_axis
vector		tv_reflex_cul_pos_new
vector		tv_axis 
vector		tv_me_to_fight_actor
vector		tv_joy_axis
vector		tv_joy_test_grimpe
vector		tv_sight
vector		tv_speed
vector		tv_normal 
vector		tv_ortho
vector		tv_bras
vector		tv_bras2
vector		tv_sens
vector		tv_sens_lance
vector		tv_temp
vector		tv_pos
vector		tv_sight_hor
vector		tv_ground_normale
vector		tv_obstacle_horizon
vector		tv_esquive_normale
vector		tv_obstacle_anim_offset
vector		tv_obstacle_pos_offset

object		to_bone
object		to_gao 
object		to_col
object		to_ride_actor
object		to_fight_actor
object		tao_zde_zde_list[20]
object		to_actor


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

	i_joy_flag_esquive = faux
	i_dash_for_walling = faux		// si interrompu...
	if( o_dash_for_walling_actor 
	&& @o_dash_for_walling_actor AI_IsModel(get_PNJ_KTREX_Path)
	&& @o_dash_for_walling_actor KT_Proc_Uncol_Check(OBJ_Me()) == -1)
	{ 
		COL_UnCollidableDel(o_dash_for_walling_actor)
		o_dash_for_walling_actor = nobody
	}
	
	if (i_jump_reception)
	{
		i_jump_reception = faux
		ACT_ForceModeSet(0) // SpeedFromActionItem
	}

	o_colonne = nobody		// Plus de colonne
	f_colonne_pos_blend = 0.0
	
	// RESET DU MODE EN COURS
	COUP_MODE_DEL()	
	KBUFFER_DEL_ALL()

	if ( i_walling_action_impulsion_before_jump)
		i_walling_action_impulsion_before_jump = 0	// nim d impulsion avant le saut
	else
		DYN_GravitySet(Cv_Kong_Gravity)		// Dans le cas de l anim de saut Imposé, on ne veux pas de gravité a l impulsion

	COL_ColSetActivationSet(C_bit_zdm_pied, none)
	
	f_kamera_cine_ann_posee_delay = 0.0
	
	return
}


// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Kong_deplacement) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Kong_deplacement

	v_reflex_cul_pos  = OBJ_PosGet() - (OBJ_SightGet() * 2)

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	// GRAB CLIENT ACCEPT
	ai_SRV_ENABLE[Ci_LNK_KKFINISH_ON_KONG] = vrai
	
	f_time_collide_ground = 0.0 // -0.2
	i_flag_just_grab = faux 								// Si on viens dans ce mode en ayant dégrabé on ne veux pas regraber directement
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}
f_global_time = TIME_Get()


// ENTER FPS ================================
if( i_etat_courant != ETAT_Kong_finished 
	&& ! o_colonne 
	&& ! @get_global i_FPS_Shoulder_force_new_entry 
	&& @get_global i_Player_on_KK_Shoulder )
{
	macro_change_etat("k_ETAT_fps")
}


// ANALYSE ============================================================================
AI_Execute("k_exec_check_obstacle")


// KAMERA (A CHAQYUE TRAME) ===========================
if( f_kamera_cine_ann_posee_delay )
	@get_Kamera Proc_Kam_FinishMode_Set(Ci_Kamera_Finish_id_PoseAnn, get_kong)
else
	@get_global i_kong_camera_status = Ci_Kcamera_deplacement 

// GRAB KONG =======================================
o_finish_actor = LNK_ServeurGet(Ci_LNK_KKFINISH_ON_KONG, mid_finish_LNK_ID, vrai, nofunc, nofunc)
if (o_finish_actor)
	macro_change_etat("k_ETAT_finished")

//MACHIN DANS LA MAIN SURVEILLER S IL COUPE PAS LA LIAISON
if ( i_GrabKong_MainActionGrab != -1 && ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
{
	i_GrabKong_Type = Ci_GrabKong_Type_Petit
    if (!MSG_GlobalIsValid(amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab]))
    		ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = nobody
    else
        ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ClientGet(Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)
    if ( !ao_CL_GRABKONG[i_GrabKong_MainActionGrab])
		i_GrabKong_MainActionGrab = -1
	else
		i_GrabKong_MainActionGrab = i_GrabKong_MainActionGrab
}

// TEST DE WALLING
if ( (i_joy_flag_dash || i_flag_trample_old || i_dash_for_walling) && WALLING_Test_Valid() )
{
	macro_change_etat("k_ETAT_walling")
}


// TEST PAF

// RAPIDE BLINDAGE A RENDRE PLUS PROPRE
switch ( i_reflex_anim)
{
	case Ci_Kanim_saute_3M :
	case Ci_Kanim_saute_5M :
	case Ci_Kanim_saute_9M :
		break
	default:
	AI_Execute("k_exec_detect_paf")
	if ( o_paf_actor)
	{
		PAF_Test_ChangeEtatValid(fct_track_change)
		if( fct_track_change != nofunc )
			macro_change_etat(fct_track_change)
	}
}

// COMPORTEMENT ===========================================================================

tf_pente_modifier = 1.0
tf_pente_coef = Cf_Kong_Angle_Mur_sol
tf_aide_orient = 1.0

ti_oriente = vrai

COL_ColSetActivationSet(C_bit_zdm_pied, none)

// On est sur une pente
if (f_time_collide_ground < 0.1 && v_last_banking.z < 0.999)
{
	tv_ground_normale = v_last_banking
	MATH_VecSetHorzNormalize(tv_ground_normale)

	if (f_joy_norm)
		tf_pente_coef = MATH_VecDotProduct(glob_joyvector_get_normalized, tv_ground_normale)
	else
		tf_pente_coef = MATH_VecDotProduct(OBJ_SightGet(), tv_ground_normale)
		
	tf_pente_modifier += tf_pente_coef * 0.15
}

if ( JUMP_Check_chute(vrai))
	macro_change_etat("k_ETAT_jump")

ti_anim = Ci_Kanim_NoAnim



// C EST PARTI

// Memo des coups dans les zones valides.
KBUFFER_All()

DYN_GravitySet(Cv_Kong_Gravity)

ti_test_esquive = faux

switch ( COUP_MODE())
{
	case C_Mode_Combo1 :
// 1ST HIT COMBO *********************************************************************************************************
		if ( ACT_ActionFinished() || ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered(C_Button_All)))
		{
			// TEST DU FINISH
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				// TO C2 : SECOND HIT COMBO
				COUP_ACTION_TEST_FINISH
				COUP_CHANGE_To_Combo2(0)
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Repulse))	
			{
				// TO T1 : REPULSE
				COUP_ACTION_TEST_RAGE
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Grab))
			{
				COUP_ACTION_TEST_GRAB
				// Si grab pas autorisé(Ann) return
				COUP_CHANGE_To_Return()
				return
			}
			else if ( KBUFFER_Buffered( C_Button_Action))
			{
				COUP_CHANGE_To_Dash()
				JUMP_HOTSPOT
				return
			}
			else
			{
				// TO NORMAL MODE ( ATT OR MOVE)
				COUP_CHANGE_To_Return()
				return
			}
		}
		else
		{
			COUP_Cancel_Mouvment( )
		}
		break		
	case C_Mode_Combo2 :
// SECOND HIT COMBO******************************************************************************************************
		if ( ACT_ActionFinished() 
		|| ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered(C_Button_Repulse)))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				// NO COMBO BUT TEST FINISH
				COUP_ACTION_TEST_FINISH
				COUP_CHANGE_To_Return()
				return
			}	
			else 
			if ( KBUFFER_Buffered( C_Button_Repulse))	
			{
				// TO T3 : SLAP 2 HANDS ON THE GROUND
				COUP_ACTION_TEST_RAGE
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Grab))
			{
				COUP_ACTION_TEST_GRAB
				// Si grab pas autorisé(Ann) return
				COUP_CHANGE_To_Return()
				return
			}
			else if (KBUFFER_Buffered( C_Button_Action))
			{
				COUP_CHANGE_To_Dash()
				JUMP_HOTSPOT
				return

			}
			else
			{
				// TO NORMAL MODE ( ATT OR MOVE)
				COUP_CHANGE_To_Return()
				return
			}
		}
		else
		{
			COUP_Cancel_Mouvment()
		}
		break
	case C_Mode_Repulse	:
// REPULSE	***********************************************************************************************************
		if ( ACT_ActionFinished() || ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered(C_Button_All)))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				if ( !i_Grab_Torse_ANN )
				{
					// TO T3 : SLAP 2 HANDS ON THE GROUND
					COUP_ACTION_TEST_FINISH
					COUP_CHANGE_To_Combo3()
				}
				else
				{
					// ANN IN THE HAND : LIMIT
					COUP_ACTION_TEST_FINISH
					COUP_CHANGE_To_Combo1(0)
				}				
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Repulse))	
			{
				if ( !i_Grab_Torse_ANN )
				{
					// TO T2 : FURY
					COUP_CHANGE_To_Fury()
				}			
				else if ( ACT_ActionFinished())
				{
					// ANN IN THE HAND : LIMIT
					COUP_END()
				}								
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Grab))
			{
				COUP_ACTION_TEST_GRAB
				// Si grab pas autorisé(Ann) return
				COUP_END()
			}
			else if (KBUFFER_Buffered( C_Button_Action))
			{
				COUP_CHANGE_To_Dash()
				JUMP_HOTSPOT
				return
			}
			else
			{
				// TO NORMAL MODE ( ATT OR MOVE)
				COUP_END()
			}
		}
		else if ( COUP_TryToHit( ))
		{
			RIDE_Clear_Link_Bat(1)
		}
		COUP_Cancel_Mouvment()
		break
	case C_Mode_Fury	:
// FURY	***********************************************************************************************************
		Proc_KK_RumbleGrowWithPower(120.0)
		if ( i_flag_just_Rage)
			f_safe_delay += 0.2							// FURY LIMIT INCREASE
		if ( ( i_flag_just_Rage && ANI_CurrentFrameGet(0) > 130)
		|| ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered(C_Button_Coup)))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				// TO T3 : SLAP 2 HANDS ON THE GROUND
				COUP_ACTION_TEST_FINISH
				COUP_CHANGE_To_Combo3( )
				return
			}
			else if ( KBUFFER_Buffered( C_Button_Grab))
			{
				COUP_ACTION_TEST_GRAB
				// Si grab pas autorisé(Ann) return
				COUP_CHANGE_To_Return()
				return
			}
			else if (KBUFFER_Buffered( C_Button_Action))
			{
				COUP_CHANGE_To_Dash()
				JUMP_HOTSPOT
				return
			}
			else
			{
				// TO NORMAL MODE RAGE SUCCEED
				RAGE_Launch( Ci_Kanim_Intimid_Furie)		
				return
			}
		}
		else 	if ( f_fury_charge_time > f_safe_delay || ACT_ActionFinished() )
		{
			// MASHING FURY CANCELLED
			
			// TO NORMAL MODE ( ATT OR MOVE)
			COUP_END()	
		}
		else
		{
			// Increase Time of fury
			f_fury_charge_time += TIME_GetDt()
			mid_fury = EVENT_AddEventFury( OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_SightGet(), f_fury_puissance, f_fury_angle, Ci_KK_Fury_Type_Intimidate)
//			DBG_RenderCone(OBJ_PosGet() + MATH_VecLocalToGlobal(Cv_KK_Fury_decalage_position) ,OBJ_SightGet() * f_fury_puissance, f_fury_angle, color_vert)
			f_fury_puissance = MATH_FloatMin( f_fury_puissance + (  (Cf_Fury_Puissance_Max / Cf_Fury_Time_Cap) * TIME_GetDt()), Cf_Fury_Puissance_Max)		
			EVENT_AddEventSound( C_EVENT_FILTER_KingKong, OBJ_Me(), Cf_EVENT_Duree_1Trame, OBJ_PosGet(), 50.0)

			COUP_Cancel_Mouvment()
		}
		break
	case C_Mode_Combo3 :
// SLAP 2 HANDS ON THE GROUND ***********************************************************************************************************
		if ( ACT_ActionFinished() 
		|| ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered(C_Button_All)))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				// TO C1 : 1ST HIT COMBO
				COUP_ACTION_TEST_FINISH
				COUP_CHANGE_To_Combo1(0)
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Repulse))	
			{
				// TO T1 : REPULSE
				COUP_ACTION_TEST_RAGE
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Grab))
			{
				COUP_ACTION_TEST_GRAB
				// Si grab pas autorisé(Ann) return
				COUP_CHANGE_To_Return()
				return
			}
			else if (KBUFFER_Buffered( C_Button_Action))
			{
				COUP_CHANGE_To_Dash()
				JUMP_HOTSPOT
				return
			}
			else
			{
				// TO NORMAL MODE ( ATT OR MOVE)
				COUP_CHANGE_To_Return()
				return
			}
		}
		else
		{
			if ( !i_frappe_impact && ANI_CurrentFrameGet(0) > 32)
			{
				i_frappe_impact = vrai
				LIBGFX_ShakeCam( 0.05, 35.0, 0.0, 0.0, 0.15, 0.99)
			}
			COUP_Cancel_Mouvment()
		}
		break
	case C_Mode_Dash_Attack :
// SHOULDER ATTACK ***********************************************************************************************************
		OBJ_CapaSet(Capa_Anim_d_Attaque, none)	// Anim d attaque( info pour le TREX)
		if ( ACT_ActionFinished())
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			COUP_END()
			i_flag_trample = faux		// Dash Fini 
			i_joy_flag_esquive = faux	// Esquive finie
		}
		else
		{
			i_test_zdf_zdc_done = vrai
			// Appeller ici le test zdf_zdc mais renommer la fonction en fonction de test de coup porté car elle fait bienplus que zdf_zdc
			if( OBJ_CapaTest(Capa_ZDE_Fight_ON) && COL_CollideType(COL_C_Wall))
			{
				Proc_KK_DashImpact(4)
				to_col = COL_ObjectGet(COL_C_Wall)
				if( ARR_ObjSearch(&ao_frappe_target[0], i_frappe_target_nb, to_col) == -1 && ! @to_col AI_IsModel(get_PNJ_KTREX_Path))				
				{
					ao_frappe_target[i_frappe_target_nb] = to_col
					i_frappe_target_nb++
					ti_puissance  = Cf_DMG_Normal
					Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_Fort, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_col, -1, ti_puissance, OBJ_SightGet(), OBJ_PosGet())
				}
			}
			// Aide a l orientation
			if ( o_esquive_actor )
			{
				v_frappe_sight = @o_esquive_actor OBJ_PosGet() - OBJ_PosGet()
				v_frappe_sight.z = 0
				if ( MATH_VecNullEpsilon(v_frappe_sight))
					v_frappe_sight = v_joy_sight
			}
			else
				v_frappe_sight = v_joy_sight
			
			to_fight_actor = nobody
			ti_ind = Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, Cf_Cos45, 0.0, 6.0, to_fight_actor, faux, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Max, 0)	// POUR KONG A LANCER AVANT CHAQUE COUP.
			DASH_O_FIGHT_ACTOR_Validate( to_fight_actor)
			if ( ti_ind == -1)
			{
				if( MATH_VecDotProduct( v_frappe_sight, OBJ_SightGet()) > 0.0 )
				{
					v_frappe_sight = MATH_VecInCone( v_frappe_sight, OBJ_SightGet(), Cf_1Degre * 45.0, 0.0)
					COUP_Orient( 3.0, 0.5, 0.0)		// Pas de target: on aide l orient en limitant a un cone de déplacement
				}
				else
					COUP_Orient( 0.0, 0.5, 0.0)		// Joy a l opposé du déplacement on oublie l orient
				
			}
			else if ( ! i_frappe_target_nb)
				COUP_Orient( 20.0, 0.5, 0.0)		// Une target, orient a fond vers cette cible		
			else
				COUP_Orient( 0.0, 0.5, 0.0)		// Target paffé on s oriente plus			
			COUP_Cancel_Mouvment()
		}
		break
	case C_Mode_Dash : 
//	DASH	***********************************************************************************************************
		if ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered( C_Button_All))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				// TO DASH ATTACK
				COUP_ACTION_TEST_FINISH
				COUP_CHANGE_To_DashAttack( )			
				return
			}	
			else if ( KBUFFER_Buffered( C_Button_Repulse))	
			{
				// TO T1 : REPULSE
				COUP_ACTION_TEST_RAGE
				return
			}
			else if ( KBUFFER_Buffered( C_Button_Grab))
			{
				COUP_ACTION_TEST_GRAB
			}
		}
		
		if ( i_flag_just_Action)
			f_time_dash_init = 0.0	
		f_time_dash_init += TIME_GetDt()
		if ( ACT_ActionFinished() || ACT_ActionGet() != Ci_Kanim_dash) // f_dash_time > Cf_Trample_Duree)
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			COUP_END()
			ti_anim = -1
			i_flag_trample = faux		// Dash fini
			i_joy_flag_esquive = faux	// Esquive finie
			i_dash_for_walling = faux	
		}
		else
		{
			// ORIENTATION
			i_flag_trample = vrai
			if( i_dash_for_walling )
			{
				// backup norme du speedvector
				DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_bleu)
				tf_esquive_speed_norm = MATH_VecNorm(DYN_SpeedGetVector())
				// nouveau speedvector
				DBG_RenderVector(OBJ_PosGet(), v_dash_for_walling_axis, color_cyan)
				DYN_SpeedSetVector(tf_esquive_speed_norm * v_dash_for_walling_axis)
				// orientation de Kong
				tv_axis = v_dash_for_walling_axis
				tv_axis.z = 0.0
				OBJ_BankingGeneralSet( MATH_VecBlendRotate(OBJ_SightGet(), tv_axis, 6.0 * TIME_GetDt()), Cv_VerticalVector)
				COUP_Cancel_Mouvment( )
			}
			
			if ( f_time_dash_init < 0.57)
			{
				AI_Execute("k_exec_check_colonnes")
				if( o_colonne)
				{
					COUP_CHANGE_To_Pillar( o_colonne, Ci_Kanim_Colonne_Grimpe)
					return
				}
			}
		}
		break
	case C_Mode_Dash_To_Grab :
// DASH TO GRAB	*************************************************************************************************
		if ( ACT_ActionFinished()) // f_dash_time > Cf_Trample_Duree)
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			i_flag_trample = faux
			COUP_END()
			ti_anim = -1
		}
		else
		{
			v_frappe_sight = v_joy_sight_normalized							// Orientation
			tv_sens = @o_GrabKong_Dash_Target OBJ_PosGet() - OBJ_PosGet()
			MATH_VecSetHorzNormalize(tv_sens)
			v_grab_object_pos = OBJ_PosGet() + ( tv_sens * 4.0)		// Joy pas a l'opposé de l'ennemi : position calculée dans l'axe de l'ennemi
	

			i_GrabKong_Type = Ci_GrabKong_Type_Gros	+ Ci_GrabKong_Type_Mashing			
			i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ThisClientGet( o_GrabKong_Dash_Target, Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", "k_exec_selection_grab", nofunc)
			if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab] 
			|| ( @o_GrabKong_Dash_Target AI_IsModel(get_PNJ_KTREX_Path) && @o_GrabKong_Dash_Target KT_Proc_Dodges()))
			{
				macro_change_etat( "k_ETAT_grab")
			}

			// orientation de Kong
			OBJ_BankingGeneralSet( MATH_VecBlendRotate(OBJ_SightGet(), tv_sens, 6.0 * TIME_GetDt()), Cv_VerticalVector)
			COUP_Cancel_Mouvment( )
			
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			// PAFFE LES STRUCTURES ODE AUTOUR
			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			COL_ZoneSizeSet(C_zde_fight, 	cvector(7.0,7.0,7.0))
			COL_ZonePosSet(C_zde_fight, Cv_NullVector)
			ti_collision_nb = COL_ZDE_ZDEListGet( &tao_zde_zde_list[0], C_zde_fight, C_zde_corps, all, none, Ci_Filter_IdentityFlag)
			for (ti_i = 0; ti_i < ti_collision_nb; ti_i++)
			{
				to_actor = tao_zde_zde_list[ti_i]
				tv_temp = @to_actor OBJ_PosGet() - OBJ_PosGet()
				if( MATH_VecNullToler(tv_temp, 0.1) )
					tv_temp = OBJ_SightGet()
				else
					MATH_VecSetNormalize(tv_temp)
				if( @to_actor AI_IsModel(get_KI_Decor_Path) )
					EVENT_AddEventPaf(C_EVENT_FILTER_Enemy, C_PAF_KK_Fort, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_actor, 0.0, tv_temp)
			}
			COL_ZonePosSet( C_zde_fight, cvector( 0.0, 0.0, 2.0))
			COL_ZoneSizeSet( C_zde_fight, Cf_ZDE_SizeFight)
		}
		break
	case C_Mode_Esquive :
// DODGE	***********************************************************************************************************
		if (ACT_ActionFinished())
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			COUP_END()
			i_joy_flag_esquive = faux	// Esquive finie
			i_flag_trample = faux
			f_depl_esquive_rotation_speed = 5.0
			f_delp_esquive_delai = 1.0			// Durée du blend de vitesse
		}
		else
		{
			if ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered( C_Button_All))
			{
				if ( KBUFFER_Buffered( C_Button_Coup))
				{
					// TO DASH ATTACK
					COUP_ACTION_TEST_FINISH
					COUP_CHANGE_To_DashAttack( )			
					return
				}	
				else if ( KBUFFER_Buffered( C_Button_Repulse))	
				{
					// TO T1 : REPULSE
					COUP_ACTION_TEST_RAGE

					// MACRO  OR PROC
					i_joy_flag_esquive = faux	// Esquive finie
					i_flag_trample = faux
					f_depl_esquive_rotation_speed = 5.0
					f_delp_esquive_delai = 1.0			// Durée du blend de vitesse

					return
				}
				else if ( KBUFFER_Buffered( C_Button_Grab))
				{
					COUP_ACTION_TEST_GRAB
					return
				}
				else if ( ANI_CurrentFrameGet(0) > 55 )
				{
					COUP_ACTION_TEST_ACTION
					return
				}
			}		

			// Detection colonne en esquive.
			AI_Execute("k_exec_check_colonnes")
			if( o_colonne)
			{	
				COUP_CHANGE_To_Pillar( o_colonne, Ci_Kanim_Colonne_Grimpe)
				return
			}
						
			f_time_dash_init += TIME_GetDt()	
			// backup norme du speedvector
			DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_bleu)
			tf_esquive_speed_norm = MATH_VecNorm(DYN_SpeedGetVector())
			// calcul de l'orientation du nouveau speedvector
			tv_me_to_fight_actor = @o_esquive_actor OBJ_PosGet()
			tv_me_to_fight_actor -= OBJ_PosGet()
			tv_me_to_fight_actor.z = 0.0
			DBG_RenderVector(OBJ_PosGet(), tv_me_to_fight_actor, color_cyan)
			MATH_VecSetNormalize(tv_me_to_fight_actor)
	
			// droite ou gauche
			tv_esquive_normale = MATH_VecCrossProduct(tv_me_to_fight_actor, Cv_VerticalVector)
//			tv_esquive_normale = MATH_VecRotate( tv_me_to_fight_actor, Cv_VerticalVector, -Cf_PiBy3 * 2.0)
			MATH_VecSetNormalize(tv_esquive_normale)
			
			if( i_reflex_anim == Ci_Kanim_esquiveG ) 
				tv_esquive_normale *= -1
			
			// nouveau speedvector
			if ( @o_esquive_actor AI_IsModel(get_PNJ_KBats_path) && @o_esquive_actor KBC_IsABigBat() && @o_esquive_actor OBJ_CapaTest( OBJ_Capa_7))
			{
				tf_esquive_speed_norm *= 0.6		// Comme la bat va viote on esquive moins vite.( ca semble pas logique mais ca l'est)
//				ANI_FrequencySet( 0, ACT_FrequencyGet(ACT_ActionGet(), 0) * 0.5)
			}

			if ( MATH_VecDotProduct( v_esquive_to_actor,tv_me_to_fight_actor) > 0)
			{
				DYN_SpeedSetVector( tf_esquive_speed_norm * tv_esquive_normale )
			}
			else
				DYN_SpeedSetVector( Cv_NullVector)
			v_delp_esquive_normale = tv_esquive_normale
			
			// orientation de Kong
			tv_axis = @o_esquive_actor OBJ_PosGet() - OBJ_PosGet()
			tv_axis.z = 0.0
			v_depl_esquive = tv_axis
			tv_axis = MATH_VecBlendRotate(OBJ_SightGet(), v_depl_esquive, 6.0 * TIME_GetDt())
			tv_axis = MATH_VecInCone( tv_axis, OBJ_SightGet(), Cf_1Degre * 10.0, 0)
			OBJ_BankingGeneralSet( tv_axis , Cv_VerticalVector)
			COUP_Cancel_Mouvment()
		}
		break
	case C_Mode_Retour :
// RETOUR (particulier) ***********************************************************************************************************
		if ( ACT_ActionFinished())
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			COUP_END()
		}
		else
		{
			switch(  ACT_ActionGet())
			{
				case Ci_Kanim_coup_C_2_Fin :
					COUP_ACTION_TEST_FINISH
					COUP_ACTION_TEST_GRAB
					break
				case Ci_Kanim_Intimid_FinishFurieReward :
					if (!ACT_ActionItemGet())
						@get_Kamera Proc_Kam_FinishMode_Set(Ci_Kamera_Finish_id_KONG_Won, OBJ_Me())	// Parametres pour le moment, le type de Finish et le perso de reference de ce finish (en principe KONG)
					break
				case Ci_Kanim_Intimid_FinishFurieCri :		
					if ( ANI_CurrentFrameGet(0) > 40)
					{
						i_Kamera_Finish_id_Forced = -1
						@get_Kamera Proc_Kam_FinishMode_Set( Ci_Kamera_Finish_id_KONG_WonSimple, OBJ_Me())	// Parametres pour le moment, le type de Finish et le perso de reference de ce finish (en principe KONG)
					}
					else if (i_Kamera_Finish_id_Forced != -1)
						@get_Kamera Proc_Kam_FinishMode_Set( i_Kamera_Finish_id_Forced, OBJ_Me())	// Parametres pour le moment, le type de Finish et le perso de reference de ce finish (en principe KONG)
					
//					if ( ANI_CurrentFrameGet(0) > 110)
//						f_rumble_power = 200
//					else
//						f_rumble_power = 0
//					IO_PafSet( f_rumble_power,1)
				case Ci_Kanim_Intimid_Furie :
				
//					if ( ANI_CurrentFrameGet(0) > 95)
//						f_rumble_power = 200
//					else
//						f_rumble_power = 0
//					IO_PafSet( f_rumble_power,1)
					if ( KBUFFER_Zone_Interrupt())
					{
						if ( KBUFFER_Buffered( C_Button_Coup))
						{
							COUP_ACTION_TEST_FINISH
							COUP_CHANGE_To_Combo3()
							return
						}
						else
						{
							// TO NORMAL MODE ( ATT OR MOVE)
							COUP_END()
						}
					}
				case Ci_Kanim_Intimid_FurieCri :
					break
				default:
					COUP_ACTION_TEST_FINISH
					COUP_ACTION_TEST_ACTION
					COUP_ACTION_TEST_RAGE
					COUP_ACTION_TEST_COUP
					COUP_ACTION_TEST_GRAB
			}
			COUP_Cancel_Mouvment()					
		}
		break
	case C_Mode_Kill :
// GNIAK BAT/RAPTOR ***********************************************************************************************************
		if ( ACT_ActionFinished())
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			COUP_END()
		}
		else if ( ANI_CurrentFrameGet(0) > 60)
		{
			if ( i_Grab_Torse_Main != -1 && ao_CL_GRABKONG[i_Grab_Torse_Main] && ! i_GrabKong_ModeKill_PafSend )
			{
				i_GrabKong_ModeKill_PafSend = vrai
				Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_KiTue, OBJ_Me(), Cf_EVENT_Duree_1Trame, ao_CL_GRABKONG[i_Grab_Torse_Main], -1, 0.0, OBJ_SightGet(), OBJ_PosGet())
			}			
			COUP_Cancel_Mouvment()					
		}
		else
		{
			i_Grab_Torse_Main = -1		// COUPER L IK
			COUP_Cancel_Mouvment()					
		}
		break
	case C_Mode_Pillar :
// COLONNE	***********************************************************************************************************
		AI_Execute("k_ETAT_colonne_exec")
		break
	default:
		COUP_Orient( 0.0, 0.5, 0.0)
}

// OLD OLD OLD OLD OLD OLD
switch(i_reflex_anim)
{
	case Ci_Kanim_coup_C_1	:
	case Ci_Kanim_coup_C_2	:
	case Ci_Kanim_coup_T_1	:
	case Ci_Kanim_coup_T_2	:
	case Ci_Kanim_coup_T_3 :
	case Ci_Kanim_Dash_Attack :
	case Ci_Kanim_esquiveG :
	case Ci_Kanim_esquiveD :
		break
	// DEMI ET QUART DE TOUR =============================================================================
	case Ci_Kanim_QuartDr : 
	case Ci_Kanim_QuartGa : 
	case Ci_Kanim_DemiDr : 
	case Ci_Kanim_DemiGa :
			
		// LANCEMENT DES COUPS
		COUP_ACTION_TEST_FINISH
		COUP_ACTION_TEST_ACTION
		COUP_ACTION_TEST_RAGE
		COUP_ACTION_TEST_COUP
		COUP_ACTION_TEST_GRAB

		if (! ACT_ActionFinished())
		{
			OBJ_RotateGlobalZ(f_angle_quart * TIME_GetDt())
			COUP_Cancel_Mouvment()	
		}
		break
	
	// FRANCHISSEMENT D'OBSTACLE =======================================================================
	case Ci_Kanim_saute_3M :
	case Ci_Kanim_saute_5M :
	case Ci_Kanim_saute_9M :
	case 120 :
		ti_oriente = faux
	
		f_time_collide_ground = 0.0
	
		if (i_joy_flag_dash)	
			ANI_FrequencySet(0, 90)
		else
			ANI_FrequencySet(0, 60)
		to_bone = ANI_CanalObjectGet(Anim_Canal_Snap_Bassin)		// snap bassin
		tv_obstacle_anim_offset = @to_bone OBJ_PosGet() - OBJ_PosGet()
		tv_obstacle_pos_offset = @to_bone OBJ_PosGet() - v_obstacle_top_point_backup
//		DBG_RenderVector(OBJ_PosGet(), tv_obstacle_anim_offset, color_rouge)
//		DBG_RenderVector(v_obstacle_top_point_backup, Cv_VerticalVector * 10, color_bleu)
//		DBG_RenderVector(v_obstacle_top_point_backup, tv_obstacle_pos_offset, color_vert)
		tv_pos = v_obstacle_top_point_backup
		tv_obstacle_pos_offset = MATH_VecBlend(tv_obstacle_pos_offset, Cv_NullVector, 3.0 * TIME_GetDt())
		tv_pos += tv_obstacle_pos_offset
		tv_pos -= tv_obstacle_anim_offset

		OBJ_PosSet(tv_pos)
		OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), -v_obstacle_normale_bkup, 3.0 * TIME_GetDt()), Cv_VerticalVector)
		if (ACT_ActionFinished())
		{
			tv_pos = OBJ_PosGet()
			tv_pos.z = v_obstacle_pente_sol.z
			OBJ_PosSet(tv_pos)

	
			DYN_GravitySet(Cv_Kong_Gravity)
		
			tv_speed = OBJ_SightGet() * f_speed_before_obstacle
			DYN_SpeedSetVector(tv_speed)
			i_flag_trample = faux
			break
		}
		else
		{
			COL_ColSetActivationSet(none, C_bit_zdm_pied)

			DYN_GravitySet(Cv_NullVector)
			DYN_TractionSet(Cv_NullVector)
			DYN_StreamSet(Cv_NullVector)
			DYN_FrictionVectorSet(Cv_NullVector)

			returntrack
		}
	case Ci_Kanim_ArretRapide :
	case 	Ci_Kanim_StopRapide :
		if( ACT_ActionFinished() )
			ti_anim = Ci_Kanim_Attente
		break
	case Ci_Kanim_dash : 
		break	
	// DEFAULT ==========================================================================================
	default:
	{
		// CAS NORMAL

		// SI ANIM NON CYCLIQUE PAS TERMINEE, ON ATTEND LA FIN
		if (ACT_CustomBitTest(0b00000001) && ! ACT_ActionFinished())
			returntrack
		
		ti_test_esquive = vrai
	}
}

// DETECTER SI KONG PEUT PAFFER
if ( COUP_TryToHit( ))
{
	AI_Execute("k_exec_zdf_zdc")
//	if ( !i_frappe_genere_ODE)
//	{
//		i_frappe_genere_ODE = vrai
//		Genere_ODE_Punch( v_frappe_ODE_pos, v_frappe_ODE_force)
//	}
}
else
	i_frappe_target_nb = 0

// ORIENTATION PENDANT LE COUP
if ( COUP_Oriented())
{
	DBG_RenderVector( OBJ_PosGet() + cvector( 0.0, 0.0, 0.75), v_frappe_sight * 5.0, color_rouge)
	push(v_frappe_sight)					// Axis Dest
	f_coup_orient_blend_current = MATH_FloatBlend( f_coup_orient_blend_current, f_coup_orient_blend_max, 4.0 * TIME_GetDt())
	push(f_coup_orient_blend_current)				// Speed
	push(f_coef_pied_d_appui)			// Coef entre les deux pieds
	AI_Execute("k_exec_2Feet_SightSet")	
}
else
	f_coup_orient_blend_current = MATH_FloatBlend( f_coup_orient_blend_current, 0.0, 8.0 * TIME_GetDt())


// RIDE SERVEUR : ACCROCHAGE DES RAPTORS
RIDE_Propose_Link()

// DETECTER S IL FAUT PASSER EN DEPLACEMENT
if( COUP_Canceled_Mouvment())
	return
	
// ACTION SELON LE PAD
COUP_ACTION_TEST_FINISH
COUP_ACTION_TEST_ACTION
COUP_ACTION_TEST_RAGE
COUP_ACTION_TEST_COUP
COUP_ACTION_TEST_GRAB

// Modificateur de vitesse
f_deplacement_speed_factor = Cf_Speed_Factor_Normal


// Joy ou joy simulé
if (f_time_auto_walk)
{
	tv_joy_axis = v_auto_walk_dir
	macro_render_Vector(OBJ_PosGet() + Cv_VerticalVector, tv_joy_axis * 10.0, 0x804060)
}
else if ( f_joy_norm || i_flag_trample)
	tv_joy_axis = v_joy_sight_normalized
else
	tv_joy_axis = Cv_NullVector
	

// ORIENTATION EN COLLISION MUR	
AI_Execute("k_DBG_WALLING")
ti_flag_mur = faux
to_col = COL_BestAngleWallGaoGet( v_joy_sight, Cf_Cos90, &ti_col)
if ( !MATH_VecNullEpsilon( tv_joy_axis) && to_col)
{
//	if ( !COL_CollideType( COL_C_Corner ) && !COL_CollideType( COL_C_Extra_ODE  ) 
	if ( !COL_CollideType( COL_C_Extra_ODE  ) 	
	&& !(@to_col OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_Anims))
	{
		
		ti_flag_mur = vrai
		if ( !MATH_VecNullEpsilon( tv_joy_axis))
		{
			if ( MATH_VecNullEpsilon( v_depl_aide_orien_wall))
				v_depl_aide_orien_wall = tv_joy_axis
			ti_flag_corner = faux
			if ( COL_CollideType( COL_C_Corner))
			{
				ti_flag_corner = vrai 
				tv_normal = COL_NormalGet( COL_C_Corner)
				if ( MATH_VecNullEpsilon(tv_normal))
					tv_normal = COL_NormalGet( COL_C_ReportIndex + ti_col) //tab_wall[0] )
			}
			else
				tv_normal = COL_NormalGet( COL_C_ReportIndex + ti_col) //tab_wall[0] )
			tv_normal.z = 0.0
			MATH_VecSetNormalize( tv_normal)
			macro_render_Vector( COL_CollidedPointGet( COL_C_Wall), tv_normal * 3.0, color_rouge)
			macro_render_Vector( COL_CollidedPointGet( COL_C_Wall), v_joy_sight * 3.0, color_vert)
			tf_dot = MATH_VecDotProduct( tv_normal, v_joy_sight)
			if ( (!ti_flag_corner && tf_dot < -Cf_Cos35)
			|| ( ti_flag_corner && tf_dot < 0 ))
				tv_joy_axis = Cv_NullVector
			else if ( tf_dot < 0)
			{
				tv_ortho = MATH_VecCrossProduct( tv_normal, Cv_VerticalVector)
				macro_render_Vector( COL_CollidedPointGet( COL_C_Wall), tv_ortho * 3.0, color_jaune)
				tv_joy_axis = tv_ortho * MATH_FloatSign(MATH_VecDotProduct( v_depl_aide_orien_wall, tv_ortho))
				tv_joy_axis -= tv_normal * 0.15
				macro_render_Vector( COL_CollidedPointGet( COL_C_Wall), tv_joy_axis * 3.0, color_bleu)		
				tf_dot = MATH_VecDotProduct( v_joy_sight, -tv_joy_axis) 
				DYN_SpeedSetVector(DYN_SpeedGetVector() - (tv_normal * 5.0) )		// Forcer dans le mur
				if ( tf_dot > Cf_Cos45)
				{
					// Demi tour
					tv_joy_axis = -tv_joy_axis
				}
				else if ( tf_dot > Cf_Cos85) // Test >0 entraine des cas de blocage trop limite
					tv_joy_axis = Cv_NullVector
				else
					v_depl_aide_orien_wall = tv_joy_axis
			}
		}
	}
}
else
	v_depl_aide_orien_wall = Cv_NullVector
// ORIENTATION EN COLLISION MUR


if ( ! MATH_VecNullEpsilon( tv_joy_axis) || i_flag_trample || i_flag_galop) //|| f_time_auto_walk))
{
	push(tv_joy_axis)		
	AI_Execute("k_exec_aide_au_deplacement")
	tv_joy_axis = pop
	if ( pop)
		tf_aide_orient = 2.0
	// Le joy a pu etre mis a 0 si je joueur va contre un mur mais il faut pouvoir monter qd meme
	if ( f_joy_norm)
		tv_joy_test_grimpe = v_joy_sight_normalized
	else
		tv_joy_test_grimpe = Cv_NullVector
	if (f_delay_before_collision < 0.5 && ( ! MATH_VecNullEpsilon(v_obstacle_normale) ) && MATH_VecDotProduct(tv_joy_test_grimpe, v_obstacle_normale) < 0.0)
	{
		if ( i_obstacle_GMAT & Gmat_KK_Face_Obstacle)
		{
			// TO NORMAL MODE ( ATT OR MOVE)
			i_joy_flag_esquive = faux	// Esquive finie
			i_dash_for_walling = faux
			
			if (f_hauteur_obstacle > Cf_Hauteur_Mur_Accroch_Auto + 1.0)
			{
				// TROP HAUT
				if ( o_colonne && COL_ObjectGet( COL_C_Wall) == o_colonne)
				{
					COUP_END()
					COUP_CHANGE_To_Pillar( o_colonne, Ci_Kanim_Colonne_Grimpe)
					return
				}
			}
			else if (f_hauteur_obstacle > 9.5)
			{
				// OBSTACLE 9M
				if(( i_joy_flag_dash || i_flag_trample ) 
				&& f_time_dash_init < 0.57)
				{
					// en grimpe que si le joueur appuie sur le bouton de dash depuis peu
					COUP_END()
					ti_anim = Ci_Kanim_saute_9M
					i_reflex_anim = Ci_Kanim_saute_9M
					
					f_speed_before_obstacle = MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet())
					
					i_jump_reception = faux
					ACT_ForceModeSet(0) // SpeedFromActionItem
					
					
					DYN_GravitySet(Cv_NullVector)
					DYN_TractionSet(Cv_NullVector)
					DYN_StreamSet(Cv_NullVector)
					DYN_FrictionVectorSet(Cv_NullVector)
					DYN_SpeedSetVector(Cv_NullVector)
		
					COL_ColSetActivationSet(none, C_bit_zdm_pied)
		
					f_obstacle_dist_a_compenser = f_obstacle_dist_true - 4.21//f_obstacle_dist - 2.5
					f_obstacle_dist -= 4.21
					f_obstacle_z_a_compenser = v_obstacle_dest_pos.z - OBJ_PosGet().z -10.0
	 				v_obstacle_pos_to_grab = v_obstacle_dest_pos
					v_obstacle_normale_bkup = v_obstacle_normale
					v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_normale, v_obstacle_normale_sol) 
					v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_pente_sol, v_obstacle_normale_sol)
					v_obstacle_pente_sol = v_obstacle_pos_to_grab + (v_obstacle_pente_sol * 4.0)
					OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), - v_obstacle_normale_bkup, 10.0 * TIME_GetDt()), Cv_VerticalVector)
					
					v_obstacle_pos_offset_total =Cv_NullVector
					v_obstacle_top_point_backup = v_obstacle_top_point
				}
			}
			else if (f_hauteur_obstacle > 6.0)
			{
				// OBSTACLE 9M
				if(( i_joy_flag_dash || i_flag_trample ) 
				&& f_time_dash_init < 0.57)
				{
					// en grimpe que si le joueur appuie sur le bouton de dash depuis peu
					COUP_END()
					ti_anim = 120
					i_reflex_anim = 120
					
					f_speed_before_obstacle = MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet())
					
					i_jump_reception = faux
					ACT_ForceModeSet(0) // SpeedFromActionItem
					
					
					DYN_GravitySet(Cv_NullVector)
					DYN_TractionSet(Cv_NullVector)
					DYN_StreamSet(Cv_NullVector)
					DYN_FrictionVectorSet(Cv_NullVector)
					DYN_SpeedSetVector(Cv_NullVector)
		
					COL_ColSetActivationSet(none, C_bit_zdm_pied)
		
					f_obstacle_dist_a_compenser = f_obstacle_dist_true - 4.21//f_obstacle_dist - 2.5
					f_obstacle_dist -= 4.21
					f_obstacle_z_a_compenser = v_obstacle_dest_pos.z - OBJ_PosGet().z -8.0
	 				v_obstacle_pos_to_grab = v_obstacle_dest_pos
					v_obstacle_normale_bkup = v_obstacle_normale
					v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_normale, v_obstacle_normale_sol) 
					v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_pente_sol, v_obstacle_normale_sol)
					v_obstacle_pente_sol = v_obstacle_pos_to_grab + (v_obstacle_pente_sol * 4.0)
					OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), - v_obstacle_normale_bkup, 10.0 * TIME_GetDt()), Cv_VerticalVector)
					
					v_obstacle_pos_offset_total =Cv_NullVector
					v_obstacle_top_point_backup = v_obstacle_top_point
				}
			}
			else if (f_hauteur_obstacle >= 4.5)
			{
				// OBSTACLE 5M	
				COUP_END()
				ti_anim = Ci_Kanim_saute_5M
				i_reflex_anim = Ci_Kanim_saute_5M
			
				f_speed_before_obstacle = MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet())
	
				i_jump_reception = faux
				ACT_ForceModeSet(0) // SpeedFromActionItem
	
	//			SND_RequestPlay(Ci_KSound_Enjambe)
	
				DYN_GravitySet(Cv_NullVector)
				DYN_TractionSet(Cv_NullVector)
				DYN_StreamSet(Cv_NullVector)
				DYN_FrictionVectorSet(Cv_NullVector)
				DYN_SpeedSetVector(Cv_NullVector)
	
				COL_ColSetActivationSet(none, C_bit_zdm_pied)
				f_obstacle_dist_a_compenser = f_obstacle_dist + 100 //-3.3
				f_obstacle_dist -= 3.0
				v_obstacle_pos_to_grab = v_obstacle_dest_pos	
				v_obstacle_normale_bkup = v_obstacle_normale
				v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_normale, v_obstacle_normale_sol) 
				v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_pente_sol, v_obstacle_normale_sol)
				v_obstacle_pente_sol = v_obstacle_pos_to_grab + (v_obstacle_pente_sol * 3.0)

				OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), - v_obstacle_normale_bkup, 10.0 * TIME_GetDt()), Cv_VerticalVector)
	
	//			OBJ_PosSet(OBJ_PosGet() - (v_obstacle_normale * f_obstacle_dist))
	//			OBJ_BankingGeneralSet(- v_obstacle_normale, Cv_VerticalVector)
	//			f_obstacle_dist = f_obstacle_dist
	
				v_obstacle_pos_offset_total =Cv_NullVector
				v_obstacle_top_point_backup = v_obstacle_top_point
			}
			else if (f_hauteur_obstacle >= 1.90) // Avant 2.5m !
			{
				// OBSTACLE 3M
				COUP_END()	
				ti_anim = Ci_Kanim_saute_3M
				i_reflex_anim = Ci_Kanim_saute_3M
		
				f_speed_before_obstacle = MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet())
	
				i_jump_reception = faux
				ACT_ForceModeSet(0) // SpeedFromActionItem
	
	//			SND_RequestPlay(Ci_KSound_Enjambe)
	
				DYN_GravitySet(Cv_NullVector)
				DYN_TractionSet(Cv_NullVector)
				DYN_StreamSet(Cv_NullVector)
				DYN_FrictionVectorSet(Cv_NullVector)
				DYN_SpeedSetVector(Cv_NullVector)
	
				COL_ColSetActivationSet(none, C_bit_zdm_pied)
	
				f_obstacle_dist_a_compenser = f_obstacle_dist + 100 //- 3.3
				f_obstacle_dist -= 3.0
				v_obstacle_pos_to_grab = v_obstacle_dest_pos	
				v_obstacle_normale_bkup = v_obstacle_normale
				v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_normale, v_obstacle_normale_sol) 
				v_obstacle_pente_sol = MATH_VecCrossProduct( v_obstacle_pente_sol, v_obstacle_normale_sol)
				v_obstacle_pente_sol = v_obstacle_pos_to_grab + (v_obstacle_pente_sol * 3.0)

				OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), -v_obstacle_normale_bkup, 10.0 * TIME_GetDt()), Cv_VerticalVector)
	
	//			OBJ_PosSet(OBJ_PosGet() - (v_obstacle_normale * f_obstacle_dist))
	//			OBJ_BankingGeneralSet(- v_obstacle_normale, Cv_VerticalVector)
	//			f_obstacle_dist = f_obstacle_dist
	
				v_obstacle_pos_offset_total =Cv_NullVector
				v_obstacle_top_point_backup = v_obstacle_top_point
			}	
			i_flag_just_Action = faux
		}
	}

	// test de ½ tour ! ----------- (code temp) -------------------------------------------------------------------------
	// ½ tour interdit en mode Fight
	if( (i_reflex_anim == Ci_Kanim_Attente || (ACT_ActionIsTransition() && ACT_ActionGetTransition() == 0) ) 
		&& ! i_flag_trample && ! o_fight_actor && ! MATH_VecNullEpsilon(tv_joy_axis) )
	{

		tf_dot = MATH_VecDotProduct(OBJ_SightGet(), tv_joy_axis) 


		if (tf_dot < -Cf_Cos45)
		{
			// 1/2 tour
			macro_render_Vector(OBJ_PosGet() + Cv_VerticalVector, tv_joy_axis * 5.0,color_jaune)
			if (MATH_VecDotProduct(OBJ_HorizonGet(), tv_joy_axis) > 0.0)
				ti_anim = Ci_Kanim_DemiGa
			else
				ti_anim = Ci_Kanim_DemiDr

			v_sight_quart = tv_joy_axis
			f_angle_quart = MATH_VecAngle(OBJ_SightGet(),v_sight_quart, Cv_VerticalVector)
			if (f_angle_quart > 0)
				f_angle_quart -= Cf_Pi
			else
				f_angle_quart += Cf_Pi
			f_angle_quart /= ACT_DurationGet(ti_anim,0)
	
		}
		else if (tf_dot < Cf_Cos70)
		{
			// 1/4 de tour
			macro_render_Vector(OBJ_PosGet() + Cv_VerticalVector, tv_joy_axis * 5.0, color_jaune)
			if (MATH_VecDotProduct(OBJ_HorizonGet(), tv_joy_axis) > 0.0)
				ti_anim = Ci_Kanim_QuartGa
			else
				ti_anim = Ci_Kanim_QuartDr
	
			v_sight_quart = tv_joy_axis
			f_angle_quart = MATH_VecAngle(OBJ_SightGet(),v_sight_quart, Cv_VerticalVector)
			if (f_angle_quart > 0)
				f_angle_quart -= Cf_PiBy2
			else
				f_angle_quart += Cf_PiBy2
			f_angle_quart /= ACT_DurationGet(ti_anim,0)
		}
	}
	// test de 1/2 tour ! ----------- (code temp) -------------------------------------------------------------------------

	if (ti_anim == Ci_Kanim_NoAnim)
	{
		ti_pose_main = vrai

		// Test Kong doit-il poser la main ?
		if( ti_flag_mur )
			ti_pose_main = faux
		
		if ( ti_flag_mur && !COL_CollideType(COL_C_Corner) && ti_pose_main && !i_flag_trample)
		{
			// Cours contre un mur
			tf_rotation_speed = 2.0

			if (i_look_do_sight_ennemi_old)
				tv_axis = MATH_VecCrossProduct(v_look_direction,Cv_VerticalVector)
			else
				tv_axis = OBJ_HorizonGet()
			
			if ( MATH_VecAngle( tv_joy_axis, tv_normal, Cv_VerticalVector) > 0)
				ti_anim = 19
			else
				ti_anim = 18

		}
		else if ( i_flag_trample)
		{
			// DASH
			i_flag_bassin_rotation = vrai
		
			// Réglage de la vitesse de rotation sur le Dash
			if ( !MATH_VecNullEpsilon(v_dash_direction))
			{
				tv_joy_axis = v_dash_direction
				if ( MATH_VecDotProduct( v_dash_direction, OBJ_SightGet()) > Cf_Cos10)
					v_dash_direction = Cv_NullVector
				tf_rotation_speed  = 6.0		// Debut de l anim
			}
			else
				tf_rotation_speed  = 1.0		// Reste du mouvement

//			if ( f_trample_time > 0.75 * Cf_Trample_Duree)
//				tf_rotation_speed  = 6.0		// Debut de l anim
//			else
//				tf_rotation_speed  = 1.0		// Reste du mouvement

			f_deplacement_speed_factor = Cf_Speed_Factor_Trample
		}
		else if ( i_flag_galop)
		{
			// GALOP
			if (i_look_do_sight_ennemi_old)
				tv_axis = MATH_VecCrossProduct(v_look_direction,Cv_VerticalVector)
			else
				tv_axis = OBJ_HorizonGet()
			tf_dot_product	= MATH_VecDotProduct(tv_axis, tv_joy_axis)
			tf_dot_product	= MATH_VecDotProduct(tv_axis, tv_joy_axis)
			if ( MATH_AbsFloat(tf_dot_product) > 1.0)
				f_move_side = tf_dot_product
				
			if(  f_move_side < 0.0)
				ti_anim = Ci_Kanim_GalopeG
			else
				ti_anim = Ci_Kanim_GalopeD

			// Réglage de la vitesse de rotation sur le Dash
			tf_rotation_speed  = 1.0		// Reste du mouvement

			f_deplacement_speed_factor = Cf_Speed_Factor_Trample
		}
		else
		{
			// COURSE
			tf_rotation_speed = 1.75       //2.0  Jouable mais pas trop rapide

			if (i_look_do_sight_ennemi_old)
				tv_axis = MATH_VecCrossProduct(v_look_direction,Cv_VerticalVector)
			else
				tv_axis = OBJ_HorizonGet()
		
			tf_dot_product	= MATH_VecDotProduct(tv_axis, tv_joy_axis)
			if (!f_move_side || MATH_AbsFloat(tf_dot_product) > 0.1)
				f_move_side = tf_dot_product
			if ( ACT_ActionIsTransition() && ( ACT_ActionGetTransition() == Ci_Kanim_courseG || ACT_ActionGetTransition() == Ci_Kanim_courseD))
				ti_anim = i_reflex_anim 
			else
			{
				if ( !i_reflex_anim)		// Si on viens de l attente on force d'aller vers la course D car on a la transition spéciale dans ce cas la
				{
					// DROITE
					if (MATH_AbsFloat(f_look_angle_old) > Cf_1Degre*55)
						ti_anim = Ci_Kanim_courseDD
					else
						ti_anim = Ci_Kanim_courseD					
				}
				else if (f_time_auto_walk || f_move_side < 0.0)
				{
					// GAUCHE
					if (MATH_AbsFloat(f_look_angle_old) > Cf_1Degre*55)
						ti_anim = Ci_Kanim_courseGG
					else
						ti_anim = Ci_Kanim_courseG
				}
				else
				{
					// DROITE
					if (MATH_AbsFloat(f_look_angle_old) > Cf_1Degre*55)
						ti_anim = Ci_Kanim_courseDD
					else
						ti_anim = Ci_Kanim_courseD
				}
			}
			f_deplacement_speed_factor = Cf_Speed_Factor_Run
		}

		// ORIENTATION
		if (ti_oriente)
		{
			v_reflex_cul_pos = OBJ_PosGet() - (OBJ_SightGet() * 2)
			if (f_time_auto_walk)
				tf_rotation_speed *= 2.0
			
			tf_rotation_speed *= tf_aide_orient

			if ( f_delp_esquive_delai > 0.0)
			{
				f_delp_esquive_delai -= TIME_GetDt()
				tf_esquive_speed_norm = MATH_VecNorm(DYN_SpeedGetVector())
		
				// nouveau speedvector
				v_delp_esquive_normale= MATH_VecBlend( v_delp_esquive_normale, tv_joy_axis, 5.0 * TIME_GetDt())
				DYN_SpeedSetVector( tf_esquive_speed_norm * v_delp_esquive_normale )				
			}
			OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), tv_joy_axis, tf_rotation_speed * TIME_GetDt())
			,MATH_VecBlendRotate( OBJ_BankingGet(),  Cv_VerticalVector, 8.0 * TIME_GetDt()))
			
			// Cul inertia -------------------------------------------------------
			tv_reflex_cul_pos_new = OBJ_PosGet() - (OBJ_SightGet() * 2)
			v_speed_cul = tv_reflex_cul_pos_new - v_reflex_cul_pos
			v_speed_cul /= TIME_GetDt()
			// Cul inertia -------------------------------------------------------
		}
	}

	f_move_dt = 0.05
}
else
{
	// PAS DE JOY : PASSAGE EN ARRET

	f_move_dt = MATH_FloatMax(0, f_move_dt -TIME_GetDt() )
	i_next_move_orientation = vrai
	f_rush_speed  = 0


	// Choix de l anim de passage en attente.( arret normal ou rapide)	
	if( ( i_reflex_anim != Ci_Kanim_ArretRapide) && i_reflex_anim != Ci_Kanim_StopRapide) 
	{
		if ( f_reflex_time_mouvement)
		{
			if( i_reflex_anim != Ci_Kanim_esquiveG && i_reflex_anim != Ci_Kanim_esquiveD)
			{
				if ( f_reflex_time_mouvement > 1.5)
					ti_anim =  Ci_Kanim_StopRapide		// kong se déplaçait depuis longtemps -> anim d'arrêt rapide
				else
					ti_anim = Ci_Kanim_ArretRapide		// kong se déplaçait depuis peu -> petit arret
				f_reflex_time_mouvement = 0.0
			}
			else
			{
				if ( (i_blesse_on || RIDE_Get_Actor_Nb() ) 
				&& (i_reflex_anim == Ci_Kanim_Attente
				|| i_reflex_anim == Ci_Kanim_AttenteBlesse
				|| i_reflex_anim == Ci_Kanim_AttenteAngry) )
					ti_anim = Ci_Kanim_AttenteBlesse
//				else if ( o_fight_actor && 
//				( i_reflex_anim == Ci_Kanim_Attente || i_reflex_anim == Ci_Kanim_AttenteAngry))
//					ti_anim = Ci_Kanim_AttenteAngry
				else
					ti_anim = Ci_Kanim_Attente
			}
		}
		else
		{
				if ( (i_blesse_on || RIDE_Get_Actor_Nb() ) 
				&& (i_reflex_anim == Ci_Kanim_Attente 
				|| i_reflex_anim == Ci_Kanim_AttenteBlesse
				|| i_reflex_anim == Ci_Kanim_AttenteAngry) )
					ti_anim = Ci_Kanim_AttenteBlesse
//				else if ( o_fight_actor && 
//				( i_reflex_anim == Ci_Kanim_Attente
//				|| i_reflex_anim == Ci_Kanim_AttenteAngry))
//					ti_anim = Ci_Kanim_AttenteAngry
				else
					ti_anim = Ci_Kanim_Attente
		}
	}
				
	DYN_FrictionVectorSet(cvector(1.0, 1.0, 0.0))

	// ORIENTATION
	if ( ACT_DesignFlagGet() & Ci_KACT_ASF_Orient_Target)
	{
//		OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), MATH_VecNormalize( v_look_position - OBJ_PosGet()), 0.5 * TIME_GetDt()),Cv_VerticalVector)		
		push(MATH_VecNormalize( v_look_position - OBJ_PosGet()))					// Axis Dest
		push(0.5)				// Speed
		push(0.0)			// Coef entre les deux pieds
		AI_Execute("k_exec_2Feet_SightSet")	
	}
	
	macro_correction_banking( OBJ_SightGet(), Cv_VerticalVector, 8.0)
}


// ESQUIVE ===============================================================
//if( ti_test_esquive )
//{
//	// ESQUIVE si DODGE, EN FIGHT avec une DIRECTION et si on ne DASH PAS
//	if( i_flag_trample && o_fight_actor && f_joy_norm )
//		i_joy_flag_esquive = vrai
//
//	if (i_joy_flag_esquive)
//	{
//		if( COUP_CHANGE_To_Dash())
//			macro_change_etat( "k_ETAT_grab")
//		return
//	}
//}


// ACTION ================================================================
if (	ti_anim != Ci_Kanim_NoAnim )
	if( ti_anim != Ci_Kanim_Attente || MATH_VecNullEpsilon(v_glisse_add_speed))		// en afterblend on fait avancer KONG donc pas d'anim d'attente...
		ACT_ActionSet(ti_anim)


// RECEPTION =============================================================
		
if (i_jump_reception)
{
	DYN_StreamSet(Cv_NullVector)
	DYN_TractionSet(Cv_NullVector)
	
	ACT_ForceModeSet(7) // SpeedFromDyna
	
	if (f_joy_norm || i_joy_flag_dash)
	{
		tf_coef = DYN_SpeedGet()
		tf_coef = 3.0 - MATH_FloatMin(tf_coef * 0.4, 2.5)
		DYN_FrictionVectorSet(cvector(tf_coef, tf_coef, 0.0))

		tf_coef = 10.0
	}
	else
	{
//		tf_coef = DYN_SpeedGet()
//		tf_coef = 20.0 - MATH_FloatMin(tf_coef * 2.0, 19.0)
		tf_coef = 20.0
		DYN_FrictionVectorSet(cvector(tf_coef, tf_coef, 0.0))
	
		tf_coef = 2.0
	}
		
	if (DYN_SpeedGet() < tf_coef)
	{
		i_jump_reception = faux
		ACT_ForceModeSet(0) // SpeedFromActionItem
	}
}	

DYN_SpeedSetVector( DYN_SpeedGetVector() * f_deplacement_speed_factor )


if ( ! MATH_FloatNullEpsilon( f_time_fury))
	ANI_FrequencySet( 0, ACT_FrequencyGet(ACT_ActionGet(),0) * 1.25)
else
	ANI_FrequencySet( 0, ACT_FrequencyGet(ACT_ActionGet(),0))