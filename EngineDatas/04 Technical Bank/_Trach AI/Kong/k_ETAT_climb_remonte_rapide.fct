#include"k_define.var"

float				tf_norm
vector			tv_new_sight 
vector			tv_sens
vector			tv_speed
vector			tv_horiz 

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

	COL_ColSetActivationSet(C_bit_zdm_pied, none)	
	v_zdm_pos = Cv_Kong_zdm_pos
	DYN_GravitySet(Cv_Kong_Gravity)
	COL_GeoColMapPosSet( 0, cvector( 0.0, 0.0, 2.8))
	OBJ_HierarchyReset() // o_climb_0D_Wall
	if ( o_climb_0D_wp)
		@o_climb_0D_wp OBJ_HierarchyReset()
	o_climb_0D_wp = nobody
	
	i_flag_auto_grab = faux

	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Kong_climb_rapide) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Kong_climb_rapide

	// CAMERA -----------------------------------------------------------------
//	@get_global i_kong_camera_status = Ci_Kcamera_grab_grimpe
//	@get_global v_kong_camera_vector		=  v_climb_normale
	// CAMERA -----------------------------------------------------------------

	// GRAB CLIENT ACCEPT
	ai_SRV_ENABLE[Ci_LNK_KKFINISH_ON_KONG] = faux
		
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()

	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_grab_grimpe		// VINCE
	// CAMERA -----------------------------------------------------------------

	f_climb_rapide_blend = 0.0
	v_climb_normale = - @o_climb_0D_wp OBJ_SightGet()
//	v_climb_position = @o_climb_0D_wp OBJ_PosGet()

	// CAlcul position destination

	// Normale a la face Horizontale
	v_climb_normale.z = 0.0
	tf_norm = MATH_VecNorm( v_climb_normale)
	if ( !MATH_FloatNullEpsilon(tf_norm))
		v_climb_normale /= tf_norm
	// Recherche du vecteur dans le sens de l Edge
	tv_horiz = MATH_VecCrossProduct( v_climb_normale , Cv_VerticalVector)
	tv_horiz *= MATH_FloatSign( MATH_VecDotProduct( tv_horiz , glob_joyvector_get))	
	// Position de remonting en fonction du joy : normale + Edge(sens joy)
	tv_horiz = v_climb_normale - tv_horiz 
	v_climb_position = @o_climb_0D_wp OBJ_PosGet() - ( tv_horiz  * 2.0)
	// A partir de la postition précédente recherche le Sol
	macro_render_Vector( v_climb_position + cvector( 0.0, 0.0, 2.0), cvector( 0.0, 0.0, -4.0), color_vert)
	if (COL_RayObject_Vector( v_climb_position + cvector( 0.0, 0.0, 2.0), cvector( 0.0, 0.0, -4.0), all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		v_climb_position = COL_RayObject_PosGet()	
	else
	{
		tv_horiz = v_climb_normale
		v_climb_position =  @o_climb_0D_wp OBJ_PosGet() - ( v_climb_normale * 2.0)
		if (COL_RayObject_Vector(  v_climb_position + cvector( 0.0, 0.0, 2.0), cvector( 0.0, 0.0, -4.0), all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
			v_climb_position = COL_RayObject_PosGet()
	}
	v_climb_normale = tv_horiz
	macro_render_Vector( v_climb_position, Cv_VerticalVector, color_rouge)
	DYN_GravitySet(Cv_NullVector)
	DYN_SpeedSetVector( Cv_NullVector)
	ACT_ActionSet( Ci_Kanim_climb_fast)
	COL_ColSetActivationSet( none, C_bit_zdm_pied)	
	
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

v_climb_speed = Cv_NullVector

// ANALYSE ======================================================================
AI_Execute("k_exec_detect_paf")
if ( o_paf_actor)
{
	PAF_Test_ChangeEtatValid(fct_track_change)
	if( fct_track_change != nofunc )
		macro_change_etat(fct_track_change)
}
 
//AI_Execute("k_exec_joy")


tv_sens = v_climb_position - OBJ_PosGet()

//if ( MATH_VecNorm(tv_sens) < 0.1)
if ( MATH_VecDotProduct( tv_sens, -v_climb_normale) < 0)
{
	tv_speed = DYN_SpeedGetVector()
	tv_speed.z = 0.0
	DYN_SpeedSetVector(tv_speed)

	f_time_collide_ground = 0.0

	macro_change_etat("k_ETAT_main")
}

// COMPORTEMENT ================================================================

//if ( f_joy_norm)
//	v_climb_normale = -glob_joyvector_get
	
tv_new_sight = MATH_VecBlendRotate(OBJ_SightGet(), -v_climb_normale, 10.0 * TIME_GetDt())
OBJ_BankingGeneralSet(tv_new_sight, Cv_VerticalVector)

MATH_VecSetNormalize(tv_sens )
OBJ_PosSet( OBJ_PosGet() + ( tv_sens * ( f_climb_rapide_blend * TIME_GetDt())))

f_climb_rapide_blend += 30.0* TIME_GetDt()
