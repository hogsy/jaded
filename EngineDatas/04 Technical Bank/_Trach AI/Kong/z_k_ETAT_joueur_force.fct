#include"k_define.var"

vector		tv_axis, tv_joy 
vector		tv_pos 
int				ti_status 
int				ti_action_grab_force
int 			ti_action
int 			ti_action_ref

float			tf_dot
float			tf_grab
float			tf_sens
float			tf_delta_grab
messageid	tmid
object		to_canal

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux

	// Couper la liaison
	ao_CL[Ci_LNK_KKGRAB_FORCE] = LNK_ClientGet(Ci_LNK_KKGRAB_FORCE, amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], faux, nofunc, nofunc, nofunc)
	AI_CBDel( o_grabbed_CBADD, CallBack_After_Blend, "k_exec_Ik_GrabForce")	
	o_grabbed_CBADD = nobody
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_joueur_force) 
{
	i_etat_courant = ETAT_joueur_force
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	o_grabbed_CBADD = ao_CL[Ci_LNK_KKGRAB_FORCE]
	AI_CBAdd( o_grabbed_CBADD, CallBack_After_Blend, "k_exec_Ik_GrabForce")	
	f_time_start_etat = 0.0

	i_exit_mode = faux
	i_old_action = -1 // Blend de position à l'init.

	OBJ_CapaSet(none,OBJ_Capa_0)

	if( LNK_GrabStatusGet( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE]) == Ci_LNK_GrabStatus_TREX_TT)
		ACT_ActionSet( Ci_Kanim_GrabTT_att)
	else
		ACT_ActionSet(Ci_Kanim_grab_devant)

	
	f_grab_blend_pos = 0.0
	f_grab_blend_main = 0.0
	f_force_time_move = 0.0
	v_force_init_grab = OBJ_PosGet()
	LNK_GrabMaxSet( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], 1.0)
	id_force = MSG_GlobalGetMsg( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE]).msg_id
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE =======================================================================

// Le PAF est prio sur les changements de mode.
AI_Execute("k_exec_detect_paf")
if (o_paf_actor)
{
	PAF_Test_ChangeEtatValid()
	return
}

// ACTION ORDONNEE PAR LA CIBLE
if (!i_exit_mode)
{
	// Choix de l action a effectuer: cette action s enchaine avec la fin du mode grab
	ti_action_grab_force = MSG_GlobalGetInt(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], INT2)
	ti_action_grab_force &= 0x0FFF
	switch (ti_action_grab_force)
	{
		case Ci_grabbed_mode_CTG_retourne_rate :						// Action: Essayer du cote gauche de renverser la cible mais ca marche pas
			ACT_ActionSet( Ci_Kanim_GrabCTE_retourneG_rate )
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_CTD_retourne_rate :						// Action: Essayer du cote droit de renverser la cible mais ca marche pas
			ACT_ActionSet( Ci_Kanim_GrabCTE_retourneD_rate )
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_TT_tire_renvers :								// Action: Donner un accout pendant que la cible est tiré par la tête pour la renverser
			ACT_ActionSet( Ci_Kanim_GrabTT_tire_renvers )
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_TT_tire_rate :									// Action: Tomber car la cible a été tiré par la tête trop longtemps
			ACT_ActionSet( Ci_Kanim_GrabTT_tire_rate)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_TT_ejectedG :								// Action: Propulser la tête de la cible sur le coté gauche(a partir de la prise tête)
			ACT_ActionSet( Ci_Kanim_GrabTT_jetteG)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_TT_ejectedD :								// Action: Propulser la tête de la cible sur le coté droite(a partir de la prise tête)
			ACT_ActionSet( Ci_Kanim_GrabTT_jetteD)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_TT_rateG :										// Action: chuter sur la gauche, la prise tête a laché
			ACT_ActionSet( Ci_Kanim_GrabTT_rateG)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_TT_rateD :										// Action: chuter sur la droite, la prise tête a laché
			ACT_ActionSet( Ci_Kanim_GrabTT_rateD)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_VTR_croche :								// Action: propulser la cible en avant
			ACT_ActionSet( Ci_Kanim_GrabVTR_croche)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_CTD_desequilibre :							// Action: propulser la cible quand elle est prise coté droit
			ACT_ActionSet( Ci_Kanim_GrabCTE_jeteD)
			i_exit_mode = vrai
			break
		case Ci_grabbed_mode_CTG_desequilibre :							// Action: propulser la cible quand elle est prise coté gauche
			ACT_ActionSet( Ci_Kanim_GrabCTE_jeteG)
			i_exit_mode = vrai
			break
	}
}	

int		ti_flag_grab
ti_flag_grab = i_flag_grab
if (i_exit_mode)
	ti_flag_grab = faux


ao_CL[Ci_LNK_KKGRAB_FORCE] = LNK_ClientGet(Ci_LNK_KKGRAB_FORCE, amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], ti_flag_grab, nofunc, nofunc, nofunc)
if (!ao_CL[Ci_LNK_KKGRAB_FORCE] || id_force != MSG_GlobalGetMsg( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE]).msg_id)
{
	if (ACT_CustomBitTest(0b00000001))
	{
		// Ce bit force la fin de l'anim en cours a se terminer avant de quitter le mode.
		if (ACT_ActionFinished())
			macro_change_etat( "k_ETAT_joueur_deplacement")
		else
			return
	}
	else
		macro_change_etat( "k_ETAT_joueur_deplacement")		// l'anim en cours est interrompue sans attendre la fin
}

// COMPORTEMENT =================================================================	
LNK_GrabVectorSet( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], glob_joyvector_get)

ti_status = 	LNK_GrabStatusGet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE])
if (ti_status == Ci_LNK_GrabStatus_Souleve)
{
	// Levé et lancé de pierre(exe)
	if (i_flag_just_intimidateD || i_flag_just_intimidateG)
	{
		// Action X demandé : lancer la pierre(exe)
		LNK_GrabStatusSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], Ci_LNK_GrabStatus_Lance)
		ACT_ActionSet(Ci_Kanim_grab_lance)
	}
	i_force_status = Ci_LNK_GrabStatus_Souleve
	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_grab_lance
	// CAMERA -----------------------------------------------------------------

	// Lever la pierre(exe)
	ACT_ActionSet(Ci_Kanim_grab_souleve)
	// Rotation	tv_joy = IO_JoyGetMove()
	if ( MATH_AbsFloat(tv_joy.x) > tolerance_joynull )
	{
		tv_joy.x = tv_joy.x - (MATH_FloatSign(tv_joy.x) * tolerance_joynull)
		tv_joy.x *= 1.5
		OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), -OBJ_HorizonGet()*MATH_FloatSign(tv_joy.x), MATH_AbsFloat(tv_joy.x) * TIME_GetDt()),Cv_VerticalVector)
	}
}
else if (ti_status == Ci_LNK_GrabStatus_Pause)
{
	// EN Grab mais sans anim particuliere
 	i_force_status = Ci_LNK_GrabStatus_Pause
	ACT_ActionSet(Ci_Kanim_Attente)
}
else if (ti_status == Ci_LNK_GrabStatus_TREX_TT)
{
	i_force_status = Ci_LNK_GrabStatus_TREX_TT
	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_grab_dyno
	// CAMERA -----------------------------------------------------------------

	LNK_GrabVectorSet( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], glob_joyvector_get)

	// CALCUL position et orientation pour les grab
	to_canal = @ao_CL[Ci_LNK_KKGRAB_FORCE] ANI_CanalObjectGet( Anim_Canal_Grab_Target)
	// Position
	tv_pos = @to_canal OBJ_PosGet()
	tv_axis = tv_pos - @ao_CL[Ci_LNK_KKGRAB_FORCE] OBJ_PosGet()			//		tv_axis *= 0.5
	tv_axis = (tv_axis*0.7) + ((tv_axis*0.3) / @ao_CL[Ci_LNK_KKGRAB_FORCE] OBJ_ZoomGet())
	tv_pos = @ao_CL[Ci_LNK_KKGRAB_FORCE] OBJ_PosGet() + tv_axis
	tv_pos.z = OBJ_PosGet().z
	// Orientation
	tv_axis = @to_canal OBJ_SightGet()

	// Si l'anim de la cible change il faut recommencer le blend de position a partir de l a position actuelle.
	ti_action_ref = @ao_CL[Ci_LNK_KKGRAB_FORCE] ACT_ActionGet()
	if ( ti_action_ref != i_old_action)
	{
		// Nouvelle anim: definition des arametre de blend position
		v_force_init_grab = OBJ_PosGet()	// Nouvelle position init
		f_grab_blend_pos = 0.0						// blend repart de 0.0 a partir de la nouvelle position
	}
	i_old_action = ti_action_ref

	// ACTION ORDONNEE PAR LA CIBLE
	ti_action_grab_force = MSG_GlobalGetInt(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_FORCE], INT2)

	// *** ATTENTE D 1 TRAME ***
	// Lorsque l anim est fini on ne sait pas quoi faire car c'est la cible qui donne l ordre: attendre 1 trame ...
	if ( ACT_ActionFinished())
		i_force_wait_info ++
	else 
		i_force_wait_info = 0
	if ( i_force_wait_info == 1)
		ti_action_grab_force = -1
	// *** ATTENTE D 1 TRAME ***
	
	// Choix de l action a effectuer: cette action ne s enchaine pas avec la fin du mode	grab
	switch( ti_action_grab_force)
	{
		case Ci_grabbed_init :									// Action : petit bond pour attraper la cible
			if (ACT_ActionGet() != Ci_Kanim_Grab_recal)
				ACT_ActionSet( Ci_Kanim_Grab_recal )
			break
		case Ci_grabbed_mode_TT_neutre :				// Action : tenir la cible par la tête
			if ( ACT_ActionFinished())
				ACT_ActionSet( Ci_Kanim_GrabTT_att)
			break
		case Ci_grabbed_mode_TT_desequilibreD :		// Action :faire pencher la cible sur la droite en pise tête
			ACT_ActionSet( Ci_Kanim_GrabTT_renversD)
			break
		case Ci_grabbed_mode_TT_desequilibreG :		// Action :faire pencher la cible sur la gauche en pise tête
			ACT_ActionSet( Ci_Kanim_GrabTT_renversG)
			break
		case Ci_grabbed_mode_TT_tire :					// Action : faire avancer la cible en la tirant par la tête
			ACT_ActionSet( Ci_Kanim_GrabTT_tire)
			break
		case Ci_grabbed_mode_VTR_attente :			// Action : tenir la cible par le ventre
			ACT_ActionSet( Ci_Kanim_GrabVTR_att)
			break
		case Ci_grabbed_mode_VTR_pousse :			// Action: pousser la cible par le ventre
			ACT_ActionSet( Ci_Kanim_GrabVTR_pousse)
			break
		case Ci_grabbed_mode_CTD_neutre :				// Action: tenir la cible par le coté droit
			ACT_ActionSet( Ci_Kanim_GrabCTE_attD)
			break
		case Ci_grabbed_mode_CTD_pousse :			// Action: posser la cible en étant coté droit
			ACT_ActionSet( Ci_Kanim_GrabCTE_pousseD)
			break
		case Ci_grabbed_mode_CTG_neutre :				// Action: tenir la cible par le coté gauche
			ACT_ActionSet( Ci_Kanim_GrabCTE_attG)
			break
		case Ci_grabbed_mode_CTG_pousse :			// Action: posser la cible en étant coté gauche
			ACT_ActionSet( Ci_Kanim_GrabCTE_pousseG)
			break		
	}
}
else
{
	i_force_status = 0
	// CAMERA -----------------------------------------------------------------
	@get_global i_kong_camera_status = Ci_Kcamera_grab_arbre
	// CAMERA -----------------------------------------------------------------


	// A METTRE A JOUR AVEC BIT POUR GARDER LA LOGIQUE CF DESSOUS
	tv_axis = @ao_CL[Ci_LNK_KKGRAB_FORCE] OBJ_PosGet() - OBJ_PosGet()
	tv_axis.z = 0
	MATH_VecSetNorm( tv_axis, 2.5)
	OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),tv_axis,10 * TIME_GetDt()),Cv_VerticalVector)
	tv_pos =  @ao_CL[Ci_LNK_KKGRAB_FORCE] OBJ_PosGet()
	tv_pos.z = OBJ_PosGet().z
	OBJ_PosSet(MATH_VecBlend(OBJ_PosGet(),tv_pos-tv_axis, 10.0 * TIME_GetDt()))
}	


if (ACT_CustomBitTest(0b00000010))
{
	// Orientation et position
	OBJ_PosSet(MATH_VecBlend( v_force_init_grab, tv_pos, f_grab_blend_pos))
	if (  ti_action_grab_force != Ci_grabbed_init)
		OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),tv_axis, 10 * TIME_GetDt()),Cv_VerticalVector)
	else
		OBJ_BankingGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(),tv_axis, 7 * TIME_GetDt()),Cv_VerticalVector)	
}