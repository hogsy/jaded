#include "k_define.var"


#define macro_limit_jump	\
if( @o_colonne OBJ_CapaTest( OBJ_Capa_10))\
{\
	if ( MATH_VecDotProduct( @o_colonne OBJ_SightGet(), tv_sight) > Cf_Cos45)\
		goto SAUTEND \
}\
if( @o_colonne OBJ_CapaTest( OBJ_Capa_11))\
{\
	if ( MATH_VecDotProduct( @o_colonne OBJ_HorizonGet(), tv_sight) > Cf_Cos45)\
		goto SAUTEND \
}\
if( @o_colonne OBJ_CapaTest( OBJ_Capa_12))\
{\
	if ( MATH_VecDotProduct( -@o_colonne OBJ_SightGet(), tv_sight) > Cf_Cos45)\
		goto SAUTEND \
}\
if( @o_colonne OBJ_CapaTest( OBJ_Capa_13))\
{\
	if ( MATH_VecDotProduct( -@o_colonne OBJ_HorizonGet(), tv_sight) > Cf_Cos45)\
		goto SAUTEND \
}	

int			ti_colon_orient
int			ti_colon_test_button
int			ti_colonne_jump
int			ti_ind
int			ti_limit

float		pf_dot_S
float		tf_dot

vector	tv_sens_lance
vector	tv_sens
vector	tv_sight 

object	to_bone
object	to_ride_actor


COL_ColSetActivationSet( none, C_bit_zdm_pied)
DYN_GravitySet( Cv_NullVector)
to_bone = ANI_CanalObjectGet(Anim_Canal_Snap_Bassin)
v_colonne_bone_pos = @to_bone OBJ_PosGet()

if ( RIDE_Get_Actor_Nb() > 2 )
//&& ACT_ActionGet() != Ci_Kanim_Colonne_Pos_Ann
//&& ACT_ActionGet() != Ci_Kanim_Colonne_Prend_Ann)
{
	// Trop de ride actor : décrocher
 	i_jump_force_chute = faux
	i_jump_force_anim_cycl = Ci_Kanim_saute_chute_paf_chute
	i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
	i_jump_force_anim_impulsion = Ci_Kanim_saute_chute_paf
	i_jump_force_no_orient_impulsion = vrai
	v_jump_force_chute_orient = Cv_NullVector
	f_jump_force_amplitude = 1.5 // Saut cloche
	i_jump_force_zdm_impulsion = faux
	i_jump_check_hotspot = faux	// Rien detecté, tester apres l impulsion
	i_jump_check_hotspot_fight = faux	// On peux enchainer sur un ennemi
	f_jump_force_hauteur = 2.0 	// Saut a l opposé du mur
	i_walling_action_impulsion_before_jump = vrai // pas rétablir la gravité
	v_jump_force_sens = -OBJ_SightGet()
	macro_change_etat("k_ETAT_jump")
}

ti_colon_test_button = faux
ti_colonne_jump = faux
switch ( ACT_ActionGet() )
{
	case Ci_Kanim_Colonne_Reception :
		if ( ACT_ActionFinished())
		{
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		}					
		else
		{
			v_colonne_pos_end.z = OBJ_PosGet().z
			v_colonne_pos_init.z = v_colonne_pos_end.z
			f_colonne_pos_blend = MATH_FloatMin( f_colonne_pos_blend + (5.0 * TIME_GetDt()), 1.0)
		}
		ti_colon_orient = vrai		
		break		
	case Ci_Kanim_Colonne_Grab :
		if ( ACT_ActionFinished())
		{
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		}					
		else
		{
			if ( !i_GrabKong_posset_allowed && ANI_NbFrameGet(0) > 15 
			&& GRAB_Propose(Ci_GrabKong_Type_Petit + Ci_GrabKong_Type_Souche))
				{
				// J'attrape un object léger : raptor
				i_GrabKong_raptor_test = faux 	// Grab reussi, ne plus tester
				i_flag_grab_raptor_en_cours = vrai	// Le test de cette variable est avant pour permettre 1 trame avec le BoneSet a nobody -> init a 0 de la variable de blend de pos sur le raptor
				if ( LNK_GrabKong_TypeGet( amid_CL_LIAISON_ID_GRABKONG[0]) & Ci_GrabKong_Type_Petit)
				{
					// l'IK du bras activée
					i_Grab_Torse_Main = 0 
					LNK_GrabKong_BoneSet( amid_CL_LIAISON_ID_GRABKONG[0], ANI_CanalObjectGet(Anim_Canal_MainDroite))
					i_GrabKong_posset_allowed = vrai
				}
			}					
		}				
		break
	case Ci_Kanim_Colonne_Lance :
		if ( ACT_ActionFinished())
		{
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		}					
		else
		{
			// JETER	
			if ( i_Grab_Torse_Main != -1 && f_colonne_time_lance > 0.3) //ACT_ActionItemGet())
			{
				v_frappe_sight = - OBJ_HorizonGet()
				tv_sens_lance = v_frappe_sight			// sens du lancer mémorisé à l'init du mode
				i_Grab_Torse_Main = -1					// libère la main

				// AIDE AU TIR
				o_Throw_Target = nobody
				// Prio a ceux qui attaquent Ann
				i_Throw_Target = Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, Cf_Cos60, 6.0, 20.0, o_Throw_Target, vrai, C_AIDE_AU_TIR_Prio_AttackAnn, C_AIDE_AU_TIR_Prio_GrabAnn, C_AIDE_AU_TIR_Bit_Only_On_Screen)
				
				// Sinon prendre ce qui reste
				if ( !o_Throw_Target)
					i_Throw_Target = Proc_KongFight_TargetBestSightGet( OBJ_PosGet(), v_frappe_sight, Cf_Cos60, 6.0, 20.0, o_Throw_Target, vrai, C_AIDE_AU_TIR_Prio_Min, C_AIDE_AU_TIR_Prio_Ennemi, C_AIDE_AU_TIR_Bit_Only_On_Screen)

				if( o_Throw_Target )
				{
					LNK_GrabKong_LanceTargetSet( amid_CL_LIAISON_ID_GRABKONG[0], i_Throw_Target)	// Cible precise
					to_bone = @o_Throw_Target ANI_CanalObjectGet(Anim_Canal_Tete)
					if( ! to_bone )
						to_bone = o_Throw_Target			// structures
					tv_sens_lance = @to_bone OBJ_PosGet() - @o_Throw_Target OBJ_PosGet()
				}
				else
					o_Throw_Target = nobody
				LNK_GrabKong_LanceObjectSet( amid_CL_LIAISON_ID_GRABKONG[0], o_Throw_Target)	// Cible precisee
				i_GrabKong_MainActionGrab = 0
				SWEEP_Change_To_Lance( tv_sens_lance, vrai, faux, faux)
			}
			else
				f_colonne_time_lance += TIME_GetDt()
		}
		break
	case Ci_Kanim_Colonne_Mord :
		if ( ACT_ActionFinished())
		{
			Proc_KK_Send_Paf( C_EVENT_FILTER_Object, C_PAF_KK_KiTue, OBJ_Me(), Cf_EVENT_Duree_1Trame, ao_CL_GRABKONG[0], -1, 2.0, OBJ_SightGet(), OBJ_PosGet())
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		}
		break
//	case Ci_Kanim_Colonne_Pos_Ann :
//		if ( ACT_ActionFinished())
//		{
//			i_Grab_Torse_ANN = faux
//			i_Grab_Torse_Actor = faux
//			i_Grab_Torse_Main = -1		
//			i_Grab_Torse_Actor = faux
//			ACT_ActionSet( Ci_Kanim_Colonne_Att)
//		}					
//		else
//		{
//			if ( ANI_CurrentFrameGet(0) > 25)
//			{
//				i_Grab_Torse_ANN = faux
//				i_Grab_Torse_Actor = faux
//				i_Grab_Torse_Main = -1				
//			}
//			if ( ANI_CurrentFrameGet(0) > 60 &&  MSG_GlobalIsValid( amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT]))
//				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Depose)
//		}
//		ti_colon_orient = faux
//		ti_colon_orient = 2
//		break
//	case Ci_Kanim_Colonne_Prend_Ann :
//		if ( ACT_ActionFinished())
//		{
//			ACT_ActionSet( Ci_Kanim_Colonne_Att)
//			i_Grab_Torse_Main = 0 // IK
//		}				
//		else
//		{
//			if ( ANI_CurrentFrameGet(0) < 30)
//			{
//				i_Grab_Torse_Actor = 0
//				i_Grab_Torse_Main = -1
//				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Attrappe_Attend)	
//			}
//			else
//			{
//				if ( !i_Grab_Torse_ANN)
//				{
//					// KONG porte ANN sur son épaule
//					LNK_KKGrabObject_BoneSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT],  ANI_CanalObjectGet(Anim_Canal_Snap_Ann) )
//					LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Porte_Epaule)
//				}
//				else
//					LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_Porte_Main)
//				
//			}
//		}
//		ti_colon_orient = faux
//		break
	case Ci_Kanim_Colonne_Grimpe :
		if ( ACT_ActionFinished())
		{
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		}					
		else
		{
			v_colonne_pos_end.z = OBJ_PosGet().z
			v_colonne_pos_init.z = v_colonne_pos_end.z
			f_colonne_pos_blend = MATH_FloatMin( f_colonne_pos_blend + (5.0 * TIME_GetDt()), 1.0)
		}
		ti_colon_orient = vrai
		if ( ANI_CurrentFrameGet(0) < 160)
			ti_colon_test_button = faux
		else
			ti_colon_test_button = vrai
		break
	case Ci_Kanim_Colonne_Att :

		ti_colon_test_button = vrai
		ti_colon_orient = vrai

		tv_sens = OBJ_PosGet() - @o_colonne OBJ_PosGet()
		MATH_VecSetHorzNormalize(tv_sens)
		pf_dot_S = MATH_VecDotProduct(  v_colonne_best_axe, tv_sens )
		if( f_joy_norm || pf_dot_S  < Cf_Cos45) 
			ti_colon_orient  = COLONNE_Choix_Best_Axe()
		break
	case Ci_Kanim_Colonne_FrappeD :
		if ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered( C_Button_All))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				STATS_IncAttack()
				ACT_ActionSet(Ci_Kanim_Colonne_FrappeG)			
			}
			else if ( KBUFFER_Buffered( C_Button_Action))
				ti_colonne_jump = vrai
			KBUFFER_DEL_ALL()
		}
		if ( ACT_ActionFinished())
			ACT_ActionSet( Ci_Kanim_Colonne_FrappeDFin)
		ti_colon_orient = 2
//		if( f_joy_norm && ! i_colonne_blend_coup) 
//			ti_colon_orient  = COLONNE_Choix_Best_Axe()
		break		
	case Ci_Kanim_Colonne_FrappeDFin :
		if ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered( C_Button_All))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				int ti_frame 
				ti_frame = ANI_CurrentFrameGet(0)
				ACT_ActionFrameSet(Ci_Kanim_Colonne_FrappeG, ti_frame)
			}
			else if ( KBUFFER_Buffered( C_Button_Action))
				ti_colonne_jump = vrai
			KBUFFER_DEL_ALL()
		}
		if ( ACT_ActionFinished())
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		ti_colon_orient = 2
		if( f_joy_norm && ! i_colonne_blend_coup) 
			ti_colon_orient  = COLONNE_Choix_Best_Axe()
		break		
	case Ci_Kanim_Colonne_FrappeG :
		if ( KBUFFER_Zone_Interrupt() && KBUFFER_Buffered( C_Button_All))
		{
			if ( KBUFFER_Buffered( C_Button_Coup))
			{
				STATS_IncAttack()
				ACT_ActionSet(Ci_Kanim_Colonne_FrappeD)
			}
			else if ( KBUFFER_Buffered( C_Button_Action))
				ti_colonne_jump = vrai
			KBUFFER_DEL_ALL()
		}
		if ( ACT_ActionFinished())
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		ti_colon_orient = 2
		if( f_joy_norm && ! i_colonne_blend_coup && ACT_ActionItemGet()) 
			ti_colon_orient  = COLONNE_Choix_Best_Axe()
		break		
	case Ci_Kanim_Colonne_TourneD :
	case Ci_Kanim_Colonne_TourneG :
		if ( ACT_ActionFinished())
			ACT_ActionSet( Ci_Kanim_Colonne_Att)
		ti_colon_orient = faux
		ti_colon_test_button = vrai
		break
}


if ( ti_colon_test_button || ti_colonne_jump)
{
	// DETECTION SAUT
	if ( i_flag_just_Action || ti_colonne_jump)
	{	
		// INTERDICTION DE CERTAINS AXES POUR LE SAUT
		if ( f_joy_norm)
		{
			tv_sens = -( OBJ_SightGet() + OBJ_HorizonGet()) * 0.5
			tv_sight = MATH_VecInCone( v_joy_sight_normalized, tv_sens, Cf_1Degre * 45.0, 0)
			DBG_RenderVector( OBJ_PosGet(), tv_sight * 5.0, color_bleu)
			HOTSPOT_Detect( tv_sight, vrai)

	 		if ( o_jump_hotspot)
			{
				
				// HOPTSPOT
				f_time_collide_ground = 0.0 // Forcer un saut
				i_jump_force_no_impulsion = faux // Jouer d anim d impulsion
				i_jump_force_no_orient_impulsion = vrai // Ne pas orienter pendant le saut
				tv_sens = @o_jump_hotspot OBJ_PosGet() - OBJ_PosGet()
				
			
				// INTERDICTION DE CERTAINS AXES POUR LE SAUT
//				tv_sight = tv_sens
//				macro_limit_jump

				MATH_VecSetHorzNormalize( tv_sens)
				if ( MATH_VecDotProduct( tv_sens, -OBJ_SightGet()) < MATH_VecDotProduct( tv_sens, -OBJ_HorizonGet()))
					i_jump_force_anim_impulsion = 	Ci_Kanim_Colonne_SautG
				else
					i_jump_force_anim_impulsion = Ci_Kanim_Colonne_Saut
						
				i_jump_check_hotspot = faux	// On peux enchainer les HOT SPOT
				f_jump_force_hauteur = -2.0 	// Saut a -1m au dessus du HS
				i_jump_force_zdm_impulsion = faux
				f_jump_force_amplitude = 0.0 
				DYN_SpeedSetVector(-OBJ_SightGet() * 2.0)
				macro_change_etat("k_ETAT_jump")
			}
			else
			{
	
				// INTERDICTION DE CERTAINS AXES POUR LE SAUT
				macro_limit_jump
						
				f_time_collide_ground = 0.0 // Forcer un saut
				i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
				i_jump_force_no_orient_impulsion = vrai // Ne pas orienter pendant le saut
				i_jump_check_hotspot = faux	// On peux enchainer les HOT SPOT

				if ( MATH_VecDotProduct( tv_sight, -OBJ_SightGet()) < MATH_VecDotProduct( tv_sight, -OBJ_HorizonGet()))
					i_jump_force_anim_impulsion = 	Ci_Kanim_Colonne_SautG
				else
					i_jump_force_anim_impulsion = Ci_Kanim_Colonne_Saut
				i_jump_force_zdm_impulsion = faux
				v_jump_force_sens = -OBJ_SightGet()
				f_jump_force_amplitude = 0.0 
				f_jump_force_distance = 6.0
				macro_change_etat("k_ETAT_jump")
			}
		}
		else
		{
			// INTERDICTION DE CERTAINS AXES POUR LE SAUT
			tv_sight = -OBJ_SightGet()
			macro_limit_jump

			f_time_collide_ground = 0.0 // Forcer un saut
			i_jump_force_no_impulsion = faux	// Jouer d anim d impulsion
			i_jump_force_no_orient_impulsion = vrai // Ne pas orienter pendant le saut
			i_jump_force_anim_impulsion = Ci_Kanim_Colonne_Saut
			i_jump_check_hotspot = faux	// On peux enchainer les HOT SPOT
			i_jump_force_zdm_impulsion = faux
			f_jump_force_amplitude = 0.0 
			f_jump_force_distance = 2.0

			v_jump_force_sens = -OBJ_SightGet()
			macro_change_etat("k_ETAT_jump")
		}
		SAUTEND:
	}
	
	// DETECTON COUP
	if ( i_flag_just_coup)
	{
		switch ( ACT_ActionGet())
		{
			case Ci_Kanim_Colonne_TourneD :
				tv_sens = OBJ_PosGet() - @o_colonne OBJ_PosGet()
				MATH_VecSetHorzNormalize(tv_sens)
				pf_dot_S = MATH_VecDotProduct(  v_colonne_best_axe, tv_sens )
				if ( pf_dot_S  < Cf_Cos45)
				{
					// Tourner pour aller dans le meilleur axe
					if ( pf_dot_S < 0)
					{
						v_colonne_best_axe = MATH_VecRotate( v_colonne_best_axe, Cv_VerticalVector, -Cf_PiBy2)
					}
				}
				
			case Ci_Kanim_Colonne_TourneG :
				i_colonne_blend_coup = 1
				break
			default:
		}
		STATS_IncAttack()
		ACT_ActionSet(Ci_Kanim_Colonne_FrappeD)		
		KBUFFER_DEL_ALL()
	}

	// POSER ANN
	if ( i_flag_just_grab)
	{
		i_GrabAnn_Tested = faux		// Tester si Ann peux etre grab
		to_ride_actor = RIDE_Get_Actor( ti_ind)											// A t on un truc sur le dos
//		if ( ao_CL[Ci_LNK_KKGRAB_OBJECT] )
//		{
//			if ( ! @o_Joueur OBJ_CapaTest(OBJ_Capa_5))								//	ANN ne peux pas etre posée
//			{
//				LNK_KKGrabObject_TypeSet(amid_CL_LIAISON_ID[Ci_LNK_KKGRAB_OBJECT], Ci_KKGrabObject_PoseSol)
//				ACT_ActionSet( Ci_Kanim_Colonne_Pos_Ann)		// POSER ANN
//			}
//		}
//		else 
		if( i_Grab_Torse_Main != -1 )
		{
			f_colonne_time_lance = 0.0
			STATS_IncAttack()
			ACT_ActionSet( Ci_Kanim_Colonne_Lance)		// LANCER
		}
		else if( to_ride_actor)
		{
			i_GrabKong_Type = Ci_GrabKong_Type_Petit
			i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
			i_GrabKong_MainActionGrab = 0
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ThisClientGet( to_ride_actor, Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)		
			if ( ao_CL_GRABKONG[i_GrabKong_MainActionGrab] )
			{
				RIDE_Del_Actor( ti_ind)
			}
			ACT_ActionSet( Ci_Kanim_Colonne_Grab)			// GRABER
		}
		else if ( o_scolo_actor)
		{
			i_GrabKong_Type = Ci_GrabKong_Type_Petit
			i_GrabKong_Type &= ~Ci_GrabKong_Type_Finish
			i_GrabKong_MainActionGrab = 0
			ao_CL_GRABKONG[i_GrabKong_MainActionGrab] = LNK_ThisClientGet(o_scolo_actor, Ci_LNK_GRAB_KONG, amid_CL_LIAISON_ID_GRABKONG[i_GrabKong_MainActionGrab], vrai, "k_exec_grab_object_param", nofunc, nofunc)
			ACT_ActionSet( Ci_Kanim_Colonne_Grab)			// GRABER
		}
		else
		{
//			if ( GRAB_ANN_Propose())
//				ACT_ActionSet( Ci_Kanim_Colonne_Prend_Ann)	// CHOPPER ANN
//			else
				ACT_ActionSet( Ci_Kanim_Colonne_Grab)			// GRABER
		}
	}
	// TUER
	if ( i_flag_just_Rage)
	{
		if ( ao_CL_GRABKONG[0] && EVENT_LIFE_CurLifeGet( EVENT_LIFE_MSGID_Get( ao_CL_GRABKONG[0])) )
			ACT_ActionSet( Ci_Kanim_Colonne_Mord)
		else
			ACT_ActionSet(Ci_Kanim_Colonne_FrappeD)		
		STATS_IncAttack()
		KBUFFER_DEL_ALL()
	}
}


// ORIENTATION
if ( ti_colon_orient)
{
	tv_sight = @o_colonne OBJ_PosGet() - OBJ_PosGet()
	MATH_VecSetHorzNormalize( tv_sight)
	if ( f_colonne_pos_blend == 1.0)
	{
//		OBJ_Rotate_FromToBlend( -tv_sight, v_colonne_best_axe, 6.0 * TIME_GetDt())
		if ( ti_colon_orient == 2)
			OBJ_BankingGeneralSet( MATH_VecBlendRotate(OBJ_SightGet(), -v_colonne_best_axe, 8.0 * TIME_GetDt()), Cv_VerticalVector)				
		else
			OBJ_BankingGeneralSet( MATH_VecBlendRotate(OBJ_SightGet(), -v_colonne_best_axe, 4.0 * TIME_GetDt()), Cv_VerticalVector)				
	}
	else
		OBJ_BankingGeneralSet( MATH_VecBlendRotate(OBJ_SightGet(),  tv_sight, 8.0 * TIME_GetDt()), Cv_VerticalVector)				
}

tf_dot = MATH_VecDotProduct( v_colonne_best_axe, @o_colonne OBJ_SightGet())
if ( tf_dot < -Cf_Cos30)
	@o_colonne OBJ_CapaSet( 1, 7)
else if ( tf_dot > Cf_Cos30)
	@o_colonne OBJ_CapaSet( 3, 7)
else
{
	tf_dot = MATH_VecDotProduct( v_colonne_best_axe, @o_colonne OBJ_HorizonGet())
	if ( tf_dot < -Cf_Cos30)
		@o_colonne OBJ_CapaSet( 2, 7)
	else if ( tf_dot > Cf_Cos30)
		@o_colonne OBJ_CapaSet( 4, 7)			
}
COUP_Cancel_Mouvment()					
