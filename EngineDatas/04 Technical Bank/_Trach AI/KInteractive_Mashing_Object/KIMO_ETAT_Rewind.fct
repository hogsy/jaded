#include "KIMO_defines.var"
Include_UltraProcedure_Header


int			ti_mashing_result


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	ANI_Pause(faux)
	i_sort_etat = faux	
//	i_uncol = vrai
//	i_uncol_reactivation_wait = faux
//	o_uncol_actor = o_mashing_actor
//	o_mashing_actor = nobody
//	COL_ColMapActivationSet(C_bit_zdm_pied, none)

	// reactivate dynamic if 	
//	if (i_dyna_option == Ci_DynaOption_Dynamic)
//		AI_Execute("KIMO_exec_dyn_on")
//	f_pourcentage_init = f_pourcentage



	return
}


// INITIALISATION ETAT ==============================================================
if( i_etat_courant != ETAT_Rewind )
{
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Rewind
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0

	f_rewind_frame = f_pourcentage

//	o_mashing_actor = o_mashing_actor_tmp
//	if( o_mashing_actor != o_uncol_actor )
//		COL_UnCollidableAdd(o_mashing_actor)
//	if( ! i_ODE_ON )
//		DYN_Off()	// from now on animation controlls movement
//	i_mashing_LNK_accepte = vrai
//	f_time_last_mashing_grab = TIME_Get()
//	i_reinit = faux
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE =======================================================================

// la liaison est censée être active
o_mashing_actor_tmp = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_mashing_LNK_ID, i_mashing_LNK_accepte, "KIMO_exec_propose_grab", nofunc)
if( i_mashing_LNK_accepte && ! o_mashing_actor_tmp )
	AI_TrackCurChangeNow("KIMO_ETAT_Wait")

// COMPORTEMENT =======================================================================
switch (ACT_ActionGet())
{
	case Ci_Action_0 :
		AI_TrackCurChangeNow("KIMO_ETAT_Wait")
		break

	case Ci_Action_wait :
		AI_TrackCurChangeNow("KIMO_ETAT_Wait")
		break

	case Ci_Action_positionne :
			


		break
	case Ci_Action_challenge :
		break
	case Ci_Action_gagne :
		break
	case Ci_Action_perdu :
		break
}
