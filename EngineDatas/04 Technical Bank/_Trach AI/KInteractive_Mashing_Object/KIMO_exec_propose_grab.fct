#include "KIMO_defines.var"

messageid		tmid_proposition

object	to_serveur

float		tf_dist

vector	tv_vers_serveur
vector	tv_temp
vector	tv_sens
vector	tv_sens_orientation
vector	tv_position
vector	tv_temp2
vector	tv_pos
vector	tv_serverPos


tmid_proposition = pop

to_serveur = MSG_GlobalGetGao(tmid_proposition, SERVEUR)


if( LNK_GrabStatusGet(tmid_proposition) & Ci_GrabKong_Type_Mashing )
{
	// reçoit une demande de liaison de type Mashing
//	tv_serverPos = LNK_GrabPositionGet(tmid_proposition) 
	tv_serverPos = @to_serveur OBJ_PosGet()
	tv_serverPos -= MATH_VecLocalToGlobal(v_grab_pos_offset)
	DBG_RenderSphere(tv_serverPos, 1.0, color_bleu)

//	tv_vers_serveur = tv_serverPos - OBJ_LIB_Nearest_Volume_Pos( OBJ_Me(), cvector( -1.0, -1.0,0.0), cvector( 1.0,1.0,6.0), tv_serverPos )
	tv_vers_serveur = tv_serverPos - OBJ_PosGet()
	DBG_RenderVector(OBJ_PosGet(), tv_vers_serveur, color_bleu)
	
	tv_temp = tv_vers_serveur

	if( ! MATH_VecNullEpsilon(tv_temp) )
		tf_dist = MATH_VecDotProduct(tv_temp, tv_temp)
	else
		tf_dist = 0.001
	
	DBG_RenderVector(LNK_GrabPositionGet(tmid_proposition), - tv_temp, color_bleu)
	
	if( i_DBG_trace_propose_grab )
	{
		DBG_TraceObject(OBJ_Me())
		DBG_TraceString(" (dist ")
		DBG_TraceFloat(tf_dist)
		DBG_TraceString(") : ")
	}
	
	if ( tf_dist <= 121 && MATH_VecDotProduct(@to_serveur OBJ_SightGet(), tv_temp) < 0 )
	{
		// la distance est bonne
		MSG_GlobalSetVector(tmid_proposition, cvector( Cf_dist_grab_carre, 0.0, 0.0), VEC2, VEC_X)
		tv_sens = LNK_GrabVectorGet(tmid_proposition)
//		if( MATH_VecNullEpsilon(tv_sens) || (MATH_VecDotProduct(tv_sens, tv_temp) < 0.0) )
		{
//			AI_Execute("KIMO_InitFromKit")			// make sure settings are up to date

			// L'orientation est bonne
			tf_dist += Ci_Grab_Kong_Pond_MashingObject
			if( ( ! MATH_VecNullEpsilon(tv_sens) ) && MATH_VecDotProduct(tv_sens, tv_temp) > 0.0 )
			{
				tf_dist += Ci_Grab_Kong_Pond_Bad_Axe
				if( i_DBG_trace_propose_grab )
					DBG_TraceString("bad axe : ")
			}
			LNK_ClientPropose(tmid_proposition, tf_dist)
			if( i_DBG_trace_propose_grab )
				DBG_TraceFloat(tf_dist)
			LNK_GrabKong_TypeSet(tmid_proposition, Ci_GrabKong_Type_Mashing)
			LNK_GrabKong_Mashing_Result_Set(tmid_proposition, Ci_Kmashing_Result_Positionne)
			LNK_GrabKong_Mashing_Kit_Set(tmid_proposition, i_kit)
			LNK_GrabKong_Mashing_Challenge_Set(tmid_proposition, i_kit_Challenge_Type)
			if( i_reinit || i_kit_Challenge_Type != Ci_Kmashing_Type_Kong_Gagne_Toujours )
			{
				// se recale sur l'anim de kong dès le début lors du prochain grab
				f_pourcentage_init = 0.0
				v_pos_init = OBJ_PosGet()
			}
			LNK_GrabKong_Mashing_Anim_Percent_Set(tmid_proposition, f_pourcentage_init)
			LNK_GrabKong_Mashing_Orientation_Set(tmid_proposition, v_kit_Mashing_Orientation)
			tv_temp2 = MATH_VecLocalToGlobal(v_kit_Mashing_Position)
			DBG_RenderVector(OBJ_PosGet(), tv_temp2, color_rouge)
			tv_pos = v_pos_init + MATH_VecLocalToGlobal(v_kit_Mashing_Position)
			LNK_GrabKong_Mashing_Position_Set(tmid_proposition, tv_pos)
		}
	}
	else if( i_DBG_trace_propose_grab )
		DBG_TraceString("trop loin...")
	if( i_DBG_trace_propose_grab )
		DBG_TraceEOL()
}

