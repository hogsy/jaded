#ifndef _FINAL_
float		tf_Z_min

object	to_wp_1
object	to_wp_2
object	to_wp_3

vector	tv_vec1
vector	tv_vec2

vector	tv_normale
vector	tv_biscectrice

// On oriente le sight des wp du reseau de maniere à avoir la perpendiculaire de chaques sommets

to_wp_1 = o_1st_wp
to_wp_2 = WAY_NetNextWP(n_net, to_wp_1, 0, 0)
to_wp_3 = WAY_NetNextWP(n_net, to_wp_2, 0, 0)

@to_wp_1 OBJ_SightSet(@to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet())

switch(move_mode)
{
	case 0 :
		// Smooth trajectory
		while (! @o_1st_wp OBJ_CapaTest(OBJ_Capa_0) && to_wp_3)
		{
			tv_vec1 = @to_wp_1 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
			tv_vec2 = @to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet()
			
			tv_normale = MATH_VecCrossProduct(tv_vec1, tv_vec2)
			MATH_VecSetNormalize(tv_normale)
			
			tv_biscectrice = MATH_VecBlendRotate(tv_vec1, tv_vec2, 0.5)
			
			@to_wp_2 OBJ_SightSet(MATH_VecCrossProduct(tv_normale, tv_biscectrice))
			@to_wp_2 OBJ_CapaSet(OBJ_Capa_0, none)	
		
			to_wp_1 = to_wp_2
			to_wp_2 = to_wp_3
			to_wp_3 = WAY_NetNextWP(n_net, to_wp_3, 0, 0)
			if(to_wp_3 == WAY_RootGet(n_net)) break
		}
	
		break
		
	case 1 :
		// Straight trajectory
		while (! @o_1st_wp OBJ_CapaTest(OBJ_Capa_0) && to_wp_3)
		{
			@to_wp_2 OBJ_SightSet(@to_wp_3 OBJ_PosGet() - @to_wp_2 OBJ_PosGet())

			to_wp_1 = to_wp_2
			to_wp_2 = to_wp_3
			to_wp_3 = WAY_NetNextWP(n_net, to_wp_3, 0, 0)
			if(to_wp_3 == WAY_RootGet(n_net)) break
		}
		
		break
}		

if (!to_wp_3)	
	@to_wp_2 OBJ_SightSet(@to_wp_2 OBJ_PosGet() - @to_wp_1 OBJ_PosGet())

#endif