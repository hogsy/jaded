#include "PLC_Defines.var"
//------------------------------------------------------------------------------------------------------------------
//	Rotate an object on its visual pivot (= center of the BV)
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLC_Rotate(vector tv_Pivot,vector tv_RotVector,float tf_RotSpeed)
{
	vector v
	// get pivot's position before rotation
	v=OBJ_PosGet()+MATH_VecLocalToGlobal(tv_Pivot)
	// rotation
	OBJ_RotateAroundVec(tv_RotVector,tf_RotSpeed*dt)
	// restore pivot's position and add speed
	OBJ_PosSet(v-MATH_VecLocalToGlobal(tv_Pivot)+(Speed*dt))
}

//------------------------------------------------------------------------------------------------------------------
//	Return the current speed of this chunk
//------------------------------------------------------------------------------------------------------------------
procedure_ultra vector PLC_GetSpeed()
{
	return Speed
}

//------------------------------------------------------------------------------------------------------------------
//	Set the initial movement for this object
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PLC_SetMvt(vector CurrentSpeed,vector ImpactPos,vector ImpactSpeed)
{
	vector v
	float f
	dt=TIME_GetDt()
	// calculate the object visual pivot
	Pivot=(BV_MinGet()+BV_MaxGet())*0.5
	// get current speed
	Speed=CurrentSpeed
	if(MATH_VecNull(ImpactPos) || MATH_VecNull(ImpactSpeed))
	{
		// random
		RotVector=cvector(MATH_RandFloat(-1,1),MATH_RandFloat(-1,1),MATH_RandFloat(-1,1))
		RotSpeed=MATH_RandFloat(-Cf_Pi,Cf_Pi)
	}
	else
	{
		// add the impact to the speed
		Speed+=ImpactSpeed*C_PLC_ImpactEfficacity
		// add some noise
		Speed.x*=MATH_RandFloat(1-C_PLC_ImpactNoise,1+C_PLC_ImpactNoise)
		Speed.y*=MATH_RandFloat(1-C_PLC_ImpactNoise,1+C_PLC_ImpactNoise)
		Speed.z*=MATH_RandFloat(1-C_PLC_ImpactNoise,1+C_PLC_ImpactNoise)
		// get vector from pivot to impact pos.
		v=OBJ_PosGet()+MATH_VecLocalToGlobal(Pivot)-ImpactPos
		// make sur the impact pos. isn't too close to the pivot, or the movement is ugly
		f=MATH_FloatMax(3,MATH_VecNorm(v))
		// calculate rotation vector and rotation speed
		RotVector=MATH_VecCrossProduct(ImpactSpeed,v)
		RotSpeed=0.1*MATH_VecAngle(ImpactSpeed,v,RotVector)/f
//		// add initial shock by rotation the chunck
//		PLC_Rotate(Pivot,RotVector,RotSpeed*5)
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Make this object a propeler, with a special behaviour
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PLC_SetAsPropeler()
{
	// initial rotation speed
	RotSpeed=50
	// special behaviour
	AI_TrackChange(2,"PLC_bhv_propeler")
}

//------------------------------------------------------------------------------------------------------------------
//	Detach the propeler from the plane
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PLC_DropPropeler()
{
	object o
	// set delay to trigger the "woosh" sound
	TimerWoosh=TIME_Get()+C_PLC_DelayWoosh
	// get the camera
	o=VIEW_GetObject(0)
	// if the camera is in front of me
	if(o && MATH_RandFloat(0,1)<0.25 && MATH_VecDotProduct(MATH_VecNormalize(@o OBJ_PosGet()-OBJ_PosGet()),OBJ_SightGet())>Cf_Cos30)
	{
		// aim at the camera
		OBJ_SightSet(@o OBJ_PosGet()-OBJ_PosGet())
		// slow down the propeler
		RotSpeed=MATH_RandFloat(0.2,0.6)*C_PLC_Propeler_SpeedRot
		// set the speed and adjust the aiming
		Speed=(OBJ_SightGet()*MATH_RandFloat(13,18))
		Speed.z+=8
	}
	else
	{
		// set the speed norm on the current sight
		Speed=OBJ_SightGet()*RotSpeed*C_PLC_Propeler_SpeedY
	}
}