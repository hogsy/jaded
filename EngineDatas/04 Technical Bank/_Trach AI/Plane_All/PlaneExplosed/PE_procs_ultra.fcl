#include "PE_Defines.var"
// PlaneChunk ultra procedures
procedure_ultra void PLC_DropPropeler();
procedure_ultra void PLC_SetAsPropeler();
procedure_ultra void PLC_SetMvt(vector CurrentSpeed,vector ImpactPos,vector ImpactSpeed);

//------------------------------------------------------------------------------------------------------------------
//	Destroy all the chunks BUT NOT THE ITSELF
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PE_DestroyChunks()
{
	int i
	// for each chunck
	for(i=0;i<C_PE_NbChunks;i++)
	{
		// it its a valide object, destroy it then reset the pointer
		if(Dup[i])
		{
			@Dup[i] OBJ_Destroy()
			Dup[i]=nobody
		}
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Initialize all the chunks
//------------------------------------------------------------------------------------------------------------------
procedure_ultra object PE_Initialize()
{
	int i
	// for each chunck
	for(i=0;i<C_PE_NbChunks;i++)
	{
		// create a duplicate
		Dup[i]=@Chunks[i] OBJ_Duplicate(OBJ_PosGet())
		if(Dup[i])
		{
			// if it's the propeler, immediatly start its special behaviour
			if(i==C_PE_Propeler)
			{
				@Dup[i] PLC_SetAsPropeler()
			}
			// else make it inactive for now
			else
			{
				@Dup[i] OBJ_FlagInactiveSet(vrai)
			}
		}
		// set the default state
		Etat[i]=C_PE_State_Present
	}
	return Dup[C_PE_Carlingue]
}

//------------------------------------------------------------------------------------------------------------------
//	Drop a chunk
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PE_DropChunk(int n,vector CurrentSpeed,vector ImpactPos,vector ImpactSpeed)
{
	// if the chunck is still here and the pointer is valid
	if(Etat[n] && Dup[n])
	{
		// if its the propeler, drop it in a special way
		if(n==C_PE_Propeler)
		{
			@Dup[n] PLC_DropPropeler()
		}
		// else make it active and give it the mechanical parameters
		else
		{
			@Dup[n] OBJ_FlagInactiveSet(faux)
			@Dup[n] PLC_SetMvt(CurrentSpeed,ImpactPos,ImpactSpeed)
		}
		// set the state to "detached"
		Etat[n]=C_PE_State_Detached
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Explosion, drop some chunks according to probability rnd
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PE_Explode(float rnd,vector CurrentSpeed,vector ImpactPos,vector ImpactSpeed)
{
	int i
	vector v
	// start at 1, the body is never droped
	for(i=1;i<C_PE_NbChunks;i++)
	{
		// test the probability
		if(MATH_RandFloat(0,1)<=rnd)
		{
			// if its ok drop the chunck
			PE_DropChunk(i,CurrentSpeed,ImpactPos,ImpactSpeed)
		}
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Move the remaining chunks to follow the plane's movement
//------------------------------------------------------------------------------------------------------------------
procedure_ultra void PE_RejoinAndOrient(object plane)
{
	int i
	vector v
	object o
	// rejoin the plane
	OBJ_RejoinAndOrient(plane)
	// for each chunck
	for(i=0;i<C_PE_NbChunks;i++)
	{
		// if its not detached and the pointer is valid
		if(Etat[i] && Dup[i])
		{
			// if it's the propeler, move it but keep the banking
			if(i==C_PE_Propeler)
			{
				// get the plane's propeler bone
				o=@plane ANI_CanalObjectGet(1)
				// and copy its position and sight but keep the propeler's banking, because its turning
				if(o)
				{
					@Dup[C_PE_Propeler] OBJ_PosSet(@o OBJ_PosGet())
					@Dup[C_PE_Propeler] OBJ_SightGeneralSet(@o OBJ_SightGet(),@Dup[C_PE_Propeler] OBJ_SightGet())
				}
			}
			// else rejoin the plane
			else
			{
				@Dup[i] OBJ_RejoinAndOrient(plane)
			}
		}
	}
}