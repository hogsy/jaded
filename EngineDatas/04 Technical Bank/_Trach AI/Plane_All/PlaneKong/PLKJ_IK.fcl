#include "PLKJ_Defines.var"
//------------------------------------------------------------------------------------------------------------------
//	Move the head to look a target
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_HeadRotation()
{
	object Enemy
	object Head,Neck,Torso
	float RotZ
	#define C_RotZ_Max		(Cf_1Degre*70)
	#define C_NeckRotation	0.5
	Neck=ANI_CanalObjectGet(Anim_Canal_Cou)
	Head=ANI_CanalObjectGet(Anim_Canal_Tete)
	Enemy=PLKJ_GetClosestEnemy()
	if(Enemy && ~cb&C_PLKJ_CB_DontMoveHead)
	{
		RotZ=MATH_VecAngle(@Head OBJ_BankingGet(),@Enemy OBJ_PosGet()-@Head OBJ_PosGet(),cvector(0,0,1))
		RotZ=MATH_FloatLimit(RotZ,-C_RotZ_Max,C_RotZ_Max)
	}
	else
	{
		RotZ=0
	}
	HeadRotationZ=MATH_FloatBlend(HeadRotationZ,RotZ,dt*1.3)
	@Neck OBJ_RotateGlobalZ(HeadRotationZ*C_NeckRotation)
	@Head OBJ_RotateGlobalZ(HeadRotationZ*(1-C_NeckRotation))
}

//------------------------------------------------------------------------------------------------------------------
//	Initialization for IK: store bones lenghts
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_IK_Init()
{
	int		ti_i
	int		ti_k
	int		ti_membre_index	

	// Calcul de la longueur des membres...
	for (ti_i=0;ti_i<4;ti_i++)
	{
		switch(ti_i)
		{
			case Ci_IK_pied_gauche :
				ti_membre_index=Anim_Canal_PiedGauche
				break
			case Ci_IK_pied_droit :
				ti_membre_index=Anim_Canal_PiedDroit
				break
			case Ci_IK_main_gauche :
				ti_membre_index=Anim_Canal_MainGauche
				break
			case Ci_IK_main_droite :
				ti_membre_index=Anim_Canal_MainDroite
				break
		}	
	
		for (ti_k=0;ti_k<3;ti_k++)
			ao_IK_bones[ti_i][ti_k]=ANI_CanalObjectGet(ti_membre_index+(2-ti_k))
	
		af_IK_bones_length[ti_i][0]=MATH_VecNorm(@ao_IK_bones[ti_i][1] OBJ_PosGet() - @ao_IK_bones[ti_i][0] OBJ_PosGet())
		af_IK_bones_length[ti_i][1]=MATH_VecNorm(@ao_IK_bones[ti_i][2] OBJ_PosGet() - @ao_IK_bones[ti_i][1] OBJ_PosGet())
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Do the IK: move the body with the given offset the restore hands and foot pos.
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_ManageIK()
{
	int			i
	float		f
	vector	Sights[4]
	vector	Bankings[4]
	vector	Positions[4]
	object	B_Bassin
	#define Ci_bone_pos_index 2
	// update angle and offset
	IK_Offset=MATH_VecBlend(IK_Offset,Cv_NullVector,dt*2)
	IK_Angle=MATH_FloatBlend(IK_Angle,0,dt*2)
	// if I need some IK
	if(MATH_AbsFloat(IK_Angle)>0.01 || MATH_VecSquareNorm(IK_Offset)>0.0001)
	{
		// limit offset norm
		f=MATH_VecNorm(IK_Offset)
		if(f>0.2)
		{
			IK_Offset*=0.2/f
		}
		// limit offset on Y
		f=MATH_VecDotProduct(IK_Offset,OBJ_SightGet())
		if(f<0)
		{
			IK_Offset-=f*OBJ_SightGet()
		}
		// save fixed bones position
		for (i=0;i<4;i++)
		{
			Sights[i]=@ao_IK_bones[i][Ci_bone_pos_index] OBJ_SightGet()
			Bankings[i]=@ao_IK_bones[i][Ci_bone_pos_index] OBJ_BankingGet()
			Positions[i]=@ao_IK_bones[i][Ci_bone_pos_index] OBJ_PosGet()
		}
		// add the offset to the skeleton
		B_Bassin=ANI_CanalObjectGet(Anim_Canal_Bassin)
		@B_Bassin OBJ_PosSet(@B_Bassin OBJ_PosGet()+IK_Offset)
		@B_Bassin OBJ_RotateGlobalZ(MATH_FloatBlend(IK_Angle,0,IK_Angle))
		// do the IK
		for (i=0;i<4;i++)
		{
			OBJ_LIB_IK(	ao_IK_bones[i][0], ao_IK_bones[i][1],
								af_IK_bones_length[i][0], af_IK_bones_length[i][1],
								Positions[i],
								-@ao_IK_bones[i][1] OBJ_BankingGet(),
								1.0 )
			@ao_IK_bones[i][Ci_bone_pos_index] OBJ_BankingGeneralSet(Sights[i],Bankings[i])
		}
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Add an impact to the IK offset
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_IK_Impact(vector d)
{
	IK_Offset+=0.05*d
}

//------------------------------------------------------------------------------------------------------------------
//	Add a big impact to the IK offset
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_IK_BigImpact()
{
	IK_Angle=MATH_RandFloat(-1,1)*Cf_1Degre*2
}