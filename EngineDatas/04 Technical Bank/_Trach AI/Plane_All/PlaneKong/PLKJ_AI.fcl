#include "PLKJ_Defines.var"
//------------------------------------------------------------------------------------------------------------------
//	Read both joysticks plus the buttons
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_GetPlayerInputs()
{
	vector v
	object o
	// read left joystick
	v=-IO_JoyGetMove()
	// ignore low values (noise)
	if(MATH_VecSquareNorm(v)>C_PLKJ_Joy_Noise && MATH_AbsFloat(MATH_VecAngle(-CurrentDirection,OBJ_SightGet(),cvector(0,0,1)))<Cf_PiBy4)
	{
		// get direction in global world
		o=VIEW_GetObject(0)
		v=@o MATH_VecLocalToGlobal(v)
//		// turn 90° if a plane is grabed (because the aiming works differently)
//		if(PLKJ_IsPlaneGrabed())
//		{
//			v=MATH_VecRotate(v,cvector(0,0,1),Cf_PiBy2*MATH_FloatSign(MATH_VecAngle(OBJ_SightGet(),v,cvector(0,0,1))))
//		}
		// snap to the world (x,y) axis
		if(MATH_AbsFloat(v.x)>MATH_AbsFloat(v.y))
		{
			// snap on x axis
			JoyDirection.x=MATH_FloatSign(v.x)
			JoyDirection.y=0
		}
		else
		{
			// snap on y axis
			JoyDirection.x=0
			JoyDirection.y=MATH_FloatSign(v.y)
		}
		// calculate the angle with the current direction
		if(JoyDirection==CurrentDirection)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_None
		}
		else if(JoyDirection==-CurrentDirection)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_180
		}
		else if(MATH_VecAngle(CurrentDirection,JoyDirection,cvector(0,0,1))<0)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_Backward
		}
		else
		{
			JoyAngleWithDir=C_PLKJ_Rotation_Forward
		}
	}
	// or reset the direction
	else
	{
		CurrentDirection=NewDirection
		JoyDirection=Cv_NullVector
		JoyAngleWithDir=C_PLKJ_Rotation_None
	}
	// read right joystick
	Joy2Direction=IO_JoyGetMove1()
	if(MATH_VecSquareNorm(Joy2Direction)<C_PLKJ_Joy_Noise)
	{
		Joy2Direction=Cv_NullVector
	}
	// get buttons
	if(IO_ButtonJustPressed(C_PLKJ_Button_Grab))
	{
		JoyButton=C_PLKJ_Button_Grab
	}
	else if(IO_ButtonJustPressed(C_PLKJ_Button_Attack))
	{
		JoyButton=C_PLKJ_Button_Attack
	}
	else
	{
		JoyButton=C_PLKJ_Button_None
	}
}

//------------------------------------------------------------------------------------------------------------------
//	Calculate "Kong's joystick plus the buttons" inputs
//------------------------------------------------------------------------------------------------------------------
procedure_local void PLKJ_KongAI()
{
	float f
	object o
	JoyAngleWithDir=C_PLKJ_Rotation_None
	JoyButton=C_PLKJ_Button_None
	// if the closest enemy is very close
	if(PLKJ_IsEnemyVeryClose())
	{
		// if I can cut the current action
		if(ACT_ActionFinished() || cb&C_PLKJ_CB_Interruptible)
		{
			CurrentDirection=NewDirection
			// random choice between attack and grab
			if(MATH_RandFloat(0,1)<0.66)
			{
				JoyButton=C_PLKJ_Button_Attack
			}
			else
			{
				JoyButton=C_PLKJ_Button_Grab
			}
		}
		// set direction according to angle with enemy
		o=PLKJ_GetClosestEnemy()
		f=MATH_VecAngle(CurrentDirection,@o OBJ_PosGet()-OBJ_PosGet(),cvector(0,0,1))
		if(MATH_AbsFloat(f)>Cf_1Degre*135)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_180
		}
		else if(MATH_AbsFloat(f)<Cf_1Degre*45)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_None
		}
		else if(f>0)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_Forward
		}
		else
		{
			JoyAngleWithDir=C_PLKJ_Rotation_Backward
		}
	}
	// else choose random action
	else if(ACT_ActionFinished())
	{
		CurrentDirection=NewDirection
		f=MATH_RandFloat(0,1)
		if(f<C_PLKJ_AI_Wait)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_None
		}
		else if(f<C_PLKJ_AI_TurnForward)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_Forward
		}
		else if(f<C_PLKJ_AI_TurnBackward)
		{
			JoyAngleWithDir=C_PLKJ_Rotation_Backward
		}
		else if(f<C_PLKJ_AI_Attack)
		{
			JoyButton=C_PLKJ_Button_Attack
		}
		else
		{
			JoyButton=C_PLKJ_Button_Grab
		}
	}
}