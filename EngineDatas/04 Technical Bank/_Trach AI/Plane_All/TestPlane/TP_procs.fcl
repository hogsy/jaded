#include "TP_Defines.var"
procedure_ultra void PRO_SetFather(object o);
procedure_ultra void PRO_SetBig();

procedure_local void TP_SmokeFX(int type);

procedure_ultra void PLKJ_ForgetEnemy(object o);

procedure_local void TP_GenerateEnemies()
{
	int i
	object o
	vector v
	float f
	if(NbProjo && OBJ_CapaTest(1) && DelayNewWave<TIME_Get())
	{
		v=-SpawnDistance*@Kamera OBJ_SightGet()
		for(i=NbEnemies;i<C_TP_PlanesByGroup;i++)
		{
			o=@Enemy OBJ_Duplicate(OBJ_PosGet())
			if(o)
			{
				v=RefPos
				f=i*Cf_2Pi/C_TP_PlanesByGroup
				v.x+=MATH_Cos(f)*SpawnDistance
				v.y+=MATH_Sin(f)*SpawnDistance
				v.z+=MATH_RandFloat(-15,15)
				@o OBJ_PosSet(v)
				@o OBJ_SightSet(@RefObj OBJ_PosGet()-v)
			}
		}
		NbEnemies=C_TP_PlanesByGroup
		OBJ_CapaSet(0,1)
	}
}

procedure_local int TP_InDogFight()
{
	if(OBJ_CapaTest(1)) return faux
	return vrai
}

procedure_local void TP_SpeechSay(text t,float d,int rnd)
{
		SPEECH_RequestPost(
			OBJ_Me(),
			nobody,
			TEXT_FileGet(t),
			TEXT_EntryGet(t),
			d,											// delay available
			SPEECH_Cte_PriorityDefault,	// priority
			rnd,										// random
			0,
			0,
			0)
}

procedure_local void TP_Speech()
{
	text t
	float f
	int i
	if(AnnSpeech>0)
	{
		if(DelaySpeechAnn<0)
		{
			f=OBJ_SqrDist(RefObj)
			if(f<400)
			{
				DelaySpeechAnn=MATH_RandFloat(50,100)
				i=AnnSpeech
				AnnSpeech--
				TP_SpeechSay(txAnn[i],8.0,0)
				DelaySpeech+=4
			}
		}
		else DelaySpeechAnn-=dt
	}

	DelaySpeech-=dt
	if(DelaySpeech<0)
	{
		DelaySpeech=MATH_RandFloat(10,30)
		if(EngleHornSpeech<11 && TP_InDogFight())
		{
			if(MATH_RandFloat(0,1)<0.8)
			{
				t=txEnnemis[EngleHornSpeech]
				EngleHornSpeech++
			}
			else if(ClosestEnemy)
			{
				f=MATH_VecAngle(OBJ_SightGet(),@ClosestEnemy OBJ_PosGet()-OBJ_PosGet(),cvector(0,0,1))
				if(MATH_AbsFloat(f)>Cf_1Degre*135) i=4	// behind me
				else if(MATH_AbsFloat(f)<Cf_1Degre*30) i=6	// in front of me
				else if(f>0) i=MATH_RandInt(2,3)	// on my left
				else i=MATH_RandInt(0,1)		// on my right
				t=txPositions[i]
			}
			else
			{
				t=txPositions[6]
			}
			TP_SpeechSay(t,4.0,0)
		}
		else if(NbProjo && ProjoSpeech<3)
		{
			t=txProjos[ProjoSpeech]
			ProjoSpeech++
			TP_SpeechSay(t,4.0,0)
		}
	}
}

procedure_local void TP_Crash()
{
	// red flash
	LIBGFX_Fade(31,0x000000FF,0xff0000FF,0.0,0.2,0.0,0.2,0.0,10)
	// "noooooo"
	TP_SpeechSay(txOuch[0],4.0,0)
	OutOfControl=TIME_Get()+3
	@RefObj PLKJ_ForgetEnemy(OBJ_Me())
	
	SND_RequestPlay(4)	// dive scream
	AI_TrackChange(2,"TP_bhv_crash")
}

procedure_local void TP_StopLoop_Gun()
{
	if(Sound_Gun!=-1)
	{
		SND_Destroy(Sound_Gun)
		Sound_Gun=-1
		SND_RequestPlay(3)
	}
}

procedure_local void TP_StopLoop_Engine()
{
	if(Sound_Engine!=-1)
	{
		SND_Destroy(Sound_Engine)
		Sound_Engine=-1
	}
}

procedure_local void TP_WatchOut()
{
	if(MATH_RandFloat(0,1)<0.2)
	{
		TP_SpeechSay(txBordel[MATH_RandInt(2,7)],0.0,0)
	}
}

procedure_local void TP_Looping()
{
	RotationX=0
	RotationZ=99
	LoopStep=0
	BumpDirection=-OBJ_SightGet()
	BumpDirection.z=0
	BumpDirection=MATH_VecNormalize(BumpDirection)
	COL_ColSetActivationSet(none,C_bit_zde_corps)
	TP_StopLoop_Gun()
	TP_StopLoop_Engine()
	SND_RequestPlay(4)
	AI_TrackCurChange("TP_bhv_looping")
}

procedure_local void TP_Collide()
{
	vector v
	// if I'm out of control, due to a previous collision
	if(OutOfControl)
	{
		// bump according to this direction
		OBJ_SightGeneralSet(MATH_VecBlend(OBJ_SightGet(),BumpDirection,dt*4),OBJ_BankingGet())
		if(TIME_Get()>OutOfControl)
		{
			OutOfControl=0
		}
	}
	else
	{
		// auto start a looping if a wall is in front of me
		if(!OutOfControl && COL_RayObject_Vector(OBJ_PosGet(),OBJ_SightGet()*15,OBJ_C_IdentityFlag_ColMap,OBJ_C_IdentityFlag_Anims,Ci_Filter_IdentityFlag,COL_C_Ray_on_ColMap_NoCrossable))
		{
			v=-COL_RayObject_NormalGet()
			if(MATH_VecDotProduct(OBJ_SightGet(),v)>0.8)
			{
				TP_Looping()
				TP_WatchOut()
			}
		}
		// collide with walls
		if(!OutOfControl && COL_CollideType(COL_C_Wall))
		{
			OutOfControl=TIME_Get()+0.5
			BumpDirection=COL_NormalGet(COL_C_Wall)+OBJ_SightGet()
			TP_WatchOut()
		}
	}
}

procedure_local void TP_GetJoy()
{
	vector v
	float f
	v=IO_JoyGetMove()
	f=MATH_VecNorm(v)
	if(f<0.2) v=Cv_NullVector
	else v*=f
	joy.y=v.y*@"univ" CAM_SensVert
	if(v.x) joy.x=MATH_FloatBlend(joy.x,v.x,dt*2)
	else joy.x=MATH_FloatBlend(joy.x,v.x,dt*6)
	v=IO_JoyGetMove1()
	if(MATH_VecSquareNorm(v)<0.2) v=Cv_NullVector
	else v.y*=@"univ" CAM_SensVert
	joy2=MATH_VecBlend(joy2,v,dt*10)
}

procedure_local int TP_LimitLiberty()
{
	vector v
	float f
	#define C_Plane_Liberty_DeltaZ		100
	#define C_Plane_Liberty_SqDist		160000
	if(!RefObj) return 1
	v=OBJ_PosGet()
	f=RefPos.z-v.z
	if(MATH_AbsFloat(f)>C_Plane_Liberty_DeltaZ && joy.y*f>=0) joy.y=-0.2*MATH_FloatSign(f)
	v-=RefPos
	v.z=0
	if(MATH_VecSquareNorm(v)>C_Plane_Liberty_SqDist && MATH_VecDotProduct(OBJ_SightGet(),v)>0)// || IO_ButtonJustPressed(5))
	{
//		OBJ_SightSet(OBJ_PosGet()-RefPos)
//		v=OBJ_PosGet()
//		v+=30*OBJ_SightGet()
//		v.z+=25
//		@Kamera OBJ_PosSet(v)
		TP_Looping()
		return 0
	}
	return 1
}

procedure_local void TP_Fly()
{
	vector v
	float f
	#define C_Plane_RotationZSpeed		(150*Cf_1Degre)
	#define C_Plane_RotationZMax			(80*Cf_1Degre)
	#define C_Plane_BankingFactor			0.7
	#define C_Plane_RotationXSpeed		(60*Cf_1Degre)
	#define C_Plane_RotationXMax			(130*Cf_1Degre)
	#define C_Plane_RotationXDSpeed		(60*Cf_1Degre)
	#define C_Plane_RotationXDMax		(120*Cf_1Degre)
	#define C_Plane_FlyingSpeedMin		10//15//17
	#define C_Plane_FlyingSpeedMax		15//22//28
	#define C_Plane_FlyingSpeedBoost	38

	// A vérifier : constantes globales pour inverser les commandes (options du joueur)
	RotationZ=MATH_FloatLimit(MATH_FloatBlend(RotationZ,-joy.x*C_Plane_RotationZSpeed,dt*3),-C_Plane_RotationZMax,C_Plane_RotationZMax)
	if(joy.y)
	{
		if(joy.y<0) RotationX=MATH_FloatBlend(RotationX,joy.y*C_Plane_RotationXSpeed,dt)
		else RotationX=MATH_FloatBlend(RotationX,joy.y*C_Plane_RotationXDSpeed,dt*1.3)
	}
	RotationX=MATH_FloatLimit(RotationX,-C_Plane_RotationXMax,C_Plane_RotationXMax)
	OBJ_BankingSet(cvector(0,0,1))
	OBJ_RotateLocalX(RotationX)
	OBJ_RotateLocalY((RotationZ*C_Plane_BankingFactor)+Roll)
	OBJ_RotateGlobalZ(RotationZ*dt)
//	if(faux)//IO_ButtonPressed(joy_button_L))
//	{
//		f=C_Plane_FlyingSpeedBoost
//	}
//	else
//	{
		v=OBJ_SightGet()
		f=MATH_FloatLimit(Speed+(v.z*dt*-25),C_Plane_FlyingSpeedMin,C_Plane_FlyingSpeedMax)
//	}
	Speed=MATH_FloatBlend(Speed,f,dt*5)
	v=dt*Speed*OBJ_SightGet()
	v+=OBJ_PosGet()
	v+=Roll*OBJ_HorizonGet()*15*dt
	OBJ_PosSet(v)
	Roll=MATH_FloatBlend(Roll,0,dt*1.7)
}

procedure_local void TP_Shoot()
{
	int i
	object o,prop
	#define C_Plane_ShootRecoil			(1.5*Cf_1Degre)
	#define C_Plane_DelayShoot				0.03
	// shoot buttons
	i=
		IO_ButtonPressed(joy_button_R)+
		IO_ButtonPressed(joy_button_R2)+
		IO_ButtonPressed(JoyPSX_Button_croix)+
		IO_ButtonPressed(JoyPSX_Button_triangle)+
		IO_ButtonPressed(JoyPSX_Button_carre)+
		IO_ButtonPressed(JoyPSX_Button_rond)
	// if I have to shoot & I'm ready to do it
	if(i && Projectile && TimerShoot<=0)
	{
		if(Sound_Gun==-1) Sound_Gun=SND_RequestPlayLoop(2)
		// get propeller
		prop=ANI_CanalObjectGet(9)
		if(prop) o=@Projectile OBJ_Duplicate(@prop OBJ_PosGet()+(0.2*OBJ_BankingGet()))
		if(o)
		{
			@o PRO_SetFather(OBJ_Me())
			@o PRO_SetBig()
			@o OBJ_SightSet(OBJ_SightGet())
			@o OBJ_RotateGlobalZ(MATH_RandFloat(-C_Plane_ShootRecoil,C_Plane_ShootRecoil))
			@o OBJ_RotateLocalX(MATH_RandFloat(-C_Plane_ShootRecoil,C_Plane_ShootRecoil))
		}
		TimerShoot=C_Plane_DelayShoot
		if(ClosestEnemy && NbEnemies>1 && OBJ_SqrDist(ClosestEnemy)<40000) @ClosestEnemy OBJ_CapaSet(1024,0)	// I'm shooting you
	}
	else TimerShoot-=dt
	if(!i) TP_StopLoop_Gun()
}

procedure_local void TP_MoveFlaps()
{
	object o
	float f
	#define C_Plane_B_Helice				1
	#define C_Plane_B_HeliceBlur		9
	#define C_Plane_B_PanoHG			2
	#define C_Plane_B_PanoHD			3
	#define C_Plane_B_PanoBG			4
	#define C_Plane_B_PanoBD			5
	#define C_Plane_B_Gouverne		6
	#define C_Plane_B_ProfHG			7
	#define C_Plane_B_ProfHD			8
	FlapsZ=MATH_FloatBlend(FlapsZ,joy.x*0.5,dt*15)
	FlapsX=MATH_FloatBlend(FlapsX,joy.y*0.3,dt*15)
	f=FlapsZ
	o=ANI_CanalObjectGet(C_Plane_B_PanoHG)
	@o OBJ_BankingSet(OBJ_BankingGet())
	@o OBJ_RotateLocalX(f)
	o=ANI_CanalObjectGet(C_Plane_B_PanoBG)
	@o OBJ_BankingSet(OBJ_BankingGet())
	@o OBJ_RotateLocalX(f)
	o=ANI_CanalObjectGet(C_Plane_B_PanoHD)
	@o OBJ_BankingSet(OBJ_BankingGet())
	@o OBJ_RotateLocalX(f)
	o=ANI_CanalObjectGet(C_Plane_B_PanoBD)
	@o OBJ_BankingSet(OBJ_BankingGet())
	@o OBJ_RotateLocalX(f)
	o=ANI_CanalObjectGet(C_Plane_B_Gouverne)
	@o OBJ_SightSet(-OBJ_SightGet())
	@o OBJ_RotateLocalZ(f*0.7)
//	f=FlapsX
//	o=ANI_CanalObjectGet(C_Plane_B_ProfHG)
//	@o OBJ_SightGeneralSet(OBJ_HorizonGet(),OBJ_BankingGet())
//	@o OBJ_RotateLocalY(f)
//	o=ANI_CanalObjectGet(C_Plane_B_ProfHD)
//	@o OBJ_SightGeneralSet(OBJ_HorizonGet(),OBJ_BankingGet())
//	@o OBJ_RotateLocalY(f)
	o=ANI_CanalObjectGet(C_Plane_B_Helice)
	@o OBJ_FlagInvisibleSet(1)
	o=ANI_CanalObjectGet(C_Plane_B_HeliceBlur)
	@o OBJ_FlagInvisibleSet(0)
//	@o OBJ_RotateLocalY((dt*-0.3*(Speed-18))+Cf_PiBy2)
	@o OBJ_RotateLocalY((dt*-0.3*(Speed-12))+Cf_PiBy2)
}

procedure_local void TP_MoveKamera()
{
	vector v
	float f
	if(DoCut)
	{
		v=OBJ_BankingGet()+cvector(0,0,1)
		@KamRef OBJ_SightSet(OBJ_SightGet())
	}
	else v=MATH_VecBlend(@KamRef OBJ_BankingGet(),OBJ_BankingGet()+cvector(0,0,1),dt*1.5)
	DoCut=faux
	@KamRef OBJ_BankingSet(v)
	f=RotationZ
	if(RotationX<0) f*=1-(RotationX*0.2)
	else f*=1+(RotationX*0.9)
	v=(RotationX*0.3*OBJ_BankingGet())+(f*0.5*OBJ_HorizonGet())
	v=MATH_VecBlend(@KamRef OBJ_SightGet(),OBJ_SightGet()+v,dt*1.2)
	@KamRef OBJ_SightSet(v)
	
	v=OBJ_PosGet()
	f=RotationX*-3.5
	if(MATH_AbsFloat(f)<1.5) f=1.5
	KamZ=MATH_FloatBlend(KamZ,f,dt*1.2)
	v+=(KamZ+2)*OBJ_BankingGet()
	v+=@Kamera OBJ_SightGet()*-15
	KamX=MATH_FloatBlend(KamX,RotationZ,dt*1.2)
	v+=KamX*3*OBJ_HorizonGet()
	@KamRef OBJ_PosSet(v)
	ViewX=MATH_FloatBlend(ViewX,-joy2.y,dt*1.5)
	ViewZ=MATH_FloatBlend(ViewZ,-joy2.x,dt*1.5)
	if(BlendKam)
	{
		BlendKam=MATH_FloatMax(0,BlendKam-(dt*0.5))
		f=1-BlendKam
		f*=f
		@Kamera OBJ_PosSet(MATH_VecBlend(@Kamera OBJ_PosGet(),v,f))
		@Kamera OBJ_BankingSet(MATH_VecBlend(@Kamera OBJ_BankingGet(),@KamRef OBJ_BankingGet(),f))
		@Kamera OBJ_SightSet(MATH_VecBlend(@Kamera OBJ_SightGet(),@KamRef OBJ_SightGet(),f))
		f*=f
		@Kamera OBJ_RotateLocalX(ViewX*Cf_1Degre*40*f)
		@Kamera OBJ_RotateGlobalZ(ViewZ*Cf_1Degre*120*f)
	}
	else
	{
		@Kamera OBJ_RejoinAndOrient(KamRef)
		@Kamera OBJ_RotateLocalX(ViewX*Cf_1Degre*40)
		@Kamera OBJ_RotateGlobalZ(ViewZ*Cf_1Degre*120)
	}
}

procedure_local void TP_GetMessages()
{
	message msg
	object o
	vector v
	while(MSG_GetCount())
	{
		msg=MSG_Get()
		if(msg.msg_id==1)		// one projector down
		{
			NbProjo--
			DelayNewWave=0
			if(!NbProjo)
			{
				// tell Kong to restore its HP
				msg.msg_id=21
				@RefObj MSG_Send(msg)
			}
			if(NbEnemies<C_TP_PlanesByGroup)
			{
				DelayNewWave=0
				OBJ_CapaSet(1,0)
			}
		}
		else if(msg.msg_id==3)		// bullet
		{
			if(HP && DelayInvulnerable<TIME_Get())
			{
				DelayInvulnerable=TIME_Get()+0.12
				HP--
				if(!HP)
				{
					// rumble
					IO_PafSet(100,12)
					TP_Crash()
				}
				else if(MATH_RandFloat(0,1)<0.3)
				{
					if(MATH_RandFloat(0,1)<0.3)
					{
						TP_SpeechSay(txOuch[OuchIndex],1.0,0)
						OuchIndex++
						if(OuchIndex==4)
						{
							OuchIndex=1
						}
					}
					SND_RequestPlay(9)
					TP_SmokeFX(4)
					// rumble
					IO_PafSet(80,1)
				}
			}
		}
		else if(msg.msg_id==2) DelayGameplayOver=TIME_Get()+5		// kong is dead
		else if(msg.msg_id==4002)		// one plane down
		{
			NbEnemies--
			if(!NbEnemies)
			{
				OBJ_CapaSet(1,0)
				DelayNewWave=TIME_Get()+C_TP_DelayToKillProjo
			}
		}
		else if(msg.msg_id==4015)	// Kong hits me
		{
			TP_Crash()
		}
	}
}

procedure_local void TP_WatchEndOfGameplay()
{
	message msg
	if(DelayGameplayOver)
	{
		if(TIME_Get()>DelayGameplayOver)
		{
			TP_StopLoop_Engine()
			TP_StopLoop_Gun()
			if(NbProjo)	OBJ_CapaSet(C_TP_Capa_KongIsDead,0)
			else OBJ_CapaSet(C_TP_Capa_ISavedKong,0)	
			OBJ_FlagInactiveSet(vrai)
		}
	}
	else if(!NbProjo && !NbEnemies)
	{
		// iniate gameover delay
		DelayGameplayOver=TIME_Get()+5
		// restore full HP for Kong
		if(RefObj)
		{
			msg.msg_id=21
			@RefObj MSG_Send(msg)
		}
	}
}