#include "Interactive_Raft_defs.var"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//	INIT PARAM E GIGOTING
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_Gigot_Init( )
{
	int ti_i
	for (ti_i = 0; ti_i < RAFT_GIGOT_MAX; ti_i++ )
		gigot_f_timer[ ti_i ] = 0
}
/////////////////////////////////////////////////////////////////////////////////////////////////////
// AJOUT D'UN GIGOTING
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int RAFT_Gigot_Add( vector pv_Axe, float pv_Angle )
{
	int		ti_i, ti_best
	
	float	tf_time
	
	// where to add
	tf_time = Cf_Infinit
	for (ti_i = 0; ti_i < RAFT_GIGOT_MAX; ti_i++ )
	{
		if ( gigot_f_timer[ ti_i ] <= 0)
		{
			ti_best = ti_i
			break
		}
		if ( gigot_f_timer[ ti_i ] < tf_time )
		{
			tf_time = gigot_f_timer[ ti_i ]
			ti_best = ti_i
		}
	}

	// set params
	gigot_f_timer[ ti_best ] = RAFT_GIGOT_TIMER	
	gigot_v_axe[ ti_best ] = pv_Axe
	gigot_f_angle[ ti_best ] = pv_Angle
	gigot_f_oldsin[ ti_best ] = 0
	gigot_f_horiztimer[ ti_best ] = 0
	gigot_f_speed[ ti_best ] = 1.0
	return ti_best
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// UPDATE LE BANKING EN FONCTION DES GIGOTING
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_Gigot_Apply( byref vector tv_banking )
{
	int 		ti_i
	float		tf_coef, tf_sin, tf_max
	vector	tv_test
	
	if ( paf_f_z > 0.1 )
		return
	
	tf_max =  RAFT_GIGOT_FREQ * Cf_Pi
	tv_test = tv_banking
	for ( ti_i = 0; ti_i < RAFT_GIGOT_MAX; ti_i++)
	{
		if (gigot_f_timer[ ti_i ] > 0)
		{
			if (gigot_f_horiztimer[ ti_i ] > 0 )
			{
				gigot_f_horiztimer[ ti_i ] -= TIME_GetDt() * gigot_f_speed[ti_i]
			}
			else
			{
				gigot_f_timer[ ti_i ] -= TIME_GetDt() * gigot_f_speed[ti_i]
			
				tf_coef = (RAFT_GIGOT_TIMER - gigot_f_timer[ ti_i ]) / RAFT_GIGOT_TIMER
				tf_coef *= tf_coef
				tf_coef *= tf_max
				
				tf_sin = ((tf_max - tf_coef) /tf_max) * MATH_Sin( tf_coef ) * gigot_f_angle[ ti_i ]
				tv_test = MATH_VecRotate( tv_test, gigot_v_axe[ ti_i ], tf_sin)
				
				if ( gigot_f_angle[ ti_i ] > 0.1 )
				{
					if ( MATH_FloatSign( tf_sin ) * MATH_FloatSign( gigot_f_oldsin[ ti_i ]) < 0)
					{
						gigot_f_angle[ ti_i ] = 0.1
						gigot_f_horiztimer[ ti_i ] = 0.5 * gigot_f_angle[ ti_i ]
					}
					gigot_f_oldsin[ti_i] = tf_sin
				}
			}
		}
	}
	tv_banking= tv_test
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// TROUVE LE WP SUIVANT SUR LE RESEAU
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local object RAFT_WP_Next( object to_wp, byref network tn_net )
{
	object	to_next

	to_next = WAY_NetNextWP(tn_net, to_wp, 7, OBJ_Capa_0)
	if ( to_next )
		return to_next
	
	to_next = WAY_NetNextWP(tn_net, to_wp, 0, 0)
	if ( to_next )
		return to_next

	if (@to_wp OBJ_CapaTest( OBJ_Capa_1 ) && @to_wp OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_DesignStruct))
	{
		to_next = to_wp.des_object1
		tn_net = @to_next WAY_NetOfObj()
	}
	return to_next
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// RECUPERE LA VITESSE SI DANS WP
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local float RAFT_WP_SpeedGet( object to_WP, float tf_DefaultSpeed )
{
	if ( !@to_WP OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_DesignStruct ) )
		return tf_DefaultSpeed * f_speed_factor
	if ( to_WP.des_float1 == 0)
		return tf_DefaultSpeed * f_speed_factor
	return to_WP.des_float1 * f_speed_factor
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// RECUPERE LA VITESSE DE ROTATION SI DANS WP
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local float RAFT_WP_RotSpeedGet( object to_WP, float tf_DefaultSpeed )
{
	if ( !@to_WP OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_DesignStruct ) )
		return tf_DefaultSpeed
	if ( to_WP.des_float2 == 0)
		return tf_DefaultSpeed
	return to_WP.des_float2
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// RECUPERE LA SYNCHRO DANS WP
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int RAFT_WP_SynchroState( object to_WP, byref object to_SynchroWP )
{
	if ( !@to_WP OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_DesignStruct ) )
		return 0
	if ( to_WP.des_int1 == 1)
	{
		if (!to_WP.des_object1)
			return 0
		to_SynchroWP = to_WP.des_object1
		return 1
	}
	if (to_WP.des_int1 == 2)
		return 2
	return 0
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// RECUPERE OBSTACLE DANS WP
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_WP_ObstacleGet( object to_WP )
{
	object	to_obstacle

	if ( !@to_WP OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_DesignStruct ) )
		return
	to_obstacle = to_WP.des_object2
	if ( to_obstacle )
	{
		obstacle_v_pos = @to_obstacle OBJ_PosGet()
		obstacle_i_type = RAFT_Obstacle_sphere
		obstacle_f_radius = 1
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// RECUP PARAM DE TANGAGE DANS WP
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_WP_TangGet( object to_WP )
{
	vector	v
	
	if ( !@to_WP OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_DesignStruct ) )
		return

	v = to_WP.des_vec1
	if (v.x == 0)
		return
	if (v.x == -1)
	{
		tang_i_on = faux
		return
	}
	
	tang_i_on = vrai
	if (v.x > 0)
	{
		tang_f_force = v.x
		tang_f_delay = v.y
		return
	}
	if (v.x == -2)
	{
		tang_f_force = 0.05
		tang_f_delay = 1.5
		return
	}
	if (v.x == -3 )
	{
		tang_f_force = 0.1
		tang_f_delay = 1
		return
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
// FIND BEST EJECTION POINT
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local object RAFT_Eject_FindWP( int pi_who )
{
	int			i
	float		f_dist, f_best
	object	o_perso, o_wp, o_cur
	
	o_perso = ao_Who[ pi_who ]
	if (!o_perso) 
		return nobody
	
	o_wp = nobody
	f_best = RAFT_WPEject_MaxSqrDist
	for ( i = 0; i < RAFT_WPEject_NumberMax; i++)
	{
		o_cur = ao_EjectWP[ i ] [ pi_who ]
		if ( !o_cur ) break
		
		f_dist = @o_perso OBJ_SqrDist( o_cur )
		if (f_dist < f_best)
		{
			f_best = f_dist
			o_wp = o_cur
		}
	}
	return o_wp
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Eject a perso
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_Eject_Perso( int pi_who )
{
	object		to_wp, to_perso
	message	tm_msg
	int				ti_perso
	
	to_perso = ao_Who[ pi_who ]
	if ( @to_perso OBJ_HierarchyGet() != OBJ_Me() )
		return
	
	to_wp = RAFT_Eject_FindWP( pi_who )
	if ( !to_wp )
		return

	// ejection
	MSG_SetNull( tm_msg )
	tm_msg.msg_gao1 = to_perso
		
//		tm_msg.msg_id = CINE_Reset
//		@to_perso MSG_Send(tm_msg)

	tm_msg.msg_id = CINE_Vala
	tm_msg.msg_gao2 = to_wp
	tm_msg.msg_int2 = 3
	@to_perso MSG_Send(tm_msg)
 		
	if (to_perso != AI_MainActorGet(0) )
	{
 		to_wp = ao_PosOnRaft[ pi_who ]
 		if ( !to_wp ) to_wp = OBJ_Me()
 		tm_msg.msg_gao2 = to_wp
	 	tm_msg.msg_gao3 = to_wp
		tm_msg.msg_int2 = 4
		@to_perso MSG_Send(tm_msg)
	}
	 		
	@to_perso OBJ_CapaSet(0, OBJ_Capa_13)
	
	ao_EjectedPerso[ pi_who ] = to_perso
	@to_perso COL_UnCollidableAdd( OBJ_Me() )
	COL_UnCollidableAdd( to_perso )
	if (o_colmap_add) @o_colmap_add OBJ_FlagInactiveSet( 1 )
	for( ti_perso = 0; ti_perso < 4; ti_perso++)
	{
		if (ti_perso == pi_who) continue
		if ( ao_Who[ ti_perso ] == nobody ) break
		@to_perso COL_UnCollidableAdd( ao_Who[ ti_perso ] )
	}
	@to_perso OBJ_HierarchyReset()
 	ao_EjectedPerso[ pi_who ] = to_perso			
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Eject equip
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_Eject_Equip( )
{
	int i
	for (i = 0; i < 4; i++)
	{
		if (ao_Who[ i ] )
			RAFT_Eject_Perso( i )
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// SEND A PAF
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_WP_SetPaf( vector pos, float inclinaison, float hforce, float vforce )
{
	vector	tv_temp
	vector	tv_axe
	vector	tv_Z
	int			ti_gigot
	
	paf_v_pos = pos 
	paf_f_zangle = inclinaison
	paf_f_force = hforce
	paf_f_zspeed = vforce
	
	// compute other params
	paf_v_dir = paf_v_pos - OBJ_PosGet()
	paf_v_dir.z = 0
	
	tv_axe = MATH_VecCrossProduct( paf_v_dir, Cv_VerticalVector )
	tv_temp = MATH_VecGlobalToLocal(tv_axe )
	OBJ_RotateAroundVec( tv_temp, paf_f_zangle)
	ti_gigot = RAFT_Gigot_Add( tv_axe, -paf_f_zangle )
	gigot_f_timer[ ti_gigot ] = 3.75
	paf_v_dir = -MATH_VecNormalize( paf_v_dir )
	paf_f_coefcourant = 1
	paf_f_time = 0
	paf_f_ztime = 0
	paf_f_z = 0 
	paf_f_oldz = 0
	
	paf_f_zspeed = 0
	RAFT_Eject_Equip()
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Point de rencontre sphere segment
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int RAFT_Inter_SphereSegment( vector Sphere_pos, float Sphere_Radius, vector SegmentA, vector SegmentB)
{
	float		tf_R2, tf_val
	vector 	tv_U, tv_V
	
	tf_R2 = Sphere_Radius * Sphere_Radius
	tv_U = Sphere_pos - SegmentA
	if ( MATH_VecDotProduct(tv_U, tv_U) < tf_R2 )
	{
		obstacle_v_colpos = SegmentA
		obstacle_v_colnorm = -tv_U
		return 2
	}
	tv_V = Sphere_pos - SegmentB
	if (MATH_VecDotProduct( tv_V, tv_V) < tf_R2 )
	{
		obstacle_v_colpos = SegmentB
		obstacle_v_colnorm = -tv_V
		return 2
	}
	tv_V = SegmentB - SegmentA
	tf_val = MATH_VecDotProduct( tv_V, tv_V)
	if ( !tf_val)
		return 0
	tf_val = MATH_VecDotProduct( tv_U, tv_V ) / tf_val
	if ((tf_val < 0) || (tf_val > 1))
		return 0
	
	obstacle_v_colpos = SegmentA + (tf_val * tv_V)
	obstacle_v_colnorm = obstacle_v_colpos - Sphere_pos
	if ( MATH_VecDotProduct(obstacle_v_colnorm, obstacle_v_colnorm) < tf_R2 )
		return 1
	return 0
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// Point de rencontre radeau_sphere
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local int RAFT_Inter_Sphere( vector Sphere_pos, float Sphere_radius  )
{
	vector	X, Y, A, B, C, D
	
	X = OBJ_HorizonGet() * RAFT_Width
	Y = OBJ_SightGet() * RAFT_Length
	
	A = OBJ_PosGet() + X + Y
	B = OBJ_PosGet() - X + Y
	//DDBG_RenderVector( A, B-A, color_vert)
	if ( RAFT_Inter_SphereSegment( Sphere_pos, Sphere_radius, A, B) )
		return 1
	C = OBJ_PosGet() - X - Y
	//DBG_RenderVector( B, C-B, color_vert)
	if ( RAFT_Inter_SphereSegment( Sphere_pos, Sphere_radius, B, C) )
		return 1
	D = OBJ_PosGet() + X - Y
	//DBG_RenderVector( C, D-C, color_vert)
	if ( RAFT_Inter_SphereSegment( Sphere_pos, Sphere_radius, C, D) )
		return 1
	//DBG_RenderVector( D, A-D, color_vert)
	if ( RAFT_Inter_SphereSegment( Sphere_pos, Sphere_radius, D, A) )
		return 1
		
	return 0
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// initialise le network
/////////////////////////////////////////////////////////////////////////////////////////////////////
procedure_local void RAFT_InitNetwork( )
{
	if ( !o_1st_wp )
		return

	n_net = @o_1st_wp WAY_NetOfObj()
	move_o_WP[ 0 ] = o_1st_wp
	AI_Execute( "Raft_exec_computemoveparams" )
	move_v_dir = move_v_Sight[ 0 ]
	
	if ( move_i_Stop )
	{
		DBG_TraceObject( OBJ_Me() )
		DBG_TraceString( "-----> no wp after 1st wp, AI stop  !" )
		DBG_TraceEOL()
		AI_TrackStop( 1 )
		AI_TrackStop( 2 )
	}
}