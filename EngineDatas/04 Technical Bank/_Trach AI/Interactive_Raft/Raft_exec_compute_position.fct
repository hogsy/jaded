#include "Interactive_Raft_defs.var"

float		tf_sin
float		tf_angle
float		tf_rot
float		tf_norm, tf_norm1

vector	tv_pos
vector	tv_temp
vector	tv_norm

object	to_target 


#define Cf_pourcentage			0.33

if (move_f_speed == 0 )
	return
	
// - - - - ( colle au paf ) - - - - 
//if (paf_i_flag && paf_o)
//{
//}


if ( OBJ_SqrDist( move_o_WP[1] ) < 9 )
{
	move_o_WP[ 0 ] = move_o_WP[ 1 ] 
	AI_Execute( "Raft_exec_computemoveparams" )
}

if (move_i_Stop)
	return

to_target = move_o_WP[1]
tv_temp = @to_target OBJ_PosGet() - OBJ_PosGet()
MATH_VecSetNormalize( tv_temp )

move_v_dir = MATH_VecBlend( move_v_dir, tv_temp , move_f_speed * 0.25 * TIME_GetDt() )
tv_pos = OBJ_PosGet() + (move_v_dir  * (move_f_speed * paf_f_coefcourant * TIME_GetDt() ) )

// --------( application du paf )-----------
if ( paf_f_force)
{
	paf_f_time += TIME_GetDt()
	paf_f_coefcourant -= TIME_GetDt()
	if (paf_f_coefcourant < 0)
		paf_f_coefcourant = 0
	while (paf_f_time > 0.016)
	{
		paf_f_time -= 0.016
		tv_pos += paf_f_force * paf_v_dir * 0.016
		if ( paf_f_z > 0.1 )	
			paf_f_force *= 0.99
		else
			paf_f_force *= 0.9
		if (paf_f_force < 0.1)
			paf_f_force = 0
	}
}
else 
{
	if (paf_f_z < 0.1 )
	{
		if (paf_f_coefcourant < 1)
		{
			paf_f_coefcourant += TIME_GetDt()
			if (paf_f_coefcourant > 1)
				paf_f_coefcourant = 1
		}
	}
	else if (paf_f_coefcourant > 0)
	{
		paf_f_coefcourant -= TIME_GetDt()
		if (paf_f_coefcourant < 0)
			paf_f_coefcourant = 0
	}
}

if ( paf_f_zspeed || paf_f_z )
{
	paf_f_ztime += TIME_GetDt()
	while (paf_f_ztime > 0.016)
	{
		paf_f_ztime -= 0.016
		
		if ( paf_f_z >= 0 )
		{
			// friction
			paf_f_zspeed *= 0.99
			// gravité
			paf_f_zspeed -= 0.016 * 9.81
		}
		else
		{
			// friction
			paf_f_zspeed *= 0.9
			// poussée
			paf_f_zspeed += 0.016 * 10
		}
		paf_f_z += paf_f_zspeed * 0.016
	}
	if ( (MATH_AbsFloat( paf_f_zspeed) < 0.1) && (MATH_AbsFloat( paf_f_z) < 0.05) )
	{
		paf_f_zspeed = 0
		paf_f_z = 0
	}
	tv_pos.z += paf_f_z - paf_f_oldz
	paf_f_oldz = paf_f_z
}

OBJ_PosSet( tv_pos )

// --------( mise à jour du sight et du banking )--------
move_v_sightideal = OBJ_SightGet()
move_v_bankingideal = OBJ_BankingGet()
if (move_b_Orient)
{
	tv_norm = MATH_VecCrossProduct( move_v_sightideal, move_v_Orient[0] )
	if ( !MATH_VecNullEpsilon( tv_norm ) )
	{
		tf_angle = MATH_VecAngle( move_v_sightideal, move_v_Orient[0], tv_norm )
		if(tf_angle > 0.05) alpha_profile = 0.9
		
		tf_rot = TIME_GetDt() * orient_f_speed *  orient_f_curspeed
		if (tf_angle < tf_rot * 5)
		{
			orient_f_curspeed *= 0.9
			if (orient_f_curspeed < 0)
				orient_f_curspeed = 0
		}
		else
		{
			orient_f_curspeed += 0.1
			if (orient_f_curspeed > 1)
				orient_f_curspeed = 1
		}
	
		tf_rot = TIME_GetDt() * orient_f_speed *  orient_f_curspeed
		if (tf_angle < tf_rot)
		{
			orient_f_curspeed = 0
			tf_rot = tf_angle
		}
			
		if (DBG_IsObjSel())	DBG_RenderVector( OBJ_PosGet(), move_v_sightideal * 10, color_rose)
		if (DBG_IsObjSel())	DBG_RenderVector( OBJ_PosGet(), move_v_Orient[0] * 10, color_vert)

		move_v_sightideal = MATH_VecRotate( move_v_sightideal, tv_norm, tf_rot )
		
		if (DBG_IsObjSel())	DBG_RenderVector( OBJ_PosGet(), move_v_sightideal * 10, color_bleu)

	}	
}
else
{
	orient_f_curspeed = 0
}

if (move_b_Orient)
{
	tv_temp = move_v_Pos[1] - move_v_Pos[0]
	tf_norm = MATH_VecNorm(tv_temp)
	tv_temp = move_v_Pos[1] - OBJ_PosGet()
	tf_norm1 = MATH_VecNorm(tv_temp)
	tf_norm = tf_norm1 / tf_norm
	move_v_bankingideal = MATH_VecBlend(move_v_Bank[1], move_v_Bank[0], tf_norm)
}
else
{
	tv_temp = MATH_VecCrossProduct(move_v_Sight[ 0 ],  Cv_VerticalVector)
	tv_temp.z = 0
	move_v_bankingideal = MATH_VecCrossProduct( tv_temp, move_v_Sight[ 0 ] )
	MATH_VecSetNormalize( move_v_bankingideal ) 
}

// add gigoting
RAFT_Gigot_Apply( move_v_bankingideal )
