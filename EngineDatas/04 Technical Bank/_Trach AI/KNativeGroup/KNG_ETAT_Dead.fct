#include "KNG_Defines.var"

int ti_i

// SORTIE ETAT
if (i_sort_etat)
{
	i_sort_etat = faux
	//JIMI_NOTE: fixed respawn to happen, but the "dead" state was still running all the time, so I added this "old fct" call.
//	if ( fct_ancien_etat )
//	{
//		AI_TrackCurChange( fct_ancien_etat )
//	}	
//	OBJ_CapaSet(none, Ci_Capa_Dead)
	return
}

// ENTREE ETAT
if (i_etat_courant != ETAT_Dead)
{
	i_etat_ancien = i_etat_courant
	i_etat_courant = ETAT_Dead
	
	if (fct_last_etat)
	{
//		fct_ancien_etat = fct_last_etat
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	f_time_start_etat = 0.0
	
	// STATS
	for (ti_i = 0; ti_i < i_number_of_natives; ti_i++)
	{
		STATS_IncEnemyKilled_New(@"univ" ao_AllHumains[C_ID_Kong], C_EnemyType_Native, 0 )
	}
	
	if( i_do_respawn || (i_respawn_when_dead && ! OBJ_CapaTest(Ci_Capa_UpdateLockedPos)) )
	{
		i_do_respawn = 0

		//JIMI_NOTE: reset the "i_all_natives_generated" flag to make sure new natives are made if a respawn is called for
		i_all_natives_generated	= faux
		//i_sort_etat 					= vrai		//JD: sort_etat will only actually be used on the next Etat_DEAD pass.
		fct_last_etat = nofunc
		mi_JustDied				= vrai
		
		f_respawn_delay = MATH_RandFloat(f_respawn_delay_min, f_respawn_delay_max)
		AI_TrackCurChangeNow("KNG_Init")
	}
	else
	{
		OBJ_CapaSet(Ci_Capa_Dead, none)		// uniquement qd vraiment morts
		OBJ_Destroy()
	}
}	
else
{
	f_time_start_etat += TIME_GetDt()
}
