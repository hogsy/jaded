#include "KNG_Defines.var"
Include_UltraProcedure_Header

#define Cf_Separation 		5.0
#define Cf_Alignment 		2.0
#define Cf_Cohesion 		3.5
#define Cf_Attirance 		4.0

procedure_local int FLK_IsValidNeighbor(byref object boid1, byref object boid2)
{
	vector tv_sight
	vector tv_dir	
	float tf_dot

	//DBG_RenderVector(@ boid1 OBJ_PosGet(), MATH_VecRotate(@boid1 OBJ_SightGet(),Cv_VerticalVector,-Cf_3PiBy4 ) * 5, color_vert)
	//DBG_RenderVector(@ boid1 OBJ_PosGet(), MATH_VecRotate(@boid1 OBJ_SightGet(),Cv_VerticalVector,Cf_3PiBy4 ) * 5, color_vert)
	//DBG_RenderCircle(@boid1 OBJ_PosGet(), 5.0, Cv_VerticalVector, color_vert)

 	if (boid1 != boid2)
	{
		tv_sight = @boid1 OBJ_SightGet()
		tv_dir = @boid2 OBJ_PosGet() - @boid1 OBJ_PosGet()
		
		if (MATH_VecNorm(tv_dir) < i_cohesion )
		{
			tf_dot = MATH_VecDotProduct(tv_sight,tv_dir)
			if (tf_dot > -Cf_3PiBy4 && tf_dot < Cf_3PiBy4)				
			{
				return vrai
			}
		}
	}	
	
	return faux
}

procedure vector FLK_GetSight(byrefarr object object_list, int object_num, byref object boid, vector target)
{
	vector tv_separation, tv_alignment, tv_cohesion, tv_attirance
	int 	ti_num_neighbors
	vector tv_sight
	int 	ti_k

	tv_separation = Cv_NullVector
	tv_alignment = Cv_NullVector
	tv_cohesion = Cv_NullVector
	tv_attirance = Cv_NullVector
	tv_sight = Cv_NullVector

	ti_num_neighbors = 0
	
	for (ti_k = 0; ti_k < object_num; ti_k++)
	{
		if ( ! object_list[ti_k])
			continue 
			
		if (FLK_IsValidNeighbor(boid, object_list[ti_k]))
		{
			tv_separation += @boid OBJ_PosGet() - @object_list[ti_k] OBJ_PosGet()
			tv_alignment += @object_list[ti_k] OBJ_SightGet()
			tv_cohesion += @object_list[ti_k] OBJ_PosGet()
			
			ti_num_neighbors++
		}
	}

	if (ti_num_neighbors)
	{
		tv_separation /= ti_num_neighbors
		tv_alignment /= ti_num_neighbors
		tv_cohesion /= ti_num_neighbors		
	}
	
	if (!MATH_VecNullEpsilon(target))
		tv_attirance = target - @boid OBJ_PosGet()

	if (!MATH_VecNullEpsilon(tv_separation))
	{
		MATH_VecSetNormalize(tv_separation)
		tv_separation *= Cf_Separation
		tv_sight += tv_separation
	}
	if (!MATH_VecNullEpsilon(tv_alignment))
	{
		MATH_VecSetNormalize(tv_alignment)
		tv_alignment *= Cf_Alignment
		tv_sight += tv_alignment
	}
	if (!MATH_VecNullEpsilon(tv_cohesion))
	{
		if(!MATH_VecNullEpsilon(tv_cohesion)) 
		{
			MATH_VecSetNormalize(tv_cohesion)
			tv_cohesion *= Cf_Cohesion
			tv_sight += tv_cohesion
		}
	}
	if (!MATH_VecNullEpsilon(tv_attirance))
	{
		MATH_VecSetNormalize(tv_attirance)
		tv_attirance *= Cf_Attirance
		tv_sight += tv_attirance
	}

	if (!MATH_VecNullEpsilon(tv_sight))
		MATH_VecSetNormalize(tv_sight)

	//DBG_RenderVector(@boid OBJ_PosGet(),tv_separation * 5, color_bleu)
	//DBG_RenderVector(@boid OBJ_PosGet(),tv_alignment * 5, color_blanc)
	//DBG_RenderVector(@boid OBJ_PosGet(),tv_cohesion * 5, color_rouge)
	//DBG_RenderVector(@boid OBJ_PosGet(),tv_attirance * 5, color_vert)

	return tv_sight
}

procedure_local object KNG_GetNearestWP()
{
	float tf_wp_best_dist
	int ti_i	
	float tf_dist
	object to_WP
	object to_best_WP 
	object to_klist_manager
	
	to_best_WP = nobody

	to_klist_manager = get_KList_manager 
	// choix du WP dans le list manager
	tf_wp_best_dist = Cf_Infinit

	for( ti_i = 0; ti_i < @get_KList_manager_path to_klist_manager  i_native_wp_nb; ti_i++ )
	{
		to_WP = @get_KList_manager_path to_klist_manager  ao_native_wp[ti_i]
		
		if( @to_WP OBJ_FlagsStatusGet() & OBJ_C_StatusFlag_Active )
		{		
			tf_dist = OBJ_SqrDist(to_WP)
			if( tf_dist < Cf_dist_wp* Cf_dist_wp  && tf_dist < tf_wp_best_dist)
			{
				to_best_WP = to_WP
				tf_wp_best_dist = tf_dist
			}
		}
	}

	if (to_best_WP)
		n_cur_net = @to_best_WP WAY_NetOfObj()
	
	return to_best_WP 	
}

procedure_local void KNG_InitPos()
{
	int 		ti_i
	vector  	tv_max, tv_min
	float 		tf_cur_x, tf_cur_y
	float 		tf_native_spawn_diameter 
	
	// build the init pos array
	tv_max = BV_MaxGet() 
	tv_min = BV_MinGet() 
	
	tf_native_spawn_diameter = MATH_FloatSqrt((MATH_AbsFloat(tv_max.x - tv_min.x) * MATH_AbsFloat(tv_max.y - tv_min.y)) / i_number_of_natives )

	tf_cur_x = tv_max.x - (tf_native_spawn_diameter  / 2.0)
	tf_cur_y = tv_max.y - (tf_native_spawn_diameter  / 2.0)

	for ( ti_i = 0; ti_i < i_number_of_natives; ti_i++ )
	{	
		if (tf_cur_x >= tv_min.x)
		{
			ao_native_init_pos[ti_i] = cvector(tf_cur_x, tf_cur_y, 0)
			tf_cur_x -= tf_native_spawn_diameter  
		}
		else
		{
			tf_cur_x = tv_max.x - (tf_native_spawn_diameter  / 2.0)
			tf_cur_y -= tf_native_spawn_diameter  
			ti_i -- 
		}
	}	
}


procedure_local void KNativeGroup_SpawnNative(int ti_i)
{
	int	ti_k
	vector tv_random_pos
	int	ti_random_native
	int sect0, sect1, sect2, sect3
	float tf_rand
	
	// Get the information from the current Object (AI)
	SCT_GetOf( &sect0, &sect1, &sect2, &sect3)
	
	//tv_random_pos = BV_RandomPosGet(1)
	tv_random_pos = OBJ_PosGet() + ao_native_init_pos[ti_i]
	tf_rand = MATH_RandFloat(0.0,0.2)
	if (MATH_RandInt(0,2))
		tf_rand = -tf_rand
	tv_random_pos.x += tf_rand 
	tv_random_pos.y += tf_rand 
	
	ti_random_native = MATH_RandInt(0,i_nb_native_ref)
	ao_native_list[ti_i] = @ao_native_ref[ti_random_native] OBJ_Duplicate(tv_random_pos)
	
	if( ! ao_native_list[ti_i] )
		return
	
	@ao_native_list[ti_i] KNative_GroupSet(OBJ_Me())		// mémo du groupe spawner
	
	@ao_native_list[ti_i] OBJ_BankingGeneralSet(OBJ_SightGet(),Cv_VerticalVector)
	
	if (i_invincible)
		@get_PNJ_KNative_path ao_native_list[ti_i]	 i_invincible = 1
	
	if (i_no_paf)
		@get_PNJ_KNative_path ao_native_list[ti_i]	 i_no_paf = 1
	
	@get_PNJ_KNative_path ao_native_list[ti_i]	 i_borg = 1
	
	if (@get_PNJ_KNative_path ao_native_list[ti_i]	 o_Weapon == nobody)
		@get_PNJ_KNative_path ao_native_list[ti_i]	 o_Weapon = o_weapon
	
	if( o_weapon && o_target_movement == o_ann )
	{
		@get_PNJ_KNative_path ao_native_list[ti_i]	 i_Weapon_Ray_on_visuel = vrai		// tire sur Ann, ne pas changer d'avant
	}
	
	if( o_weapon && i_weapon_fire )			// VINC : on vire ce fuck### random qui fait qu'on peut avoir 0 native avec du feu avec 75%....
		@get_PNJ_KNative_path ao_native_list[ti_i]	 i_Weapon_FlamOnInit = vrai
	else
	 	@get_PNJ_KNative_path ao_native_list[ti_i]	 i_Weapon_FlamOnInit = faux
	
	@get_PNJ_KNative_path ao_native_list[ti_i]	 o_target = o_kong
	
	// Set the secto information on to new duplicated gameobject.
	@ao_native_list[ti_i] SCT_SetOf( sect0, sect1, sect2, sect3)
	
	// uncol kong
	@ao_native_list[ti_i] COL_UnCollidableAdd(o_kong)
	
	// VINC : uncol some other objects (KK grabbing souche for example)
	for( ti_k = 0; ti_k < Ci_uncol_objects_max; ti_k++ )
	{
		if( ao_uncol_objects[ti_k] )
			@ao_native_list[ti_i] COL_UnCollidableAdd(ao_uncol_objects[ti_k])
	}
	
	// if activation trigger, disable natives
	if ( AI_TriggerIsValid(tr_activation_trigger))
	{
		//@ao_native_list[ti_i] OBJ_FlagInactiveSet(1)
		@ao_native_list[ti_i] GRP_FlagInvisibleSet(1)
	}
	
	mai_AleadyTestedForInactiveDWZThrowRate[ti_i] = faux
}


procedure_local void KNativeGroup_ThrownJavelinInc()
{
	i_nb_javelin_this_wave++
}
