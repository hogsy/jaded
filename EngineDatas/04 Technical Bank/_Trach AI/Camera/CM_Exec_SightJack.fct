#include "CM_Defines.var"

vector	tv_joy1

i_visee_force_sight = vrai

// Sight
if(IO_ButtonJustPressed(joy_button_StickR))
{
	v_ideal_sight = -@o_mf_actor OBJ_SightGet()
	i_auto_evitementsight = faux
	i_auto_blendsight = faux
	i_mf_cut = vrai
	f_angle_z = 0
}
else if(i_mf_cut)
{
	i_mf_cut = vrai
	v_ideal_sight = -@o_mf_actor OBJ_SightGet()
	i_auto_evitementsight = faux
	i_auto_blendsight = faux
}
else 
{
	i_auto_evitementsight = vrai
	i_auto_blendsight = vrai
	
	// Mouvement sight par joy
	v_joy_1 = MATH_VecBlend(v_joy_1, IO_JoyGetMove1(), 7 * TIME_GetDt())
	tv_joy1 = v_joy_1
	if(MATH_AbsFloat(tv_joy1.x) > C_JoyTolX)
	{
		tv_joy1.x -= C_JoyTolX * MATH_FloatSign(tv_joy1.x)
		tv_joy1.x *= @"univ" CAM_SensHoriz
		v_ideal_sight = MATH_VecRotate(v_ideal_sight, Cv_VerticalVector, tv_joy1.x * 0.1)
		i_auto_evitementsight = faux
		i_auto_blendsight = faux
	}
	
	if(MATH_AbsFloat(tv_joy1.y) > C_JoyTolY)
	{
		tv_joy1.y -= C_JoyTolY * MATH_FloatSign(tv_joy1.y)
		f_angle_z += (tv_joy1.y * 0.1)
		f_angle_z = MATH_FloatLimit(f_angle_z, -1, 1)
		i_auto_evitementsight = faux
		i_auto_blendsight = faux
		i_stick_zmax = faux
	}
}

