#include "CM_Defines.var"
 
vector  tv_joy1
vector  tv_temp, tv_temp1
float   tf_dot, tf_temp
object  to_obj
 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
// Params
AI_TrackChange(2, "CM_Meca_Kong")
o_mf_actor = AI_MainActorGet(0)
v_cur_pos_suivi = MATH_VecBlend(v_cur_pos_suivi, @o_mf_actor OBJ_PosGet(), 5 * TIME_GetDt())
 
// Swap (TEMPORAIRE)
if (!@o_mf_actor AI_IsModel("KingKong/Kong2")) 
{
 i_mf_cut = vrai
 AI_TrackCurChangeNow("CM_Mode_Jack")
}
 
// Changement de mode ?
if(i_mode_cur != CM_ModeKong_Lock)
{
 i_mode_cur = CM_ModeKong_Lock
}
 
// Sortie si plus de perso locké
if
(
  (@get_global i_kong_camera_status != Ci_Kcamera_fight)
&& (@get_global i_kong_camera_status != Ci_Kcamera_grab_dyno)
)
{
 AI_TrackCurChangeNow("CM_Mode_Kong")
}
 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
// Calcul objet suivi
if(MSG_GlobalIsValid(@get_global mid_kong_camera_status))
{
 o_object_cur = EVENT_PereGet(@get_global mid_kong_camera_status)
 v_pos_cible = @o_object_cur OBJ_PosGet()
 v_offset_obj_cur = EVENT_LockCamOffsetGet(@get_global mid_kong_camera_status)
 MSG_GlobalSetInvalid(@get_global mid_kong_camera_status)
}
 
// Distance
f_IdealDist = 10
f_blend_pos = 4
 
// Monte/descend la camera
to_obj = @o_mf_actor ANI_CanalObjectGet(Anim_Canal_Tete)
f_IdealZMax = (@to_obj OBJ_PosGet().z - v_cur_pos_suivi.z) + 3
f_IdealZMin = 8
 
tv_temp = v_cur_pos_suivi - @o_object_cur OBJ_PosGet()
tf_temp = MATH_VecNorm(tv_temp)
MATH_VecSetHorzNormalize(tv_temp)
tv_temp = MATH_VecCrossProduct(tv_temp, OBJ_SightGet())
if(MATH_AbsFloat(tv_temp.z) > 0.1)
{
 if(tv_temp.z > 0)
  tf_dot = -0.5
 else
  tf_dot = 0.5
 f_angle_dec_lock = MATH_FloatBlend(f_angle_dec_lock, tf_dot, TIME_GetDt())
}
 
// Vitesse max inversement prop a la distance a la cible
tv_temp = v_cur_pos_suivi - @o_object_cur OBJ_PosGet()
tv_temp.z = 0
tf_temp = MATH_FloatMin(MATH_VecNorm(tv_temp), 5)
tv_temp = MATH_VecRotate(tv_temp, Cv_VerticalVector, f_angle_dec_lock)
AI_Execute("CM_Exec_SightKong")
v_ideal_sight = CM_BlendRotate(v_ideal_sight, tv_temp, 1.0, tf_temp)
 
i_visee_force_sight = faux
i_auto_evitementsight = faux
i_auto_blendsight = faux
af_FctIdeal_XTgt[1] = -8 * f_angle_dec_lock
af_FctIdeal_XTgt[3] = af_FctIdeal_XTgt[1]
 
tv_temp = @o_object_cur OBJ_PosGet() - @o_mf_actor OBJ_PosGet()
tf_temp = (f_IdealZMax - 1) - 3.5
//tf_temp += tv_temp.z
af_FctIdeal_ZTgt[1] = tf_temp
af_FctIdeal_ZTgt[3] = 5
 
//i_force_pos_cible = vrai
//v_force_pos_cible = @o_object_cur OBJ_PosGet()
