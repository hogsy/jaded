#include "Kann_defines.var"

int 		ti_i
vector 	tv_new_sight
float		tf_dist
float 		tf_dot
vector	tv_direction
float		tf_coef_dist
vector	tv_pos_safe_wp, tv_pos_old_safe_wp
float		tf_dist_vert_ref, tf_dist_horiz_ref, tf_dist_horiz_ann
vector	tv_pos_ann
int			ti_num_link
object	to_next_wp
int			ti_design
network	tn_net
vector	tv_speed

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	
	if (! (OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_Dyna))
	{
		AI_Execute("KAnn_exec_dyn_on")
	}	
	
	// if we're climbing, don't memorize the current waypoint
	if (i_link_action_type == MOVE_Climb)
	{
		o_safe_wp	= nobody
	}

	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_follow_network)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_follow_network

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	
	// AUTORISATIONS DES GRABS
	for (ti_i = 0; ti_i < Ci_LNK_TYPE_NB; ti_i++)
		ai_SRV_ENABLE[ti_i] = faux
	ai_SRV_ENABLE[Ci_LNK_GRAB_RAPTOR]		= vrai
	ai_SRV_ENABLE[Ci_LNK_GRAB_TRANSPORTE]	= vrai
	ai_SRV_ENABLE[Ci_LNK_KKGRAB_OBJECT]	= vrai
	
	ai_SRV_ENABLE[Ci_LNK_INTERACTION] = faux
	
	f_time_start_etat = 0.0
	
	o_fight_actor = nobody
	DYN_FrictionVectorSet(cvector(5.0, 5.0, 5.0))
	
	REINIT:
	
	// Choix du WP -----------------------------------------------------------------------------------------------------------------------
	i_au_sol_mode = Ci_ANN_au_sol_pas_de_wp		// par défaut, ANN n'a pas d'endroit ou aller

	if (	i_CINE_force_new_safe_WP)
	{
		o_safe_wp = KAnn_Choix_du_WP()		// Choix d'un wp si ANN n'en a pas déjà choisi un	
	}
	else if ( ! i_wp_already_set)
	{
		if (o_safe_wp == nobody)
		{
			o_safe_wp = KAnn_Choix_du_WP()		// Choix d'un wp si ANN n'en a pas déjà choisi un
		}	
		else if (o_safe_wp && @o_safe_wp COL_BV_PivotCollide(OBJ_Me()))
		{
			if (n_current_net)
			{
				KAnn_Set_Safe_Wp(KAnn_GetNextWPOnNetwork())
//				if (o_safe_wp)
				if (o_safe_wp && n_current_net) 	// fix de simon !!!!
				{
					i_old_link_action_type = i_link_action_type
					i_link_action_type = WAY_LinkDesignGet(n_current_net,o_old_safe_wp,o_safe_wp )	
				}
		    }
		}
	}
	else
	{
		i_wp_already_set	= 0
	}

	if( o_safe_wp )
	{
		i_au_sol_mode = Ci_ANN_au_sol_va_au_wp			// ANN a un WP de destination
		n_current_net = @o_safe_wp WAY_NetOfObj()	
	}
	else
	{
		AI_TrackCurChangeNow("KAnn_ETAT_action")	
	}
	
	i_CINE_force_new_safe_WP = faux
	
	i_au_sol_move_coll_flag = faux			// n'a pas encore collisionné de mur en allant au wp (une fois vrai, ANN se dirige vers le wp et plu sselon l'axe de déplacement)
	f_time_se_soigne = 0.0
	f_action_timer = 0.0
	
	i_action_id = 0
	i_sub_action_id = 0
	i_action_pos_safe = 0
	i_action = 0
	i_at_end = 0
	f_total_dist = -1

	OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)

}
else
{
	// When wounded she's not able to move or follow the network. On frame 2 after entering state, 
	// if state wasnt changed to action yet (else we wouldnt be here) force a fake action if she's wounded.  
	// we have to pass throught the function on frame 1 to detect if there an action wp nearby (really that's
	// for the Pillar action wp only)
	if (OBJ_CapaTest(Capa_Wounded))
	{
		OBJ_CapaSet(Capa_Action_Ann, none)
	}	

	f_time_start_etat += TIME_GetDt()
	
	f_dyn_timer = MATH_FloatMax(0.0,f_dyn_timer - TIME_GetDt()) 
		
}

// ANALYSE =======================================================================================================

if (i_link_action_type == MOVE_Climb)
	ai_SRV_ENABLE[Ci_LNK_KKGRAB_OBJECT] = faux
else
	ai_SRV_ENABLE[Ci_LNK_KKGRAB_OBJECT] = vrai

// CINE FORCER UN NOUVEAU WP
if( i_CINE_force_new_safe_WP )
{
	goto REINIT
}

// SERVEURS ===================================================================
AI_Execute("KAnn_exec_serveur_get")
if(ao_SRV[Ci_LNK_GRAB_TRANSPORTE])
	macro_change_etat("KAnn_ETAT_grabbed_bat")
if(ao_SRV[Ci_LNK_KKGRAB_OBJECT])
	macro_change_etat("KAnn_ETAT_grabbed_KK")

// CHECK PAF
if( @get_global i_KAnn_check_paf_on_network )
{
	AI_Execute("KAnn_exec_CHECK_paf")
	if (o_paf_sender) 
	{
		i_life_state = Life_ETAT_Mort 
		macro_change_etat("KAnn_ETAT_paf")
	}
}

// UPDATE TARGET
KAnn_UpdateTarget()

// if wp just changed, check if we must do a u-turn
if (i_wp_just_changed)
{
	// pilier and sacrifice wps teleport ann, so don't do a demi-tour
	if( o_safe_wp && ! ( @o_safe_wp OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_DesignStruct) 
		&& (o_safe_wp.des_int1 == WP_Action_Colonne || o_safe_wp.des_int1 == WP_Action_Sacrifice) ) )
	{
		i_wp_just_changed = 0	
		
		tv_direction = @o_safe_wp OBJ_PosGet() - OBJ_PosGet()
		
		if ( ! MATH_VecNullEpsilon(tv_direction))
			MATH_VecSetNormalize(tv_direction)
			
		tf_dot = MATH_VecDotProduct(OBJ_SightGet(),tv_direction)
		if (tf_dot < 0.1 && i_link_action_type != MOVE_Climb)
		{
			ACT_ActionSet(Ann_demi_tour)
		}
	}
}

if (ACT_ActionGet() == Ann_demi_tour)
{
	if (ACT_ActionFinished())
	{
 		if( i_has_weapon )
			ACT_ActionSet(Ann_att_enjoue_bambou)
		else
			ACT_ActionSet(Ann_stress_attente)
			
		OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
	}
	else
		return
}

// COMPORTEMENT =================================================================================================

// orientation
if (o_safe_wp && ! i_action)
{
	tv_new_sight = @o_safe_wp OBJ_PosGet() - OBJ_PosGet() 

	tf_dist = MATH_VecNorm(tv_new_sight)
	tf_dot = MATH_VecDotProduct(OBJ_SightGet(),tv_new_sight)
	
	if ( ! MATH_VecNullEpsilon(tv_new_sight) )
	{
		tv_new_sight = MATH_VecNormalize(tv_new_sight)
		tv_new_sight = MATH_VecBlend(OBJ_SightGet(),tv_new_sight,TIME_GetDt() * 4.0)
		OBJ_BankingGeneralSet(tv_new_sight , Cv_VerticalVector)
	}
}

if (o_safe_wp)
{
	// arrivé a destination
	if (COL_Pivot_BVCollide(o_safe_wp))
	{
		// lecture d'actions
		i_action = @o_safe_wp OBJ_CapaGet() & WP_Capa_Action
		
		// if no action, go to next waypoint
		if ( ! i_action || OBJ_CapaTest(Capa_Disable_Action) )			
		{
			i_action = 0
			tn_net = n_current_net
			
			if (n_current_net)
			{
				KAnn_Set_Safe_Wp(KAnn_GetNextWPOnNetwork())
				// if theres a next wp, and it is on the same network we were on
				if (o_safe_wp && n_current_net && tn_net == n_current_net)
				{
					i_old_link_action_type = i_link_action_type
					i_link_action_type = WAY_LinkDesignGet(n_current_net,o_old_safe_wp,o_safe_wp )	
				}
			}
			else
				o_safe_wp = nobody			
		
			if ( ! o_safe_wp)
				i_at_end = 1
		}
	}
	else
	{
		tv_direction = @o_safe_wp OBJ_PosGet() - OBJ_PosGet()
		if ( ! MATH_VecNullEpsilon(tv_direction))
			MATH_VecSetNormalize(tv_direction)
	
		tf_dot = MATH_VecDotProduct(OBJ_SightGet(),tv_direction)
	
		if (tf_dot < 0.5)
		{
			if (OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna))	// not in climbing	
			{	 
				tv_speed = DYN_SpeedGetVector() 
				
				tv_speed.x *= MATH_FloatMax(0,tf_dot)
				tv_speed.y *= MATH_FloatMax(0,tf_dot)

				DYN_SpeedSetVector(tv_speed)
			}
		}
	}
}



// reset delta z
f_delta_z = 0.0

// manage climbing
if (i_link_action_type == MOVE_Climb && ! i_action)
{
	if (i_at_end)
	{
		if (! (OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_Dyna))
		{
			DYN_On()
			DYN_FlagsSet(DYN_C_BasicForces + DYN_C_NeverDynamicFather + DYN_C_VectorFriction + DYN_C_GlobalFriction + DYN_C_SkipFrictionWhenSpeedFromAnim, none)
			DYN_GravitySet(Cv_NormalGravity)
			DYN_MaxStepSet(0.45)		
		}	
	}	
	else
	{
		DYN_Off()	
		
		tv_pos_safe_wp = @o_safe_wp OBJ_PosGet() 
		tv_pos_old_safe_wp = @o_old_safe_wp OBJ_PosGet()
		
		tv_direction = tv_pos_safe_wp - tv_pos_old_safe_wp
				
		if (f_total_dist == -1.0)		
			f_total_dist = MATH_VecNorm(tv_direction)

		if ( ! MATH_VecNullEpsilon(tv_direction))
			tv_direction = MATH_VecNormalize(tv_direction)
	
		tf_dot = MATH_VecDotProduct(Cv_VerticalVector,tv_direction)	
		
		if (tf_dot > 0.8)
		{
			OBJ_BankingGeneralSet(@o_safe_wp OBJ_SightGet(), tv_direction)
	
			ACT_ActionSet(Ann_grimpe_monte)
		}
		else if (tf_dot < -0.8)	
		{
			if (ACT_ActionGet() == Ann_stress_course || ACT_ActionGet() == Ann_stress_marche || ACT_ActionGet() == Ann_cache_marche ||
			   ACT_ActionGet() == Ann_stress_course_affolee || ACT_ActionGet() == Ann_stress_course_affolee_G || ACT_ActionGet() == Ann_stress_course_affolee_D) 
			{
				ACT_ActionSet(Ann_grimpe_descentedeb)
				f_dyn_timer = 2.0	
			}
			
			if (ACT_ActionGet() == Ann_grimpe_descente || (ACT_ActionGet() == Ann_grimpe_descentedeb && ACT_ActionFinished()))
			{
				OBJ_BankingGeneralSet(@o_safe_wp OBJ_SightGet(), -tv_direction)	
						ACT_ActionSet(Ann_grimpe_descente)
			}
		}
		else 
		{
			tf_dot = MATH_VecDotProduct(OBJ_SightGet(),tv_direction)	
			if (tf_dot >= 0.0)
			{
				ACT_ActionSet(Ann_grimpe_coteD)
				tv_new_sight = MATH_VecRotate(tv_direction,Cv_VerticalVector, Cf_PiBy2)
				OBJ_SightGeneralSet(tv_new_sight , Cv_VerticalVector)
			}			
			else if (tf_dot < 0.0)
			{
				ACT_ActionSet(Ann_grimpe_coteG)
				tv_new_sight = MATH_VecRotate(tv_direction,Cv_VerticalVector, -Cf_PiBy2)
				OBJ_SightGeneralSet(tv_new_sight , Cv_VerticalVector)
			}
			
			// compute where ann should be in z on the link, according to her position in x/y
			tf_dist_vert_ref = tv_pos_safe_wp.z - tv_pos_old_safe_wp.z
			tv_pos_safe_wp.z = 0.0 
			tv_pos_old_safe_wp.z = 0.0 
			tf_dist_horiz_ref = MATH_VecNorm(tv_pos_safe_wp - tv_pos_old_safe_wp)

			tv_pos_ann = OBJ_PosGet()
			tv_pos_ann.z = 0.0
			tf_dist_horiz_ann = MATH_VecNorm(tv_pos_ann - tv_pos_old_safe_wp)
				
			tf_coef_dist = tf_dist_horiz_ann / tf_dist_horiz_ref
			f_delta_z = tf_dist_vert_ref * tf_coef_dist
				
		}	
	}
}
else 
{
	if (ACT_ActionGet() == Ann_grimpe_monte)
	{
		ACT_ActionSet(Ann_grimpe_montefin )
		f_dyn_timer = 4.0	
	}
	else if (ACT_ActionGet() == Ann_grimpe_montefin && ACT_ActionFinished())
	{
		f_dyn_timer = 0.0
	}
}

if ( i_action )
{
	if (@o_safe_wp OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_DesignStruct) )
	{
		i_action_id = o_safe_wp.des_int1
		i_sub_action_id = o_safe_wp.des_int2
		i_action_pos_safe = o_safe_wp.des_int3
	}
	macro_change_etat("KAnn_ETAT_action")
}
else if (o_safe_wp)
{
	if (i_at_end)
	{
	 	if( i_has_weapon )
			ACT_ActionSet(Ann_att_enjoue_bambou)
		else
			ACT_ActionSet(Ann_stress_attente)
	}
	else
	{
		if (ACT_ActionGet() != Ann_grimpe_montefin || (ACT_ActionGet() == Ann_grimpe_montefin && ACT_ActionFinished()) )
		{
			// Action déplacement
//			if( i_link_action_type == MOVE_Climb || ! KAnn_Action_Kong_Proche() )	
			// commenté car ça peut foutre la merde dans les ciné (on filme Ann qui est censée courir 
			// mais en fait elle reste accroupie en se protégeant car Kong est là et est en tran de se battre...)
			{
				// Action standard (Kong loin)
				switch (i_link_action_type)
				{
					case 	MOVE_Run : 
						//ACT_ActionSet(Ann_stress_course_affolee)   
						ACT_ActionSet(Ann_stress_course)   
						break		
					case MOVE_Walk : 
						ACT_ActionSet(Ann_stress_marche)
						break
					case MOVE_Crouch : 
						ACT_ActionSet(Ann_cache_marche)
						break		
					case MOVE_Trot : 
						ACT_ActionSet(Ann_stress_trot)   
						break
					case 	MOVE_Panicked	:
						ACT_ActionSet(Ann_stress_course_affolee)   
						break
					case MOVE_Panicked_Right :
						ACT_ActionSet(Ann_stress_course_affolee_D)   
						break
					case MOVE_Panicked_Left :
						ACT_ActionSet(Ann_stress_course_affolee_G)   
						break
				}
			}
		}
	}
}
else if (i_at_end)
{
	// tmp ------------------- 
 	DBG_Warning("Ann has reached the end of a network, or has to get fire but has no javelin !!!")
	DBG_Error("LD bug on Ann's network !!!")
	// tmp ------------------- 
	
 	if( i_has_weapon )
		ACT_ActionSet(Ann_att_enjoue_bambou)
	else
		ACT_ActionSet(Ann_stress_attente)
}

if (i_link_action_type != MOVE_Climb && ! (OBJ_FlagsIdentityGet() & OBJ_C_IdentityFlag_Dyna) && f_dyn_timer == 0)
{
	AI_Execute("KAnn_exec_dyn_on") 
}	

i_run_breath_enabled = vrai		// autorisée à jouer le son GeneKAnn_C_breath_run_fear
