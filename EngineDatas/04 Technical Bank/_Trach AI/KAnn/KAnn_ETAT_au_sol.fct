#include "KAnn_defines.var"

#define			Cf_dist_min_detect_fight_actor					400.0			// distance de détection d'un ennemi qui m'a pris pour cible
#define			Cf_dist_min_detect_enemy						100.0			// distance de détection d'un ennemi proche (qui ne m'a pas pris pour cible)
#define			Cf_toler_arrivee_sur_le_wp							0.3			// tolérance contact wp

int					ti_i
int					ti_indice_text
int					ti_context
int					ti_rank
int					ti_flag_gotowp
int					ti_action
int					ti_suivi_regard
int					ti_type_wp

float				tf_dist_max
float				tf_dist
float				tf_dot

object			to_actor
object			to_sight_object
object			to_WP
object			to_tmp
object			to_head
object			to_fight_actor_head

vector			tv_sight
vector			tv_temp

message		tm_msg
message		tm_msg_filter
messageid		EVT_ID

// Résolution locale ==============
int				ti_coll
vector		tav_coll_normales[Ci_max_wall]
vector		tv_sight_perfect
vector		tv_new_sight_init
vector		tv_new_sight_res_loc
float			tf_wp_best_dist
vector		tv_trace_res_loc_screen_pos
int				tai_coll_gmat_flags[Ci_max_wall]

#define macro_init_resolution_locale	\
{\
	tv_temp = @to_WP OBJ_PosGet() - OBJ_PosGet()\
	MATH_VecSetHorzNormalize(tv_temp)\
	to_tmp = @get_global o_ANN_KK_move_dir_wp \
	if (to_tmp == nobody)\
		to_tmp = to_WP\
	// tf_dot is unused => comment \
	// tf_dot = MATH_VecDotProduct(@to_tmp OBJ_SightGet(), tv_temp)\
	if( i_au_sol_move_coll_flag || i_force_sens_axe == faux || OBJ_SqrDist(to_WP) < 9.0 )\
		tv_sight_perfect = @to_WP OBJ_PosGet() - OBJ_PosGet()\
	else\
		tv_sight_perfect = @to_tmp OBJ_SightGet()\
	tv_new_sight_init = MATH_VecBlendRotate(OBJ_SightGet(), tv_sight_perfect, 5 * TIME_GetDt())\
	tv_sight = tv_new_sight_init \
	//DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_new_sight_init, color_jaune)\
	//DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_sight_perfect, color_vert)\
}


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	o_safe_wp = nobody
	MSG_SetNull(msg_KK_pose_ANN)
	@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN	
	DYN_FrictionVectorSet(cvector(1.0, 1.0, 0.0))
	
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_au_sol)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_au_sol

	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	fct_last_etat = AI_TrackCurGet()
	
	// AUTORISATIONS DES GRABS
	for (ti_i = 0; ti_i < Ci_LNK_TYPE_NB; ti_i++)
		ai_SRV_ENABLE[ti_i] = faux
	ai_SRV_ENABLE[Ci_LNK_GRAB_RAPTOR]		= vrai
	ai_SRV_ENABLE[Ci_LNK_GRAB_TRANSPORTE]	= vrai
	ai_SRV_ENABLE[Ci_LNK_KKGRAB_OBJECT]	= vrai
	
	ai_SRV_ENABLE[Ci_LNK_INTERACTION] = vrai
	
	f_time_start_etat = 0.0
	
	@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
	o_fight_actor = nobody
	DYN_FrictionVectorSet(cvector(5.0, 5.0, 5.0))
	
	// Choix du WP -----------------------------------------------------------------------------------------------------------------------
	i_au_sol_mode = Ci_ANN_au_sol_pas_de_wp		// par défaut, ANN n'a pas d'endroit ou aller
	
	o_safe_wp = KAnn_Choix_du_WP_Safe()		// Choix d'un wp si ANN n'en a pas déjà choisi un
	
	if( o_safe_wp )
		i_au_sol_mode = Ci_ANN_au_sol_va_au_wp			// ANN a un WP de destination
	
	i_au_sol_move_coll_flag = faux			// n'a pas encore collisionné de mur en allant au wp (une fois vrai, ANN se dirige vers le wp et plu sselon l'axe de déplacement)
	f_time_se_soigne = 0.0
	f_action_timer = 0.0
	
	ACT_ActionSet(Ann_stress_attente)
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// ANALYSE =======================================================================================================

AI_Execute("KAnn_exec_serveur_get")
if(ao_SRV[Ci_LNK_GRAB_RAPTOR])
	macro_change_etat("KAnn_ETAT_grabbed_raptor")
	
if(ao_SRV[Ci_LNK_GRAB_TRANSPORTE])
	macro_change_etat("KAnn_ETAT_grabbed_bat")

if(ao_SRV[Ci_LNK_KKGRAB_OBJECT])
	macro_change_etat("KAnn_ETAT_grabbed_KK")

if(ao_SRV[Ci_LNK_INTERACTION])
	macro_change_etat("KAnn_ETAT_attack_bat")

if ( MATH_FloatNullEpsilon( @get_global f_time_KK_ANN_avant_la_mort))
{
	AI_Execute("KAnn_exec_CHECK_paf")
	if (o_paf_sender) 
		macro_change_etat("KAnn_ETAT_paf")
}

// COMPORTEMENT =======================================================================================================

if( COL_CollideType(COL_C_Ground) )
	i_au_sol_flag = vrai
else
	i_au_sol_flag = faux


// Résolution Locale
if( i_res_loc_flag && i_au_sol_mode != Ci_ANN_au_sol_va_au_wp )
	i_res_loc_flag = faux			// fin de la résolution locale


// WP =========================================================================================
to_WP = o_safe_wp

// CHECK ENNEMI DIRECT ==========================================================================
switch ( i_au_sol_mode )
{
	case Ci_ANN_au_sol_sur_le_wp :
	case Ci_ANN_au_sol_pas_de_wp :
	case Ci_ANN_au_sol_fight :
		// ANN fuit jusqu'à ce qu'elle soit à son wp. Une fois au wp elle se retourne pour se défendre
		MSG_SetNull(tm_msg_filter)
		tm_msg_filter.msg_gao1 = OBJ_Me()
		if( ( ! o_fight_actor ) || ( o_fight_actor && (f_fight_actor_maj > 0.25) ) )
		{
			// Pas d'ennemi ou ennemi updaté il y a plus de 1.5 sec
			o_fight_actor = nobody
			f_fight_actor_maj = 0.0
			
			tf_dist_max = Cf_Infinit
			tf_dist = Cf_Infinit
			ti_rank = -1
			for( 	EVT_ID = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Interet, &ti_rank, tm_msg_filter);
					MSG_GlobalIsValid(EVT_ID);
					EVT_ID = MSG_GlobalSearchIntGao( C_EVENT_TYPE_Interet, &ti_rank, tm_msg_filter) )
			{
				to_actor = MSG_GlobalGetSender(EVT_ID)
				tf_dist = OBJ_SqrDist(to_actor)
				if( (tf_dist < tf_dist_max) && (tf_dist <= Cf_dist_min_detect_fight_actor) )
				{
					// plus proche que l'ancien mais suffisamment proche tout de même
					if( i_au_sol_mode != Ci_ANN_au_sol_fight )
						KAnn_Texte(Gene_C_caught)			// passage en mode fight -> aaaaaahh !!!
					
					o_fight_actor = to_actor
					tf_dist_max = tf_dist
					i_au_sol_mode = Ci_ANN_au_sol_fight
				}
			}
		}
		else
			f_fight_actor_maj += TIME_GetDt()
	break
	default:
		o_fight_actor = nobody
	break
}


// CHECK ENNEMI PROCHE ==========================================================================
// NOTE : la différence est que ANN ne passe pas en mode Ci_ANN_au_sol_fight, 
// ce test sert à jouer l'anim terrorisé sans être en combat (et donc le timer est stoppé)
//if( i_au_sol_mode != Ci_ANN_au_sol_fight )
//{
//	o_fight_actor = nobody
//	tf_dist_max = Cf_Infinit
//	tf_dist = Cf_Infinit
//	ti_rank = -1
//	for( 	EVT_ID = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank);
//			MSG_GlobalIsValid(EVT_ID);
//			EVT_ID = MSG_GlobalScan( C_EVENT_TYPE_Enemy, &ti_rank) )
//	{
//		to_actor = MSG_GlobalGetSender(EVT_ID)
//		tf_dist = OBJ_SqrDist(to_actor)
//		if( (tf_dist < tf_dist_max) && (tf_dist <= Cf_dist_min_detect_enemy) )
//		{
//			// plus proche que l'ancien mais suffisamment proche tout de même
//			o_fight_actor = to_actor
//			tf_dist_max = tf_dist
//		}
//	}
//}

// COMPORTEMENT ==========================================================================

// ACTION, ORIENTATION ET REGARD -------------------------------------------------------------------------------------------------------------------------
to_sight_object = nobody

switch ( i_au_sol_mode )
{
	case Ci_ANN_au_sol_fight :
		if( ! o_fight_actor )
		{
			// orientation
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_KONG
			
			// action
			//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
			
			// Combat terminé
			i_cine_ANN_attack_played = faux		// autorise un nouveau cut scene
			
			if( to_WP )
			{
				// KONG a déposé ANN près d'un WP
				tv_temp = @to_WP OBJ_PosGet() - OBJ_PosGet()
				tv_temp.z = 0.0
				tf_dist = MATH_VecNorm(tv_temp)
				if( MATH_FloatNullToler(tf_dist, Cf_toler_arrivee_sur_le_wp) )
					i_au_sol_mode = Ci_ANN_au_sol_sur_le_wp
				else
					i_au_sol_mode = Ci_ANN_au_sol_va_au_wp
			}
			else
				i_au_sol_mode = Ci_ANN_au_sol_pas_de_wp
		}
		else
		{
			// Combat en cours
			
			// orientation
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_fight_actor
			
			// action
			if (  OBJ_SqrDist( o_fight_actor) < 100.0)
			{
				// Timer avant la mort
				@get_global f_time_KK_ANN_avant_la_mort -= MATH_FloatMin( @get_global f_time_KK_ANN_avant_la_mort, TIME_GetDt())
			 	if ( @get_global f_time_KK_ANN_avant_la_mort  <= 0)
			 	{
				 	//@get_global f_time_KK_ANN_avant_la_mort = 0.0
					//tm_msg.msg_id = msg_id_KK_Tue_ANN
					//tm_msg.msg_sender = OBJ_Me()
					//@o_fight_actor MSG_Send( tm_msg)
					//ti_indice_text = STR_CreateText("\h0.1\",cvector( 0.5, 0.1, 0.0), 0)	
					//STR_AppendText( ti_indice_text, "TOO LATE")
				}
				else
				{
					//ti_indice_text = STR_CreateText("\jxy\ \h",cvector( 0.5, 0.1, 0.0), 0)	
					//STR_AppendFloat( ti_indice_text, 0.04 + ( ( 1.0 - (@get_global f_time_KK_ANN_avant_la_mort / 15.0)) * 0.06),3)
					//STR_AppendText( ti_indice_text, "\")
					//STR_AppendFloat( ti_indice_text, @get_global f_time_KK_ANN_avant_la_mort, 1)
				}
			}
			
			// action
			//ti_action = Ann_terrorisee_attente
			//ti_action = Action_Attack_torch_wait

		
			//to_fight_actor_head = @o_fight_actor ANI_CanalObjectGet(Anim_Canal_Tete) OBJ_PosGet()
			 	 		
			//if (MATH_VecNorm( OBJ_PosGet() - @to_fight_actor_head OBJ_PosGet()) < 3.0)
			//{
//				ti_action = Action_Attack_torch
//			}
						
			if( ( ! i_cine_ANN_attack_played ) && ( f_time_start_etat > 2.0 ) )
			{
				// Cut scene pas encore jouée
				i_cine_ANN_attack_played = vrai
				
				// ANN CRIE
				KAnn_Texte(Gene_C_help)
//				Str_DisplayTextOnce("\c000000FF\KOOOOONG A L'AIIIIIIIIDE !!!", cvector(0, 0.5, 0))
				f_time_start_etat = 0.0
				
				// CUT SCENE
				// Kcamera_Insert_Plan( float Kcamera_duration, vector Kcamera_axis, float Kcamera_dist, object Kcamera_target, int Kcamera_module , vector Kcamera_offset, float Kcamera_transpeed, int Kcamera_flags)
				tv_temp = @o_fight_actor OBJ_PosGet() - OBJ_PosGet()
				tv_temp.z = 0.0
				tv_temp = MATH_VecBlendRotate(tv_temp, Cv_VerticalVector, 0.2)
//				Kcamera_Insert_Plan(4.0, tv_temp, 2.0, OBJ_Me(), -1, cvector(0.5, 0.0, 1.5), 0.0, 0b0)
			}
//			else
//			{
//				// Cut scene déjà jouée
//				if( f_time_start_etat <= 2.0 )
//					Str_DisplayTextOnce("\c000000FF\KOOOOONG A L'AIIIIIIIIDE !!!", cvector(0, 0.5, 0))
//			}
		}
		break
		
	case Ci_ANN_au_sol_va_au_wp :
		// orientation
		if( ! to_WP )
		{
			i_au_sol_mode = Ci_ANN_au_sol_pas_de_wp
			break
		}
		
		macro_init_resolution_locale
		RES_LOC_LIB_Collision(1.0, tv_sight_perfect, ti_coll, &tav_coll_normales[0], &tai_coll_gmat_flags[0], faux )
		if( ( ! i_res_loc_flag && ti_coll )
			|| ( i_res_loc_flag && ! ti_coll ) )
		{
			// on n'est pas encore en résolution locale et une collision est détectée
			// OU on est en résolution locale et aucune collision n'est détectée
			// => début ou fin de la résolution locale => on checke si le meilleur wp safe n'a pas changé
			i_au_sol_move_coll_flag = vrai
			o_safe_wp = KAnn_Choix_du_WP_Safe()
			to_WP = o_safe_wp
			if( ! to_WP )
			{
				i_au_sol_mode = Ci_ANN_au_sol_pas_de_wp
				break
			}

			macro_init_resolution_locale
			RES_LOC_LIB_Collision(1.0, tv_sight_perfect, ti_coll, &tav_coll_normales[0], &tai_coll_gmat_flags[0], faux )
		}
		
		tv_new_sight_res_loc = RES_LOC_LIB_Resolution_Locale_Normales(tv_new_sight_init, tv_sight_perfect, ti_coll, &tav_coll_normales[0], &tai_coll_gmat_flags[0], f_res_loc_force_sens, v_res_loc_normale_choisie, i_DBG_trace_res_loc)
		
		if( tv_new_sight_res_loc != tv_new_sight_init )
		{
			i_res_loc_flag = vrai
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_new_sight_res_loc, 5 * TIME_GetDt())
			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_new_sight_res_loc, color_cyan)
		}
		else
			i_res_loc_flag = faux
		
		// Timer avant la mort
		@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
		
		// action
		//if( OBJ_SqrDist(to_WP) > 9 )
		//	ti_action = KAnn_Select_Action(Ci_Action_Type_Course)
		//else
		//	ti_action = KAnn_Select_Action(Ci_Action_Type_Marche)
		
		// test wp atteint
		tv_temp = @to_WP OBJ_PosGet() - OBJ_PosGet()
		tv_temp.z = 0.0
		tf_dist = MATH_VecNorm(tv_temp)
		if( MATH_FloatNullToler(tf_dist, Cf_toler_arrivee_sur_le_wp) )
		{
			i_au_sol_mode = Ci_ANN_au_sol_sur_le_wp					// WP atteint
			f_time_start_etat = 0.0
		}
		
		// regard
		to_sight_object = to_WP
		
		break
		
	case Ci_ANN_au_sol_sur_le_wp :
		// Timer avant la mort
		@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
		
		if( o_fight_actor )
		{
			// ennemi menaçant (proche de ANN mais ce n'est pas ANN sa cible)
			ti_action = Ann_terrorisee_attente
			//tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), - @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_fight_actor
		}
		else
		{
			ti_type_wp = @get_KIAS_Path o_safe_wp i_action_type
			switch( ti_type_wp )
			{
				case Ci_PoseAnn_CacheToi :
					// orientation
//					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), - @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
				to_sight_object = o_KONG
					
					// action
					//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
					break
					
		 		case Ci_PoseAnn_VaBoire :
			 		if( i_life_state == Life_ETAT_Agonisant )
			 		{
				 		// ANN blessée
			 			
			 			// orientation
						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
						to_sight_object = to_WP
						
						// action
						ti_action = Ann_Se_Soigne
				 		
				 		f_time_se_soigne += TIME_GetDt()
				 		if( f_time_se_soigne > 5.0)
						{
							f_time_se_soigne = 0.0
							KAnn_Life_Set(Life_ETAT_Conval)
						}
					}
					else
					{
						// ANN pas blessée
						
						// orientation
//						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), - @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
						to_sight_object = o_KONG
						
						// action
						//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
					}
			 		break
			 		
				case Ci_PoseAnn_VaAgir :
					// orientation
//					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
	
					if (f_action_timer <= 5.0)
					{
						// action temporaire de test à remplacer par la bonne action d'activation qd elle sera dispo
	//					ti_action = Action_Ramasse_Debut
      					f_action_timer += TIME_GetDt()
						tv_sight = @to_WP OBJ_PosGet() - OBJ_PosGet()
					}
					else
					{
						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
						to_sight_object = to_WP
					
						// action
						//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
					}
					
					break
					
				case Ci_PoseAnn_SuisReseau :
					n_net = @to_WP WAY_NetOfObj()
					//macro_change_etat("KAnn_ETAT_follow_network")
					to_WP = WAY_NetNextWP(n_net, to_WP, 0, 0)
					
					// Not the last waypoint in the network ?
					if (to_WP != nobody)
					{
						tv_sight_perfect = @to_WP OBJ_PosGet() - OBJ_PosGet()
						tv_new_sight_init = MATH_VecBlendRotate(OBJ_SightGet(), tv_sight_perfect, 5 * TIME_GetDt())
						tv_sight = tv_new_sight_init
						i_au_sol_mode = Ci_ANN_au_sol_va_au_wp
						o_safe_wp = to_WP
					}
					else
					{
						// There is no other WP in the current network : Ann looks at Kong and waits
						tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
						to_sight_object = to_WP
						//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
					}
					break
					
				default:
					DBG_Error("KAnn_ETAT_au_sol : Ci_ANN_au_sol_sur_le_wp Pose : ti_type_wp inconnu")
					
					// orientation
//					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @to_WP OBJ_SightGet(), 3 * TIME_GetDt())
					tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
					to_sight_object = o_KONG
					
					// action
					//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
					break
			}
		}
		break
		
	case Ci_ANN_au_sol_pas_de_wp :
		if( o_fight_actor )
		{
			// ennemi menaçant (proche de ANN mais ce n'est pas ANN sa cible)
			ti_action = Ann_terrorisee_attente
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_fight_actor OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_fight_actor
		}
		else
		{
			// orientation	
//			tv_sight = OBJ_SightGet()
			tv_sight = MATH_VecBlendRotate(OBJ_SightGet(), @o_KONG OBJ_PosGet() - OBJ_PosGet(), 3 * TIME_GetDt())
			to_sight_object = o_KONG
			
			// Timer avant la mort
			@get_global f_time_KK_ANN_avant_la_mort = Cf_Delai_Tue_ANN
			
			// action
			//ti_action = KAnn_Select_Action(Ci_Action_Type_Attente)
		}
		break
		
	default:
		DBG_Error("KAnn_ETAT_au_sol : i_au_sol_mode inconnu")
		break
}

OBJ_BankingGeneralSet(tv_sight, Cv_VerticalVector)
ACT_ActionSet(ti_action)


// SUIVI DU REGARD ==================================================================================

o_suivi_regard_object = to_sight_object

if( i_DBG_trace_res_loc )
{
	if( i_res_loc_flag )
	{
		tv_trace_res_loc_screen_pos = cvector(0,0.85,0)
		Str_DisplayTextOnce("ANN RES LOC", tv_trace_res_loc_screen_pos)
		if( f_res_loc_force_sens == 1.0 )
			Str_DisplayTextOnce("Sens Force Gauche", tv_trace_res_loc_screen_pos + cvector(0,0.05,0))
		else if( f_res_loc_force_sens == -1.0 )
			Str_DisplayTextOnce("Sens Force Droite", tv_trace_res_loc_screen_pos + cvector(0,0.05,0))
	}
}

//Str_DisplayGaoOnce(to_sight_object, Cv_NullVector)

