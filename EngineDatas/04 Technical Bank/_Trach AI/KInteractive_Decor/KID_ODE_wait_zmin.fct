#include "KID_Defines.var"

int			ti_ind
int			ti_off
int			ti_IsTrackDone
int 		ti_IsDestroyNeeded
int 		ti
int 		ti_instance
int 		ti_DistDest
int 		ti_TimeDest

// TIME SOUND FOR MAX NUMBER OF SECOND INSTANCES SOUND MANAGEMENT
f_time_sound += TIME_GetDt()
f_time_break += TIME_GetDt()
ti_IsTrackDone = vrai
ti_IsDestroyNeeded = faux

ti = 0
while( ti < C_MaxBriques )
{
	if ( ao_ODE_briques[ti] )
	{
		KID_Proc_ODE_Limit( ao_ODE_briques[ti], 20.0, 5.0)
		af_ode_vitesseL_frame[ti] = @ao_ODE_briques[ti] ODE_Getf( 2 )
		af_ode_deriveeL_frame[ti] = ( af_ode_vitesseL_frame[ti] - af_ode_vitesseL_old_frame[ti] ) / TIME_GetDt()
	
		af_ode_vitesseA_frame[ti] = @ao_ODE_briques[ti] ODE_Getf( 3 )
		af_ode_deriveeA_frame[ti] = ( af_ode_vitesseA_frame[ti] - af_ode_vitesseA_old_frame[ti] ) / TIME_GetDt()
	}
	ti ++
}

// set the approriate briques to activated
for( ti_ind = 0; ti_ind < C_MaxBriques; ti_ind++)
{
	if ( ao_ODE_briques[ti_ind] )
	{
		if ( mai_PafNumberToBreakOn[ti_ind] <= mi_NumberOfPafs || !mi_IsMultiHit )
		{
//			if ( !mai_DontDestroyBriqueAfterODE[ti_ind] )
			{
				mai_IsBriqueOdeActive[ti_ind] = vrai
			}
		}
	}
}

ti_off = 0
for( ti_ind = 0; ti_ind < C_MaxBriques; ti_ind++)
{
	ti_DistDest = faux
	ti_TimeDest = faux

	if ( ao_ODE_briques[ti_ind] && @ao_ODE_briques[ti_ind] OBJ_PosGet().z - OBJ_PosGet().z <= mf_VertDistFrmAIWPToDestBrick[ti_ind] )
	{
		ti_DistDest = vrai
	}
	
	if ( ao_ODE_briques[ti_ind]  && f_break_time > 0.1 && mai_DestroyAfterTime[ti_ind] && ( TIME_Get() - f_break_time >= maf_MaxTimeToLiveAfterActive[ti_ind] ) )
	{
		ti_TimeDest = vrai
		@ao_ODE_briques[ti_ind] ODE_Enable(0)
		if ( @ao_ODE_briques[ti_ind] VIEW_Culled(0))
			ti_DistDest = vrai
			
	}
	
	if ( ao_ODE_briques[ti_ind] && mai_IsBriqueOdeActive[ti_ind] && ti_DistDest) // || ti_TimeDest ) )
	{
		mai_IsBriqueOdeActive[ti_ind] = faux
		@ao_ODE_briques[ti_ind] ODE_Enable(0)
	
		if ( !( @ao_ODE_briques[ti_ind] OBJ_FlagsIdentityTest( OBJ_C_IdentityFlag_AI ) ) )
		{	
			if ( ( ti_DistDest || ( i_detruit_apres_paf && ti_TimeDest ) ) && !mai_IsGFXActive[ti_ind] && !mai_IsDestroyGFXStarting[ti_ind] )
			{
				mai_IsDestroyGFXStarting[ti_ind]	= vrai
				ti_IsDestroyNeeded						= vrai
				
				@ao_ODE_briques[ti_ind] OBJ_FlagInvisibleSet( vrai )
			}
		}
	}
}

if ( ti_IsDestroyNeeded )
{
	AI_TrackChange( C_Track_Destroy, "KID_destroy" )	// GFX start...you might want to try not making the brique invisible yet
}

//JIMI_NOTE: added i_ODE_break condition so that this only happens when the whole structure is destroyed
if( !mi_IsProjDestructionDone && i_ODE_break && o_ODE_projectile  && MATH_VecDistance( v_ODE_Punch_init_pos, @o_ODE_projectile OBJ_PosGet()) > 7.0)
{
	@o_ODE_projectile ODE_Enable( faux)
	@o_ODE_projectile OBJ_Destroy()
	o_ODE_projectile = nobody
	
	mi_IsProjDestructionDone = vrai
}	

if ( i_ODE_break && !mi_IsProjDestructionDone )
{
	if ( o_ODE_projectile )
	{
		@o_ODE_projectile ODE_Enable( faux )
		@o_ODE_projectile OBJ_Destroy()
		o_ODE_projectile  = nobody
	}
}

for( ti_ind = 0; ti_ind < C_MaxBriques; ti_ind++)
{
	if ( mai_IsBriqueOdeActive[ti_ind] )
	{
		ti_IsTrackDone = faux
	}
}

// ------- GESTION DU SON -------
AI_Execute("kid_exec_gestion_son")

// ------- SAUVEGARDE DES VITESSES  -------
ti = 0
while( ( ti < C_MaxBriques ) ) // && ao_ODE_briques[i] )
{
	if ( ao_ODE_briques[ti] )
	{
		af_ode_vitesseL_old_frame[ti] = af_ode_vitesseL_frame[ti]
		af_ode_deriveeL_old_frame[ti] = af_ode_deriveeL_frame[ti]
		af_ode_vitesseA_old_frame[ti] = af_ode_vitesseA_frame[ti]
		af_ode_deriveeA_old_frame[ti] = af_ode_deriveeA_frame[ti]
	}
	ti ++
}


// TEST ZMIN NEW
//ti_DistDest = 0
//for( ti_ind = 0; ti_ind < C_MaxBriques; ti_ind++)
//{
//	if ( ! ao_ODE_briques[ti_ind] )
//		ti_DistDest ++
//	else if (@ao_ODE_briques[ti_ind] OBJ_PosGet().z - OBJ_PosGet().z <= mf_VertDistFrmAIWPToDestBrick[ti_ind] 
//	|| ( f_time_break > 5.0 && ODE_Pause(-1)) )
//	{
//		@ao_ODE_briques[ti_ind] OBJ_FlagInactiveSet(vrai)
//		ao_ODE_briques[ti_ind] = nobody
//	}
//}
//if ( ti_DistDest  ==  C_MaxBriques)
//	OBJ_FlagInactiveSet( vrai)
// TEST ZMIN NEW


// normal check for zmin stop
if ( ti_IsTrackDone )
{
	if ( i_instance_snd_rumble != -1)
	{
		SND_Stop( i_instance_snd_rumble )
		i_instance_snd_rumble = -1
	}

	AI_TrackStop( C_Track_WaitZMin )
}