#include "KID_Defines.var"

int		ti_control_flag
int		ti_IndexToBrique
int		ti_IndexToPAG
int		ti_test
int		ti_sf

if (i_MemoBrokenStatus)
{
	// SF RULES ======================================================
	i_SF_AlreadyPlayed = AI_SFDynGet(0, SF_MinById, SF_MaxById)		// Detruite ?
	SpecialFlag_get(i_SF_AlreadyPlayed, ti_sf)
	if ( ti_sf )
	{
		i_ODE_nb_briques = 0
		while( i_ODE_nb_briques < C_MaxBriques && ao_ODE_briques[i_ODE_nb_briques] )
		{
			@ao_ODE_briques[i_ODE_nb_briques] ODE_Enable(faux)
			@ao_ODE_briques[i_ODE_nb_briques] OBJ_Destroy()
			i_ODE_nb_briques++
		}
		ODE_Enable(faux)
		OBJ_Destroy()
	}
	// SF RULES ======================================================
}

ai_instance_snd_whoosh[0] = -1
ai_instance_snd_whoosh[1] = -1
ai_instance_snd_whoosh[2] = -1
ai_instance_snd_whoosh[3] = -1

// Calcul du nb de briques ODE
i_ODE_nb_briques = 0
while( i_ODE_nb_briques < C_MaxBriques && ao_ODE_briques[i_ODE_nb_briques] )
{

	// FUCK LES VARS dESIGN	
	mai_DestroyAfterTime[i_ODE_nb_briques] = 1.0
	maf_MaxTimeToLiveAfterActive[i_ODE_nb_briques]	 = 5.0
	mf_VertDistFrmAIWPToDestBrick[i_ODE_nb_briques] = -10.0

	switch( i_type_decor )
	{
		case Ci_type_decor_palmier :
		case Ci_type_decor_porte :
		case Ci_type_decor_pilier :
		case Ci_type_decor_muret :
			i_extra_force[i_ODE_nb_briques] = vrai
			f_amount_force = MATH_FloatMax(f_amount_force, 8.0)
			break
	}

	ti_control_flag = @ao_ODE_briques[i_ODE_nb_briques] ODE_Geti( 0 )
	ti_control_flag |= 0x20		// Immovable
	@ao_ODE_briques[i_ODE_nb_briques] BV_MinSet(cvector(-10.0, -10.0, -10.0))		// Set la taille BV Min et Max
	@ao_ODE_briques[i_ODE_nb_briques] BV_MaxSet(cvector(10.0, 10.0, 10.0))		// Set la taille BV Min et Max
	@ao_ODE_briques[i_ODE_nb_briques] ODE_Seti( 0, ti_control_flag )
	@ao_ODE_briques[i_ODE_nb_briques] OBJ_FlagInactiveSet( vrai )
	i_ODE_nb_briques++
}

if ( i_ODE_nb_briques )
{
	i_ODE_break = faux								// Il faut casser le mur ODE avant de passer dessus
	f_break_time = 0.0
}
else
{
	i_ODE_break = vrai								// Pas d ODE le mur est déjà cassé
	f_break_time = TIME_Get()
}

f_time_end = 0.0

i_projection_passe_mur_du1er_coup = faux
switch( i_type_decor )
{
	case Ci_type_decor_muret :
		i_projection_passe_mur_du1er_coup = vrai
		i_Kong_puissance_pour_KC = Ci_puissance_pour_KC_Moyen
		break
		
	case Ci_type_decor_palmier :
		mi_TargetType = Ci_target_type_Tree		// force le type de target
		mi_IsThrownObjectTargettable = faux
		i_detruit_apres_paf = vrai		// force vrai
		i_Kong_puissance_pour_KC = Ci_puissance_pour_KC_Repousse
		break
	
	case Ci_type_decor_pilier :
		i_Kong_puissance_pour_KC = Ci_puissance_pour_KC_Repousse
		break
		
	case Ci_type_decor_pieu :
	case Ci_type_decor_porte :
	default:
		i_Kong_puissance_pour_KC = Ci_puissance_pour_KC_Moyen
		break
}

// TARGETTABLE ?
if( mi_IsThrownObjectTargettable && OBJ_CapaTest(CAPA_Not_Targettable) )
	mi_IsThrownObjectTargettable = faux

o_ODE_projectile = get_KODE_Poing

// make sure there is a good (non zero) value in the vertical z value limit.
//for ( ti_IndexToBrique = 0; ti_IndexToBrique < C_MaxBriques; ti_IndexToBrique++ )
//{
//	if ( ( mf_VertDistFrmAIWPToDestBrick[ti_IndexToBrique] ) <= 0.0001 && ( mf_VertDistFrmAIWPToDestBrick[ti_IndexToBrique] >= -0.0001 ) )
//	{
//		mf_VertDistFrmAIWPToDestBrick[ti_IndexToBrique] = -10.0
//	}
//}


// init the PAG stuff
for ( ti_IndexToBrique = 0; ti_IndexToBrique < C_MaxBriques; ti_IndexToBrique++ )
{
	// if there isn't a brick, there won't be PAGs to activate there
	if ( ao_ODE_briques[ti_IndexToBrique] )
	{
		for ( ti_IndexToPAG = 0; ti_IndexToPAG < C_MaxHitPags; ti_IndexToPAG++ )
		{
			mai_IsPAGActiveForLocation[ti_IndexToBrique][ti_IndexToPAG]	= faux
			maf_PAGStartTime[ti_IndexToBrique][ti_IndexToPAG]					= 0.0
			mai_IsPAGCreatedForLocation[ti_IndexToBrique][ti_IndexToPAG]	= faux
		}
	}
}

// init the multi-hit stuff
mi_NumberOfPafs = 0

for ( ti_IndexToBrique = 0; ti_IndexToBrique < C_MaxBriques; ti_IndexToBrique++ )
{
	if ( mai_PafNumberToBreakOn[ti_IndexToBrique] > mi_LastHit )
	{
		mi_LastHit = mai_PafNumberToBreakOn[ti_IndexToBrique]
	}
}

if ( mi_LastHit <= 0 )
{
	mi_IsMultiHit = faux
}

// ------ INIT SOUND
i_instance_snd_rumble = -1
f_percent_rumble = 1.0
i_cur_num_instances_per_second = 0


// init trigger flags
for ( ti_IndexToBrique = 0; ti_IndexToBrique < C_MAX_Triggers; ti_IndexToBrique++ )
{
	mi_TriggerExec_Flag[ti_IndexToBrique] = faux
}

AI_TrackCurChange( "KID_wait" )
