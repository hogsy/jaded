Include_UltraProcedure_Header
#include "KID_Defines.var"

int		ti_ind
int		ti_rank
int		ti_paf
int		ti_control_flag
int		ti_paf_force
int		ti_i
int		ti_TrackIsDone
int		ti_ActualNumCols
int 	ti_JumpPafToBeIgnored
int		ti_desactive
int		i
int		j 
int		ti_casse
int		i_Native
int		i_LinkedKID

float		tf_dot
float		tf_dist
float		tf_dist2

vector	tv_speed
vector	tv_pos
vector	tv_sens
vector	tv_sens_ortho
vector	tv_paf_sens
vector	tv_paf_pos
vector 	tv_Velocity

object	to_sender
object	to_actor
object	to_obj
object	to_kong

message	tm_msg_filter
messageid	tmid_paf_event
messageid	EVT_ID

//f_time_sound = 0

ti_TrackIsDone = faux

if ( AI_TriggerIsValid( mt_TriggerTest) && ! call_trigger( mt_TriggerTest))
	return

to_kong = @"univ" ao_AllHumains[C_ID_Kong]

// FIND TREX  FOR MURET AND PIEUX =======================================================================
//if( i_type_decor == Ci_type_decor_muret || i_type_decor == Ci_type_decor_pieu )
//{
//	if ( o_uncol )
//	{
//		// Ce TREX veux passer le muret ----------------------------------------
//		tv_sens = OBJ_PosGet() - @o_uncol OBJ_PosGet()
//		tv_sens.z = 0.0
//		if( i_type_decor == Ci_type_decor_muret )
//		{
//			// Muret : passer dessus
//			@o_uncol OBJ_BankingGeneralSet( MATH_VecBlendRotate( @o_uncol OBJ_SightGet(), -f_uncol_sign * OBJ_HorizonGet(), 6.0 * TIME_GetDt()), Cv_VerticalVector)
//			tf_dist = MATH_AbsFloat( MATH_VecDotProduct( tv_sens, OBJ_SightGet()))
//			if ( @o_uncol  ANI_CurrentFrameGet(0) > 60 && (( f_uncol_sign * f_uncol_dist * MATH_VecDotProduct( tv_sens, OBJ_SightGet()) > 0.0 ) || tf_dist < f_epaisseur) )
//				@o_uncol OBJ_PosSet( @o_uncol OBJ_PosGet( ) + (f_uncol_sign * f_uncol_dist * 2.0 * (OBJ_SightGet() * TIME_GetDt())))
//			if( ! @o_uncol OBJ_CapaTest(REX_CAPA_Passe_Muret) )
//			{
//				@o_uncol COL_UnCollidableDel(OBJ_Me())
//				o_uncol = nobody
//			}
//		}
//		else
//		{
//			// Pieux : tomber dessus ----------------------------------------------
//			@o_uncol OBJ_BankingGeneralSet( MATH_VecBlendRotate( @o_uncol OBJ_SightGet(), v_sens_KM , 6.0 * TIME_GetDt()), Cv_VerticalVector)
//			tv_pos = OBJ_PosGet()
//			tv_pos.z = @o_uncol OBJ_PosGet( ).z
//			@o_uncol OBJ_PosSet( MATH_VecBlend(@o_uncol OBJ_PosGet( ), tv_pos, f_snap_blend))
//			f_snap_blend += TIME_GetDt()
//			if ( ! @o_uncol OBJ_CapaTest(REX_CAPA_Passe_Muret) )
//			{
//				if ( MATH_FloatNullEpsilon( f_time_end))
//					EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, C_PAF_KK_KiTue, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_uncol, -1, 0, Cv_NullVector, OBJ_PosGet())
//				else if ( f_time_end > 1.5)
//					AI_TrackCurStop()
//				f_snap_blend += TIME_GetDt() * 2.0
//				f_time_end += TIME_GetDt()
//			}
//		}
//	}
//	else if ( i_ODE_break && ( i_projection_passe_mur_du1er_coup || TIME_Elapsed( f_break_time, 1.0) ) )
//	{
//		// Detection d un TREX qui veux passer le muret
//		for( ti_ind = 0; ti_ind< @get_list_manager i_TREX_nb ; ti_ind++ )
//		{
//			to_actor = @get_list_manager ao_TREX[ ti_ind]
//			if( COL_BV_PivotCollide( to_actor) && @to_actor OBJ_CapaTest(REX_CAPA_Passe_Muret) )		// REX dans la BV & en passe mur
//			{
//				tf_dot = MATH_VecDotProduct( @to_actor OBJ_HorizonGet(), OBJ_SightGet())
//				tv_speed = @to_actor DYN_SpeedGetVector()
//				tv_speed.z = 0.0
//				tv_sens = OBJ_PosGet() - @to_actor OBJ_PosGet()
//				tv_sens.z = 0.0
//				tf_dist = MATH_AbsFloat( MATH_VecDotProduct( tv_sens, OBJ_SightGet()))
//				tf_dist2 = MATH_AbsFloat( MATH_VecDotProduct( tv_sens, OBJ_HorizonGet()))
//	
//				if ( tf_dist < 7.0 && tf_dist2 < f_longueur && ( i_type_decor == Ci_type_decor_pieu || MATH_AbsFloat( tf_dot) > Cf_Cos60 ) && MATH_VecDotProduct( tv_speed, tv_sens) > 0.0	// Rex se deplace vers le mur
//				&& @to_actor ANI_CurrentFrameGet(0) < 75 )													// Rex a encore le temps de passer le mur
//				{
//	 				f_uncol_sign = MATH_FloatSign( tf_dot)
//					f_uncol_dist = tf_dist * MATH_FloatSign( MATH_VecDotProduct(tv_speed, @to_actor OBJ_HorizonGet())   )
//					o_uncol = to_actor
//					@o_uncol COL_UnCollidableAdd(OBJ_Me())
//					f_snap_blend = 0.0
//					tv_sens = OBJ_PosGet() - @o_uncol OBJ_PosGet()
//					tv_sens.z = 0.0
//					v_sens_KM =MATH_VecRotate( tv_sens, Cv_VerticalVector, -Cf_PiBy2 * MATH_FloatSign( MATH_VecDotProduct(tv_speed, @o_uncol OBJ_HorizonGet())))
//				}
//			}
//		}
//	}
//}


// LECTURE DES PAFS ==========================================================================
ti_paf = faux
MSG_SetNull(tm_msg_filter)
tm_msg_filter.msg_gao1 = OBJ_Me()
ti_rank = -1
tv_paf_sens = Cv_NullVector
for(	tmid_paf_event = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_rank, tm_msg_filter);
	MSG_GlobalIsValid(tmid_paf_event);
	tmid_paf_event = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_rank, tm_msg_filter)	)
{
	to_sender = MSG_GlobalGetSender( tmid_paf_event)
	if( i_type_decor == Ci_type_decor_pieu )
		continue
	
	tv_sens = OBJ_PosGet() - @to_sender OBJ_PosGet()
	MATH_VecSetHorzNormalize(tv_sens)
	if ( i_type_decor == Ci_type_decor_porte && MATH_VecDotProduct( tv_sens, @to_sender OBJ_SightGet()) < Cf_Cos60 )
		continue		// Acteur pas assez dans l axe
	
	tv_paf_sens += EVENT_PafDirGet(tmid_paf_event)
	tv_paf_pos =  EVENT_PafPositionGet(tmid_paf_event)
	ti_paf_force = EVENT_PafTypeGet(tmid_paf_event)
	
	// if the paf is from a jump/fall, check to see if this structure wants to ignore this
	ti_JumpPafToBeIgnored = faux
	
	if ( to_sender == to_kong && @to_sender Proc_KK_JumpStatusGet() && mi_IgnoreJumpPafs )
		ti_JumpPafToBeIgnored = vrai
	
	// check to see if the object wants to accept a Kong paf
	if ( to_sender == to_kong && mi_IsFirstPafValid && @to_sender Proc_KK_GetCannotPaf_KID() )
		ti_JumpPafToBeIgnored = vrai		// its shit but I am reusing this crap flag
	
	ti_casse = faux
	if( ! ti_JumpPafToBeIgnored )
	{
		// TESTS SELON LE PARAMETRAGE
		switch( i_Kong_puissance_pour_KC )
		{
			case Ci_puissance_pour_KC_Repousse :
				if( ti_paf_force & C_PAF_KK_Repousse )
					ti_casse = vrai
			// pas de break...
			case Ci_puissance_pour_KC_Moyen :
				if( ti_paf_force & C_PAF_KK_Moyen )
					ti_casse = vrai
			// pas de break...
			case Ci_puissance_pour_KC_Fort :
				if( ti_paf_force & C_PAF_KK_Fort )
					ti_casse = vrai
				break
		}
		
		// TESTS QU'IMPORTE LE PARAMETRAGE
		if( ti_paf_force & C_PAF_KK_KiTue )
			ti_casse = vrai
		else if( ti_paf_force & C_PAF_KK_Ecrasement )
			ti_casse = vrai
	}
	
	if( ti_casse )
	{
		if ( to_sender == to_kong)
			@to_kong Proc_KK_SetCannotPaf_KID()		// mark Kong as having paffed this action
		
		if ( (ti_paf_force & C_PAF_KK_Fort) || (ti_paf_force & C_PAF_KK_Ecrasement) )
		{
			if ( mai_PafNumberToBreakOn[0] < 4)
			{
				OBJ_CapaSet(CAPA_BigHit, none)
				mi_IsMultiHit = faux		// the whole thing is going down.  This might be bad if we want multi hits even with strong hits...because from now on its single hit
			}
			else
			{
				if ( mi_NumberOfPafs > 2 )
					OBJ_CapaSet(CAPA_BigHit, none)
				mi_NumberOfPafs += 2
			}
		}
		ti_paf = vrai
		
		// increment the number of hits
		mi_NumberOfPafs++
		
		if ( mi_NumberOfPafs >= mi_LastHit || ! mi_IsMultiHit )
		{
			if ( i_desactive_colmap_apres_paf )
				COL_ColMapActivationSet( none, all )
			COL_ColSetActivationSet( none, C_bit_zde_corps )
		}
	}
}

//*************************************************************************************************************************
//RESISTANCE

//find what objects are colliding with the structure
f_globalTime = TIME_Get()
i_NumCols =  COL_ZDE_ZDEListGet(&tao_zdecol_objects[0], C_zde_corps, C_zde_corps, OBJ_C_IdentityFlag_ZDE , 0, 0)

// clamp to max out cols allowed in our col list array
if ( i_NumCols >= C_Max_Collisions )
	i_NumCols = C_Max_Collisions - 1

// parse the collision list for AI types not to be included.
// parse for these types of KID objects: right now its all of them, I just want to make sure there is a way to have different rules for different object types without breaking already existing KIDS
if ( mi_TargetType >= 0	&& mi_TargetType <= 7 )
{
	for ( j = 0; j < i_NumCols; j++ )
	{
		if ( tao_zdecol_objects[j] )
		{
			if ( !( @tao_zdecol_objects[j] AI_IsModel(get_Kong_Path) ) && !( @tao_zdecol_objects[j] AI_IsModel(get_PNJ_KTREX_Path) ) )			
			{
				// ne mémoriser les collisions que pour KONG et REX
				tao_zdecol_objects[j] = nobody
			}
		}
	}
}

// count number of objects still in col list
ti_ActualNumCols = 0

for( i=0; i < NUM_NON_PAF; i++)
{
	for(j=0; j < i_NumCols; j++)
	{
		if(! (ao_objets_non_paffables[i] == tao_zdecol_objects[j]))
		{
			if ( tao_zdecol_objects[j] )
			{
				f_speed_actor 	= @tao_zdecol_objects[j]  DYN_SpeedGet()
				ti_ActualNumCols++
			}
		}
	}
}

//create resistance using a timer and speed of actor	
if( ti_ActualNumCols )
{
	if( ! mi_IsKnocking )
		f_resistanceTimer = TIME_Get()
		
	mi_IsKnocking = vrai
	
	if( f_speed_actor < f_speedThreshold )
		mi_IsKnocking = faux
}
else
{
	f_speed_actor		=0.0
	mi_IsKnocking	= faux
}

//if more than 15 actors collided, break
if ( ti_ActualNumCols > 15)
	DBG_BreakPoint()


//the result of the resistance, pafs get incremented if actor is pushing on structure at a certain speed for a certain time
if(f_globalTime - f_resistanceTimer  >= f_pushTime && mi_IsKnocking)
{
	ti_paf = vrai
	mi_NumberOfPafs++
	f_resistanceTimer = 0.0
	mi_IsKnocking = faux
}

// if we don't already have a paf, then check CAPA for faked one from a linked KID
if ( ! ti_paf )
{
	if ( OBJ_CapaTest( CAPA_Break ) )
	{
		mi_NumberOfPafs++
		ti_paf = vrai
		OBJ_CapaSet( none, CAPA_Break )
	}
}


// ODE Activation ====================================================================
if ( ti_paf && i_ODE_nb_briques && ! i_ODE_break)	//JIM_NOTE: temp
{
	//JD: snd
	if(i_son_activation_autorise)
		SND_RequestPlay(ODE_Sound_Choc_Activation)

	if ( mi_NumberOfPafs >= mi_LastHit || ! mi_IsMultiHit )
	{
		i_ODE_break = vrai
		f_break_time = TIME_Get()
		
		if (i_MemoBrokenStatus)
			SpecialFlag_set(i_SF_AlreadyPlayed) 

		//triggers:
		for ( ti_ind = 0; ti_ind < C_MAX_Triggers; ti_ind++ )
		{
			// if there is a valid trigger, trigger it and
			if ( mt_TriggerExec[ti_ind] && AI_TriggerIsValid( mt_TriggerExec[ti_ind] ) && !mi_TriggerExec_Flag[ti_ind] )
			{
				call_trigger( mt_TriggerExec[ti_ind] )
				
				mi_TriggerExec_Flag[ti_ind] = vrai
			}
		}
		
		if ( mi_BreakSound )
		{
			SND_RequestPlay( 30 )
		}
			
		ti_TrackIsDone = vrai
	}

	for( ti_ind = 0; ti_ind < i_ODE_nb_briques; ti_ind++)
	{
		// activate the ode for the item that corresponds to the paf number
		if ( ao_ODE_briques[ti_ind] && ( mai_PafNumberToBreakOn[ti_ind] <= mi_NumberOfPafs || !mi_IsMultiHit ) )
		{
//			mai_PafNumberToBreakOn[ti_ind] = 100
			@ao_ODE_briques[ti_ind] COL_EnableSnP()
			
			@ao_ODE_briques[ti_ind] ODE_Enable( vrai)
						
			ti_control_flag = @ao_ODE_briques[ti_ind] ODE_Geti(0)
			ti_control_flag &= ~0x20		// Immovable
			@ao_ODE_briques[ti_ind] ODE_Seti(0, ti_control_flag)
			@ao_ODE_briques[ti_ind] OBJ_FlagInactiveSet( faux)
			
			//**********************************************************************************************************************
			//EXTRA FORCE OPTION
			if(i_extra_force[ti_ind] || ( i_type_decor  == Ci_type_decor_pilier ) )
			{
				tv_Velocity = tv_paf_sens * f_amount_force
				
				// randomize the extra force so the whole system doesn't move in exactly the same direction
				tv_Velocity.x = MATH_RandFloat( ( tv_Velocity.x * 0.75 ), ( tv_Velocity.x * 1.25 ) )
				tv_Velocity.y = MATH_RandFloat( ( tv_Velocity.y * 0.75 ), ( tv_Velocity.y * 1.25 ) )
				tv_Velocity.z = MATH_RandFloat( ( tv_Velocity.z * 0.75 ), ( tv_Velocity.z * 1.25 ) )
				
#ifdef DEBUG_VECTORS_ON
	if ( ti_paf && ( tv_paf_sens != Cv_NullVector ) && ( debugv_ExtraForceDirection == Cv_NullVector ) )
	{
		//debugv_ExtraForceDirection = tv_paf_sens
		debugv_ExtraForceDirection = tv_Velocity
	}
	
	DBG_TraceFloat( MATH_VecNorm( tv_Velocity ) )
	DBG_TraceEOL()
#endif	// _FINAL_
			
				@ao_ODE_briques[ti_ind] ODE_Setv(0, tv_Velocity )
				@ao_ODE_briques[ti_ind] ODE_Setf(2, 100.0)					
			}
			//**********************************************************************************************************************
			
			if ( mo_Floor && !mi_IsFloorActive )
			{
				@mo_Floor ODE_Enable( vrai )
				
				@mo_Floor OBJ_FlagInactiveSet( faux )
				
				mi_IsFloorActive = vrai
			}
		}
	}

	tv_paf_sens = OBJ_SightGet() * MATH_FloatSign(MATH_VecDotProduct( OBJ_SightGet(), tv_paf_sens ))
	v_ODE_Punch_init_pos = OBJ_PosGet() - (tv_paf_sens * 4.0)
	if ( o_ODE_projectile == get_KODE_Poing)
		o_ODE_projectile = @o_ODE_projectile OBJ_Duplicate( v_ODE_Punch_init_pos)
	else
		@o_ODE_projectile OBJ_PosSet( v_ODE_Punch_init_pos)
	@o_ODE_projectile ODE_Setv( 0, tv_paf_sens * 20.0)
	@o_ODE_projectile ODE_Enable(vrai)
	
	AI_TrackChange( C_Track_WaitZMin, "KID_ODE_wait_zmin")
	AI_TrackChange( C_Track_PagActivation, "KID_bhv_PAGActivation" )
}

// BROKEN ? ==============================================================================
if( i_ODE_break )
{
	// unnsupport supported native groups
	for ( i_Native = 0; i_Native < C_MAX_NativeGroupsSupported; i_Native++ )
		if ( mao_NativeGroupsSupporting[i_Native] && ( @mao_NativeGroupsSupporting[i_Native] OBJ_CapaTest( NativeGroup_CAPA ) ) )
			@mao_NativeGroupsSupporting[i_Native] OBJ_CapaSet( none, NativeGroup_CAPA )
	
	OBJ_CapaSet( CAPA_Broken, none )	// capa to show that the structure is broken
	
	// send a faked paf to linked KIDs through this CAPA
	for ( i_LinkedKID = 0; i_LinkedKID < C_MAX_LinkedKIDs; i_LinkedKID++ )
		if ( mao_LinkedKIDs[i_LinkedKID] )
			@mao_LinkedKIDs[i_LinkedKID] OBJ_CapaSet( CAPA_Break, none )
	
	// Geler les palmiers après un délai ---------------------------------------------
	if( i_type_decor == Ci_type_decor_palmier )
	{
		if( ! i_ODE_broken_disabled )
		{
			f_ODE_broken_duration += TIME_GetDt()
			if( f_ODE_broken_duration > 5.0 )
			{
				ti_desactive = vrai
				i_ODE_broken_disabled = vrai
				for( ti_i = 0; ti_i < C_MaxBriques; ti_i++ )
				{
					to_obj = ao_ODE_briques[ti_i]
					if( to_obj )
					{
						if( ti_desactive )
						{
							@to_obj ODE_Enable(faux)
							@to_obj OBJ_FlagInactiveSet(vrai)
						}
					}
				}
				if( ti_desactive )
				{
					ODE_Enable(faux)
					OBJ_FlagInactiveSet(vrai)
				}
			}
		}
	}
	// Geler les palmiers après un délai ---------------------------------------------
}
else if( mi_IsThrownObjectTargettable )
	Proc_KongFight_TargetAdd(OBJ_Me(), OBJ_PosGet() + mv_TargetOffset, 1.0, C_AIDE_AU_TIR_Prio_Mur, 0 )
	
//JIMI_NOTE: debug
#ifdef DEBUG_VECTORS_ON	// debugging tool
	if ( debugv_ExtraForceDirection != Cv_NullVector )
	{
		vector v_Source
		
		v_Source = OBJ_PosGet()
		v_Source.z	+= 1.0
		
		DBG_RenderVector( v_Source, debugv_ExtraForceDirection, color_rouge )
	}
#endif	// DEBUG_VECTORS_ON