
#include "KIGO_defines.var"

vector			tv_souche_hauteur
vector 			tv_souche_pos
int					ti_rank
int					ti_ind
int					ti_i
message		tm_msg_filter
messageid		EVT_ID
object			to_actor


// Positions (centre et pivot) de la souche -----------------------------------------------------
tv_souche_pos = OBJ_PosGet()
tv_souche_hauteur = Cf_hauteur_souche * OBJ_BankingGet()
//DBG_RenderVector(OBJ_PosGet(), tv_souche_hauteur, color_jaune)
tv_souche_pos += (tv_souche_hauteur / 2)
v_centre_pos = tv_souche_pos


// Destruction de la souche ----------------------------------------------------------------------------
//if ( i_nb_coup >= i_nb_coup_avt_destruction)
//{
//	AI_TrackChange( 2, "KIGO_ETAT_explose")
//	AI_TrackCurStop()
//}

// GESTION DES UNCOLLIDES =======================================================================

//for( ti_rank = 0; ti_rank< @get_list_manager i_TREX_nb ; ti_rank++ )
//{
//	to_actor = @get_list_manager ao_TREX[ ti_rank]
//	ti_ind = ARR_ObjSearch( &ao_uncol_list[0], i_nb_uncol, to_actor) 
//	if ( ti_ind == -1 )
//	{
//		// ajout d'un uncollide
//		ao_uncol_list[ i_nb_uncol] = to_actor
//		i_nb_uncol ++
//		@to_actor COL_UnCollidableAdd( OBJ_Me())
//	}
//}

// REACTIVATION DE LA COLLISION AVEC KONG
if ( o_snap_actor && i_etat_courant != ETAT_KIGO_grabbed && ! o_projectile_actor && ! OBJ_LIB_Virtual_Collision(OBJ_Me(), o_KONG, vrai) )
{
	// Permettre la collision a nouveau avec Kong: si on la réactivait ndirectement la collision empècherait la projection
	@o_snap_actor COL_UnCollidableDel( OBJ_Me())	
	o_snap_actor = nobody
}
