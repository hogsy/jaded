
//===============================================================================
// Attente Grab : le tronc attend d'être grabbé par un acteur (Kong)
//===============================================================================

#include "KIGO_defines.var"

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	if( i_flag_vertical )
		i_flag_vertical = faux		// la position de repos de la souche est désormais horizontale
	
	AI_Execute("KIGO_exec_dyn_on")
	DYN_GravitySet( Cv_NormalGravity * 2.0)
	COL_ColSetActivationSet( C_bit_zdm_pied + C_bit_zdm_recalagespecial, none)	

	i_sort_etat = faux
	return
}


// INITIALISATION ETAT ==============================================================
if ( i_etat_courant != ETAT_KIGO_attente)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_KIGO_attente
	
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0

	COL_ColSetActivationSet(C_bit_zdm_pied + C_bit_zdm_recalagespecial, none)
//	f_time_ground = 0.0
//	o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, faux, nofunc, nofunc)
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// friction au sol
if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
{
	if( ! COL_CollideType(COL_C_Ground) )
		DYN_FrictionVectorSet(Cv_souche_petite_friction)
	else
	{
		if( i_flag_vertical )
			DYN_FrictionVectorSet(Cv_souche_grosse_friction)				// friction modifiée si le tronc est au sol
		else
			DYN_FrictionVectorSet(Cv_souche_grosse_friction_H)				// friction modifiée si le tronc est au sol
	}
}
else
{
	if( COL_CollideType(COL_C_Ground) )
		AI_Execute("KIGO_exec_dyn_on")		// Activer la dyna pour les blocs si on touche un sol non ODE
	if( i_grab_detail == Ci_mode_Roc && f_time_start_etat > 2.0 )
		AI_Execute("KIGO_exec_dyn_on")		// Activer la dyna pour les blocs après un délai max
}

// ANALYSE ==============================================================

o_grabbed_actor_KK = LNK_ServeurGet(Ci_LNK_GRAB_KONG, mid_grabbed_by_Kong_LNK_ID, vrai, nofunc, nofunc)
if (o_grabbed_actor_KK)
	AI_TrackCurChangeNow("KIGO_ETAT_grabbed")

AI_Execute("KIGO_exec_check_paf")
if( ! MATH_VecNullEpsilon(v_sum_pafs_dir) )
{
	// le tronc tombe au sol
	v_add_speed = v_sum_pafs_dir * 8.0
	AI_Execute("KIGO_exec_dyn_on")
	DYN_FrictionVectorSet(Cv_souche_petite_friction)

	if ( o_PAF_actor == o_KONG)
	{
		COL_UnCollidableAdd( o_KONG)
	}
	AI_TrackCurChangeNow("KIGO_ETAT_tombe")
}


// vitesse courante
if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
{
	v_last_speed = DYN_SpeedGetVector()
	if( v_last_speed.z > 0.0 )
	{
		v_last_speed.z = 0.0
		DYN_SpeedSetVector(v_last_speed)
	}
}

//if ( MATH_VecNullToler( v_last_speed, 0.2) && COL_CollideType(COL_C_Ground))
//{
////	OBJ_BankingGeneralSet( MATH_VecBlendRotate( OBJ_SightGet(), Cv_VerticalVector, 5.0 * TIME_GetDt()), OBJ_BankingGet())
//	f_time_ground += TIME_GetDt()
////	if ( f_time_ground > 1.0)
////	{
////		DYN_GravitySet( Cv_NullVector)
////		COL_ColSetActivationSet( none, C_bit_zdm_pied + C_bit_zdm_recalagespecial)
////	}
//}
//else
//	f_time_ground = 0.0
//
// COMPORTEMENT ==============================================================

if( ! i_flag_vertical )
	AI_Execute("KIGO_exec_incline_horiz")
