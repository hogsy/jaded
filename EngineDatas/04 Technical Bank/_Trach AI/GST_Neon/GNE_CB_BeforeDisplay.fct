
int		ti_loop 
int		ti_colA, ti_colB
int		ti_col, ti_colr
float	tf_int, tf_blend
float	tf_delta_total 
float	tf_rand 

c_old_constante = MAT_ConstantGet(i_submat_id)

i_color_neonA = COLOR_SetRGBA(COLOR_GetR(c_Color_NeonA),COLOR_GetG(c_Color_NeonA),COLOR_GetB(c_Color_NeonA),COLOR_GetA(c_Color_NeonA))
i_color_neonB = COLOR_SetRGBA(COLOR_GetR(c_Color_NeonB),COLOR_GetG(c_Color_NeonB),COLOR_GetB(c_Color_NeonB),COLOR_GetA(c_Color_NeonB))

tf_blend = (MATH_Sin(TIME_Get() * f_Color_SinusSpeed) + 1.0) * 0.5
ti_col = COLOR_Blend(i_color_neonA,i_color_neonB,tf_blend )

switch(i_neon_type_cur)
{
	case 0:
		tf_delta_total = Sinus_Max - Sinus_Min
		tf_int = MATH_Sin(TIME_Get() * Sinus_Speed) * 0.5 * tf_delta_total
		tf_int += (tf_delta_total * 0.5) + Sinus_Min
		ti_colr = Proc_GNE_ColorIntGet( ti_col , tf_int )
		break

	case 1:
		// Random
		tf_rand = MATH_RandFloat(0.2,0.8)
		ti_colr = Proc_GNE_ColorIntGet( ti_col, tf_rand)
		if (i_flag_paf)
		{
			for (ti_loop = 0; ti_loop<5; ti_loop++)
			{
				if ( Etincelle_Pos[ti_loop] && MATH_RandFloat(0.2,0.8) < 0.5)
					Proc_GNE_SFXEtincelle(@Etincelle_Pos[ti_loop] OBJ_PosGet(), -@Etincelle_Pos[ti_loop] OBJ_SightGet())
			}
		}
		else
		{
			if (tf_rand<0.5)
				Proc_GNE_SFXEtincelle(@Etincelle_Pos[Etincelle_ID] OBJ_PosGet(), -@Etincelle_Pos[Etincelle_ID] OBJ_SightGet())
		}

		break
		
	case 2:
		// Blend
		ti_colr = Proc_GNE_ColorIntGet( ti_col , Blend_Intensity)
		break		

	default:
		ti_colr = 0x0
		break
	
}
	
MAT_ConstantSet( ti_colr , i_submat_id)