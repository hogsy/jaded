#include "_Projectile_Javelin_defs.var"

vector 	n, z
float		f
object	o_tmp
vector	tv_temp, tv_temp1
object	to_obj, to_sender
int			ti_snd

#define COLCOUNT_1	10
#define COLCOUNT_2	20

//---------( GFX )--------------------------------------------
if (mi_flamme)
{
	AI_Execute( "Javelin_GFX_fire1" )
}
	
//---------( tomber trop bas ? )---------
if ( MATH_AbsFloat( OBJ_PosGet().z - mf_ZInit) > 50)
//	AI_Execute( "Javelin_destroy" )
	OBJ_Destroy()

if(mi_fall && mi_TypeLance == 2) 
{
	OBJ_RotateGlobalZ(f_rotate_fall * TIME_GetDt())
	OBJ_PosSet(OBJ_PosGet() + (OBJ_SightGet() * f_rotate_fall * TIME_GetDt() * 0.5))
}


//--------( detection de la flotte )--------
if (i_GFX_Fire != -1)
{
	tv_temp1 = mf_ContactPointDistance* OBJ_SightGet()
	tv_temp = v_last_pos + tv_temp1
	tv_temp1 += OBJ_PosGet() 
	if( !MATH_VecNullEpsilon(OBJ_PosGet() - v_last_pos) )
	{
		to_sender = mo_Sender
		if (to_sender)
			to_obj = @to_sender COL_RayObject_Vector(tv_temp, tv_temp1 - tv_temp, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel_and_bone_volumes)
		else
			to_obj = COL_RayObject_Vector(tv_temp, tv_temp1 - tv_temp, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel_and_bone_volumes)
		if (to_obj && COL_RayObject_ActorGet() != to_sender) 
		{
			ti_snd = COL_RayObject_SoundGet()
			if(ti_snd == COL_C_Snd_Water)
			{
				mi_flamme = 0
				if (i_GFX_Fire != -1)
				{
					GFX_Seti( i_GFX_Fire, 13106, 0)	
					i_GFX_Fire = -1
				}
			}
		}
	}
}

if (COL_CollideType(COL_C_Ground + COL_C_crossable))
{
	if ( COL_GMAT_FlagsGet(COL_C_Ground + COL_C_crossable) & Gmat_KK_Face_eau )
	{
		mi_flamme = 0
		if (i_GFX_Fire != -1)
		{
			GFX_Seti( i_GFX_Fire, 13106, 0)	
			i_GFX_Fire = -1
		}
		mi_ColCount--
		if (mi_ColCount < 0) mi_ColCount = 0
	}
}

//---------( compte le nombre de collision pour atteindre l'équilibre )---------
else if (COL_CollideType(COL_C_Ground ))
{
	if (mi_flamme && mi_ColCount == 0 && !i_snd_impact)
	{
		if(!i_fire_deja)
		{
			i_fire_deja = vrai
			v_fire_deja_pos = GRID_PosGet(OBJ_PosGet())
			LIBGFX_GridFire(OBJ_PosGet(), vrai)
		}
		else if ( v_fire_deja_pos != GRID_PosGet(OBJ_PosGet()) )
		{
			i_fire_deja = faux
		}
	}
		
	if (mi_ColCount == 0 && !i_snd_impact)
	{
		i_snd_impact = vrai
		SND_RequestPlay( SND_rebond_dirt )
	}
			
	n = COL_NormalGet( COL_C_Ground )
	z = OBJ_BankingGet()
	z = z + n
	OBJ_BankingSet( z )
	mi_ColCount += 2
}
else
{
	mi_ColCount--
	if (mi_ColCount < 0) mi_ColCount = 0
}

i_pas_les_compagnons = vrai
AI_Execute("Javelin_waittaken")
i_pas_les_compagnons = faux

//---------( amortissement )---------
if (mi_ColCount < COLCOUNT_1)
	f = 1
else if (mi_ColCount < COLCOUNT_2)
{
	f = mi_ColCount - COLCOUNT_1
	f /= COLCOUNT_2 - COLCOUNT_1
	f = 1.0 - f
}
else
{
	//DYN_Off()
	DYN_SpeedSetVector( Cv_NullVector )
	DYN_GravitySet( Cv_NullVector )
	DYN_TractionSet( Cv_NullVector )
	DYN_FrictionVectorSet( Cv_NullVector )
	COL_UnCollidableReset()
	
	// Bidoche
	AI_TrackCurChangeNow( "Javelin_waittaken" )
}

//---------( déplacement )---------
n = DYN_SpeedGetVector()
n *= f
DYN_SpeedSetVector( n )
v_last_pos = OBJ_PosGet()