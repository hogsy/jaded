//============================================================
//	PAF de la DYNAMITE
//============================================================
procedure_local void Proj_Dynamite_Paf_Send(object to_obj)
{
	vector		tv_temp, tv_temp2
	float			tf_damage
	float				ti_damage
	object		to_gao
	
	//----( calcul point de dommage )----
	ti_damage = Cf_grenade_pointblank
	if (@to_obj COL_HasZone(C_zde_corps) )
	{
		tv_temp = @to_obj COL_ZonePosGet(C_zde_corps) - OBJ_PosGet()
		tf_damage = MATH_VecNorm( tv_temp )
		tv_temp /= tf_damage
		tf_damage -= @to_obj COL_ZoneSizeGet( C_zde_corps )
		if ( tf_damage > Cf_grenade_range_pointblank )
		{
			tf_damage = (tf_damage - Cf_grenade_range_pointblank) / ( Cf_grenade_range_medium - Cf_grenade_range_pointblank)
			tf_damage *= (Cf_grenade_paf - Cf_grenade_pointblank)
			tf_damage += Cf_grenade_pointblank
			ti_damage = tf_damage
		}
		
		//----( lancer de rayons )----
		to_gao = COL_RayObject_Dist( OBJ_PosGet(), tv_temp, Cf_grenade_range_medium, all, none, 0, COL_C_Ray_on_visuel_and_bone_volumes)
		if (COL_RayObject_CanalGet() != -1) to_gao = COL_RayObject_ActorGet()
		if ( to_gao != to_obj )
			return
	}

	//----( calcul paf dir )----
	tv_temp = @to_obj OBJ_PosGet() - OBJ_PosGet()
	tv_temp.z = 0.0
	if( ! MATH_VecNullEpsilon(tv_temp) )
		MATH_VecSetNormalize(tv_temp)
	else
		tv_temp = OBJ_SightGet()
		
	EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_KK_Fort, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_obj, ti_damage, tv_temp)
}



//============================================================
//	LAUNCH CRANE
//============================================================
procedure_local void Proj_Crane_Launch( )
{
	object	to_colobj
	
	COL_ColSetActivationSet(none, all)
	v_last_speed = DYN_SpeedGetVector()
	if (!MATH_VecNullEpsilon( OBJ_PosGet() - v_last_pos ) )
	{
		to_colobj = COL_RayObject_Vector(v_last_pos, OBJ_PosGet() - v_last_pos, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel_and_bone_volumes)
		if (to_colobj && ( COL_RayObject_ActorGet() != mo_Sender ) )
		{
			if ( COL_RayObject_SoundGet() == COL_C_Snd_Water )
			{
				mi_crane_allume = 0
			}
			else
			{
				mi_crane_choc = 1
				mv_ImpactPos = COL_RayObject_PosGet()
				mv_ImpactNormal = COL_RayObject_NormalGet()
			}
		}
	}
}

//============================================================
//	Crane Flamme -> Launch
//============================================================
procedure_local void Proj_CraneFlamme_Launch( )
{
	object	to_colobj
	vector	tv_temp
	float		tf_norm

	COL_ColSetActivationSet(none, all)
	
	v_last_speed = DYN_SpeedGetVector()
	
	// big friction
	mf_craneflamme_timeleft += TIME_GetDt()
	while (mf_craneflamme_timeleft  > 0.0167)
	{
		mf_craneflamme_timeleft -= 0.0167
		if (mi_craneflamme_splof)
			v_last_speed *= 0.9
		mi_craneflamme_tramecount--
		if ( (mi_craneflamme_tramecount <= 0 ) || (mi_craneflamme_spg2_nb == 10 ) )
		{
			if ( mi_crane_gfx != -1)
			{	
				GFX_Seti( mi_crane_gfx, 13106, 0)	
				mi_crane_gfx = -1
			}

			AI_TrackChange( 0, "Projectile_waitendoffire" )
			AI_TrackStop(4)
		}
	}
	
	// collision ?
	if(MATH_VecNullEpsilon(v_last_speed)) return
	if (!MATH_VecNullEpsilon( OBJ_PosGet() - v_last_pos ) )
	{
		to_colobj = COL_RayObject_Vector(v_last_pos, OBJ_PosGet() - v_last_pos, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_visuel_and_bone_volumes)
		if (to_colobj && ( COL_RayObject_ActorGet() != mo_Sender ) )
		{
			mi_craneflamme_splof = 1

			if ( COL_RayObject_SoundGet() == COL_C_Snd_Water )
				mi_crane_allume = 0
			else
			{
				mv_ImpactPos = COL_RayObject_PosGet()
				mv_ImpactNormal = COL_RayObject_NormalGet()
				
				tv_temp = MATH_VecCrossProduct( mv_ImpactNormal, v_last_speed )
				tv_temp = MATH_VecCrossProduct( tv_temp, mv_ImpactNormal )
				tf_norm = MATH_VecNorm( v_last_speed )
				MATH_VecSetNorm( tv_temp, tf_norm)
				v_last_speed = tv_temp
				OBJ_PosSet( mv_ImpactPos + (mv_ImpactNormal * 0.1) )
				
				if(mv_ImpactNormal.z > Cf_Cos45)
				{
					DYN_GravitySet(Cv_NullVector)
					DYN_SpeedSetVector(Cv_NullVector)
				}
			}
		}
	}
}

//============================================================
//	DEBUG -> Reflex
//============================================================
procedure_local void Proj_Dbg_Reflex()
{
	vector	tv_temp, tv_cross
	float		tf_norm
	int			ti_texte
	
	tv_temp = OBJ_PosGet() - v_start_pos
	tf_norm = MATH_VecNorm( tv_temp )

	ti_texte = STR_CreateText( "\jr\\h0.05\ distance = ", cvector( 0.95, 0.04, 0), 0 )
	STR_AppendFloat( ti_texte, tf_norm, 2)

	tv_cross = MATH_VecCrossProduct( tv_temp, v_start_impulsion )
	tf_norm = MATH_VecNorm( tv_cross )
	if (tf_norm != 0)
		tf_norm = MATH_AbsFloat( MATH_VecAngle( tv_temp, v_start_impulsion , tv_cross ) )
	
	ti_texte = STR_CreateText( "\jr\\h0.05\ déviation = ", cvector( 0.95, 0.1, 0), 0 )
	STR_AppendFloat( ti_texte, tf_norm, 2)
	
	DBG_RenderVector( v_start_pos, v_start_impulsion , 0xFF0000 )
	DBG_RenderVector( v_start_pos, tv_temp, 0xFF00FF )
}
