int			i, j
vector	tv_separation, tv_alignement, tv_cohesion
vector	tv_attirance
vector	tv_temp
vector	tv_dest_pos
object	to_obj
float		tf_temp
vector	tv_vert, tv_sight
int			cpt, cpt1
message	EVT_msg_filter
messageid	EVT_ID
int				ti_rank
int			ti_GFX_Impact

// Generation
if(!ao_obj[0])
{
	for(i = 0; i < num_oiseaux; i++)
	{
		int		sect0,sect1,sect2,sect3

		tv_temp = OBJ_PosGet()
		tf_temp = i 
		tf_temp /= num_oiseaux
		tv_temp.z += tf_temp
		ao_obj[i] = @oiseau_reference OBJ_Duplicate(tv_temp)
		
		// Sectorisation...
		SCT_GetOf( &sect0, &sect1, &sect2, &sect3)
		@ao_obj[i] SCT_SetOf( sect0, sect1, sect2, sect3)

		af_speed[i] = MATH_RandInt(min_speed, max_speed)
		af_speed_rot[i] = MATH_RandFloat(min_speed_rot, max_speed_rot)

		// each object starts with a different morph progression value
		// between 0 and the number of morph target
		if (@ao_obj[i] OBJ_MorphNumberOfData() > 0)
		{
			af_morph_prog[i] = MATH_RandFloat(0,@ao_obj[i] OBJ_MorphNumberOfData())
		}
	}
}

if(carotte)
{
	to_obj = carotte
	tv_dest_pos = @to_obj OBJ_PosGet()
}
else
{
	to_obj = AI_MainActorGet(C_ID_Kong)
	if( ! to_obj )
		to_obj = AI_MainActorGet(C_ID_Joueur)
	tv_dest_pos = @to_obj OBJ_PosGet()
	tv_dest_pos.z += 5
}

for(i = 0; i < num_oiseaux; i++)
{
	cpt = 0
	tv_separation = Cv_NullVector
	tv_alignement = Cv_NullVector
	tv_cohesion = Cv_NullVector
	cpt1 = 0
	for(j = MATH_Modulo(i + 1, num_oiseaux); cpt1 < max_iter; j = MATH_Modulo(j + 1, num_oiseaux))
	{
		cpt1++
		if(i == j) break
		tv_temp = @ao_obj[j] OBJ_PosGet() - @ao_obj[i] OBJ_PosGet()
		if(MATH_VecDotProduct(@ao_obj[i] OBJ_SightGet(), tv_temp) < 0) continue
		if(@ao_obj[i] OBJ_SqrDist(ao_obj[j]) > distance  * distance) continue
		
		tv_temp = @ao_obj[i] OBJ_PosGet() - @ao_obj[j] OBJ_PosGet()
		MATH_VecSetNorm(tv_temp, distance  - MATH_VecNorm(tv_temp))
		tv_separation += tv_temp
		
		tv_alignement += @ao_obj[j] OBJ_SightGet()
		
		tv_cohesion += @ao_obj[j] OBJ_PosGet()
		
		cpt++
	}
	
	// ROT
	tv_sight = Cv_NullVector
	tv_attirance = tv_dest_pos - @ao_obj[i] OBJ_PosGet()
	if(!MATH_VecNullEpsilon(tv_attirance)) 
	{
		MATH_VecSetNormalize(tv_attirance)
		tv_attirance *= attirance
		tv_sight += tv_attirance
	}
	
	if(cpt) tv_alignement /= cpt
	if(!MATH_VecNullEpsilon(tv_alignement)) 
	{
		MATH_VecSetNormalize(tv_alignement)
		tv_alignement *= alignement
		tv_sight += tv_alignement
	}
	
	if(cpt) 
	{
		tv_cohesion /= cpt
		tv_cohesion -= @ao_obj[i] OBJ_PosGet()
		if(!MATH_VecNullEpsilon(tv_cohesion)) 
		{
			MATH_VecSetNormalize(tv_cohesion)
			tv_cohesion *= cohesion
			tv_sight += tv_cohesion
		}
	}
	
	if(cpt) 
	{
		tv_separation /= cpt
		if(!MATH_VecNullEpsilon(tv_separation)) 
		{
			MATH_VecSetNormalize(tv_separation)
			tv_separation *= separation
			tv_sight += tv_separation
		}
	}
	
	// sight
	MATH_VecSetNormalize(tv_sight)
	tv_temp = MATH_VecBlendRotate(@ao_obj[i] OBJ_SightGet(), tv_sight, af_speed_rot[i] * TIME_GetDt())
	tv_temp.z = MATH_FloatBlend(@ao_obj[i] OBJ_SightGet().z, tv_sight.z, af_speed_rot[i] * TIME_GetDt() * 1.5)
	tv_sight = tv_temp
	MATH_VecNormalize(tv_sight)
	
	// rool
	tf_temp = MATH_VecDotProduct(@ao_obj[i] OBJ_SightGet(), tv_alignement)
	tf_temp = 1 - tf_temp
	tv_temp = MATH_VecCrossProduct(@ao_obj[i] OBJ_SightGet(), tv_sight)
	tf_temp = MATH_FloatMin(MATH_AbsFloat(tf_temp), 0.5) * MATH_FloatSign(tv_temp.z)
	tv_vert = Cv_VerticalVector
	tv_vert += @ao_obj[i] OBJ_HorizonGet() * tf_temp
	tv_vert = MATH_VecBlendRotate(@ao_obj[i] OBJ_BankingGet(), tv_vert, af_speed_rot[i] * TIME_GetDt())
	
	@ao_obj[i] OBJ_SightGeneralSet(tv_sight, tv_vert)
	
	// TRANS
	tv_temp = @ao_obj[i] OBJ_SightGet() * af_speed[i] * TIME_GetDt()
	@ao_obj[i] OBJ_PosSet(@ao_obj[i] OBJ_PosGet() + tv_temp)
	
	//////////////////// PAF
	MSG_SetNull( EVT_msg_filter)
	EVT_msg_filter.msg_gao1 = ao_obj[i]
	ti_rank = -1
	EVT_ID = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Paf, &ti_rank, EVT_msg_filter)
	if(MSG_GlobalIsValid(EVT_ID))
	{
		// Etincelles
		ti_GFX_Impact = GFX_Add(9)
		GFX_FlagSet(ti_GFX_Impact , 0, 1)
		GFX_FlagSet(ti_GFX_Impact , 2, 1)
		GFX_MaterialSet(ti_GFX_Impact , get_SFX_light_and_smoke, 3)
		GFX_Setf(ti_GFX_Impact, 9000, Cf_PiBy2)									// angle d'ouverture
		GFX_Setf(ti_GFX_Impact, 9001, 1.0)											// vitesse initiale minimum
		GFX_Setf(ti_GFX_Impact, 9002, 3.0)											// vitesse initiale maximum
		GFX_Setf(ti_GFX_Impact, 9003, 0.95 )											// friction
		GFX_Setf(ti_GFX_Impact, 9004, 1.2)											// épaisseur
		GFX_Setf(ti_GFX_Impact, 9005, 0.5)											// durée de vie minimum
		GFX_Setf(ti_GFX_Impact, 9006, 1.0)											// durée de vie maximum
		GFX_Setf(ti_GFX_Impact, 9007, 4.0 )											// multiplicateur de longueur
		GFX_Setf(ti_GFX_Impact, 9008, 0.005 )										// generation périod
		GFX_Setf(ti_GFX_Impact, 9009, 0.2)											// durée de mort minimun
		GFX_Setf(ti_GFX_Impact, 9010, 0.4)											// durée de mort maximun
		GFX_Seti(ti_GFX_Impact, 9100, 15)											// Nombre
		GFX_Seti(ti_GFX_Impact, 9102, 0b11000)									// Flags (1 => agrandissement centré)
		GFX_Setv(ti_GFX_Impact, 9200, @ao_obj[i] OBJ_PosGet())			// Origine des étincelles
		GFX_Setv(ti_GFX_Impact, 9201, cvector(0,0,1))								// Direction
		GFX_Setv(ti_GFX_Impact, 9202, cvector(0.0, 0.0, -2.0) )					// gravity
		GFX_Seti(ti_GFX_Impact, 9101, 0xFF0000FF)								// couleur		
		
		@ao_obj[i] OBJ_Destroy()
		ao_obj[i]	 = ao_obj[num_oiseaux - 1]
		num_oiseaux--
		i--
	}
}

// lets morph!
for(i = 0; i < num_oiseaux; i++)
{
	if (@ao_obj[i] OBJ_MorphNumberOfData() > 0)
	{
		af_morph_prog[i] += TIME_GetDt() * 24
		if (af_morph_prog[i] > @ao_obj[i] OBJ_MorphNumberOfData())
			af_morph_prog[i] = 0.0

		@ao_obj[i] OBJ_MorphProgSet(0, af_morph_prog[i])
	}
}



