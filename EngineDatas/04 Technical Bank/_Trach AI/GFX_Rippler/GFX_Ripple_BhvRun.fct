#include "GFX_Ripple_Defines.var"

float f_CurrentTime

f_CurrentTime = TIME_Get()

if ( f_CurrentTime - mf_StartTime < mf_Duration || mi_IsPersistent )
{
	// position manipulation
	if ( mi_UseRandomMoving )
	{
		if ( f_CurrentTime - mf_LastRandMoveTime >= mf_RandomMoveInterval )
		{
			vector v_Pos
				
			v_Pos = OBJ_PosGet()
				
			v_Pos.x += MATH_RandFloat( mv_MinPosOffset.x, mv_MaxPosOffset.x )
			v_Pos.y += MATH_RandFloat( mv_MinPosOffset.y, mv_MaxPosOffset.y )
			v_Pos.z += MATH_RandFloat( mv_MinPosOffset.z, mv_MaxPosOffset.z )
		
			GFX_Setv( mi_GFX_Key, 20200, v_Pos )
			
			mf_LastRandMoveTime = TIME_Get()
		}
	}
	
	if ( mi_NumberOfDynamicMaterials )
	{
		if ( f_CurrentTime - mf_LastMatChangeTime >= mf_MaterialChangeInterval )
		{
			int i_MatToChoose
			int i_NumberMatsSeen
			int i_NumberMatsChecked

			i_NumberMatsChecked	= 0 			 
			i_NumberMatsSeen		= 0
			i_MatToChoose 			= MATH_RandInt( 0, mi_NumberOfDynamicMaterials )
					
			while ( i_NumberMatsChecked < mi_NumberOfDynamicMaterials )
			{
				if ( mi_DynamicMaterialIndex[i_NumberMatsChecked] > -1 )
				{
					if ( i_NumberMatsSeen == i_MatToChoose )
					{
						GFX_MaterialSet( mi_GFX_Key, mo_Material, mi_DynamicMaterialIndex[i_NumberMatsChecked] )
					
						// break the loop once we are done choosing a new random mat
						i_NumberMatsChecked		= mi_NumberOfDynamicMaterials
						
						mf_LastMatChangeTime	= TIME_Get()
						
						break
					}
					
					i_NumberMatsSeen++
				}

				i_NumberMatsChecked++
			}
		}
	}
}
else
{
	if ( !mi_IsPersistent )
	{
		if ( mi_GFX_Key != C_Invalid_GFX )
		{
			GFX_Del( mi_GFX_Key )
		}
		
		// salut la visite
		if ( mi_IsChild  && !i_no_death)
		{
			OBJ_Destroy()
		}
	
		AI_TrackCurStop()
	}
}