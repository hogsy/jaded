#include "GFX_Ripple_Defines.var"

int i_Index
message m_Msg
message m_MsgReturn
color c_temp 

mf_TimeRunning += TIME_GetDt()

if ( mi_UseStartDelay && mf_StartDelay > mf_TimeRunning )
{
	return
}
else
{
	mi_GFX_Key = GFX_Add( 20 )
	
	// get the number of dynamic materials
	mi_NumberOfDynamicMaterials = 0
	
	for ( i_Index = 0; i_Index < C_Max_Dynamic_Materials; i_Index++ )
	{
		if ( mi_DynamicMaterialIndex[i_Index] > -1 )
		{
			mi_NumberOfDynamicMaterials++
		}
	}
	
	if ( mi_GFX_Key != C_Invalid_GFX )
	{
		if ( mo_Material )
		{
			GFX_MaterialSet( mi_GFX_Key, mo_Material, mi_MaterialIndex )
		}
		else
		{
			GFX_MaterialSet( mi_GFX_Key, OBJ_Me(), 0 )
		}
		
		GFX_FlagSet( mi_GFX_Key, 0, 1 )																											// activation de l’effet
		GFX_FlagSet( mi_GFX_Key, 2, 1 )																											// matériau transparent
	
		GFX_Seti( mi_GFX_Key, GFX_RippleSetNumber, mi_SetNumber )	
		
		//========================================================
		if(o_GFX_Ambiant_Controller)
		{
			m_Msg.msg_sender = OBJ_Me()
			m_Msg.msg_int1 = COLOR_GetR(mc_StartColour )
			m_Msg.msg_int2 = COLOR_GetG(mc_StartColour )
			m_Msg.msg_int3 = COLOR_GetB(mc_StartColour )
			m_Msg.msg_int4 = COLOR_GetA(mc_StartColour ) 
			m_MsgReturn = Dispatch_Interaction(o_GFX_Ambiant_Controller, m_Msg)
			c_temp = COLOR_SetRGBA(m_MsgReturn.msg_int1,m_MsgReturn.msg_int2,m_MsgReturn.msg_int3,m_MsgReturn.msg_int4) 
		}
		else
			c_temp  = 	mc_StartColour 
		//========================================================
		
		GFX_Seti( mi_GFX_Key, 20101, c_temp )																						// couleur start
		GFX_Setf( mi_GFX_Key, GFX_RippleLifeTime, ( MATH_RandFloat( mf_MinLifeTime, mf_MaxLifeTime ) ) )
		GFX_Setf( mi_GFX_Key, GFX_RippleIncreaseSpeed, ( mf_SpeedIncreaseBase + ( MATH_RandFloat( mf_SpdIncMinAdd, mf_SpdIncMaxAdd ) ) ) )
		GFX_Setf( mi_GFX_Key, GFX_RippleGenerationRate, mf_GenerationRate )	
		GFX_Setf( mi_GFX_Key, GFX_RippleSpeed, mf_Speed )
		
		GFX_Setf( mi_GFX_Key, GFX_RippleStartSize, mf_StartSize )
		
		//========================================================
		if(o_GFX_Ambiant_Controller)
		{
			m_Msg.msg_sender = OBJ_Me()
			m_Msg.msg_int1 = COLOR_GetR(mc_EndColour )
			m_Msg.msg_int2 = COLOR_GetG(mc_EndColour )
			m_Msg.msg_int3 = COLOR_GetB(mc_EndColour )
			m_Msg.msg_int4 = COLOR_GetA(mc_EndColour ) 
			m_MsgReturn = Dispatch_Interaction(o_GFX_Ambiant_Controller, m_Msg)
			c_temp = COLOR_SetRGBA(m_MsgReturn.msg_int1,m_MsgReturn.msg_int2,m_MsgReturn.msg_int3,m_MsgReturn.msg_int4) 
		}
		else
			c_temp  = 	mc_EndColour 
		//========================================================
		
		GFX_Seti( mi_GFX_Key, 20102, c_temp )
		
		if ( mi_AutoDestrution )
		{
			GFX_Seti( mi_GFX_Key, GFX_RippleSetNumber, mi_AutoDestrution )
		}
		
		if ( mi_UseRandomMoving )
		{
			vector v_Pos
			
			v_Pos = OBJ_PosGet()
			
			v_Pos.x += MATH_RandFloat( mv_MinPosOffset.x, mv_MaxPosOffset.x )
			v_Pos.y += MATH_RandFloat( mv_MinPosOffset.y, mv_MaxPosOffset.y )
			v_Pos.z += MATH_RandFloat( mv_MinPosOffset.z, mv_MaxPosOffset.z )
		
			GFX_Setv( mi_GFX_Key, 20200, v_Pos )
			
			mf_LastRandMoveTime = TIME_Get()
		}
		else
		{
			GFX_Setv( mi_GFX_Key, 20200, OBJ_PosGet() )
		}
	
		GFX_Setv( mi_GFX_Key, 20201, mv_Direction )
		GFX_Setv( mi_GFX_Key, 20202, mv_Banking )
			
		if ( !mi_IsPersistent )
		{
			GFX_LifeTimeSet( mi_GFX_Key, mf_Duration )
		}
		
		mf_StartTime = TIME_Get()
	}
	
	AI_TrackCurChange( "GFX_Ripple_BhvRun.fct" )
	
	//AI_TrackCurStop()
}
