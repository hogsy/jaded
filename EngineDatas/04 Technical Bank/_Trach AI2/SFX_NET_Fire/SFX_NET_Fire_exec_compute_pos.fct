float		tf_coef

vector	tv_point_A
vector	tv_point_B
vector	tv_point_C
vector	tv_point_D

#define Cf_pourcentage			0.33

compute:

if (!o_next_wp)
	return

tf_coef = f_link_coef / f_link_length

if (tf_coef >= 1.0)
{
	o_last_wp = o_next_wp
	o_next_wp = WAY_NetNextWP(n_net, o_last_wp, 0, 0)

	f_link_coef -= f_link_length

	if (!o_next_wp || o_last_wp == OBJ_Me())
	{
		f_net_coef = f_net_length
	
		v_GFX_last_pos = v_GFX_next_pos
		v_GFX_next_pos = @o_last_wp OBJ_PosGet()
		return
	}

	f_link_length = MATH_VecNorm(@o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet())

	goto compute
}

// Smooth trajectory
tv_point_A = @o_last_wp OBJ_PosGet()

tv_point_B = tv_point_A 
tv_point_B += @o_last_wp OBJ_SightGet() * (f_link_length * (Cf_pourcentage * @o_last_wp OBJ_ScaleGet().y))

tv_point_D = @o_next_wp OBJ_PosGet()
	
tv_point_C = tv_point_D
tv_point_C -= @o_next_wp OBJ_SightGet() * (f_link_length * (Cf_pourcentage * @o_next_wp OBJ_ScaleGet().y))

tv_point_A += (tv_point_B - tv_point_A) * tf_coef
tv_point_B += (tv_point_C - tv_point_B) * tf_coef
tv_point_C += (tv_point_D - tv_point_C) * tf_coef

tv_point_A += (tv_point_B - tv_point_A) * tf_coef
tv_point_B += (tv_point_C - tv_point_B) * tf_coef

tv_point_A += (tv_point_B - tv_point_A) * tf_coef

v_GFX_last_pos = v_GFX_next_pos
v_GFX_next_pos = tv_point_A

#ifndef _FINAL_
if (write)
{
	tv_point_A = @o_last_wp OBJ_PosGet()
	tv_point_A += MATH_VecNormalize(@o_next_wp OBJ_PosGet() - @o_last_wp OBJ_PosGet()) * f_link_coef
	DBG_RenderVector(tv_point_A, v_GFX_next_pos - tv_point_A, color_blanc)
}
#endif
