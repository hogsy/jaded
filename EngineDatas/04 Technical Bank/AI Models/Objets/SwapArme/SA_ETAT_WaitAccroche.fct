//int				ti_i
//
//float			tf_dist
//float			tf_time
//
//vector		tv_paf
//vector		tv_ground_pos
//
//object		to_collide_object
//object		to_camera
//
//vector		tv_dest_pos		
//vector		tv_speed
//
//OBJ_Me().des_int1 = 0
//
//av_modules_speed[i_modules_nb - 1] += MATH_VecRotate(cvector(0.0,1.0,0.0), Cv_VerticalVector, TIME_Get() * Cf_Pi) * 0.02
//
//// ==================================================
//// Si la caisse touche un mur, elle se décroche
//// ==================================================
//if (COL_CollideType(COL_C_Wall))
//{
//	to_collide_object = COL_ObjectGet(COL_C_Wall)
//	if (to_collide_object == AI_MainActorGet(C_ID_Jack))
//	{
//		av_modules_speed[i_modules_nb - 1] += COL_NormalGet(COL_C_Wall) * 6.0
//		
//		if (! i_paf_done)
//		{
//			i_paf_done = vrai
//			v_start_speed = av_modules_speed[i_modules_nb - 1]
//		}
//	}
//	else
//	{
//		f_life_cur = 0.0
//		ai_modules_locked[i_modules_nb - 1] = vrai
//		@ao_modules[i_modules_nb - 1] OBJ_PosSet(OBJ_PosGet() + (OBJ_BankingGet() * af_modules_length[i_modules_nb - 1]))
//	}
//}
//
//// ==========================================================================
//// Si la caisse ou les suspentes prennent un paf, la caisse se décrochera quand sa vitesse s'inversera
//// ou quand elle s'éloignera de plus d'un mètre de sa position initiale
//// ==========================================================================
//SA_Rope_check_paf()
//tv_paf = SA_CheckPaf()
//
////if (IO_KeyJustPressed(VK_SPACE))
////{
////	av_modules_speed[5] +=  MATH_VecRotate(cvector(1.0, 0.0, 0.0), Cv_VerticalVector, MATH_RandFloat(0.0, Cf_2Pi)) * MATH_RandFloat(10.0, 20.0)
////
////	if (! i_paf_done)
////	{
////		i_paf_done = vrai
////		v_start_speed = av_modules_speed[i_modules_nb - 1]
////	}
////}
//
//if (!MATH_VecNull(tv_paf))
//{
//	// On s'est pris un coup
//	av_modules_speed[i_modules_nb - 1] += tv_paf * 2.0
//	
//	if (! i_paf_done)
//	{
//		i_paf_done = vrai
//		v_start_speed = av_modules_speed[i_modules_nb - 1]
//	}
//}
//
//OBJ_RotateLocalZ(f_rotate * TIME_GetDt() * 5.0) 
//f_rotate = MATH_FloatBlend(f_rotate,0.0, TIME_GetDt())
//
//// ========================================================
//// Ragdoll du parachute et positionnement de la caisse
//// ========================================================
//ai_modules_locked[0] = vrai
//SA_Rag_Doll(0)
//if (ai_modules_locked[i_modules_nb - 1])
//{
//	ai_modules_locked[i_modules_nb - 1] = faux
//	@ao_modules[i_modules_nb - 1] OBJ_BankingGeneralSet(@ao_modules[i_modules_nb - 1] OBJ_SightGet(), @ao_modules[i_modules_nb - 1] OBJ_PosGet() - OBJ_PosGet())
//}
//else
//{
//	OBJ_PosSet(@ao_modules[i_modules_nb - 1] OBJ_PosGet() - (@ao_modules[i_modules_nb - 1] OBJ_BankingGet() * af_modules_length[i_modules_nb]))
//	OBJ_BankingGeneralSet(OBJ_SightGet(), @ao_modules[i_modules_nb - 1] OBJ_BankingGet())
//}
//
//
//// =======================================================
//// test de l'inversion de la vitesse
//// et test de la distance à la position initiale
//// après un paf
//// =======================================================
//tv_dest_pos = OBJ_PosInitGet() - OBJ_PosGet()
//tv_dest_pos.z = 0.0
//if (i_paf_done && ( MATH_VecDotProduct(v_start_speed, av_modules_speed[i_modules_nb - 1]) < 0.0 || MATH_VecSquareNorm(tv_dest_pos) > 2.0 ))
//	f_life_cur = 0.0
//
//// =======================================================
//// Si plus de vie alors la caisse se décroche
//// =======================================================
//if (!f_life_cur)
//{
//	SND_RequestPlay( 1 )
//
//	// On a assez shooté la caisse.
//	DYN_On()
//	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_GlobalFriction, none)
//	DYN_GravitySet(cvector(0,0,-20))
//	DYN_FrictionVectorSet(cvector(2.0, 2.0, 0.0))
//	
//	COL_RayObject_Dist(OBJ_PosInitGet(), -Cv_VerticalVector, 20.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//	tv_ground_pos = COL_RayObject_PosGet()
//
//	DBG_RenderCircle(tv_ground_pos, 2.0, Cv_VerticalVector, color_blanc)
//
//	tf_time = DYN_LIB_Time_To_Reach_Z(av_modules_speed[i_modules_nb - 1], DYN_GravityVectorGet(), tv_ground_pos.z - OBJ_PosGet().z, faux)
//	DYN_LIB_Display_Trajectory(OBJ_PosGet(), av_modules_speed[i_modules_nb - 1], DYN_GravityVectorGet(), DYN_FrictionVectorGet(), tf_time, 10, 0.0)
//	
////	DYN_LIB_Position_After_N_Seconds(vector tv_init_pos, byref vector tv_init_speed, vector tv_friction, vector tv_gravity, float tf_time, float tf_exp)
//	tv_speed = av_modules_speed[i_modules_nb - 1]
//	tv_dest_pos = DYN_LIB_Position_After_N_Seconds(OBJ_PosGet(), tv_speed, DYN_FrictionVectorGet(), DYN_GravityVectorGet(), tf_time, 0.0)
//	tv_dest_pos -= tv_ground_pos
//
//	tf_dist = MATH_VecSquareNorm(tv_dest_pos)
//	if (tf_dist > 4.0)
//	{
//		tf_dist = MATH_FloatSqrt(tf_dist)
//		tv_dest_pos /= tf_dist
//		tv_dest_pos *= 2.0
//		tv_dest_pos += tv_ground_pos
//
//		DBG_RenderVector(tv_dest_pos, Cv_VerticalVector * 10.0, color_blanc)
//
//		tf_time = 0.0
//		tf_dist = MATH_VecNorm(av_modules_speed[i_modules_nb - 1])
//		if (tf_dist > 0.001)
//		{
//			tv_speed = av_modules_speed[i_modules_nb - 1] / tf_dist
////			DYN_LIB_Impulsion_Dir_Friction(vector tv_start_pos, vector tv_dest_pos, vector tv_gravity, float tf_friction, byref float tf_time, int ti_flag_Z_friction, vector tv_dir, int ti_max_iteration)
//			tv_speed = DYN_LIB_Impulsion_Dir_Friction(OBJ_PosGet(), tv_dest_pos, DYN_GravityVectorGet(), DYN_FrictionVectorGet().x, tf_time, faux, tv_speed, 10)
//		}
//		else
//		{
////			DYN_LIB_ImpulsionGet_Friction(vector tv_start_pos, vector tv_dest_pos, vector tv_gravity, float tf_friction, byref float tf_time, int ti_flag_Z_friction, float tf_hauteur_saut)
//			tv_speed = DYN_LIB_ImpulsionGet_Friction(OBJ_PosGet(), tv_dest_pos, DYN_GravityVectorGet(), DYN_FrictionVectorGet().x, tf_time, faux, 0.0)
//		}
//
////		DYN_LIB_Display_Trajectory(vector tv_start_pos, vector tv_start_speed, vector tv_gravity, vector tv_friction, float tf_duration, int ti_iteration_nb, float tf_Z)
//		DYN_LIB_Display_Trajectory(OBJ_PosGet(), tv_speed, DYN_GravityVectorGet(), DYN_FrictionVectorGet(), 1.0, 10, 0.0)
//	}
//	else
//	{
//		tv_speed = av_modules_speed[i_modules_nb - 1]
//	}
//
//	DYN_SpeedSetVector(tv_speed)
// 
//	COL_ColSetActivationSet(C_bit_zdm_pied, none)
//
//	to_camera = @get_global o_camera
//
//	for (ti_i = 0; ti_i < i_modules_nb; ti_i++)
//	{
//		av_modules_speed[ti_i] += @ao_modules[ti_i] OBJ_BankingGet() * 3.0
//		av_modules_speed[ti_i] += @to_camera OBJ_HorizonGet() * MATH_RandFloat(-1.0, 1.0)
//	}
//
// 	AI_TrackCurChangeNow("SA_ETAT_Fall")
//}