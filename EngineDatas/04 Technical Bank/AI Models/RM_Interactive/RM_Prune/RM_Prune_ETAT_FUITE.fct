#include "RM_Prune_defines.var"
vector		tv_dest
float			tf_dist
float			tf_vitesse


// SORTIE ETAT ===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if( i_etat_courant != ETAT_Prune_FUITE)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Prune_FUITE
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_previous_etat = fct_last_etat
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	f_ForceRebond=f_ForceRebondAvance
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI ===========================================================================

o_Rided_Actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)
if( o_Rided_Actor )
	macro_change_etat("RM_Prune_ETAT_RIDED")

if(f_time_start_etat>1.0)
	macro_change_etat(fct_wait)
	

// COMPORTEMENT ===================================================================

v_SightVoulu=OBJ_PosGet() - @o_AFuir OBJ_PosGet()

if(COL_CollideType(COL_C_Ground))
{
	tv_dest=OBJ_PosGet() - @o_AFuir OBJ_PosGet()
	tf_dist=MATH_VecNorm(tv_dest)
	tv_dest.z=0.0
	tf_vitesse=6.0
	v_ForceVoulue=OBJ_SightGet()*tf_vitesse+cvector(MATH_RandFloat(-1.0,1.0),MATH_RandFloat(-1.0,1.0),MATH_RandFloat(0.0,1.0))
//	v_ForceVoulue=((tv_dest/tf_dist)*tf_vitesse)+cvector(MATH_RandFloat(-2.0,2.0),MATH_RandFloat(-2.0,2.0),MATH_RandFloat(0.0,2.0))
} 

Prune_Rebondit()