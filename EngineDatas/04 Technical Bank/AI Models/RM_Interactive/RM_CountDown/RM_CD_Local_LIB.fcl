#include "RM_CD_Defines.var"

procedure_local void RM_CD_DelSFX()
{
	int			ti_i
	for(ti_i=0;ti_i<Ci_RM_CD_MaxHalo;ti_i++)
		PROC_DESTROY_SFX(ai_Halo[ti_i])
}

procedure_local void RM_CD_MajCoeur(byrefarr int pai_GFX, int pi_Halo, vector pv_Centre)
{
	if(pi_Halo==(i_NbLeftHalos-1))
		af_TimeLeft[pi_Halo]-=TIME_GetDt()
	if(af_TimeLeft[pi_Halo]>0.0)
	{
		if(pai_GFX[pi_Halo]==-1)
		{
			pai_GFX[pi_Halo] = @o_CentreHalos GFX_Add(4)                                                                                                                 //création du halo
			GFX_FlagSet(pai_GFX[pi_Halo], 2, 1)                       								// transparent
			GFX_FlagSet(pai_GFX[pi_Halo], 4, 1)														// detache de l’objet
			GFX_MaterialSet(pai_GFX[pi_Halo], get_SFX_light_and_smoke,-1)				// affectation du matériau
			GFX_Seti(pai_GFX[pi_Halo], 4100, 3)													// flags
			GFX_Setf(pai_GFX[pi_Halo], 4001, 0.1 )													// temps de disparition du halo lorsqu'il est occulté

			GFX_Seti(pai_GFX[pi_Halo], 4101, i_IDSprite)
			GFX_Seti(pai_GFX[pi_Halo], 4102, c_Color)									// couleur du halo
		
			GFX_Setf( pai_GFX[pi_Halo], 4000, -af_TimeLeft[pi_Halo]/f_Size) // taille du halo 
			GFX_Setv( pai_GFX[pi_Halo], 4200, pv_Centre + MATH_VecRotate(v_RefVecteur,-@get_camera OBJ_SightGet(), f_Angle * pi_Halo ) )	// position du halo
			GFX_FlagSet(pai_GFX[pi_Halo],0,1)                           								// activation
		}
		else
		{
			GFX_Setf( pai_GFX[pi_Halo], 4000, -af_TimeLeft[pi_Halo]/f_Size) // taille du halo 
			GFX_Setv( pai_GFX[pi_Halo], 4200, pv_Centre + MATH_VecRotate(v_RefVecteur,-@get_camera OBJ_SightGet(), f_Angle * pi_Halo ) )	// position du halo
		}
	}
	else
	{
		if(pi_Halo!=0)
			af_TimeLeft[pi_Halo-1]+=af_TimeLeft[pi_Halo]
		i_NbLeftHalos--
		GFX_Del(pai_GFX[pi_Halo])
		pai_GFX[pi_Halo]=-1
	}
		
}

procedure_local void RM_CD_MajHalo(byrefarr int pai_GFX, int pi_Halo,vector pv_Centre)
{
	if(pi_Halo==(i_NbLeftHalos-1))
		af_TimeLeft[pi_Halo]-=TIME_GetDt()
	if(af_TimeLeft[pi_Halo]>0.0)
	{
		if(pai_GFX[pi_Halo]==-1)
		{

			pai_GFX[pi_Halo] = @o_CentreHalos GFX_Add(4)                                                                                                                 //création du halo
			GFX_FlagSet(pai_GFX[pi_Halo],0,1)                           								// activation
			GFX_FlagSet(pai_GFX[pi_Halo], 2, 1)                       								// transparent
			GFX_FlagSet(pai_GFX[pi_Halo], 4, 1)														// detache de l’objet
			GFX_MaterialSet(pai_GFX[pi_Halo], get_SFX_light_and_smoke,0)				// affectation du matériau
			GFX_Seti(pai_GFX[pi_Halo], 4100, 3)														// flags
			GFX_Setf(pai_GFX[pi_Halo], 4001, 0.1 )													// temps de disparition du halo lorsqu'il est occulté

			GFX_Seti(pai_GFX[pi_Halo], 4102, c_Color)									// couleur du halo
	
		
			GFX_Setf( pai_GFX[pi_Halo], 4000, MATH_RandFloat(af_TimeLeft[pi_Halo], af_TimeLeft[pi_Halo] + (0.05*f_Size))/f_Size) // taille du halo 
			GFX_Setv( pai_GFX[pi_Halo], 4200, pv_Centre + MATH_VecRotate(v_RefVecteur,-@get_camera OBJ_SightGet(), f_Angle * pi_Halo ) )	// position du halo
		}
		else
		{
			GFX_Setf( pai_GFX[pi_Halo], 4000, MATH_RandFloat(af_TimeLeft[pi_Halo], af_TimeLeft[pi_Halo] + (0.05*f_Size))/f_Size) // taille du halo 
			GFX_Setv( pai_GFX[pi_Halo], 4200, pv_Centre + MATH_VecRotate(v_RefVecteur,-@get_camera OBJ_SightGet(), f_Angle * pi_Halo ) )	// position du halo
		}
	}
	else
	{
		if(pi_Halo!=0)
			af_TimeLeft[pi_Halo-1]+=af_TimeLeft[pi_Halo]
		i_NbLeftHalos--
		GFX_Del(pai_GFX[pi_Halo])
		pai_GFX[pi_Halo]=-1
	}
}


//--------------------------------------------------------------------------------------------------------------------------------------------
// 									DESTRUCTION DU DERNIER MODULE
//--------------------------------------------------------------------------------------------------------------------------------------------
procedure_local int PROC_SFX_COUNTDOWN_DESTROY_LAST_MODULE()
{
	int		ti_retour
	float	tf_speed

	ti_retour = faux

	tf_speed = MATH_VecDistance(tv_last_pos,v_pos_modules[i_NbHalos-1])

	if (i_NbHalos > 0)
	{
		PROC_DESTROY_SFX(ai_Halo[i_NbHalos-1])
		PROC_SFX_PETITE_ETOILES(v_pos_modules[i_NbHalos-1], f_Rayon * 10.0, c_Color, tf_speed)

		ti_retour = vrai
		i_NbHalos-=1
	}

	return ti_retour
}


//--------------------------------------------------------------------------------------------------------------------------------------------
// 									DESTRUCTION DE TOUS LE MODULES
//--------------------------------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_SFX_COUNTDOWN_DESTROY_ALL_MODULE()
{
	int		ti_i, ti_total

	ti_total = i_NbHalos

	for (ti_i = 0; ti_i<ti_total; ti_i++)
		PROC_SFX_COUNTDOWN_DESTROY_LAST_MODULE()
}


//--------------------------------------------------------------------------------------------------------------------------------------------
// 									RAJOUT D'UN MODULE
//--------------------------------------------------------------------------------------------------------------------------------------------
procedure_local int PROC_SFX_COUNTDOWN_ADD_MODULE()
{
	int			ti_retour
	vector	tv_pos

	ti_retour = faux

	if (i_NbHalos < Ci_RM_CD_MaxHalo)
	{
		if (i_NbHalos > 0)
			tv_pos = v_pos_modules[i_NbHalos-1] - cvector(0.0,0.0,i_espacement)
		else
			tv_pos = OBJ_PosGet() - cvector(0.0,0.0,i_espacement) + tv_decalage_vertical

		PROC_SFX_FLARE_COEUR(o_CentreHalos, ai_Halo[i_NbHalos], tv_pos, f_Rayon, c_Color)

		v_pos_modules[i_NbHalos] = tv_pos
		i_NbHalos++
		ti_retour = vrai
	}
	return ti_retour
}


//--------------------------------------------------------------------------------------------------------------------------------------------
// 									MODIFICATION DE LA GRAVITE
//--------------------------------------------------------------------------------------------------------------------------------------------
procedure_local vector PROC_COUNTDOWN_GRAVITE()
{
	//------------------------------------------------------------------------------------------------------------------------
	// Ajout de bruit dans la gravité pour faire bouger les coeurs aléatoirement
	//------------------------------------------------------------------------------------------------------------------------
	v_target_gravite.x += MATH_RandFloat(-f_increment_gravite,f_increment_gravite)
	if (v_target_gravite.x > (v_gravite_init.x + f_amplitude_gravite))
		v_target_gravite.x -= f_increment_gravite
	else 
	if (v_target_gravite.x < (v_gravite_init.x - f_amplitude_gravite))
		v_target_gravite.x += f_increment_gravite

	v_target_gravite.y += MATH_RandFloat(-f_increment_gravite,f_increment_gravite)
	if (v_target_gravite.y > (v_gravite_init.y + f_amplitude_gravite))
		v_target_gravite.y -= f_increment_gravite
	else 
	if (v_target_gravite.y < (v_gravite_init.y - f_amplitude_gravite))
		v_target_gravite.y += f_increment_gravite

	v_target_gravite.z += MATH_RandFloat(-f_increment_gravite,f_increment_gravite)
	if (v_target_gravite.z > (v_gravite_init.z + f_amplitude_gravite))
		v_target_gravite.z -= f_increment_gravite
	else 
	if (v_target_gravite.z < (v_gravite_init.z - f_amplitude_gravite))
		v_target_gravite.z += f_increment_gravite

	if (o_CentreHalos)
		return @o_CentreHalos MATH_VecLocalToGlobal(v_target_gravite)
	else
		return @get_rayman MATH_VecLocalToGlobal(v_target_gravite)
}

//--------------------------------------------------------------------------------------------------------------------------------------------
// 											MISE A JOUR DES MODULES
//--------------------------------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_CD_UpdateChaineCoeurs()
{
	int			ti_i
	vector	tv_pos, tv_pos_old, tv_pos_init, tv_turbulences, tv_gravite
	float		tf_rayon

	tf_rayon = f_Rayon
	tv_gravite = PROC_COUNTDOWN_GRAVITE()

// Traitement de chaque module
	for (ti_i = 0; ti_i < i_NbHalos; ti_i++)
	{
		if (ti_i == i_NbHalos-1)
		{
			af_TimeLeft[ti_i]-=TIME_GetDt()
			tf_rayon = f_Rayon * af_TimeLeft[ti_i] / (f_Time / i_nb_modules)
		}

		// Définition de la position du WP père
		if (ti_i == 0)
			tv_pos_init = @o_CentreHalos OBJ_PosGet() + tv_decalage_vertical
		else
			tv_pos_init = v_pos_modules[ti_i-1]
	
		tv_pos_old = v_pos_modules[ti_i]
	
		// On détermine sa nouvelle position
		tv_pos = i_espacement * MATH_VecNormalize((tv_pos_init - tv_pos_old) - (tv_gravite * TIME_GetDt()) + (v_dir_modules[ti_i] * 0.75))
	
		// On mémorise la direction du vecteur
		v_dir_modules[ti_i] = tv_pos_old - (tv_pos_init - tv_pos)
	
		// On mémorise la position du module
		tv_last_pos = v_pos_modules[ti_i]
		v_pos_modules[ti_i] = tv_pos_init - tv_pos
	
		// On déplace le module
		PROC_SFX_FLARE_COEUR(o_CentreHalos, ai_Halo[ti_i], v_pos_modules[ti_i], tf_rayon, c_Color)

		if(af_TimeLeft[ti_i]<0.0)
			PROC_SFX_COUNTDOWN_DESTROY_LAST_MODULE()
	}
}

procedure_local void RM_CD_MajHalos()
{
	int			ti_i
	v_RefVecteur = Cv_VerticalVector * (MATH_VecDistance(@get_camera OBJ_PosGet(),@o_CentreHalos OBJ_PosGet() ) * f_Rayon )
	
	v_Centre = MATH_VecBlend(@o_CentreHalos OBJ_PosGet(),v_Centre,f_Follow * TIME_GetDt())
	
	switch(i_TypeHalo)
	{
	case 1:
		for(ti_i=0;ti_i<i_NbLeftHalos;ti_i++)
		{
			RM_CD_MajHalo(&ai_Halo[0],ti_i,v_Centre)
		}
		break
	case 2:
		for(ti_i=0;ti_i<i_NbLeftHalos;ti_i++)
		{
			RM_CD_MajCoeur(&ai_Halo[0],ti_i,v_Centre)
		}
		break
	case 3:
		PROC_CD_UpdateChaineCoeurs()
		break
	}
}


procedure_local void RM_CD_TimePrint()
{
	vector	tv_pos_2D
//	tv_pos_2D = VIEW_3dWorldTo2d(0, OBJ_PosGet()+cvector(0,0,1.5))
	tv_pos_2D = cvector(0.1,0.15,0.1)
	Str_DisplayFloatDecOnce(f_CurTime, 1, tv_pos_2D)	
	if(o_CentreHalos)
		RM_CD_MajHalos()
}