#include "RM_Plateforme_defines.var"

procedure_ultra void PROC_RM_KeepHierarchy();

//float		tf_Norm
object	to_Backup
int			ti_col
int			ti_Arret

// SORTIE ETAT ===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if( i_etat_courant != RM_PF_ETAT_Go )
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = RM_PF_ETAT_Go
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_previous_etat = fct_last_etat
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	f_VitesseCourante = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI ===========================================================================

if (AI_TriggerIsValid(trig_Electricite) && !call_trigger(trig_Electricite))
{
	AI_TrackCurChangeNow("RM_Plateforme_ETAT_Wait")
}


// COMPORTEMENT ===================================================================

//v_VitesseVoulue = v_Destination - OBJ_PosGet()
//tf_Norm = MATH_VecNorm(v_VitesseVoulue)

if(o_Passager)
	ti_col = COL_BV_PivotCollide(o_Passager)
else
{
	if(i_RMSensitive && @get_rayman OBJ_HierarchyGet()==OBJ_Me())
	{
		o_Passager=get_rayman
		ti_col = COL_BV_PivotCollide(o_Passager)
	}
	else
		ti_col = faux
}

if(!ti_col)
{
	if(o_Passager)
	{
		@o_Passager OBJ_HierarchyReset()
		o_Passager = nobody
	}
}
else
{
	if(o_Passager==AI_MainActorGet(0))
	{
		@o_Passager PROC_RM_KeepHierarchy()
	}
}


if(i_DestTrouvee)
{
	
	if((f_WaitingTime>0.0) || (!ti_col && @o_DestWP OBJ_CapaTest(OBJ_Capa_31)))
	{
		if(o_DestWPForce)
		{
	 		if(o_DestWPForce!=o_DestWP)
				ti_Arret = faux
			else
				ti_Arret = vrai 		
		}
		else
			ti_Arret = vrai
	}
	else 
		ti_Arret = faux	

	if(f_Prog>=f_spline_segment_length)
	{	// ARRIVEE
		if(o_DestWPForce && (o_DestWPForce==o_DestWP))
		{
			o_DestWPForce= nobody
		}		
		if(ti_Arret)
		{
			i_DestTrouvee = faux
			AI_TrackCurChangeNow("RM_Plateforme_ETAT_Wait")
		}
		else
		{	// change de WP
			f_Prog-=f_spline_segment_length
			RM_PF_NextWP()
			RM_PF_SplineCalc()
		}
	}
}
else
{
	f_Prog-=f_spline_segment_length
	RM_PF_NextWP()
	RM_PF_SplineCalc()
}

if((f_spline_coef>0.8) && ti_Arret)
{
	if(f_VitesseCourante>f_SpeedMin)
		f_VitesseCourante-=TIME_GetDt()*Cf_RM_PF_Decel
}
else	
{
	if(f_VitesseCourante<f_SpeedMax)
		f_VitesseCourante+=TIME_GetDt()*Cf_RM_PF_Accel
}

RM_PF_SplinePos(f_Prog)
f_Prog+=f_VitesseCourante * TIME_GetDt()
