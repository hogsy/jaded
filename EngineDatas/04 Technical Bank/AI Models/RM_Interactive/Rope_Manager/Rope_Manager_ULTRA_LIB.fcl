Include_UltraProcedure_Header

procedure_ultra void Rope_Manager_Update(int ti_index, object to_gao_A, object to_gao_B, float tf_length, float tf_ratio, float tf_rope_inc_speed, float tf_rope_dec_speed)
{
	ao_rope_gao[ti_index][0] = to_gao_A
	ao_rope_gao[ti_index][1] = to_gao_B
	af_rope_dest_length[ti_index] = tf_length
	af_rope_ratio[ti_index] = tf_ratio
	af_rope_inc_speed[ti_index] = tf_rope_inc_speed
	af_rope_dec_speed[ti_index] = tf_rope_dec_speed
}

procedure_ultra void Rope_Manager_ModeSet(int ti_index, int ti_mode)
{
	ai_rope_mode[ti_index] = ti_mode
}

procedure_ultra void Rope_Manager_Enable_Offset(int ti_index, int ti_offset_A, vector tv_offset_A, int ti_offset_B, vector tv_offset_B)
{
	ai_rope_offset[ti_index][0] = ti_offset_A
	av_rope_offset[ti_index][0] = tv_offset_A

	ai_rope_offset[ti_index][1] = ti_offset_B
	av_rope_offset[ti_index][1] = tv_offset_B
}

procedure_ultra float Rope_Manager_RopeLengthGet(int ti_index)
{
	return af_rope_start_length[ti_index]
}

procedure_ultra int Rope_Manager_RopeTendue(int ti_index)
{
	return ai_rope_tension[ti_index]
}

procedure_ultra void Rope_Manager_RopeLastTrameTractionGet(int ti_index, byref vector tv_traction_A, byref vector tv_traction_B)
{
	tv_traction_A = av_rope_last_trame_traction[ti_index][0]
	tv_traction_B = av_rope_last_trame_traction[ti_index][1]
}

procedure_ultra object Rope_Manager_Get_Linked_Gao(object to_gao_A, byref float tf_rope_length, byref float tf_rope_ratio, byref vector tv_offset_A, byref vector tv_offset_B)
{
	int		ti_i
	
	for (ti_i = 0; ti_i < i_rope_nb; ti_i++)
	{
		if (ao_rope_gao[ti_i][0] == to_gao_A)
		{
			tf_rope_ratio = af_rope_ratio[ti_i]
			tf_rope_length = af_rope_dest_length[ti_i]
			tv_offset_A = av_rope_offset[ti_i][0]
			tv_offset_B = av_rope_offset[ti_i][1]
			return(ao_rope_gao[ti_i][1])
		}

		if (ao_rope_gao[ti_i][1] == to_gao_A)
		{
			tf_rope_ratio = 1.0 - af_rope_ratio[ti_i]
			tf_rope_length = af_rope_dest_length[ti_i]
			tv_offset_A = av_rope_offset[ti_i][1]
			tv_offset_B = av_rope_offset[ti_i][0]
			return(ao_rope_gao[ti_i][0])
		}
	}
	
	return(nobody)
}

procedure_ultra int Rope_Manager_Add(object to_gao_A, object to_gao_B, float tf_rope_dest_length, float tf_rope_speed_length, float tf_ratio_A_vs_B)
{
	int		ti_index
	ti_index = i_rope_nb
	ao_rope_gao[ti_index][0] = to_gao_A
	ao_rope_gao[ti_index][1] = to_gao_B
	af_rope_start_length[ti_index] = -1.0
	af_rope_dest_length[ti_index] = tf_rope_dest_length
	af_rope_inc_speed[ti_index] = tf_rope_speed_length
	af_rope_dec_speed[ti_index] = tf_rope_speed_length
	af_rope_ratio[ti_index] = tf_ratio_A_vs_B
	ai_rope_tension[ti_index] = faux
	av_rope_last_trame_traction[ti_index][0] = Cv_NullVector
	av_rope_last_trame_traction[ti_index][1] = Cv_NullVector
	ai_rope_mode[ti_index] = 0
	i_rope_nb++
	return ti_index
}

procedure_ultra int Rope_Manager_Del(int ti_i)
{
	i_rope_nb--
	
	ao_rope_gao[ti_i][0] = ao_rope_gao[i_rope_nb][0]
	ao_rope_gao[ti_i][1] = ao_rope_gao[i_rope_nb][1]
	af_rope_start_length[ti_i] = af_rope_start_length[i_rope_nb]
	af_rope_dest_length[ti_i] = af_rope_dest_length[i_rope_nb]
	af_rope_inc_speed[ti_i] = af_rope_inc_speed[i_rope_nb]
	af_rope_dec_speed[ti_i] = af_rope_dec_speed[i_rope_nb]
	af_rope_ratio[ti_i] = af_rope_ratio[i_rope_nb]
	ai_rope_offset[ti_i][0] = ai_rope_offset[i_rope_nb][0]
	av_rope_offset[ti_i][0] = av_rope_offset[i_rope_nb][0]
	ai_rope_offset[ti_i][1] = ai_rope_offset[i_rope_nb][1]
	av_rope_offset[ti_i][1] = av_rope_offset[i_rope_nb][1]
	ai_rope_tension[ti_i] = ai_rope_tension[i_rope_nb]
	av_rope_last_trame_traction[ti_i][0] = av_rope_last_trame_traction[i_rope_nb][0]
	av_rope_last_trame_traction[ti_i][1] = av_rope_last_trame_traction[i_rope_nb][1]
	ai_rope_mode[ti_i] = ai_rope_mode[i_rope_nb]
	
	ao_rope_gao[i_rope_nb][0] = nobody
	ao_rope_gao[i_rope_nb][1] = nobody
	af_rope_start_length[i_rope_nb] = -1.0
	af_rope_dest_length[i_rope_nb] = -1.0
	af_rope_inc_speed[i_rope_nb] = 0.0
	af_rope_dec_speed[i_rope_nb] = 0.0
	af_rope_ratio[i_rope_nb] = 0.0
	ai_rope_offset[i_rope_nb][0] = faux
	av_rope_offset[i_rope_nb][0] = Cv_NullVector
	ai_rope_offset[i_rope_nb][1] = faux
	av_rope_offset[i_rope_nb][1] = Cv_NullVector
	ai_rope_tension[i_rope_nb] = faux
	av_rope_last_trame_traction[i_rope_nb][0] = Cv_NullVector
	av_rope_last_trame_traction[i_rope_nb][1] = Cv_NullVector
	ai_rope_mode[i_rope_nb] = 0
	
	return -1
}

procedure_ultra int Rope_Manager_Get_Corde_Index(object to_gao_A, object to_gao_B)
{
	int		ti_i	

	for (ti_i = 0; ti_i < i_rope_nb; ti_i++)
	{
		if (ao_rope_gao[ti_i][0] == to_gao_A && ao_rope_gao[ti_i][1] == to_gao_B)
			return(ti_i)
	}
	
	return(-1)
}

procedure_local vector GRAPPIN_Rope_Traction_Set(object to_gao, vector tv_traction)
{
	vector	tv_traction_reelle
	if( to_gao == get_rayman )
	{
		tv_traction_reelle = @get_rayman  PROC_RM_ApplyTension(tv_traction)
		if ( MATH_VecNullEpsilon( tv_traction_reelle))
			i_RM_refuse_tension = vrai
		else
			i_RM_refuse_tension = faux
	}
	else
	{
		tv_traction_reelle = tv_traction
		// toujours calculer et mémoriser même si elle n'est pas appliquable (poignées de roues)
		if( @to_gao OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
			@to_gao DYN_TractionSet(@to_gao DYN_TractionVectorGet() + tv_traction)
	}
	return tv_traction_reelle
}


procedure_local void Rope_Manager_Compute_Rope(int ti_index, object to_gao_A, object to_gao_B, float tf_rope_length, float tf_ratio_A_vs_B, vector tv_offset_A, vector tv_offset_B)
{
	int			ti_A_Dyn_Flag
	int			ti_B_Dyn_Flag
	int			ti_A_flag_local_friction
	int			ti_B_flag_local_friction

	float		tf_length
	float		tf_A_ratio
	float		tf_B_ratio
	
	vector	tv_A_speed
	vector	tv_A_next_speed
	vector	tv_A_pos
	vector	tv_A_friction
	vector	tv_A_forces
	vector	tv_A_move
	
	vector	tv_B_speed
	vector	tv_B_next_speed
	vector	tv_B_pos
	vector	tv_B_friction
	vector	tv_B_forces
	vector	tv_B_move
	
	vector	tv_offset
	vector	tv_rope_traction
	
	if (ai_rope_tension[ti_index])
		ai_rope_tension[ti_index]-- // = faux
	av_rope_last_trame_traction[ti_index][0] = Cv_NullVector
	av_rope_last_trame_traction[ti_index][1] = Cv_NullVector
	
	// DYN INFO => GAO A
	tv_A_pos = @to_gao_A OBJ_PosGet()
	
	// ON CALCULE TOUJOURS LES FORCES MÊME ELLES NE SONT PAS APPLIQUEES (lecture des calculs dans certains acteurs)
	tf_A_ratio = 0.0
//	if( @to_gao_A OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) && (@to_gao_A COL_ColSetActivationGet() & C_bit_zdm_pied) )
	{
		tf_A_ratio = 1.0 - tf_ratio_A_vs_B
	
		if( @to_gao_A OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) && (@to_gao_A COL_ColSetActivationGet() & C_bit_zdm_pied) )
		{
			tv_A_speed = @to_gao_A DYN_SpeedGetVector()
			tv_A_friction = @to_gao_A DYN_FrictionVectorGet()
	
			tv_A_forces = @to_gao_A DYN_GravityVectorGet()
			tv_A_forces += @to_gao_A DYN_TractionVectorGet()
			tv_A_forces += @to_gao_A DYN_StreamVectorGet()
	
	//		DBG_RenderVector(tv_A_pos, tv_A_forces, color_cyan)
			
			ti_A_Dyn_Flag = @to_gao_A DYN_FlagsGet()
		}
		else
		{
			tv_A_speed = Cv_NullVector
			tv_A_friction = Cv_NullVector
			tv_A_forces = Cv_NullVector
			ti_A_Dyn_Flag = 0
		}
		
		if ( (ti_A_Dyn_Flag & DYN_C_VectorFriction	) && ! (ti_A_Dyn_Flag & DYN_C_GlobalFriction) )
			ti_A_flag_local_friction = vrai
		else
			ti_A_flag_local_friction = faux
			
		if (ti_A_flag_local_friction)
		{
			tv_A_pos = Cv_NullVector
			tv_A_speed = @to_gao_A MATH_VecGlobalToLocal(tv_A_speed)
			tv_A_forces = @to_gao_A MATH_VecGlobalToLocal(tv_A_forces)
		}
	
		// ATTENTION, tv_A_next_speed va être modifié par la fonction DYN_LIB_Position_After_N_Seconds
		tv_A_next_speed = tv_A_speed
		tv_A_pos = DYN_LIB_Position_Next_Trame(tv_A_pos, tv_A_next_speed, tv_A_friction, tv_A_forces)

		if (ti_A_flag_local_friction)
		{
			tv_A_pos = @to_gao_A MATH_VecLocalToGlobal(tv_A_pos)
			tv_A_pos += @to_gao_A OBJ_PosGet()
		}
		
//		DBG_RenderVector(@to_gao_A OBJ_PosGet(), tv_A_pos - @to_gao_A OBJ_PosGet(), color_bleu)
//		DBG_RenderVector(tv_A_pos, tv_A_next_speed, color_jaune)
	}
	
	// DYN INFO => GAO B
	tv_B_pos = @to_gao_B OBJ_PosGet()
	
	// ON CALCULE TOUJOURS LES FORCES MÊME ELLES NE SONT PAS APPLIQUEES (lecture des calculs dans certains acteurs)
	tf_B_ratio = 0.0
//	if( @to_gao_B OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) && (@to_gao_B COL_ColSetActivationGet() & C_bit_zdm_pied) )
	{
		tf_B_ratio = tf_ratio_A_vs_B
		
		if( @to_gao_B OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) && (@to_gao_B COL_ColSetActivationGet() & C_bit_zdm_pied) )
		{
			tv_B_speed = @to_gao_B DYN_SpeedGetVector()
			tv_B_friction = @to_gao_B DYN_FrictionVectorGet()
		
			tv_B_forces = @to_gao_B DYN_GravityVectorGet()
			tv_B_forces += @to_gao_B DYN_TractionVectorGet()
			tv_B_forces += @to_gao_B DYN_StreamVectorGet()
		
			ti_B_Dyn_Flag = @to_gao_B DYN_FlagsGet()
		}
		else
		{
			tv_B_speed = Cv_NullVector
			tv_B_friction = Cv_NullVector
			tv_B_forces = Cv_NullVector
			ti_B_Dyn_Flag = 0
		}
		
		if ( (ti_B_Dyn_Flag & DYN_C_VectorFriction	) && ! (ti_B_Dyn_Flag & DYN_C_GlobalFriction) )
			ti_B_flag_local_friction = vrai
		else
			ti_B_flag_local_friction = faux
			
		if (ti_B_flag_local_friction)
		{
			tv_B_pos = Cv_NullVector
			tv_B_speed = @to_gao_B MATH_VecGlobalToLocal(tv_B_speed)
			tv_B_forces = @to_gao_B MATH_VecGlobalToLocal(tv_B_forces)
		}

		// ATTENTION, tv_B_next_speed va être modifié par la fonction DYN_LIB_Position_After_N_Seconds
		tv_B_next_speed = tv_B_speed
		tv_B_pos = DYN_LIB_Position_Next_Trame(tv_B_pos, tv_B_next_speed, tv_B_friction, tv_B_forces)

		if (ti_B_flag_local_friction)
		{
			tv_B_pos = @to_gao_B MATH_VecLocalToGlobal(tv_B_pos)
			tv_B_pos += @to_gao_B OBJ_PosGet()
		}

//		DBG_RenderVector(@to_gao_B OBJ_PosGet(), tv_B_pos - @to_gao_B OBJ_PosGet(), color_bleu)
//		DBG_RenderVector(tv_B_pos, tv_B_next_speed, color_jaune)
	}
	
	// OFFSET
	tv_offset = tv_B_pos + tv_offset_B 
	tv_offset -= tv_A_pos + tv_offset_A

	DBG_RenderVector(tv_A_pos + tv_offset_A, tv_offset, color_rose)

	tf_length = MATH_VecSquareNorm(tv_offset)

	if (ai_rope_mode[ti_index] || tf_length > tf_rope_length * tf_rope_length)
	{
		ai_rope_tension[ti_index] = 2
		
		tf_length = MATH_FloatSqrt(tf_length)
		tv_offset /= tf_length

		tv_offset *= tf_length - tf_rope_length

		if (tf_A_ratio > 0.001)
		{
			tv_A_move = tv_A_pos
			tv_A_move += tv_offset * tf_A_ratio
			tv_A_move -= @to_gao_A OBJ_PosGet()
			
//			DBG_RenderVector(@to_gao_A OBJ_PosGet(), tv_A_move, color_cyan)	
		
			tv_A_next_speed = 2.0 * tv_A_move / TIME_GetDt()

			if (ti_A_flag_local_friction)
			{
				tv_rope_traction = DYN_LIB_Traction_To_Reach_Speed(tv_A_speed, @to_gao_A MATH_VecGlobalToLocal(tv_A_next_speed) - tv_A_speed, tv_A_friction, tv_A_forces, Cv_NullVector, Cv_NullVector, TIME_GetDt())
				tv_rope_traction = @to_gao_A MATH_VecLocalToGlobal(tv_rope_traction)
			}
			else
			{
				tv_rope_traction = DYN_LIB_Traction_To_Reach_Speed(tv_A_speed, tv_A_next_speed - tv_A_speed, tv_A_friction, tv_A_forces, Cv_NullVector, Cv_NullVector, TIME_GetDt())
			}
			av_rope_last_trame_traction[ti_index][0] = GRAPPIN_Rope_Traction_Set(to_gao_A, tv_rope_traction)
		}
		else
		{
			av_rope_last_trame_traction[ti_index][0] = Cv_NullVector
		}

		if (tf_B_ratio > 0.001)
		{
			tv_B_move = tv_B_pos
			tv_B_move -= tv_offset * tf_B_ratio
			tv_B_move -= @to_gao_B OBJ_PosGet()

//			DBG_RenderVector(@to_gao_B OBJ_PosGet(), tv_B_move, color_cyan)	

			tv_B_next_speed = 2.0 * tv_B_move / TIME_GetDt()

			if (ti_B_flag_local_friction)
			{
				tv_rope_traction = DYN_LIB_Traction_To_Reach_Speed(tv_B_speed, @to_gao_B MATH_VecGlobalToLocal(tv_B_next_speed) - tv_B_speed, tv_B_friction, tv_B_forces, Cv_NullVector, Cv_NullVector, TIME_GetDt())
				tv_rope_traction = @to_gao_B MATH_VecLocalToGlobal(tv_rope_traction)
			}
			else
			{
				tv_rope_traction = DYN_LIB_Traction_To_Reach_Speed(tv_B_speed, tv_B_next_speed - tv_B_speed, tv_B_friction, tv_B_forces, Cv_NullVector, Cv_NullVector, TIME_GetDt())
			}
			av_rope_last_trame_traction[ti_index][1] = GRAPPIN_Rope_Traction_Set(to_gao_B, tv_rope_traction)
		}
		else
		{
			av_rope_last_trame_traction[ti_index][1] = Cv_NullVector
		}
	}
}

