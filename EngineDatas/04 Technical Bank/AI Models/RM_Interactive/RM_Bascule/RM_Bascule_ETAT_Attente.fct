#include "RM_Bascule_defines.var"

Include_UltraProcedure_Header

int			ti_i
int			ti_index

float		tf_angle
float		tf_rot_speed
float		tf_rot_sign
float		tf_norm

object	to_gao
object	to_hotspot
object	to_main_actor

vector	tv_init_pos
vector	tv_init_sight
vector	tv_init_banking
vector	tv_init_horizon
vector	tv_torque
vector	tv_rot_pivot
vector	tv_new_sight
vector	tv_new_banking
vector	tv_speed
vector	tv_angle
vector	tv_traction_A
vector	tv_traction_B
vector	tv_force
vector	tv_move

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux
	return
}

if (i_etat_courant != ETAT_Attente)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Attente
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	DYN_On()
	DYN_FlagsSet(DYN_C_NeverDynamicHierarchy, none)

//	BV_MinSet(cvector(-20.0, -20.0, -20.0))
//	BV_MaxSet(cvector(20.0, 20.0, 20.0))

	o_father = OBJ_HierarchyGet()
	if (o_father)
	{
		v_init_pos = @o_father MATH_VecGlobalToLocal(OBJ_PosGet() - @o_father OBJ_PosGet())
		v_init_horizon = @o_father MATH_VecGlobalToLocal(OBJ_HorizonGet())
		v_init_sight = @o_father MATH_VecGlobalToLocal(OBJ_SightGet())
		v_init_banking = @o_father MATH_VecGlobalToLocal(OBJ_BankingGet())
	}
	else
	{
		v_init_pos = OBJ_PosGet()
		v_init_horizon = OBJ_HorizonGet()
		v_init_sight = OBJ_SightGet()
		v_init_banking = OBJ_BankingGet()
	}

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
if (o_father)
{
	tv_init_pos = @o_father OBJ_PosGet() + @o_father MATH_VecLocalToGlobal(v_init_pos)
	tv_init_horizon = @o_father MATH_VecLocalToGlobal(v_init_horizon)
	tv_init_sight = @o_father MATH_VecLocalToGlobal(v_init_sight)
	tv_init_banking = @o_father MATH_VecLocalToGlobal(v_init_banking)
}
else
{
	tv_init_pos = v_init_pos
	tv_init_horizon = v_init_horizon
	tv_init_sight = v_init_sight
	tv_init_banking = v_init_banking
}

tv_torque = v_torque
v_torque = Cv_NullVector

tv_force = v_force
v_force = Cv_NullVector

tv_move = Cv_NullVector

to_main_actor = AI_MainActorGet(0)
ti_index = ARR_ObjSearch(&ao_inertia_actor[0], i_inertia_actor, to_main_actor)
if (ti_index == -1)
{
	for (ti_i = 0; ti_i < 10; ti_i++)
	{
		if ( ! hotspot_list[ti_i] )
			break
			
		ti_index = @o_rope_manager Rope_Manager_Get_Corde_Index(to_main_actor, hotspot_list[ti_i])	
		if (ti_index == -1)
			continue
	
		if (@o_rope_manager Rope_Manager_RopeTendue(ti_index))
		{
			@o_rope_manager Rope_Manager_RopeLastTrameTractionGet(ti_index, tv_traction_A, tv_traction_B)
			tf_norm = MATH_VecSquareNorm(tv_traction_A)
			if (tf_norm)
			{
				tv_traction_A /= MATH_FloatSqrt(tf_norm)
				tv_traction_A *= -10.0
			
//				DBG_RenderVector(@to_main_actor OBJ_PosGet(), tv_traction_A, color_cyan)
				tv_torque += MATH_VecCrossProduct(@hotspot_list[ti_i] OBJ_PosGet() - OBJ_PosGet(), tv_traction_A)
				tv_force += tv_traction_A
			}
			break
		}
	}
}


if (linear_dyn)
{
	tv_move = tv_init_pos - OBJ_PosGet()

	switch(i_spring_Z_mode)
	{
		case 0 :
			tv_move = MATH_VecDotProduct(tv_move, OBJ_BankingGet()) * OBJ_BankingGet()
			break
			
		case 1 :
			tv_move = MATH_VecDotProduct(tv_move, tv_init_banking) * tv_init_banking
			break
	}
		
	tf_norm = MATH_VecSquareNorm(tv_move)
	if (tf_norm)
	{
		tf_norm = MATH_FloatSqrt(tf_norm)
		tv_move /= tf_norm
	
		tv_force += tv_move * tf_norm * f_spring_coef
	}

	switch(i_spring_Z_mode)
	{
		case 0 :
			tv_force = MATH_VecDotProduct(tv_force, OBJ_BankingGet()) * OBJ_BankingGet()
			break
			
		case 1 :
			tv_force = MATH_VecDotProduct(tv_force, tv_init_banking) * tv_init_banking
			break
	}
	
	v_speed = MATH_VecGlobalToLocal(v_speed)
	tv_force = MATH_VecGlobalToLocal(tv_force)
	tv_move = DYN_LIB_Position_After_N_Seconds(Cv_NullVector, v_speed, cvector(0.0, 0.0, f_spring_friction), tv_force, TIME_GetDt(), 0.0)
	tv_move = MATH_VecLocalToGlobal(tv_move)
	v_speed = MATH_VecLocalToGlobal(v_speed)

	switch(i_spring_Z_mode)
	{
		case 0 :
			tv_move = MATH_VecDotProduct(tv_move, OBJ_BankingGet()) * OBJ_BankingGet()
			break
			
		case 1 :
			tv_move = MATH_VecDotProduct(tv_move, tv_init_banking) * tv_init_banking
			break
	}

	OBJ_PosSet(OBJ_PosGet() + tv_move)

//	DBG_RenderVector(OBJ_PosGet(), OBJ_BankingGet() * 1000.0,  color_blanc)
//	DBG_RenderVector(OBJ_PosGet(), tv_init_pos - OBJ_PosGet(),  color_blanc)
}

switch(i_spring_Z_mode)
{
	case 0 :
		tv_move = MATH_VecDotProduct(tv_move, OBJ_BankingGet()) * OBJ_BankingGet()
		break
		
	case 1 :
		tv_move = MATH_VecDotProduct(tv_move, tv_init_banking) * tv_init_banking
		break
}

if (MATH_VecNull(v_grav_offset))
{
	tv_rot_pivot = -OBJ_BankingGet()
	tv_rot_pivot += tv_move

	switch(i_spring_Z_mode)
	{
		case 0 :
			tv_torque += MATH_VecCrossProduct(tv_rot_pivot, cvector(0.0, 0.0, -base_torque))
			break
			
		case 1 :
			tv_torque += MATH_VecCrossProduct(tv_rot_pivot, -base_torque * tv_init_banking)
			break
	}
	
	DBG_RenderVector(tv_init_pos, tv_rot_pivot, color_bleu)
	DBG_RenderVector(tv_init_pos + tv_rot_pivot, cvector(0.0, 0.0, -base_torque), color_cyan)
}
else
{
	tv_rot_pivot = MATH_VecLocalToGlobal(v_grav_offset)
	tv_rot_pivot += tv_move

	switch(i_spring_Z_mode)
	{
		case 0 :
			tv_torque += MATH_VecCrossProduct(tv_rot_pivot, cvector(0.0, 0.0, -base_torque))
			break
			
		case 1 :
			tv_torque += MATH_VecCrossProduct(tv_rot_pivot, -base_torque * tv_init_banking)
			break
	}
	
	DBG_RenderVector(tv_init_pos, tv_rot_pivot, color_bleu)
	DBG_RenderVector(tv_init_pos + tv_rot_pivot, cvector(0.0, 0.0, -base_torque), color_cyan)
}

v_rot_speed = MATH_VecGlobalToLocal(v_rot_speed)
tv_angle = DYN_LIB_Position_After_N_Seconds(Cv_NullVector, v_rot_speed, v_rot_friction, MATH_VecGlobalToLocal(tv_torque), TIME_GetDt(), 0.0)
tv_angle = MATH_VecLocalToGlobal(tv_angle)
v_rot_speed = MATH_VecLocalToGlobal(v_rot_speed)

//DBG_RenderVector(OBJ_PosGet(), tv_torque * 1000.0, color_cyan)
//DBG_RenderVector(OBJ_PosGet(), v_rot_speed * 1000.0, color_jaune)

AI_Execute("RM_Bascule_exec_check_paf")

OBJ_CapaSet(none, all)
switch(liaison)
{
	case Ci_liaison_rotule :
		tf_rot_sign = 1.0

		if (f_angle_limit)
		{
			tf_rot_speed = MATH_VecNorm(v_rot_speed)
			if (tf_rot_speed > f_angle_limit)
			{
				OBJ_CapaSet(OBJ_Capa_0, none)
				DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
			}
		}
		break

	case Ci_liaison_horizon_axis :
		tf_rot_speed = MATH_VecDotProduct(v_rot_speed, OBJ_HorizonGet())
		tf_rot_sign = MATH_FloatSign(tf_rot_speed)
	
		if (f_angle_limit)
		{
			if (MATH_FloatSign(f_angle_limit) == 1.0)
			{
				if (tf_rot_speed > f_angle_limit)
				{
					OBJ_CapaSet(OBJ_Capa_0, none)
					DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
				}
			}
			else
			{
				if (tf_rot_speed < f_angle_limit)
				{
					OBJ_CapaSet(OBJ_Capa_0, none)
					DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
				}
			}
		}
		break

	case Ci_liaison_sight_axis :
		tf_rot_speed = MATH_VecDotProduct(v_rot_speed, OBJ_SightGet())
		tf_rot_sign = MATH_FloatSign(tf_rot_speed)
		
		if (f_angle_limit)
		{
			if (MATH_FloatSign(f_angle_limit) == 1.0)
			{
				if (tf_rot_speed > f_angle_limit)
				{
					OBJ_CapaSet(OBJ_Capa_0, none)
					DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
				}
			}
			else
			{
				if (tf_rot_speed < f_angle_limit)
				{
					OBJ_CapaSet(OBJ_Capa_0, none)
					DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
				}
			}
		}
		break

	case Ci_liaison_banking_axis :
		tf_rot_speed = MATH_VecDotProduct(v_rot_speed, OBJ_BankingGet())
		tf_rot_sign = MATH_FloatSign(tf_rot_speed)
		
		if (f_angle_limit)
		{
			if (MATH_FloatSign(f_angle_limit) == 1.0)
			{
				if (tf_rot_speed > f_angle_limit)
				{
					OBJ_CapaSet(OBJ_Capa_0, none)
					DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
				}
			}
			else
			{
				if (tf_rot_speed < f_angle_limit)
				{
					OBJ_CapaSet(OBJ_Capa_0, none)
					DBG_RenderSphere(@to_main_actor OBJ_PosGet(), 2.0, color_rouge)
				}
			}
		}
		break

}

tf_angle = MATH_VecNorm(tv_angle)
if (tf_angle)
{
	tv_rot_pivot = tv_angle / tf_angle

	tf_angle	*= TIME_GetDt()

	// ROTATION DES OBJETS ADDITIONNELS
	for (ti_i = 0; ti_i < 10; ti_i++)
	{
		if (! ao_rot_gao[ti_i] )
			break
	
		switch(ai_rot_axis[ti_i])
		{
			case 0 :
				@ao_rot_gao[ti_i] OBJ_RotateLocalX(tf_rot_sign * tf_angle * af_rot_speed_coef[ti_i])
				break
	
			case 1 :
				@ao_rot_gao[ti_i] OBJ_RotateLocalY(tf_rot_sign * tf_angle * af_rot_speed_coef[ti_i])
				break
	
			case 2 :
				@ao_rot_gao[ti_i] OBJ_RotateLocalZ(tf_rot_sign * tf_angle * af_rot_speed_coef[ti_i])
				break
		}
	}

	switch(liaison)
	{
		case Ci_liaison_rotule :
			tv_new_sight = MATH_VecRotate(OBJ_SightGet(), tv_rot_pivot, tf_angle)
			tv_new_banking = MATH_VecRotate(OBJ_BankingGet(), tv_rot_pivot, tf_angle)

			if (f_angle_max != 180.0)
			{
				DBG_RenderCone(OBJ_PosGet(), tv_init_banking * 10.0, f_angle_max * Cf_PiBy180, color_rouge)
				tf_angle = MATH_ASin(MATH_VecNorm(MATH_VecCrossProduct(tv_init_banking, tv_new_banking)))
				if (tf_angle > f_angle_max * Cf_PiBy180)
				{
					tv_new_banking = MATH_VecInCone(tv_new_banking, tv_init_banking, f_angle_max * Cf_PiBy180, 0)
					v_rot_speed *= -f_rebound
				}	
			}
		
			if (keep_init_sight)
				OBJ_BankingGeneralSet(tv_init_sight, tv_new_banking)
			else
				OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)
			break
			
		case Ci_liaison_sight_axis :
	
			tv_new_sight = tv_init_sight
			tv_new_banking = MATH_VecRotate(OBJ_BankingGet(), tv_rot_pivot, tf_angle)

			if (f_angle_min != -180.0 || f_angle_max != 180.0)
			{
				DBG_RenderVector(OBJ_PosGet(), tv_init_banking * 100.0, color_blanc)
				DBG_RenderVector(OBJ_PosGet(), MATH_VecRotate(tv_init_banking, tv_init_sight, f_angle_min * Cf_PiBy180) * 100.0, color_rouge)
				DBG_RenderVector(OBJ_PosGet(), MATH_VecRotate(tv_init_banking, tv_init_sight, f_angle_max * Cf_PiBy180) * 100.0, color_vert)
	
				tf_angle = MATH_VecAngle(tv_init_banking, tv_new_banking, tv_init_sight)
				if (tf_angle < f_angle_min * Cf_PiBy180)
				{
					tv_new_banking = MATH_VecRotate(tv_init_banking, tv_init_sight, f_angle_min * Cf_PiBy180)
					v_rot_speed *= -f_rebound
				}	
				else if (tf_angle > f_angle_max * Cf_PiBy180)
				{
					tv_new_banking = MATH_VecRotate(tv_init_banking, tv_init_sight, f_angle_max * Cf_PiBy180)
					v_rot_speed *= -f_rebound
				}	
			}

			OBJ_SightGeneralSet(tv_new_sight, tv_new_banking)
			break

		case Ci_liaison_horizon_axis :
			tv_new_sight = tv_init_sight
			tv_new_banking = MATH_VecRotate(OBJ_BankingGet(), tv_rot_pivot, tf_angle)
			tv_new_banking -= MATH_VecDotProduct(tv_new_banking, tv_init_horizon) * tv_init_horizon

			if (f_angle_min != -180.0 || f_angle_max != 180.0)
			{
				DBG_RenderVector(OBJ_PosGet(), tv_init_banking * 100.0, color_blanc)
				DBG_RenderVector(OBJ_PosGet(), MATH_VecRotate(tv_init_banking, tv_init_horizon, f_angle_min * Cf_PiBy180) * 100.0, color_rouge)
				DBG_RenderVector(OBJ_PosGet(), MATH_VecRotate(tv_init_banking, tv_init_horizon, f_angle_max * Cf_PiBy180) * 100.0, color_vert)
	
				tf_angle = MATH_VecAngle(tv_init_banking, tv_new_banking, tv_init_horizon)
				if (tf_angle < f_angle_min * Cf_PiBy180)
				{
					tv_new_banking = MATH_VecRotate(tv_init_banking, tv_init_horizon, f_angle_min * Cf_PiBy180)
					v_rot_speed *= -f_rebound
				}	
				else if (tf_angle > f_angle_max * Cf_PiBy180)
				{
					tv_new_banking = MATH_VecRotate(tv_init_banking, tv_init_horizon, f_angle_max * Cf_PiBy180)
					v_rot_speed *= -f_rebound
				}	
			}

			OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)
			break

		case Ci_liaison_banking_axis :
			tv_new_sight = MATH_VecRotate(OBJ_SightGet(), tv_rot_pivot, tf_angle)
			tv_new_banking = tv_init_banking
			OBJ_BankingGeneralSet(tv_new_sight, tv_new_banking)
			break
	}
}

tv_move = tv_init_pos
switch(i_spring_Z_mode)
{
	case 0 :
		tv_move += MATH_VecDotProduct(OBJ_PosGet() - tv_init_pos, OBJ_BankingGet()) * OBJ_BankingGet()
		break
		
	case 1 :
		tv_move += MATH_VecDotProduct(OBJ_PosGet() - tv_init_pos, tv_init_banking) * tv_init_banking
		break
}
OBJ_PosSet(tv_move)

v_speed = MATH_VecDotProduct(v_speed, OBJ_BankingGet()) * OBJ_BankingGet()

if (f_expulsion_limit)
{
	for (ti_i = 0; ti_i < i_inertia_actor; ti_i++)
	{
		tv_speed = @ao_inertia_actor[ti_i] OBJ_PosGet() - OBJ_PosGet()
		tv_speed = MATH_VecCrossProduct(v_rot_speed, tv_speed)
		tv_speed *= TIME_GetDt()
	//	DBG_RenderVector(@ao_inertia_actor[ti_i] OBJ_PosGet(), tv_speed, color_cyan)
		if (tv_speed.z > f_expulsion_limit)
		{
			@ao_inertia_actor[ti_i] OBJ_HierarchyReset()
			@ao_inertia_actor[ti_i] DYN_SpeedSetVector(tv_speed  / af_inertia_actor_weight[ti_i])
		}
	}
}

i_inertia_actor = 0
