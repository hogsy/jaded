#include "Box_defines.var"

#define Cf_Traction_Ice 			2.5

int			ti_i
int			ti_target
int			ti_ice
int			ti_flag_tension

float		tf_best_dot
float		tf_dot_product
float		tf_abs_dot
float		tf_norm
float		tf_glisse_coef
float		tf_friction

vector	tv_axis[3]
vector	tv_from[3]
vector	tv_rot_speed

float		tf_sin_angle
float		tf_sin_angle_sight
float		tf_sin_angle_banking
float		tf_rot_friction

vector	tv_sight_based_quat
vector	tv_banking_based_quat

vector	tv_temp
vector	tv_horizon_ground
vector	tv_traction_ground

float		tf_speed

vector	tv_rot_dir
vector	tv_joy_dir
vector	tv_AB
vector	tv_pos_A
vector	tv_pos_B
vector	tv_start_dir
vector	tv_dest_dir

object	to_rope_gao

int			ti_zde_corps_nb
object	tao_zde_corps_gao[100]

object	to_target
int			ti_ind


#define Cf_Gogo_Traction			30.0 // 30.0

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_BOX_Caisse)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_BOX_Caisse
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}

	// DYNA
	DYN_On()
//	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_NeverDynamicHierarchy | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_SkipFrictionWhenSpeedFromAnim | DYN_C_SlipOnGroundEdge | DYN_C_ApplyRec, none)
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_NeverDynamicFather | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_SkipFrictionWhenSpeedFromAnim | DYN_C_SlipOnGroundEdge | DYN_C_ApplyRec, DYN_C_NeverDynamicHierarchy)
	DYN_TractionSet(Cv_NullVector)
	
	fct_last_etat = AI_TrackCurGet()
}

// GRABBED ???
o_Grabbed_Actor = LNK_ServeurGet(Ci_LNK_GRAB_EAGLE, mid_Grabbed_LNK_ID, vrai, nofunc, nofunc)
if( o_Grabbed_Actor )
	AI_TrackCurChangeNow("Box_ETAT_Grabbed")

if( DYN_Immovable )
	return

//AI_Execute("HS_Box_exec_GroundCol")

ti_ice = faux
tf_rot_friction = 1.5

// GROUND OU FALLING ??? ===================================================
if( i_real_ground_flag )
{
	// NORMALE DE REFERENCE ?
//	v_Ground_Normale = COL_ZonePosGet(C_zdm_pied)
//	v_Ground_Normale -= COL_CollidedPointGet(COL_C_Ground)
//	MATH_VecSetNormalize(v_Ground_Normale)

	tf_best_dot = -1.0
	
	tv_axis[0] = OBJ_HorizonGet()
	tv_axis[1] = -OBJ_SightGet()
	tv_axis[2] = OBJ_BankingGet()

	tv_from[0] = cvector(1,0,0)
	tv_from[1] = cvector(0,1,0)
	tv_from[2] = cvector(0,0,1)

	if (Keep_Z_Axis)
	{
//		tf_dot_product = MATH_VecDotProduct(tv_axis[2], v_Ground_Normale)
//		v_Ground_Quat = MATH_FloatSign(tf_dot_product) * tv_from[2]
		
		v_Ground_Quat = tv_from[2]
	}
	else
	{
		for( ti_i = 0; ti_i < 3; ti_i++ )
		{
			tf_dot_product = MATH_VecDotProduct(tv_axis[ti_i], v_Ground_Normale)
			tf_abs_dot = MATH_AbsFloat(tf_dot_product) 
	
			if( tf_abs_dot > tf_best_dot )
			{
				tf_best_dot = tf_abs_dot
				v_Ground_Quat = MATH_FloatSign(tf_dot_product) * tv_from[ti_i]
			}
		}
	}

	DBG_RenderVector(OBJ_PosGet(), MATH_VecLocalToGlobal(v_Ground_Quat) * 5.0, color_rouge)
	ti_i = ti_i
	
	if (f_No_Ground_Duration)
		v_Ground_Normale_Cur = MATH_VecLocalToGlobal(v_Ground_Quat)
	
	// PENTE ?
	if( Glissement == Ci_Glissement_Ice )
	{
		DBG_RenderVector(OBJ_PosGet(), v_Ground_Normale_Cur, color_bleu)
		tv_horizon_ground = MATH_VecCrossProduct(v_Ground_Normale_Cur, Cv_VerticalVector)
		DBG_RenderVector(OBJ_PosGet(), tv_horizon_ground, color_rouge)
		tv_traction_ground = MATH_VecCrossProduct(v_Ground_Normale_Cur, tv_horizon_ground)
		DBG_RenderVector(OBJ_PosGet(), tv_traction_ground, color_vert)
		
		// GMAT
		if( COL_GMAT_FlagsGet(COL_C_Ground) & Gmat_RM_Ice )
			ti_ice = vrai
//		if( 1 ) ti_ice = vrai
		if( ti_ice )
		{
			tf_norm = MATH_VecNorm(tv_traction_ground)
			if( tf_norm > 0.1 )
			{
				MATH_VecSetNormalize(tv_traction_ground)
				tf_glisse_coef = 1 - v_Ground_Normale_Cur.z
				tf_glisse_coef *= 10.0 * Size
				tv_traction_ground *= (tf_glisse_coef * Cf_Traction_Ice)	
			}
			else
				tv_traction_ground = Cv_NullVector
		}
		else
			tv_traction_ground = Cv_NullVector
		v_Traction_Pente = tv_traction_ground
	}
	
	f_Ground_Duration += TIME_GetDt()
	f_No_Ground_Duration = 0.0
}
else
{
	f_Ground_Duration = 0.0
	f_No_Ground_Duration += TIME_GetDt()
}

// ROPE =====================================================================
tv_joy_dir = IO_JoyGetMove()
if ( MATH_VecSquareNorm(tv_joy_dir) < tolerance_joynull * tolerance_joynull )
	tv_joy_dir = Cv_NullVector

to_rope_gao = Box_Get_Rope_Gao(tv_pos_A, tv_pos_B, ti_flag_tension) 
if (to_rope_gao == o_main_actor)
{
	tv_AB = tv_pos_B - tv_pos_A
	
	tf_rot_friction = 6.0

	if (ti_flag_tension)
	{
		f_rot_speed	 = 0.0

		tv_start_dir = MATH_VecGlobalToLocal(tv_pos_A - OBJ_PosGet())	
		tv_dest_dir = MATH_VecGlobalToLocal(tv_pos_B - OBJ_PosGet())
		
		if ( ! MATH_VecSquareNorm(tv_start_dir) )
			tv_start_dir = cvector(0.0, -1.0, 0.0)
			
		if (f_No_Ground_Duration < 0.1)
			OBJ_Rotate_FromToBlend(tv_start_dir, tv_dest_dir, 6.0 * TIME_GetDt())
		else
			OBJ_Rotate_FromTo(tv_start_dir, tv_dest_dir)
	}

	tf_speed = MATH_VecSquareNorm(DYN_SpeedGetVector())
	tv_rot_dir = MATH_VecCrossProduct(tv_joy_dir, v_last_joy_dir)

	if (MATH_AbsFloat(tv_rot_dir.z) > 4.0 * TIME_GetDt())
	{
		if (tf_speed < 25.0 ||  MATH_FloatSign(tv_rot_dir.z) == MATH_FloatSign(MATH_VecCrossProduct(tv_AB, DYN_SpeedGetVector()).z))
			f_joy_cycl_duration += MATH_FloatMin(1.0 - f_joy_cycl_duration, TIME_GetDt())
		else
			f_joy_cycl_duration -= MATH_FloatMin(f_joy_cycl_duration, TIME_GetDt())
	}
	else
	{
//		DBG_RenderSphere(@o_main_actor OBJ_PosGet(), 2.0, color_rouge)
		f_joy_cycl_duration -= MATH_FloatMin(f_joy_cycl_duration, 0.5 * TIME_GetDt())
	}
		
	if (f_joy_cycl_duration > Cf_joy_cycl_duration_gogo)
	{
		DYN_GravitySet(cvector(0.0, 0.0, -5.0))
		
		ti_zde_corps_nb =  COL_ZDE_ZDEListGet(&tao_zde_corps_gao[0], C_zde_fight, C_zde_corps, all, none, Ci_Filter_IdentityFlag)
		for (ti_i = 0; ti_i < ti_zde_corps_nb; ti_i++)
		{
			to_target = tao_zde_corps_gao[ti_i]
			if ( to_target == o_main_actor )
				continue
			
			ti_ind = ARR_ObjSearch(&ao_frappe_target[0], i_frappe_target_nb, to_target)
			if( ti_ind == -1 )
			{
				ao_frappe_target[i_frappe_target_nb] = to_target
				i_frappe_target_nb++
				EVENT_AddEventPafCanal( C_EVENT_FILTER_Object,  C_PAF_RM_Fort, o_main_actor, Cf_EVENT_Duree_1Trame, tao_zde_corps_gao[ti_i], -1, 10.0, -tv_AB, OBJ_PosGet())
			}
		}
		
		if (tf_speed < 25.0 && ! MATH_VecNull(tv_rot_dir) )
		{
			tv_temp = -tv_rot_dir
			tv_AB = MATH_VecCrossProduct(tv_AB, tv_temp)
		}
		else
		{
			tv_temp = MATH_VecCrossProduct(tv_AB, DYN_SpeedGetVector())	

			if (MATH_VecNull(tv_temp))
				tv_temp	= Cv_VerticalVector

			tv_AB = MATH_VecCrossProduct(tv_AB, tv_temp)
			if (MATH_VecNull(tv_AB))
				tv_AB = cvector(1.0, 0.0, 0.0)
		
			tv_AB *= MATH_FloatSign(MATH_VecDotProduct(tv_AB, DYN_SpeedGetVector()))
		}

		MATH_VecSetNormalize(tv_AB)
		
//		DBG_RenderVector(OBJ_PosGet(), tv_AB * 10.0, color_jaune)
		
//		if (f_No_Ground_Duration < 0.1)
//			tv_AB *= 30.0
//		else
//			tv_AB *= 60.0

		tv_AB *= Cf_Gogo_Traction

		v_Traction_Exterieure += tv_AB
	}
}
else
{
	f_joy_cycl_duration = 0.0
}

f_backup_joy_delay += TIME_GetDt()
if (f_backup_joy_delay > 0.05)
{
	f_backup_joy_delay -= 0.05
	v_last_joy_dir = tv_joy_dir
}

// GROUND NORMALE OU FALLING ROTATION ??? ==============================================
if (f_No_Ground_Duration < 0.1)
{
	DBG_RenderVector(OBJ_PosGet(), v_Ground_Normale * 10.0, color_bleu)
	v_Ground_Normale_Cur = MATH_VecBlendRotate(v_Ground_Normale_Cur, v_Ground_Normale, 10.0 * TIME_GetDt())
	
	if( MATH_VecDotProduct(v_Ground_Quat, MATH_VecGlobalToLocal(v_Ground_Normale_Cur)) > -1.0 )
	{
		OBJ_Rotate_FromTo(v_Ground_Quat, MATH_VecGlobalToLocal(v_Ground_Normale_Cur))
		
		tv_rot_speed = f_rot_speed * v_rot_speed
		tv_rot_speed = MATH_VecDotProduct(tv_rot_speed, v_Ground_Normale_Cur) * v_Ground_Normale_Cur
		
		f_rot_speed = MATH_VecNorm(tv_rot_speed)
		if (f_rot_speed)
		{
			v_rot_speed = tv_rot_speed / f_rot_speed
			f_rot_speed *= MATH_Exp(- tf_rot_friction * TIME_GetDt())
		}
	}
}
else if (to_rope_gao)
{
	if (f_rot_speed)
		f_rot_speed *= MATH_Exp(- tf_rot_friction * TIME_GetDt())
}

if (f_rot_speed)
{
	DBG_RenderVector(OBJ_PosGet(), f_rot_speed * v_rot_speed, color_jaune)	

	switch(i_rot_quat_used)
	{
		case 0 :	
			tv_rot_speed = MATH_VecRotate(OBJ_SightGet(), v_rot_speed, f_rot_speed * TIME_GetDt())
			OBJ_Rotate_FromTo(cvector(0.0, -1.0, 0.0), MATH_VecGlobalToLocal(tv_rot_speed))	
			break

		case 1 :
			tv_rot_speed = MATH_VecRotate(OBJ_BankingGet(), v_rot_speed, f_rot_speed * TIME_GetDt())
			OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), MATH_VecGlobalToLocal(tv_rot_speed))	
			break		
	}
}

// FALLING ROTATION ANGLE & SPEED ==============================================
tv_sight_based_quat = MATH_VecCrossProduct(v_last_sight, OBJ_SightGet())
tv_banking_based_quat = MATH_VecCrossProduct(v_last_banking, OBJ_BankingGet())

tf_sin_angle_sight = MATH_VecSquareNorm(tv_sight_based_quat)
tf_sin_angle_banking = MATH_VecSquareNorm(tv_banking_based_quat)

if (tf_sin_angle_sight > tf_sin_angle_banking)
{
	i_rot_quat_used = 0 
	tf_sin_angle = tf_sin_angle_sight
	tv_temp = tv_sight_based_quat
}
else
{
	i_rot_quat_used = 1
	tf_sin_angle = tf_sin_angle_banking
	tv_temp = tv_banking_based_quat
}

DBG_RenderVector(OBJ_PosGet(), tv_temp * 10.0, color_cyan)

if (tf_sin_angle && tf_sin_angle < 1.0)
{
	tf_sin_angle = MATH_FloatSqrt(tf_sin_angle)
	v_rot_speed = tv_temp / tf_sin_angle
	f_rot_speed = MATH_ASin(tf_sin_angle) / TIME_GetDt()
}
else
{
	f_rot_speed = 0.0
}


// REINIT
if( Proc_Box_Grappin_GogoMode() )
	f_gogo_paf_timer += TIME_GetDt()
else
{
	f_gogo_paf_timer = 0.0
	i_frappe_target_nb = 0		// refrapper les persos
}
if( f_gogo_paf_timer > 0.5 )
{
	f_gogo_paf_timer = 0.0
	i_frappe_target_nb = 0		// refrapper les persos
}


// TARGET ????
ti_target = faux
if( Proc_Box_Explosive() && @o_main_actor PROC_RM_Current_HotSpot_Get() == OBJ_Me() )
	ti_target = vrai
if( ti_target )
{
	if( ! i_target )
	{
		i_target = vrai
		RM_TARGET_Add(OBJ_Me(), cvector(0,0,0.75))
	}
}
else
{
	if( i_target )
	{
		i_target = faux
		RM_TARGET_Del(OBJ_Me())
	}
}

