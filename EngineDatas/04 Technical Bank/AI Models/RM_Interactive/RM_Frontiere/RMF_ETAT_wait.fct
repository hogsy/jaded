#include "RM_Frontiere_defines.var"

int				ti_i
int				ti_target_in_bv

#ifndef _FINAL_
vector		tv_vec
float			tf_length
float			tf_width
float			tf_height
#endif

// SORTIE ETAT 	===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	return
}

// INIT ETAT 	=====================================================================
if( i_etat_courant != RMF_ETAT_WAIT)
{
	i_etat_courant = RMF_ETAT_WAIT
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0

} 
else
{
	f_time_start_etat += TIME_GetDt()
}

// COMPORTEMENT ================================================================

// Target dans la BV ?
if (COL_BV_PivotCollide(o_target )) 
{
	// De quel côté du sight ?
	ti_target_in_bv = MATH_FloatSign(MATH_VecDotProduct(@o_target OBJ_PosGet() - OBJ_PosGet(), OBJ_SightGet()))
	if (i_target_in_bv && (MATH_FloatSign(i_target_in_bv) != MATH_FloatSign(ti_target_in_bv)))
	{
		// Changement de côté : appeller les triggers
		if (i_target_in_bv > 0)
		{
			for (ti_i=0; ti_i < 5; ti_i++)
			{
				if (AI_TriggerIsValid(t_vers_l_avant[ti_i]))
					call_trigger(t_vers_l_avant[ti_i])
			}
			
		}
		else
		{
			for (ti_i=0; ti_i < 5; ti_i++)
			{
				if (AI_TriggerIsValid(t_vers_l_arriere[ti_i]))
					call_trigger(t_vers_l_arriere[ti_i])
			}
		}
	}
	
 	i_target_in_bv = ti_target_in_bv
}
else
	i_target_in_bv = 0


#ifndef _FINAL_
tv_vec = BV_MaxGet() - BV_MinGet()
tf_length = MATH_VecDotProduct(-OBJ_SightGet(), tv_vec)
tf_width = MATH_VecDotProduct(OBJ_HorizonGet(), tv_vec)
tf_height = MATH_VecDotProduct(OBJ_BankingGet(), tv_vec)
DBG_RenderVector(OBJ_PosGet() + ((tf_width / 2.0) * OBJ_HorizonGet()) + ((tf_height / 2.0) * OBJ_BankingGet()),  - (tf_width  * OBJ_HorizonGet()), color_rouge)
DBG_RenderVector(OBJ_PosGet() - ((tf_width / 2.0) * OBJ_HorizonGet()) + ((tf_height / 2.0) * OBJ_BankingGet()),  - (tf_height * OBJ_BankingGet()) , color_rouge)
DBG_RenderVector(OBJ_PosGet() - ((tf_width / 2.0) * OBJ_HorizonGet()) - ((tf_height / 2.0) * OBJ_BankingGet()),  (tf_width  * OBJ_HorizonGet()), color_rouge)
DBG_RenderVector(OBJ_PosGet() + ((tf_width / 2.0) * OBJ_HorizonGet()) - ((tf_height / 2.0) * OBJ_BankingGet()),  (tf_height * OBJ_BankingGet()) , color_rouge)
#endif

