#include "PNJ_Volant_defines.var"

Include_UltraProcedure_Header

procedure_local void PNJ_Volant_Shoot()
{
	int			ti_i	

	float		tf_coef	
	float		tf_dot_product
	float		tf_best_dot
	float		tf_norm
	
	vector	tv_pos
	vector	tv_target_pos

	object	to_gao
	object	to_bullet
	object	to_target
	
	if (o_Rided_Actor != o_main_actor)
	{
		if (GFX_Shoot != -1)
		{
			GFX_Del(GFX_Shoot)
			GFX_Shoot = -1
		}

		return
	}

	tv_pos = OBJ_PosGet()
	tv_pos += OBJ_SightGet() * 1.3
	tv_pos += OBJ_BankingGet() * 0.5

	if (IO_ButtonPressed(RM_Monture_Button_Action1) || IO_ButtonPressed(RM_Monture_Button_Action2))
	{
		f_shoot_duration += TIME_GetDt()

		if (f_shoot_duration > 0.3)
		{
			tf_coef = MATH_FloatMin((f_shoot_duration - 0.3), 1.0)
		
			if( GFX_Shoot == -1 )
			{
				GFX_Shoot = GFX_Add(21)	// Halo
				GFX_FlagSet(GFX_Shoot, 4, 1)
				GFX_MaterialSet(GFX_Shoot, get_SFX_light_and_smoke,0) // affectation du matériau
				GFX_Seti(GFX_Shoot, 21103, 1)			// 0 (défaut) flare mural		1 flare très simple 
				GFX_Seti(GFX_Shoot, 21101, 0xC000C0)     // couleur du halo
				GFX_Setf(GFX_Shoot, 21002, 1.0) // Extraction
			}

			GFX_Setf(GFX_Shoot, 21000, 4.0 * tf_coef)  // taille du halo
			GFX_Setv(GFX_Shoot, 21200, tv_pos )      // position du halo
		}
	}
	else if (f_shoot_duration )
	{
		if (GFX_Shoot != -1)
		{
			GFX_Del(GFX_Shoot)
			GFX_Shoot = -1
		}

		if (f_shoot_duration < 0.3)
		{
			to_bullet = @get_Bullet OBJ_Duplicate(tv_pos)
			@to_bullet OBJ_BankingGeneralSet(OBJ_SightGet(), OBJ_BankingGet())
			@get_RM_Bullet_path to_bullet i_GFX_color = 0x800080
			@get_RM_Bullet_path to_bullet f_GFX_taille = 3.0
			to_bullet.des_object1 = o_main_actor
			to_bullet.des_vec1 = cvector(MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet()) + 100.0, 0.0, 0.0) 
			to_bullet.des_float1 = 10.0 // Dommage
			to_bullet.des_float2 = 300.0 // Portée
		}
		else
		{
			tf_coef = MATH_FloatMin(f_shoot_duration / 1.0, 1.0)
		
			to_target = nobody
			tf_best_dot = -1.0
			
			for (ti_i = 0; ti_i < @get_list_manager i_target_nb; ti_i++)
			{
				to_gao = @get_list_manager ao_target[ti_i]

				tv_target_pos = @to_gao OBJ_PosGet()
				tv_target_pos += @to_gao MATH_VecLocalToGlobal(@get_list_manager av_target[ti_i])
				
				tv_target_pos -= tv_pos

				tf_norm = MATH_VecSquareNorm(tv_target_pos)
				if (tf_norm > 40000.0)
					continue
					
				if (tf_norm < 0.01)
				{
					to_target = to_gao
					break
				}

				tf_norm = MATH_FloatSqrt(tf_norm)
				tv_target_pos /= tf_norm
				
				tf_dot_product = MATH_VecDotProduct(OBJ_SightGet(), tv_target_pos)
				if (tf_dot_product < Cf_Cos70)
					continue
			
				if (tf_dot_product > tf_best_dot)
				{
					tf_best_dot = tf_dot_product
					to_target = to_gao
				}
			}

			to_bullet = @get_Spider_Ball OBJ_Duplicate(tv_pos)
			@get_RM_Spider_Ball_path to_bullet o_target = to_target
			@get_RM_Spider_Ball_path to_bullet o_sender = o_Rided_Actor
			@get_RM_Spider_Ball_path to_bullet o_sender_2 = OBJ_Me()
			@get_RM_Spider_Ball_path to_bullet i_GFX_Smoke_color = 0x800080
			@get_RM_Spider_Ball_path to_bullet f_life_time = 3.0 * (tf_coef * tf_coef)
			@get_RM_Spider_Ball_path to_bullet f_move_speed = MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet()) + 40.0
			@to_bullet OBJ_BankingGeneralSet(OBJ_SightGet(), OBJ_BankingGet())

		}
		
		f_shoot_duration = 0.0
	}
}

procedure_local void PNJ_Volant_Penching()
{
	float		tf_dot_product
	float		tf_sign
	
	vector	tv_joy_dir
	vector	tv_dir
	vector	tv_pos
	vector	tv_sight
	vector	tv_banking
	vector	tv_quat_aile_gauche	
	vector	tv_quat_aile_droite

	object	to_head
	object	to_bassin
	object	to_aile_gauche
	object	to_aile_droite

	v_IK_ref_ground_pos = OBJ_PosGet()
	v_IK_ref_ground_pos -= OBJ_BankingGet() * OBJ_ZoomGet()

	if (creature_type == Ci_CreatureType_Soucoupe)
	{
		if ( ! OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna))
		{
			tf_dot_product = MATH_VecDotProduct((v_last_pos - OBJ_PosGet()) / TIME_GetDt(), OBJ_HorizonGet())
			tf_dot_product = MATH_FloatLimit(tf_dot_product * 0.25, -Cf_PiBy3, Cf_PiBy3)
			f_speed_angle = MATH_FloatBlend(f_speed_angle, -tf_dot_product, 4.0 * TIME_GetDt())
			
			tv_dir = MATH_VecRotate(OBJ_BankingGet(), OBJ_SightGet(), f_speed_angle)
		
			v_virtual_banking = OBJ_BankingGet()
			
			OBJ_SightGeneralSet(OBJ_SightGet(), tv_dir)	
		}
		else if ( f_no_ground_col_duration > 0.2)
		{
			tv_dir = DYN_SpeedGetVector()	
			tf_dot_product = MATH_VecDotProduct(tv_dir, -OBJ_HorizonGet())
			tf_dot_product *= MATH_FloatBlend(1.0, 0.1, MATH_VecDotProduct(tv_dir, OBJ_SightGet()) * 0.1)
	
			tf_dot_product = MATH_FloatLimit(tf_dot_product, -1.4, 1.4)
	
			f_speed_angle = MATH_FloatBlend(f_speed_angle, -tf_dot_product, 6.0 * TIME_GetDt())
			
			tv_dir = MATH_VecRotate(OBJ_BankingGet(), OBJ_SightGet(), f_speed_angle)
		
			v_virtual_banking = OBJ_BankingGet()
			
			OBJ_SightGeneralSet(OBJ_SightGet(), tv_dir)	
		}
		else
		{
			f_speed_angle = 0.0
		}

		v_last_pos = OBJ_PosGet()

		return	
	}

	if (i_col_flag_on_ground || f_no_ground_col_duration < 0.2)
	{
		to_head = ANI_CanalObjectGet(Anim_Canal_Tete)
		to_bassin = ANI_CanalObjectGet(Anim_Canal_Bassin)
		
		// ACCELERATION => PENCHING
		
		tv_dir = DYN_SpeedGetVector() - v_last_speed
		tv_dir /= TIME_GetDt()
		tf_dot_product = MATH_VecDotProduct(tv_dir, OBJ_HorizonGet())
		tf_dot_product *= 0.02
		
		tf_dot_product = MATH_FloatLimit(tf_dot_product, -0.3, 0.3)
		
		f_speed_angle = MATH_FloatBlend(f_speed_angle, -tf_dot_product, 6.0 * TIME_GetDt())
		//f_speed_angle = IO_JoyGetMove().x * Cf_PiBy3
		
		tv_dir = MATH_VecRotate(OBJ_BankingGet(), OBJ_SightGet(), f_speed_angle)
		
		v_virtual_banking = tv_dir
		
		to_aile_gauche = ANI_CanalObjectGet(Anim_Canal_AvantBrasGauche)
		tv_quat_aile_gauche	= @to_aile_gauche MATH_VecGlobalToLocal(OBJ_BankingGet())

		to_aile_droite = ANI_CanalObjectGet(Anim_Canal_AvantBrasDroit)
		tv_quat_aile_droite = @to_aile_droite MATH_VecGlobalToLocal(OBJ_BankingGet())

		// Rotation autour du bassin
		v_IK_ref_ground_pos = @to_bassin MATH_VecGlobalToLocal(v_IK_ref_ground_pos - @to_bassin OBJ_PosGet())
		@to_bassin OBJ_Rotate_FromTo(@to_bassin MATH_VecGlobalToLocal(OBJ_BankingGet()), @to_bassin MATH_VecGlobalToLocal(tv_dir))
		v_IK_ref_ground_pos = @to_bassin OBJ_PosGet() + @to_bassin MATH_VecLocalToGlobal(v_IK_ref_ground_pos)
		
		@to_aile_gauche OBJ_Rotate_FromTo(tv_quat_aile_gauche, @to_aile_gauche MATH_VecGlobalToLocal(OBJ_BankingGet()))
		@to_aile_droite OBJ_Rotate_FromTo(tv_quat_aile_droite, @to_aile_droite MATH_VecGlobalToLocal(OBJ_BankingGet()))
	}
	else
	{
//		tv_dir = DYN_SpeedGetVector() - v_last_speed
//		tv_dir /= TIME_GetDt()
//		tf_dot_product = MATH_VecDotProduct(tv_dir, OBJ_HorizonGet())
//		tf_dot_product *= 0.02

//		tf_dot_product = MATH_VecDotProduct(-DYN_SpeedGetVector(), OBJ_HorizonGet())
//		tf_dot_product *= 0.1
		
		tv_dir = DYN_SpeedGetVector()	
		tf_dot_product = MATH_VecDotProduct(tv_dir, -OBJ_HorizonGet())
		tf_dot_product *= MATH_FloatBlend(1.0, 0.1, MATH_VecDotProduct(tv_dir, OBJ_SightGet()) * 0.1)

		tf_dot_product = MATH_FloatLimit(tf_dot_product, -1.4, 1.4)

		f_speed_angle = MATH_FloatBlend(f_speed_angle, -tf_dot_product, 6.0 * TIME_GetDt())
		
		tv_dir = MATH_VecRotate(OBJ_BankingGet(), OBJ_SightGet(), f_speed_angle)
	
		v_virtual_banking = OBJ_BankingGet()
		
//		if (MATH_VecDotProduct(@ao_IK_bones[Ci_IK_pied_gauche][3] OBJ_PosGet() - OBJ_PosGet(), OBJ_BankingGet()) < MATH_VecDotProduct(@ao_IK_bones[Ci_IK_pied_droit][3] OBJ_PosGet() - OBJ_PosGet(), OBJ_BankingGet()))
//			v_IK_ref_ground_pos = @ao_IK_bones[Ci_IK_pied_gauche][3] OBJ_PosGet()
//		else
//			v_IK_ref_ground_pos = @ao_IK_bones[Ci_IK_pied_droit][3] OBJ_PosGet()

		OBJ_SightGeneralSet(OBJ_SightGet(), tv_dir)	
	}

	v_last_speed = DYN_SpeedGetVector()
}

procedure_local void PNJ_Volant_Init_IK()
{
	int			ti_i
	int			ti_k
	int			ti_membre_index
	
	o_bassin = ANI_CanalObjectGet(Anim_Canal_Bassin)

	// IK NECK INIT ================================================================================================
	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		switch(ti_i)
		{
			case Ci_IK_pied_gauche :
				ti_membre_index = Anim_Canal_PiedGauche
				ao_IK_bones[ti_i][3] = ANI_CanalObjectGet(Anim_Canal_OrteilGauche)
				break
			case Ci_IK_pied_droit :
				ti_membre_index = Anim_Canal_PiedDroit
				ao_IK_bones[ti_i][3] = ANI_CanalObjectGet(Anim_Canal_OrteilDroit)
				break
//			case Ci_IK_main_gauche :
//				ti_membre_index = Anim_Canal_MainGauche
//				break
//			case Ci_IK_main_droite :
//				ti_membre_index = Anim_Canal_MainDroite
//				break
		}	
	
		for (ti_k = 0; ti_k < 3; ti_k++)
			ao_IK_bones[ti_i][ti_k] = ANI_CanalObjectGet(ti_membre_index + (2 - ti_k))
	
		af_IK_bones_length[ti_i][0] = MATH_VecNorm(@ao_IK_bones[ti_i][1] OBJ_PosGet() - @ao_IK_bones[ti_i][0] OBJ_PosGet())
		af_IK_bones_length[ti_i][1] = MATH_VecNorm(@ao_IK_bones[ti_i][2] OBJ_PosGet() - @ao_IK_bones[ti_i][1] OBJ_PosGet())
		af_IK_bones_length[ti_i][2] = MATH_VecNorm(@ao_IK_bones[ti_i][3] OBJ_PosGet() - @ao_IK_bones[ti_i][2] OBJ_PosGet())	

		f_IK_leg_length[ti_i] = af_IK_bones_length[ti_i][0]
		f_IK_leg_length[ti_i] += af_IK_bones_length[ti_i][1]
		f_IK_leg_length[ti_i] += af_IK_bones_length[ti_i][2]
		f_IK_leg_length[ti_i] *= 1.2
		
		v_IK_ground_normale[ti_i] = Cv_VerticalVector
	}
}

procedure_local void PNJ_Volant_Reset_IK()
{
	int			ti_i	

	// IK LEG
	f_bassin_Z_offset = 0.0

	v_IK_ref_ground_pos = OBJ_PosGet()

	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		i_flag_leg_IK[ti_i] = faux

		f_IK_Z_offset[ti_i] = 0.0
		f_IK_coef[ti_i] = 0.0
		f_IK_ground_coef[ti_i] = 0.0
	}
}

procedure float PNJ_Volant_Angle_After_N_Seconds(byref float tf_rot_speed, float tf_rot_friction, float tf_torque, float tf_time, float tf_exp)
{
	float		tf_A
	float		tf_B
	float		tf_V0
	float		tf_angle

	tf_V0 = tf_rot_speed
	
	if (!tf_exp)
		tf_exp = MATH_Exp(-tf_time * tf_rot_friction)
	
	// CALCUL VITESSE 
	tf_A = tf_torque / tf_rot_friction
	tf_B = (tf_A - tf_V0) * tf_exp
	
	tf_rot_speed = tf_A - tf_B
	
	// CALCUL DEPLACEMENT
	tf_angle = tf_A * tf_time
	tf_angle -= (tf_A - tf_V0) / tf_rot_friction
	tf_angle += tf_B / tf_rot_friction
	
	return(tf_angle)	
}

procedure_local int PNJ_Volant_Get_Rope_Gao(byref vector tv_rope_pos)
{
	object	to_gao	

	float		tf_sqr_rope_length
	float 		tf_rope_length
	float 		tf_rope_ratio

	vector	tv_offset_A
	vector	tv_offset_B
	vector	tv_rope_AB

	to_gao = @o_rope_manager Rope_Manager_Get_Linked_Gao(OBJ_Me(), tf_rope_length, tf_rope_ratio, tv_offset_A, tv_offset_B)
//	@o_rope_manager 	Rope_Manager_Update_Dest_Length

	if (to_gao)
	{
//		EVENT_AddEventLockCam(OBJ_Me(), C_EVENT_LockCamStatus_Fight, cvector(0.0, 0.0, 2.0)) 
	
		if ( tf_rope_ratio == 1.0)
		{
			return(faux)
		}
		else
		{
			tv_rope_pos = @to_gao OBJ_PosGet() + @to_gao MATH_VecLocalToGlobal(tv_offset_B)
		
			tv_rope_AB	 = tv_rope_pos
			tv_rope_AB -= OBJ_PosGet() + MATH_VecLocalToGlobal(tv_offset_A)
		
			tf_sqr_rope_length = tf_rope_length * 0.8
			tf_sqr_rope_length *= tf_sqr_rope_length
			
			if (MATH_VecSquareNorm(tv_rope_AB) > tf_sqr_rope_length)
				return(vrai)
		}
	}
	
	return(faux)
}

procedure_local void PNJ_Volant_Rotation_Speed_Compute()
{
	float			tf_friction
	float			tf_angle

	tf_friction = f_rot_friction
	tf_angle = PNJ_Volant_Angle_After_N_Seconds(f_rot_speed, tf_friction, f_rot_torque, TIME_GetDt(), 0.0)
	if (tf_angle)
		OBJ_RotateGlobalZ(tf_angle)
}



procedure_local void PNJ_Volant_BatProjectile()
{
	vector		tv_pos
	vector		tv_projectile_axis
	vector		tv_axis
	float			tf_norm
	
	if (o_projectile_light)
	{
		if (i_projectile_launched)
		{
			if (f_projectile_speed < 0)
			{
				// Retour

				// Gestion test retour sur le Bat
				tv_projectile_axis = @o_projectile_light OBJ_PosGet() - (OBJ_PosGet() + cvector(0,0,1))
				if (f_projectile_speed < -2.0 && MATH_VecDotProduct(v_projectile_axis,tv_projectile_axis)<0)
				{
					// Retour du Projectile
					i_projectile_launched = faux
					tv_pos = OBJ_PosGet() + cvector(0,0,1)
				}
				else
					v_projectile_axis = MATH_VecNormalize(tv_projectile_axis)
			}
			if (i_projectile_launched)
			{
				// Deplacement + Speed
				tv_pos = @o_projectile_light OBJ_PosGet() + ((v_projectile_axis * f_projectile_speed) * TIME_GetDt())
				f_projectile_speed = MATH_FloatMax(f_projectile_speed - (35.0 * TIME_GetDt()), -40.0  )
			}
			if (f_projectile_speed>0)
			{
				// Aller

				// Gestion Collision Obstacle
				tv_axis = tv_pos - v_projectile_pos_old
				tf_norm = MATH_VecNorm(tv_pos - v_projectile_pos_old)
				tv_axis /= tf_norm
				COL_SpecificCrossableSet(Gmat_RM_Crossable_Default | Gmat_RM_Crossable_Grappin)
				if (COL_RayIsCut_Dist(v_projectile_pos_old, tv_axis, tf_norm, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet))
				{
					// Obstacle, je retourne vers la Bat
					f_projectile_speed = 0
					tv_pos = @o_projectile_light OBJ_PosGet()
				}
			}	
			@o_projectile_light OBJ_PosSet(tv_pos)
		}
		else
		{
			@o_projectile_light OBJ_PosSet( OBJ_PosGet() + cvector(0,0,1) )		// Light sur la Bat
			if (o_Rided_Actor && IO_ButtonJustPressed(RM_Joy_Punch))
			{
				// Je lance le Projectile
				i_projectile_launched = vrai
				f_projectile_speed = 40.0
				v_projectile_axis = OBJ_SightGet()
			}
		}
		v_projectile_pos_old = @o_projectile_light OBJ_PosGet()
	}
}

procedure_local void PNJ_Volant_Select_Action(byref vector tv_traction)
{
	float		tf_flap_duration
	float		tf_action_speed_coef
	float		tf_action_speed

	vector	tv_X

	if (creature_type == Ci_CreatureType_Soucoupe) 
	{
		if ( i_col_flag_on_ground )
		{
			// AU SOL

			if ( ! o_Rided_Actor )
			{
				// RIEN
			}
			else if (Proc_JOY_Boost_Pressed())
			{
				tv_traction += OBJ_SightGet() * f_air_speed_R2 * DYN_FrictionVectorGet().y
			}
			else if (glob_joynorm_get)
			{
				tv_traction += OBJ_SightGet() * f_air_speed_R2 * DYN_FrictionVectorGet().y
			}
		}
		else 
		{
			// EN L'AIR

			if ( ! o_Rided_Actor )
			{
				// RIEN
			}
			else if (Proc_JOY_Boost_Pressed() && o_Rided_Actor)
			{
				tv_traction += OBJ_SightGet() * f_air_speed_R2 * DYN_FrictionVectorGet().y
			}
		}
		
		return
	}

	if ( ! ACT_ActionFinished() )
	{	
		switch(ACT_ActionGet())
		{
			case Action_Attaque :
			case Action_Atterrissage :
				return
				break
		}	
	}


	if (i_flag_landing)
	{
		ACT_ActionSet(Action_Atterrissage)
	}
	else if (i_etat_courant == ETAT_Alone)
	{
		if ( ! i_col_flag_on_ground ) 
		{
			tf_flap_duration = ACT_LIB_ActionDurationGet(1)
		
			if (i_flag_boost || (f_flap_duration && f_flap_duration < tf_flap_duration * 0.7))
			{
				// BAT DES AILES
				if (f_no_ground_col_duration < 0.2)
					ACT_ActionSet(Action_Vole_Sol)
				else
					ACT_ActionSet(Action_Vole)
	
				// Flap Flap
				f_flap_duration += TIME_GetDt() 
				if (f_flap_duration > tf_flap_duration)
					f_flap_duration -= tf_flap_duration 
	
				if (i_monture_ID == C_ID_Monture_Bat)
				{
					f_wing_speedratio = MATH_FloatBlend(f_wing_speedratio, 2.0, 6.0 * TIME_GetDt())
					ACT_LIB_ActionFrequencyMultiply(f_wing_speedratio) 
				}
		
				tv_traction += OBJ_SightGet() * (f_air_speed_R2 * ((1.0 + MATH_Sin(ANI_RatioGet(0) * Cf_Pi)) * 0.5)) * DYN_FrictionVectorGet().y
			}
			else
			{
				// PLANE
				if (f_no_ground_col_duration < 0.2)
					ACT_ActionSet(Action_Vole_Sol)
				else
					ACT_ActionSet(Action_Plane)
			}
		}
		else
		{
			// AU SOL
			f_flap_duration = 0.001
		
			if (i_flag_boost)
			{
				tf_action_speed_coef = MATH_FloatMax(MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet()), 0.0)
				tv_traction += OBJ_SightGet() * f_action_marche_speed * DYN_FrictionVectorGet().y
				if (i_monture_ID == C_ID_Monture_Bat)
					f_wing_speedratio = MATH_FloatBlend(f_wing_speedratio, 2.0, 2.0 * TIME_GetDt())
			}
			else
			{
				tf_action_speed_coef = 0.0
			}
	
			if (tf_action_speed_coef < 0.4)
			{
				// STOP
				if (o_grab_actor)
					ACT_ActionSet(Action_Plane)
				else
					ACT_ActionSet(Action_Pose)
			}
			else
			{
				// MARCHE
				if (o_grab_actor)
				{
					if (f_no_ground_col_duration < 0.2)
						ACT_ActionSet(Action_Vole_Sol)
					else
						ACT_ActionSet(Action_Vole)
				}
				else
				{
					ACT_ActionSet(Action_Marche)	
					tf_action_speed_coef /= f_action_marche_speed
					ACT_LIB_ActionFrequencyMultiply(tf_action_speed_coef)
				}
			}
		}
	}
	else if (o_Rided_Actor) 
	{
		if ( ! i_col_flag_on_ground )
		{
			tf_flap_duration = ACT_LIB_ActionDurationGet(1)
		
			// EN L'AIR
			if ( (IO_ButtonJustPressed(RM_Monture_Button_Action1) || IO_ButtonJustPressed(RM_Monture_Button_Action2)) && ! o_grab_actor )
			{
				if (ACT_ActionGet()!= Action_Attaque)
					SND_RequestPlay(Ci_Aigle_SND_CriGrab)
				ACT_ActionSet(Action_Attaque)
			}
			else if (Proc_JOY_Boost_Pressed() || (f_flap_duration && f_flap_duration < tf_flap_duration * 0.7))
			{
				// BAT DES AILES
				if (f_no_ground_col_duration < 0.2)
					ACT_ActionSet(Action_Vole_Sol)
				else
					ACT_ActionSet(Action_Vole)
	
				// Flap Flap
				f_flap_duration += TIME_GetDt() 
				if (f_flap_duration > tf_flap_duration)
					f_flap_duration -= tf_flap_duration 
	
				if (i_monture_ID == C_ID_Monture_Bat)
				{
					if (Proc_JOY_Boost_Pressed())
						f_wing_speedratio = MATH_FloatBlend(f_wing_speedratio, 2.0, 6.0 * TIME_GetDt())
					else
						f_wing_speedratio = MATH_FloatBlend(f_wing_speedratio, 0.9, 6.0 * TIME_GetDt())
					ACT_LIB_ActionFrequencyMultiply(f_wing_speedratio) 
				}
	
				// Traction Uniquement si on appuie sur le Bouton	
				if (Proc_JOY_Boost_Pressed())
					tv_traction += OBJ_SightGet() * (f_air_speed_R2 * ((1.0 + MATH_Sin(ANI_RatioGet(0) * Cf_Pi)) * 0.5)) * DYN_FrictionVectorGet().y
			}
			else
			{
				// PLANE
				if (i_monture_ID == C_ID_Monture_Bat)
				{
					ACT_ActionSet(Action_Vole)
					f_wing_speedratio = MATH_FloatBlend(f_wing_speedratio, 0.9, 6.0 * TIME_GetDt())
					ACT_LIB_ActionFrequencyMultiply(f_wing_speedratio) 
				}
				else
				{
					if (f_no_ground_col_duration < 0.2)
						ACT_ActionSet(Action_Vole_Sol)
					else
						ACT_ActionSet(Action_Plane)
				}
				
				f_flap_duration = 0.0
			}
		}
		else
		{
			// AU SOL
			f_flap_duration = 0.001
		
			tf_action_speed_coef = MATH_FloatMax(MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet()), 0.0)
			
			if (Proc_JOY_Boost_Pressed())
			{
				tv_traction += OBJ_SightGet() * f_action_marche_speed * DYN_FrictionVectorGet().y
				if (i_monture_ID == C_ID_Monture_Bat)
					f_wing_speedratio = MATH_FloatBlend(f_wing_speedratio, 2.0, 2.0 * TIME_GetDt())
			}
			else if (glob_joynorm_get)
			{
//				tv_traction += OBJ_SightGet() * f_ground_speed_Joy * DYN_FrictionVectorGet().y * glob_joynorm_get
				tv_traction += OBJ_SightGet() * f_action_marche_speed * DYN_FrictionVectorGet().y
			}
	
			if (tf_action_speed_coef < 0.4)
			{
				// STOP
				if (o_grab_actor)
					ACT_ActionSet(Action_Plane)
				else
					ACT_ActionSet(Action_Pose)
			}
			else
			{
				// MARCHE
				if (o_grab_actor)
					ACT_ActionSet(Action_Vole)
				else
				{
					ACT_ActionSet(Action_Marche)	
					tf_action_speed_coef /= f_action_marche_speed
					ACT_LIB_ActionFrequencyMultiply(tf_action_speed_coef)
				}
			}
		}
	}
	else
	{
		if ( ! i_col_flag_on_ground )		
			ACT_ActionSet(Action_Plane)
		else
			ACT_ActionSet(Action_Pose)
	}
}


procedure_local void PNJ_Volant_SND_EnVol()
{
	// SND ================================================
	if (i_snd_vol1 == -1) 
	{
		i_snd_vol1 = SND_RequestPlayLoop(Ci_Aigle_SND_Vol1)
		SND_RequestPlay(Ci_Aigle_SND_TakeOff)
	}
	if (i_snd_vol2 == -1) 
		i_snd_vol2 = SND_RequestPlayLoop(Ci_Aigle_SND_Vol2)
	if (i_snd_vol3 == -1) 
		i_snd_vol3 = SND_RequestPlayLoop(Ci_Aigle_SND_Vol3)
	if (i_snd_vol4 == -1) 
		i_snd_vol4 = SND_RequestPlayLoop(Ci_Aigle_SND_Vol4)
	// SND ===============================================

	f_snd_crivol -= TIME_GetDt()
	if (f_snd_crivol <= 0.0)
	{
		SND_RequestPlay(Ci_Aigle_SND_CriVol)
		f_snd_crivol = MATH_RandFloat(6.0,15.0)
	}
}

procedure_local void PNJ_Volant_SND_AuSol()
{
	// SND ================================================
	f_snd_crivol = MATH_RandFloat(6.0,15.0)

	if (i_snd_vol1 != -1) 
	{
		SND_Stop(i_snd_vol1)
		i_snd_vol1 = -1
	}
	if (i_snd_vol2 != -1) 
	{
		SND_Stop(i_snd_vol2)
		i_snd_vol2 = -1
	}
	if (i_snd_vol3 != -1) 
	{
		SND_Stop(i_snd_vol3)
		i_snd_vol3 = -1
	}
	if (i_snd_vol4 != -1) 
	{
		SND_Stop(i_snd_vol4)
		i_snd_vol4 = -1
	}
	// SND ===============================================
}

procedure_local void PNJ_Volant_Clean_GFX()
{
}

procedure_local void PNJ_Volant_Clean_Sound()
{
	if (i_snd_vol1 != -1)
	{
		SND_Destroy(i_snd_vol1)
		i_snd_vol1 = -1
	}

	if (i_snd_vol2 != -1)
	{
		SND_Destroy(i_snd_vol2)
		i_snd_vol2 = -1
	}

	if (i_snd_vol3 != -1)
	{
		SND_Destroy(i_snd_vol3)
		i_snd_vol3 = -1
	}

	if (i_snd_vol4 != -1)
	{
		SND_Destroy(i_snd_vol4)
		i_snd_vol4 = -1
	}
}