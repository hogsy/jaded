#include "Splinter_Bunny_defines.var"

procedure_local void Splinter_Bunny_Seg_Display(int ti_index)
{
	int		ti_i
	int		ti_offset	

	float	tf_coef
	float	tf_step

	vector	tv_pos
	vector	tv_next_pos
	vector	tv_A
	vector	tv_B
	vector	tv_C
	vector	tv_D
	vector	tv_sight

	tv_A = av_modules_pos[ti_index]
	tv_B = tv_A

	if (ti_index)
		tv_B += (av_modules_pos[ti_index + 1] - av_modules_pos[ti_index - 1]) * 0.2
	else
		tv_B += (av_modules_pos[ti_index + 1] - av_modules_pos[ti_index]) * 0.2

	tv_D = av_modules_pos[ti_index + 1]
	tv_C = tv_D

	if (ti_index < Ci_modules_nb - 2)
		tv_C += (av_modules_pos[ti_index] - av_modules_pos[ti_index + 2]) * 0.2
	else
		tv_C += (av_modules_pos[ti_index] - av_modules_pos[ti_index + 1]) * 0.2

	DBG_RenderVector(tv_A, tv_B - tv_A, color_rouge)
	DBG_RenderVector(tv_B, tv_C - tv_B, color_vert)
	DBG_RenderVector(tv_C, tv_D - tv_C, color_bleu)
	DBG_RenderVector(tv_A, tv_D - tv_A, color_cyan)

	ti_offset = ti_index * Ci_sub_segment_nb

	tf_step = 1.0 / Ci_sub_segment_nb
	tf_coef = tf_step
	tv_pos = tv_A

	for (ti_i = 0; ti_i < Ci_sub_segment_nb - 1; ti_i++)
	{
		tv_next_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_A, tv_B, tv_C, tv_D, tv_sight)
	
		GFX_Setv(ai_modules_line[ti_offset + ti_i], 1200, tv_pos)		// Coordonnée de la position 3D du début du faisceau	
		GFX_Setv(ai_modules_line[ti_offset + ti_i], 1201, tv_next_pos)		// Coordonnée de la position 3D de la fin du faisceau

		tv_pos = tv_next_pos
		tf_coef += tf_step
	}

	GFX_Setv(ai_modules_line[ti_offset + ti_i], 1200, tv_next_pos)		// Coordonnée de la position 3D du début du faisceau	
	GFX_Setv(ai_modules_line[ti_offset + ti_i], 1201, tv_D)		// Coordonnée de la position 3D de la fin du faisceau
}

procedure_local void Splinter_Bunny_Display()
{
	int		ti_i	
	int		tc_color

	for (ti_i = 0; ti_i < Ci_modules_nb - 1; ti_i++)
	{
		Splinter_Bunny_Seg_Display(ti_i)
		ti_i = ti_i

//		GFX_Setv(ai_modules_line[ti_i], 1200, av_modules_pos[ti_i])		// Coordonnée de la position 3D du début du faisceau	
//		GFX_Setv(ai_modules_line[ti_i], 1201, av_modules_pos[ti_i + 1])		// Coordonnée de la position 3D de la fin du faisceau
	}

	if (i_flag_on_ground)
	{	
		tc_color = COLOR_Blend(0xFFFFFFFF, 0, f_time_start_etat / 3.0)
		for (ti_i = 0; ti_i < Ci_line_nb; ti_i++)
			GFX_Seti(ai_modules_line[ti_i], 1100, tc_color)		// Couleur de la ligne
	}

	return
}

procedure_local void Splinter_Bunny_Init_Rope()
{
	int		ti_i
	int		ti_k

	vector	tv_pos
	vector		tv_min
	vector		tv_max

	f_gravity = -20.0

	ai_modules_locked[0] = vrai
	COL_RayObject_Dist(OBJ_PosGet(), -OBJ_BankingGet(), 1000.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
	v_ground_pos = COL_RayObject_PosGet()
	v_ground_normal = COL_RayObject_NormalGet()
//	v_ground_normal  = Cv_VerticalVector
	DBG_RenderVector(OBJ_PosGet(), v_ground_pos - OBJ_PosGet(), color_cyan)
	DBG_RenderVector(v_ground_pos, v_ground_normal * 5.0, color_bleu)

	f_rope_length = MATH_VecNorm(v_ground_pos - OBJ_PosGet())
	f_speed = f_rope_length / 2.0	
	f_speed *= MATH_RandFloat(0.8, 1.2)
	f_rope_length = MATH_FloatMax(f_rope_length * 1.3, 15.0)

	f_segment_length = f_rope_length / Ci_modules_nb

	for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
	{
		av_modules_pos[ti_i] = OBJ_PosGet()
		av_modules_pos[ti_i] -= OBJ_BankingGet() * (ti_i * 0.1)
		if (OBJ_CapaTest(OBJ_Capa_0))
			av_modules_pos[ti_i] += OBJ_SightGet() * (ti_i * 0.1)
		else
			av_modules_pos[ti_i] -= OBJ_SightGet() * (ti_i * 0.1)

		if (ti_i)
		{
			if (MATH_Modulo(ti_i, 2))
				av_modules_pos[ti_i] += OBJ_HorizonGet() * 0.5
			else
				av_modules_pos[ti_i] -= OBJ_HorizonGet() * 0.5
		}
		if (OBJ_CapaTest(OBJ_Capa_0))
			av_modules_speed[ti_i]	= OBJ_SightGet() * (ti_i * 0.1)
		else
			av_modules_speed[ti_i]	= -OBJ_SightGet() * (ti_i * 0.3)
		av_modules_speed[ti_i].z += MATH_RandFloat(-2.0, 2.0)
	}

	for (ti_i = 0; ti_i < Ci_line_nb; ti_i++)
	{
		ai_modules_line[ti_i] = GFX_Add(1)		// Ligne
		GFX_FlagSet(ai_modules_line[ti_i] , 0, 1)
		GFX_FlagSet(ai_modules_line[ti_i], 2, 1)
		GFX_MaterialSet(ai_modules_line[ti_i], get_SFX_light_and_smoke, 49)
		GFX_Setf(ai_modules_line[ti_i], 1000, 0.1)		// Epaisseur de la ligne
		GFX_Seti(ai_modules_line[ti_i], 1100, 0xFFFFFFFF)		// Couleur de la ligne
	}

	return
}

procedure_local void Splinter_Bunny_Compute_Module_Speed(float tf_dt)
{
	int				ti_i
	int				ti_k

	float			tf_friction
	float			tf_exp

	vector		tv_A
	vector		tv_B
	vector		tv_move

	tf_friction = 40.0
	tf_exp = MATH_Exp(-tf_dt * tf_friction)

	for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
	{
		if (ai_modules_locked[ti_i])
		{
			av_modules_speed[ti_i] = Cv_NullVector
			continue
		}	
		
		if (MATH_VecDotProduct(av_modules_pos[ti_i] - v_ground_pos, v_ground_normal) < 0.3)
		{
			if (i_flag_on_ground)
			{
			}
			else
			{
				tv_A = cvector(0.0, 0.0, -20.0 / tf_friction) 
				tv_B = (tv_A - av_modules_speed[ti_i]) * tf_exp
		
				tv_move = tv_A * tf_dt
				tv_move -= (tv_A - av_modules_speed[ti_i]) / tf_friction
				tv_move += tv_B / tf_friction
				
				av_modules_pos[ti_i] += tv_move
				av_modules_speed[ti_i] = tv_A - tv_B
			}
		}
		else
		{
//			if (ti_i != i_rided_module_index)
			if (ti_i > i_rided_module_index)
				av_modules_speed[ti_i].z += f_gravity * tf_dt
			else
				av_modules_speed[ti_i].z += 60.0 * f_gravity * tf_dt

			av_modules_pos[ti_i] += av_modules_speed[ti_i] * tf_dt
		}
		
		if ( OBJ_CapaTest(OBJ_Capa_0) )
		{
			// CORDE LIBRE
		}
		else
		{
			av_modules_pos[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(av_modules_pos[ti_i] - OBJ_PosGet(), -OBJ_SightGet()), 0.0) * -OBJ_SightGet()
		}

		av_modules_pos[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(av_modules_pos[ti_i] - v_ground_pos, v_ground_normal), 0.0) * v_ground_normal
	}
}

procedure_local void Splinter_Bunny_Renormalisation(int ti_iteration_nb)
{
	int			ti_i
	int			ti_k

	float		tf_norm
	float		tf_temp

	vector	tv_temp
	vector	tav_renormalisation[Ci_modules_nb]

	// LES POINTS ONT BOUGE
	Splinter_Bunny_Compute_Module_Speed(f_dt)		

	for (ti_k = 0; ti_k < ti_iteration_nb; ti_k++)
	{
//		Splinter_Bunny_Compute_Module_Speed(f_dt / ti_iteration_nb)	
	
		tav_renormalisation[0] = Cv_NullVector

		for (ti_i = 1; ti_i < Ci_modules_nb; ti_i++)
		{
			tav_renormalisation[ti_i] = Cv_NullVector		

			tv_temp = av_modules_pos[ti_i - 1] - av_modules_pos[ti_i]
			tf_norm = MATH_VecSquareNorm(tv_temp)
			if (tf_norm > 0.001)
			{
				tf_norm = MATH_FloatSqrt(tf_norm)
				tv_temp /= tf_norm
				tf_norm -= f_segment_length
				tv_temp *= tf_norm
			}
			else
			{
				tv_temp = -Cv_VerticalVector
				tv_temp *= f_segment_length
			}

			tav_renormalisation[ti_i - 1] -= tv_temp * 0.5
			tav_renormalisation[ti_i] += tv_temp * 0.5
		}
	
		for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
		{
			if ( ! ai_modules_locked[ti_i] )
			{
//				tav_renormalisation[ti_i] -= MATH_FloatMin(MATH_VecDotProduct(tav_renormalisation[ti_i], av_modules_normal[ti_i]), 0.0) * av_modules_normal[ti_i]
				av_modules_pos[ti_i] += tav_renormalisation[ti_i]
			}
		}
		
//		Splinter_Bunny_Display(color_bleu)
	}
		
	return
}


procedure_local void Splinter_Bunny_Rag_Doll()
{
	int			ti_i

	float		tf_dt
	float		tf_inv_dt

	vector	tav_modules_last_pos[Ci_modules_nb]	

	tf_dt = f_dt
	tf_inv_dt = 1.0 / tf_dt

	for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
		tav_modules_last_pos[ti_i] = av_modules_pos[ti_i]

	Splinter_Bunny_Renormalisation(10)

	// CALCUL DES SPEED
	for (ti_i = 1; ti_i < Ci_modules_nb; ti_i++)
	{
		av_modules_speed[ti_i] = av_modules_pos[ti_i] - tav_modules_last_pos[ti_i]
		av_modules_speed[ti_i] *= tf_inv_dt
	}

	return
}



