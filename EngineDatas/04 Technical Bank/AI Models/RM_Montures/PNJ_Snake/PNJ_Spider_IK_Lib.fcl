#include "PNJ_Snake_defines.var"

#define Cf_offset_min						-100.0
#define Cf_offset_max						100.0
#define Cf_walk_Z_blend_speed			12.0

#define Ci_bone_pos_index				2

procedure_local void PNJ_Spider_Init_IK()
{
	int			ti_i
	int			ti_k
	int			ti_membre_index
	
	object	to_obj
	
	o_bassin = ANI_CanalObjectGet(Anim_Canal_Cou)

	switch(creature_type)
	{
		case Ci_CreatureType_Spider :
		
			i_leg_nb = 8

			for (ti_i = 0; ti_i < i_leg_nb; ti_i++)
			{
				switch(ti_i)
				{
					case 0 :
						to_obj = ANI_CanalObjectGet(47)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(46)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 1 :
						to_obj = ANI_CanalObjectGet(27)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(26)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 2 :
						to_obj = ANI_CanalObjectGet(45)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(44)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 3 :
						to_obj = ANI_CanalObjectGet(25)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(24)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 4 :
						to_obj = ANI_CanalObjectGet(43)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(42)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 5 :
						to_obj = ANI_CanalObjectGet(23)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(22)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 6 :
						to_obj = ANI_CanalObjectGet(41)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(40)
						ao_IK_bones[ti_i][1] = to_obj
						break
					case 7 :
						to_obj = ANI_CanalObjectGet(21)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(20)
						ao_IK_bones[ti_i][1] = to_obj
						break
				}	
			
				f_IK_ground_coef[ti_i] = MATH_RandFloat(0.0, 1.0)	
		
		//		v_IK_ground_normale[ti_i] = Cv_VerticalVector
		//		v_IK_last_dest_quat[ti_i] = Cv_VerticalVector
		
				ao_IK_ground_actor[ti_i] = OBJ_Me()
				v_IK_ground_normale[ti_i] = @ao_IK_ground_actor[ti_i] MATH_VecGlobalToLocal(Cv_VerticalVector)
				v_IK_last_dest_quat[ti_i] = @ao_IK_ground_actor[ti_i] MATH_VecGlobalToLocal(Cv_VerticalVector)
			}

			break
			
		case Ci_CreatureType_Quadri :
		
			i_leg_nb = 4

			for (ti_i = 0; ti_i < i_leg_nb; ti_i++)
			{
				switch(ti_i)
				{
					case 0 :
						to_obj = ANI_CanalObjectGet(82)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(81)
						ao_IK_bones[ti_i][1] = to_obj
						to_obj = ANI_CanalObjectGet(80)
						ao_IK_bones[ti_i][2] = to_obj
						break
					case 1 :
						to_obj = ANI_CanalObjectGet(62)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(61)
						ao_IK_bones[ti_i][1] = to_obj
						to_obj = ANI_CanalObjectGet(60)
						ao_IK_bones[ti_i][2] = to_obj
						break
					case 2 :
						to_obj = ANI_CanalObjectGet(42)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(41)
						ao_IK_bones[ti_i][1] = to_obj
						to_obj = ANI_CanalObjectGet(40)
						ao_IK_bones[ti_i][2] = to_obj
						break
					case 3 :
						to_obj = ANI_CanalObjectGet(22)
						ao_IK_bones[ti_i][0] = to_obj
						to_obj = ANI_CanalObjectGet(21)
						ao_IK_bones[ti_i][1] = to_obj
						to_obj = ANI_CanalObjectGet(20)
						ao_IK_bones[ti_i][2] = to_obj
						break
				}	
			
				f_IK_ground_coef[ti_i] = MATH_RandFloat(0.0, 1.0)	
		
		//		v_IK_ground_normale[ti_i] = Cv_VerticalVector
		//		v_IK_last_dest_quat[ti_i] = Cv_VerticalVector
		
				ao_IK_ground_actor[ti_i] = OBJ_Me()
				v_IK_ground_normale[ti_i] = @ao_IK_ground_actor[ti_i] MATH_VecGlobalToLocal(Cv_VerticalVector)
				v_IK_last_dest_quat[ti_i] = @ao_IK_ground_actor[ti_i] MATH_VecGlobalToLocal(Cv_VerticalVector)
			}
			break
	}

}

procedure_local void PNJ_Spider_Reset_IK()
{
	int			ti_i	

	// IK LEG
	f_bassin_Z_offset = 0.0

	v_IK_ref_ground_pos = OBJ_PosGet()

	for (ti_i = 0; ti_i < i_leg_nb; ti_i++)
	{
		i_flag_leg_IK[ti_i] = faux

		f_IK_coef[ti_i] = 0.0
		f_IK_ground_coef[ti_i] = 0.0
	}
}


procedure_local void PNJ_Spider_IK()
{
	int			ti_i
	int			ti_k
	int			ti_frame_num
	int			ti_flag_ok
	int			ti_action
	
	float		tf_angle
	float		tf_offset
	float		tf_bassin_offset
	float		tf_bassin_offset_min
	float		tf_bassin_offset_max
	float		tf_norm
	float		tf_coef
	float		tf_IK_coef
	float		tf_ray_start_offset
	float		tf_dot_product
	float		tf_ray_length
	float		tf_A
	float		tf_B
	float		tf_C
	
	vector	tv_pied_pos
	vector	tv_collide_pos
	vector	tv_ray_start
	vector	tv_ray_dir
	vector	tv_start_axis
	vector	tv_dest_axis
	vector	tv_ray_normale
	vector	tv_bassin_dest_pos
	vector	tv_rot_pivot_pos
	vector	tv_temp	

	object	to_target
	object	to_bone
	object	to_obj
	
	//vector	tv_queue_banking
	//object	to_queue
	
	//v_IK_ref_ground_pos = OBJ_PosGet()
	
	tf_coef = OBJ_LodVisGet() 
	if (tf_coef < 0.1 && o_Rided_Actor != o_main_actor)
	{
		PNJ_Spider_Reset_IK()
	//	DBG_RenderVector(OBJ_PosGet(), Cv_VerticalVector * 100.0, color_blanc)
		return
	}
	
//	@o_bassin OBJ_PosSet(OBJ_PosGet())

	v_IK_ref_ground_pos = OBJ_PosGet()
	v_IK_ref_ground_pos -= OBJ_BankingGet() * f_size_coef * 0.6
	
	DBG_RenderVector(v_IK_ref_ground_pos, Cv_VerticalVector, color_jaune)	
	
	//to_queue = ANI_CanalObjectGet(Anim_Canal_Queue)
	//tv_queue_banking = @to_queue OBJ_BankingGet()
	
	tf_ray_start_offset = 0.0
	
	i_ik_ray_index = MATH_Modulo(i_ik_ray_index + 1, i_leg_nb)

	// EST-CE QU'ON S'ADAPTE AU RELIEF DU SOL ??? =============================================================
	tf_bassin_offset = 0.0
	
	ti_action = ACT_ActionGet()
	
	tf_coef = DYN_SpeedGet()
	
	for (ti_i = 0; ti_i < i_leg_nb; ti_i++)
	{
		i_flag_leg_IK[ti_i]	= vrai
	
		if (! i_flag_leg_IK[ti_i] && ! f_IK_coef[ti_i])
			continue
	
		tv_ray_dir = -OBJ_BankingGet()

		if ( ! ti_i )
			tv_temp = cvector(0.0, 0.0, 1.0) * f_size_coef
		else if ( ti_i == 1 )
			tv_temp = cvector(0.0, 0.0, 1.0) * f_size_coef
		else if (ti_i == 2)
			tv_temp = cvector(0.0, 0.0, 1.0) * f_size_coef
		else if (ti_i == 3)
			tv_temp = cvector(0.0, 0.0, 1.0) * f_size_coef
		else if (ti_i == 4)
			tv_temp = cvector(0.0, 0.0, 1.1) * f_size_coef
		else if (ti_i == 5)
			tv_temp = cvector(0.0, 0.0, 1.1) * f_size_coef
		else if (ti_i == 6)
			tv_temp = cvector(0.0, 0.0, 1.2) * f_size_coef
		else
			tv_temp = cvector(0.0, 0.0, 1.2) * f_size_coef

//		f_IK_ground_coef[ti_i] = (1.0 + MATH_Sin(TIME_Get() * 4.0)) * 0.5

		@ao_IK_bones[ti_i][1] OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), MATH_VecBlendRotate(cvector(0.0, 0.0, 1.0), - @ao_IK_bones[ti_i][1] MATH_VecGlobalToLocal(@ao_IK_bones[ti_i][0] OBJ_BankingGet()), (1.0 - f_IK_ground_coef[ti_i]) * 0.6))

		tv_pied_pos = @ao_IK_bones[ti_i][1] OBJ_PosGet()
		tv_pied_pos += @ao_IK_bones[ti_i][1] MATH_VecLocalToGlobal(tv_temp)
		tv_pied_pos -= MATH_VecDotProduct(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), @ao_IK_bones[ti_i][0] OBJ_HorizonGet()) * @ao_IK_bones[ti_i][0] OBJ_HorizonGet()
		tv_pied_pos -= MATH_FloatMax(MATH_VecDotProduct(tv_pied_pos - v_IK_ref_ground_pos, OBJ_BankingGet()), 0.0) * OBJ_BankingGet()
//		DBG_RenderVector(@ao_IK_bones[ti_i][1] OBJ_PosGet(), tv_pied_pos - @ao_IK_bones[ti_i][1] OBJ_PosGet(), color_blanc)
		
		if (0 || ti_i == i_ik_ray_index)
		{
			tv_ray_dir = tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet()
			tv_ray_dir = MATH_VecCrossProduct(@ao_IK_bones[ti_i][0] OBJ_HorizonGet(), tv_ray_dir)
//			tv_ray_dir = MATH_VecBlendRotate(MATH_VecCrossProduct(@ao_IK_bones[ti_i][0] OBJ_HorizonGet(), tv_ray_dir), tv_ray_dir, f_IK_ground_coef[ti_i])
			MATH_VecSetNormalize(tv_ray_dir)

			tv_ray_start = tv_pied_pos
			tv_ray_start -= tv_ray_dir * f_size_coef * 2.0

			tf_ray_length = 4.0 * f_size_coef
	
			to_obj = COL_RayObject_Dist(tv_ray_start, tv_ray_dir, tf_ray_length, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			if (to_obj)
			{
				// OK ON TOUCHE UN SOL, ON VA POUVOIR POSITIONNER EN IK ==============================================
				i_flag_IK_col[ti_i]	= vrai
	
				tv_collide_pos = COL_RayObject_PosGet()
				tv_ray_normale = COL_RayObject_NormalGet()
		
//				DBG_RenderVector(tv_ray_start, tv_collide_pos - tv_ray_start, color_vert)
//				DBG_RenderVector(tv_collide_pos, tv_ray_normale * 0.5, color_jaune)
//
//				v_IK_ground_pos[ti_i] = tv_collide_pos
//				v_IK_ground_normale[ti_i]	= tv_ray_normale

				ao_IK_ground_actor[ti_i] = to_obj
				v_IK_ground_pos[ti_i] = @to_obj MATH_VecGlobalToLocal(tv_collide_pos - @to_obj OBJ_PosGet())
				v_IK_ground_normale[ti_i]	= @to_obj MATH_VecGlobalToLocal(tv_ray_normale)
			}
			else
			{
				i_flag_IK_col[ti_i]	= faux
	
//				DBG_RenderVector(tv_ray_start, tv_ray_dir * tf_ray_length, color_rouge)

//				tv_collide_pos = v_IK_ground_pos[ti_i]
//
//				tv_temp = OBJ_HorizonGet() * MATH_FloatSign(MATH_VecDotProduct(tv_pied_pos - OBJ_PosGet(), OBJ_HorizonGet()))
//				v_IK_ground_normale[ti_i]	= MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_temp, 2.0 * TIME_GetDt())
//
//				tv_ray_normale = v_IK_ground_normale[ti_i]

				tv_temp = @ao_IK_ground_actor[ti_i] MATH_VecGlobalToLocal(OBJ_HorizonGet() * MATH_FloatSign(MATH_VecDotProduct(tv_pied_pos - OBJ_PosGet(), OBJ_HorizonGet())))
				v_IK_ground_normale[ti_i]	= MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_temp, 2.0 * TIME_GetDt())

				tv_collide_pos = @ao_IK_ground_actor[ti_i] OBJ_PosGet() + @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_pos[ti_i])
				tv_ray_normale = @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_normale[ti_i])
			}
		}
		else
		{
//			tv_collide_pos = v_IK_ground_pos[ti_i]
//			tv_ray_normale = v_IK_ground_normale[ti_i]

			tv_collide_pos = @ao_IK_ground_actor[ti_i] OBJ_PosGet() + @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_pos[ti_i])
			tv_ray_normale = @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_normale[ti_i])
		}

//		DBG_RenderVector(tv_collide_pos, tv_ray_normale * 5.0, color_bleu)			

		tv_dest_axis = v_IK_last_dest_quat[ti_i]

		tv_ray_normale -= MATH_VecDotProduct(tv_ray_normale, @ao_IK_bones[ti_i][0] OBJ_HorizonGet()) * @ao_IK_bones[ti_i][0] OBJ_HorizonGet()
		tf_norm = MATH_VecSquareNorm(tv_ray_normale)
		if (tf_norm)
		{
			tv_ray_normale /= MATH_FloatSqrt(tf_norm)

//			DBG_RenderVector(tv_collide_pos, tv_ray_normale * 5.0, color_bleu)			

			tv_temp = tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet()
			tf_C = MATH_VecNorm(tv_temp)
			tf_A = MATH_VecDotProduct(@ao_IK_bones[ti_i][0] OBJ_PosGet() - tv_collide_pos, tv_ray_normale)
			tf_B = tf_C * tf_C
			tf_B -= tf_A * tf_A
			if (tf_B > 0.0)
			{
				tf_B = MATH_FloatSqrt( tf_B)
	
				tv_temp -= MATH_VecDotProduct(tv_temp, tv_ray_normale) * tv_ray_normale
				MATH_VecSetNormalize(tv_temp)
				
				tv_collide_pos = @ao_IK_bones[ti_i][0] OBJ_PosGet()
				tv_collide_pos -= tf_A * tv_ray_normale
				tv_collide_pos += tf_B * tv_temp
	
//				DBG_RenderVector(@ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), color_rouge)
				v_IK_last_vec[ti_i] -= MATH_VecDotProduct(v_IK_last_vec[ti_i], @ao_IK_bones[ti_i][0] OBJ_HorizonGet()) * @ao_IK_bones[ti_i][0] OBJ_HorizonGet()
//				DBG_RenderVector(@ao_IK_bones[ti_i][0] OBJ_PosGet(), v_IK_last_vec[ti_i], color_vert)
				v_IK_last_vec[ti_i] = MATH_VecBlend(v_IK_last_vec[ti_i], tv_collide_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), 6.0 * TIME_GetDt())
//				DBG_RenderVector(@ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_collide_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), color_bleu)

				tv_dest_axis = @ao_IK_bones[ti_i][0] MATH_VecGlobalToLocal(v_IK_last_vec[ti_i])
				v_IK_last_dest_quat[ti_i] = tv_dest_axis
			}
			else
			{
				i_flag_IK_col[ti_i]	= faux
			
				v_IK_last_vec[ti_i] = MATH_VecBlend(v_IK_last_vec[ti_i], tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), 6.0 * TIME_GetDt())
				tv_dest_axis = @ao_IK_bones[ti_i][0] MATH_VecGlobalToLocal(v_IK_last_vec[ti_i])
				v_IK_last_dest_quat[ti_i] = tv_dest_axis
			}
		}
		
		if (f_delay_until_last_ground_col > 0.3 && f_delay_until_last_wall_col > 0.3)	
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 1.5 * TIME_GetDt())
		else if (i_flag_IK_col[ti_i])
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 0.5 * TIME_GetDt())
		else
			f_IK_ground_coef[ti_i] -= MATH_FloatMin(f_IK_ground_coef[ti_i], TIME_GetDt())	
	
		tv_start_axis = @ao_IK_bones[ti_i][0] MATH_VecGlobalToLocal(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet())
		@ao_IK_bones[ti_i][0] OBJ_Rotate_FromTo(tv_start_axis, tv_dest_axis)
	}
}

procedure_local void PNJ_Quadri_IK()
{
	int			ti_i
	int			ti_k
	int			ti_frame_num
	int			ti_flag_ok
	int			ti_action
	
	float		tf_angle
	float		tf_offset
	float		tf_bassin_offset
	float		tf_bassin_offset_min
	float		tf_bassin_offset_max
	float		tf_norm
	float		tf_coef
	float		tf_IK_coef
	float		tf_ray_start_offset
	float		tf_dot_product
	float		tf_ray_length
	float		tf_A
	float		tf_B
	float		tf_C
	
	vector	tv_pied_pos
	vector	tv_collide_pos
	vector	tv_ray_start
	vector	tv_ray_dir
	vector	tv_start_axis
	vector	tv_dest_axis
	vector	tv_ray_normale
	vector	tv_bassin_dest_pos
	vector	tv_rot_pivot_pos
	vector	tv_temp	
	vector	tv_rot_axis
	vector	tv_feet_start_axis
	vector	tv_ground_normal

	object	to_target
	object	to_bone
	object	to_obj
	
	//vector	tv_queue_banking
	//object	to_queue
	
	//v_IK_ref_ground_pos = OBJ_PosGet()
	
	tf_coef = OBJ_LodVisGet() 
	if (tf_coef < 0.1 && o_Rided_Actor != o_main_actor)
	{
		PNJ_Spider_Reset_IK()
	//	DBG_RenderVector(OBJ_PosGet(), Cv_VerticalVector * 100.0, color_blanc)
		return
	}
	
//	@o_bassin OBJ_PosSet(OBJ_PosGet())

	v_IK_ref_ground_pos = OBJ_PosGet()
	v_IK_ref_ground_pos -= OBJ_BankingGet() * f_size_coef * 0.6
	
	DBG_RenderVector(v_IK_ref_ground_pos, Cv_VerticalVector, color_jaune)	
	
	//to_queue = ANI_CanalObjectGet(Anim_Canal_Queue)
	//tv_queue_banking = @to_queue OBJ_BankingGet()
	
	tf_ray_start_offset = 0.0
	
	i_ik_ray_index = MATH_Modulo(i_ik_ray_index + 1, i_leg_nb)

	// EST-CE QU'ON S'ADAPTE AU RELIEF DU SOL ??? =============================================================
	tf_bassin_offset = 0.0
	
	ti_action = ACT_ActionGet()
	
	tf_coef = DYN_SpeedGet()
	
	for (ti_i = 0; ti_i < i_leg_nb; ti_i++)
	{
		i_flag_leg_IK[ti_i]	= vrai
	
		if (! i_flag_leg_IK[ti_i] && ! f_IK_coef[ti_i])
			continue
	
		tv_ray_dir = -OBJ_BankingGet()

//		@ao_IK_bones[ti_i][1] OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), MATH_VecBlendRotate(cvector(0.0, 0.0, 1.0), - @ao_IK_bones[ti_i][1] MATH_VecGlobalToLocal(@ao_IK_bones[ti_i][0] OBJ_BankingGet()), (1.0 - f_IK_ground_coef[ti_i]) * 0.6))

		tv_feet_start_axis = @ao_IK_bones[ti_i][2] MATH_VecGlobalToLocal(OBJ_BankingGet())

		tv_pied_pos = @ao_IK_bones[ti_i][2] OBJ_PosGet()
//		tv_pied_pos +=  @ao_IK_bones[ti_i][2] OBJ_BankingGet() * 0.7
		tv_pied_pos -= MATH_FloatMax(MATH_VecDotProduct(tv_pied_pos - v_IK_ref_ground_pos, OBJ_BankingGet()), 0.0) * OBJ_BankingGet()
		DBG_RenderVector(@ao_IK_bones[ti_i][1] OBJ_PosGet(), tv_pied_pos - @ao_IK_bones[ti_i][1] OBJ_PosGet(), color_blanc)
	
//		tv_rot_axis = MATH_VecNormalize(MATH_VecCrossProduct(@ao_IK_bones[ti_i][0] OBJ_BankingGet(), @ao_IK_bones[ti_i][1] OBJ_BankingGet()))
		tv_rot_axis = MATH_VecCrossProduct(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), OBJ_BankingGet())
		MATH_VecSetNormalize(tv_rot_axis)

		if (0 || ti_i == i_ik_ray_index)
		{
			tv_ray_dir = tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet()
			tv_ray_dir = MATH_VecCrossProduct(tv_ray_dir, tv_rot_axis)
//			tv_ray_dir = MATH_VecBlendRotate(MATH_VecCrossProduct(@ao_IK_bones[ti_i][0] OBJ_HorizonGet(), tv_ray_dir), tv_ray_dir, f_IK_ground_coef[ti_i])
			MATH_VecSetNormalize(tv_ray_dir)

			tv_ray_start = tv_pied_pos
			tv_ray_start -= tv_ray_dir * f_size_coef * 2.0

			tf_ray_length = 4.0 * f_size_coef
	
			to_obj = COL_RayObject_Dist(tv_ray_start, tv_ray_dir, tf_ray_length, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			if (to_obj)
			{
				// OK ON TOUCHE UN SOL, ON VA POUVOIR POSITIONNER EN IK ==============================================
				i_flag_IK_col[ti_i]	= vrai

				tv_ray_normale = COL_RayObject_NormalGet()
	
				tv_collide_pos = COL_RayObject_PosGet()
				tv_collide_pos	+= tv_ray_normale * 0.3 * OBJ_ZoomGet()
		
				DBG_RenderVector(tv_ray_start, tv_collide_pos - tv_ray_start, color_vert)
				DBG_RenderVector(tv_collide_pos, tv_ray_normale * 0.5, color_jaune)

				ao_IK_ground_actor[ti_i] = to_obj
				v_IK_ground_pos[ti_i] = @to_obj MATH_VecGlobalToLocal(tv_collide_pos - @to_obj OBJ_PosGet())
				v_IK_ground_normale[ti_i]	= @to_obj MATH_VecGlobalToLocal(tv_ray_normale)
			}
			else
			{
				i_flag_IK_col[ti_i]	= faux
	
				DBG_RenderVector(tv_ray_start, tv_ray_dir * tf_ray_length, color_rouge)

//				tv_temp = @ao_IK_ground_actor[ti_i] MATH_VecGlobalToLocal(OBJ_HorizonGet() * MATH_FloatSign(MATH_VecDotProduct(tv_pied_pos - OBJ_PosGet(), OBJ_HorizonGet())))
//				v_IK_ground_normale[ti_i]	= MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_temp, 2.0 * TIME_GetDt())
//
				tv_collide_pos = @ao_IK_ground_actor[ti_i] OBJ_PosGet() + @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_pos[ti_i])
				tv_ray_normale = @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_normale[ti_i])
			}
		}
		else
		{
//			tv_collide_pos = v_IK_ground_pos[ti_i]
//			tv_ray_normale = v_IK_ground_normale[ti_i]

			tv_collide_pos = @ao_IK_ground_actor[ti_i] OBJ_PosGet() + @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_pos[ti_i])
			tv_ray_normale = @ao_IK_ground_actor[ti_i] MATH_VecLocalToGlobal(v_IK_ground_normale[ti_i])
		}

//		DBG_RenderVector(tv_collide_pos, tv_ray_normale * 5.0, color_bleu)			

		tv_dest_axis = v_IK_last_dest_quat[ti_i]

		tv_ground_normal = tv_ray_normale
		tv_ray_normale -= MATH_VecDotProduct(tv_ray_normale, tv_rot_axis) * tv_rot_axis
		tf_norm = MATH_VecSquareNorm(tv_ray_normale)
		if (tf_norm)
		{
			tv_ray_normale /= MATH_FloatSqrt(tf_norm)

//			DBG_RenderVector(tv_collide_pos, tv_ray_normale * 5.0, color_bleu)			

			tv_temp = tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet()
			tf_C = MATH_VecNorm(tv_temp)
			tf_A = MATH_VecDotProduct(@ao_IK_bones[ti_i][0] OBJ_PosGet() - tv_collide_pos, tv_ray_normale)
			tf_B = tf_C * tf_C
			tf_B -= tf_A * tf_A
			if (tf_B > 0.0)
			{
				tf_B = MATH_FloatSqrt( tf_B)
	
				tv_temp -= MATH_VecDotProduct(tv_temp, tv_ray_normale) * tv_ray_normale
				MATH_VecSetNormalize(tv_temp)
				
				tv_collide_pos = @ao_IK_bones[ti_i][0] OBJ_PosGet()
				tv_collide_pos -= tf_A * tv_ray_normale
				tv_collide_pos += tf_B * tv_temp
	
				DBG_RenderVector(@ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), color_rouge)
				v_IK_last_vec[ti_i] -= MATH_VecDotProduct(v_IK_last_vec[ti_i], tv_rot_axis) * tv_rot_axis
				DBG_RenderVector(@ao_IK_bones[ti_i][0] OBJ_PosGet(), v_IK_last_vec[ti_i], color_vert)
				v_IK_last_vec[ti_i] = MATH_VecBlend(v_IK_last_vec[ti_i], tv_collide_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), 6.0 * TIME_GetDt())
				DBG_RenderVector(@ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_collide_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), color_bleu)

				tv_dest_axis = @ao_IK_bones[ti_i][0] MATH_VecGlobalToLocal(v_IK_last_vec[ti_i])
				v_IK_last_dest_quat[ti_i] = tv_dest_axis
			}
			else
			{
				i_flag_IK_col[ti_i]	= faux
			
				v_IK_last_vec[ti_i] = MATH_VecBlend(v_IK_last_vec[ti_i], tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), 6.0 * TIME_GetDt())
				tv_dest_axis = @ao_IK_bones[ti_i][0] MATH_VecGlobalToLocal(v_IK_last_vec[ti_i])
				v_IK_last_dest_quat[ti_i] = tv_dest_axis
			}
		}
		
		if (f_delay_until_last_ground_col > 0.3 && f_delay_until_last_wall_col > 0.3)	
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 1.5 * TIME_GetDt())
		else if (i_flag_IK_col[ti_i])
			f_IK_ground_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_ground_coef[ti_i], 0.5 * TIME_GetDt())
		else
			f_IK_ground_coef[ti_i] -= MATH_FloatMin(f_IK_ground_coef[ti_i], TIME_GetDt())	
	
		tv_start_axis = @ao_IK_bones[ti_i][0] MATH_VecGlobalToLocal(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet())
		@ao_IK_bones[ti_i][0] OBJ_Rotate_FromTo(tv_start_axis, tv_dest_axis)
		
		tv_dest_axis = @ao_IK_bones[ti_i][2] MATH_VecGlobalToLocal(tv_ground_normal)
		@ao_IK_bones[ti_i][2] OBJ_Rotate_FromTo(tv_feet_start_axis, tv_dest_axis)
	}
}
	