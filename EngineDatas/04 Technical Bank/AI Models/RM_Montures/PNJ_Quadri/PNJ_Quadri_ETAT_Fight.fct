#include "PNJ_Quadri_defines.var"

Include_UltraProcedure_Header

int				ti_car_index
int				ti_flag_complex_dodge

object		to_head
object		to_car
object		to_current_wp
object		to_next_wp

float			tf_coef
float			tf_dist
float			tf_speed_coef
float			tf_delay_before_collision
float			tf_lateral_speed
float			tf_move_length
float			tf_wanted_traction
float			tf_rot_speed
float			tf_wanted_rot_angle
float			tf_next_rot_angle
float			tf_rot_torque
float			tf_angle_delta
float			tf_time
float			tf_hor_speed

vector		tv_pos
vector		tv_joy_dir
vector		tv_speed
vector		tv_traction
vector		tv_collision_pos
vector		tv_X
vector		tv_Y
vector		tv_target_pos
vector		tv_move_dir

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux
	return
}

if (i_etat_courant != ETAT_Fight)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Fight
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	COL_SwapToSpecific(C_zdm_pied)
	COL_ZoneSizeSet(C_zdm_pied, cvector(Cf_zdm_size, Cf_zdm_size, Cf_zdm_size))
	COL_ZonePosSet(C_zdm_pied, cvector(0.0, 0.0, COL_ZoneSizeGet(C_zdm_pied)))

	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_NeverDynamicFather | DYN_C_NeverDynamicHierarchy | DYN_C_HorizontalGrounds | DYN_C_ApplyRec | DYN_C_Col, none)
	DYN_GravitySet(cvector(0.0, 0.0, -40.0))

//	f_acceleration = 40.0
//	f_decceleration = 40.0

	COL_UnCollidableAdd(o_main_actor)

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
o_Rided_Actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)
if ( o_Rided_Actor && !  o_fake_pilot )
	macro_change_etat("PNJ_Quadri_ETAT_Basic")

tf_speed_coef = 1.0

tv_target_pos = @o_main_actor OBJ_PosGet()

tv_joy_dir = tv_target_pos
tv_joy_dir -= OBJ_PosGet()

tv_joy_dir.z = 0.0
tf_dist = MATH_VecNorm(tv_joy_dir)
tv_joy_dir /= tf_dist

v_joy_dir	 = tv_joy_dir

// ANTICIPATION LIEE A LA DERIVE =======================================
tv_joy_dir.z = tv_joy_dir.x
tv_joy_dir.x = tv_joy_dir.y
tv_joy_dir.y = - tv_joy_dir.z
tv_joy_dir.z = 0.0

tf_lateral_speed = MATH_VecDotProduct(DYN_SpeedGetVector(),  - tv_joy_dir)
tv_joy_dir = tf_lateral_speed * tv_joy_dir
tv_joy_dir += tv_target_pos
tv_joy_dir -= OBJ_PosGet()

DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_joy_dir, color_jaune)

tv_joy_dir.z = 0.0
tf_dist = MATH_VecNorm(tv_joy_dir)
tv_joy_dir /= tf_dist

tf_coef = 1.0 + (MATH_VecDotProduct(OBJ_SightGet(), tv_joy_dir) * 2.0)
tf_coef *= 0.5
tf_speed_coef *= MATH_FloatBlend(0.5, 1.0, tf_coef)

tf_wanted_traction = f_speed_max * tf_speed_coef

// ANTICIPATION LIEE A L'INERTIE ANGULAIRE =================================

// ANGLE DEST
tf_wanted_rot_angle = MATH_VecAngle(OBJ_SightGet(), tv_joy_dir, OBJ_BankingGet())

// COMBIEN DE TEMPS POUR S'ARRETER EN CONTRE BRAQUANT A FOND ?
tf_rot_torque = -MATH_FloatSign(f_rot_speed) * f_rot_speed_max * f_rot_current_friction
tf_time = PNJ_Quadri_Time_To_Reach_Speed(f_rot_speed, f_rot_current_friction, tf_rot_torque, 0.01)
tf_time = MATH_FloatMax(tf_time, 0.1)

// ANGLE ATTEINT QUAND ON ATTEINT UNE VITESSE ANGULAIRE NULLE
tf_rot_speed = f_rot_speed
tf_rot_torque = MATH_FloatSign(tf_wanted_rot_angle) * f_rot_speed_max * f_rot_current_friction
tf_next_rot_angle = PNJ_Quadri_Angle_After_N_Seconds(tf_rot_speed, f_rot_current_friction, tf_rot_torque, tf_time, 0.0)

// SI ON DEPASSE L'ANGLE VOULU, ON  CONTRE BRAQUE
if (tf_wanted_rot_angle > 0.0 && tf_next_rot_angle > tf_wanted_rot_angle)
	tv_joy_dir = -MATH_FloatSign(tf_wanted_rot_angle) * OBJ_HorizonGet()
else if (tf_wanted_rot_angle < 0.0 && tf_next_rot_angle < tf_wanted_rot_angle)
	tv_joy_dir = -MATH_FloatSign(tf_wanted_rot_angle) * OBJ_HorizonGet()
else
	tv_joy_dir = MATH_FloatSign(tf_wanted_rot_angle) * OBJ_HorizonGet()

// COMPORTEMENT =========================================================

PNJ_Quadri_Sight_And_Banking(tv_joy_dir)
PNJ_Quadri_Apply_Traction_And_Choose_Action(tf_wanted_traction)

if (COL_ZDE_ZDECollide(o_main_actor, C_zde_fight, C_zde_corps))
	EVENT_AddEventPafCanal( C_EVENT_FILTER_Object,  C_PAF_RM_Fort, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_main_actor, -1, 10.0, DYN_SpeedGetVector(), OBJ_PosGet())
