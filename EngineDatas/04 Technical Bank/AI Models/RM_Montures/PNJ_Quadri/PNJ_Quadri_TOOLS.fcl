#include "PNJ_Quadri_defines.var"

Include_UltraProcedure_Header

procedure_local void PNJ_Quadri_Water_Col()
{
	int			ti_col_report_id	

	float		tf_dot_product
	float		tf_zdm_size

	vector	tv_archimede

	tf_zdm_size = COL_ZoneSizeGet(C_zdm_pied)

	ti_col_report_id = COL_GMatReportGet(Gmat_RM_Face_eau) 
	if (ti_col_report_id != -1)
	{
		v_water_pos = COL_CollidedPointGet(COL_C_ReportIndex + ti_col_report_id)
		v_water_normal = COL_NormalGet(COL_C_ReportIndex + ti_col_report_id)
		
		if (v_water_normal.z < 0.0)
			v_water_normal *= -1.0
		
		DBG_RenderVector(v_water_pos, v_water_normal * 10.0, color_bleu)
	}
	
	f_in_water_depth = MATH_VecDotProduct(v_water_pos - OBJ_PosGet(), v_water_normal)
	if (f_in_water_depth > 0.0)
	{
		i_flag_water_col = vrai	
	
		i_col_gmat_id |= Gmat_RM_Face_eau
		
		if (f_delay_since_last_ground_col > Cf_hysteresis_no_ground_col)
			v_col_ground_normal = v_water_normal
			
		tf_dot_product = MATH_FloatLimit(f_in_water_depth, 0.0, tf_zdm_size * 3.0)
		tf_dot_product /= tf_zdm_size * 2.0
		tf_dot_product *= - DYN_GravityVectorGet().z

		tv_archimede = cvector(0.0, 0.0, tf_dot_product)
	
		DBG_RenderVector(OBJ_PosGet(), tv_archimede, 0xFF8080)	
	
		DYN_TractionSet(DYN_TractionVectorGet() + tv_archimede)
	}
	else
	{
		i_flag_water_col = faux	
	
		v_water_pos = cvector(0.0, 0.0, -Cf_Infinit)
		v_water_normal = Cv_VerticalVector
	}
}

procedure_local int PNJ_Quadri_Get_Rope_Gao(byref vector tv_rope_pos)
{
	object	to_gao	

	float		tf_sqr_rope_length
	float 		tf_rope_length
	float 		tf_rope_ratio

	vector	tv_offset_A
	vector	tv_offset_B
	vector	tv_rope_AB

	to_gao = @o_rope_manager Rope_Manager_Get_Linked_Gao(OBJ_Me(), tf_rope_length, tf_rope_ratio, tv_offset_A, tv_offset_B)
	if (to_gao)
	{
//		EVENT_AddEventLockCam(OBJ_Me(), C_EVENT_LockCamStatus_Fight, cvector(0.0, 0.0, 2.0)) 
	
		if (to_gao == o_eagle)
		{
			return(faux)
		}
		else if ( tf_rope_ratio == 1.0)
		{
			return(faux)
		}
		else
		{
			tv_rope_pos = @to_gao OBJ_PosGet() + @to_gao MATH_VecLocalToGlobal(tv_offset_B)
		
			tv_rope_AB	 = tv_rope_pos
			tv_rope_AB -= OBJ_PosGet() + MATH_VecLocalToGlobal(tv_offset_A)
	
//			DBG_RenderVector(tv_rope_pos, -tv_rope_AB, color_cyan)	
	
			tf_sqr_rope_length = tf_rope_length * 0.8
			tf_sqr_rope_length *= tf_sqr_rope_length
			
			if (MATH_VecSquareNorm(tv_rope_AB) > tf_sqr_rope_length)
				return(vrai)
		}
	}
	
	return(faux)
}

procedure float PNJ_Quadri_Torque_To_Reach_Angle(float tf_current_speed, float tf_wanted_angle, float tf_friction, float tf_dt)
{
	float		tf_f_under_1
	float		tf_exp_m_dt

	float		tf_return_torque
	
	tf_exp_m_dt = MATH_Exp( - tf_friction *  tf_dt )

	tf_f_under_1 = 1.0 / tf_friction

	tf_return_torque = tf_wanted_angle
	tf_return_torque -= (tf_current_speed * tf_f_under_1) * (1.0 - tf_exp_m_dt)
	tf_return_torque /= tf_f_under_1 * (tf_dt - tf_f_under_1 + (tf_f_under_1 * tf_exp_m_dt))

	return(tf_return_torque)
}


procedure float PNJ_Quadri_Time_To_Reach_Speed(float tf_init_speed, float tf_friction, float tf_torque, float tf_wanted_speed)
{
	float		tf_time
	float		tf_A
	float		tf_B
	float		tf_C
	float		tf_DELTA
	float		tf_torque_under_friction
	float		tf_torque_under_friction_minus_init_speed

	tf_wanted_speed *= tf_wanted_speed

	tf_torque_under_friction = tf_torque
	tf_torque_under_friction /= tf_friction

	tf_torque_under_friction_minus_init_speed = tf_torque_under_friction
	tf_torque_under_friction_minus_init_speed -= tf_init_speed

	tf_A = tf_torque_under_friction_minus_init_speed * tf_torque_under_friction_minus_init_speed
	if (tf_A == 0.0)
		return(Cf_Infinit)
	
	tf_B = -2.0 * tf_torque_under_friction * tf_torque_under_friction_minus_init_speed
	tf_C = (tf_torque_under_friction * tf_torque_under_friction) - tf_wanted_speed
	
	tf_DELTA = tf_B * tf_B
	tf_DELTA -= 4.0 * tf_A * tf_C

	if (tf_DELTA < 0.0)
	{
		return(Cf_Infinit)
	}
	else if (tf_DELTA == 0.0)
	{
		tf_time = -tf_B
		tf_time /= 2.0 * tf_A
		
		if (tf_time <= 0.0)
			return(Cf_Infinit)

		tf_time = - MATH_Ln(tf_time)
		tf_time /= tf_friction
	}
	else
	{
		tf_DELTA = MATH_FloatSqrt(tf_DELTA)
		
		tf_time = -tf_B + tf_DELTA
		tf_time /= 2.0 * tf_A

		if (tf_time <= 0.0)
			return(Cf_Infinit)

		tf_time = - MATH_Ln(tf_time)
		tf_time /= tf_friction
	}
	
	return(tf_time)
}


procedure float PNJ_Quadri_Angle_After_N_Seconds(byref float tf_rot_speed, float tf_rot_friction, float tf_torque, float tf_time, float tf_exp)
{
	float		tf_A
	float		tf_B
	float		tf_V0
	float		tf_angle

	tf_V0 = tf_rot_speed
	
	if (!tf_exp)
		tf_exp = MATH_Exp(-tf_time * tf_rot_friction)
	
	// CALCUL VITESSE 
	tf_A = tf_torque / tf_rot_friction
	tf_B = (tf_A - tf_V0) * tf_exp
	
	tf_rot_speed = tf_A - tf_B
	
	// CALCUL DEPLACEMENT
	tf_angle = tf_A * tf_time
	tf_angle -= (tf_A - tf_V0) / tf_rot_friction
	tf_angle += tf_B / tf_rot_friction
	
	return(tf_angle)	
}


procedure_local void PNJ_Quadri_Rotation_Speed_Compute()
{
	float			tf_friction
	float			tf_angle


	if (o_eagle)
		f_rot_current_friction = 1.5
	else if (o_current_wp)
		f_rot_current_friction = f_rot_friction
	else
		f_rot_current_friction = 6.0
	
	f_rot_torque *= f_rot_current_friction

	if (i_flag_water_col || f_delay_since_last_ground_col < Cf_hysteresis_no_ground_col || o_eagle)
		tf_angle = PNJ_Quadri_Angle_After_N_Seconds(f_rot_speed, f_rot_current_friction, f_rot_torque, TIME_GetDt(), 0.0)
	else
		tf_angle = f_rot_speed * TIME_GetDt()
	
	if (tf_angle)
		OBJ_RotateLocalZ(tf_angle)

//	f_rot_speed = MATH_VecAngle(v_last_sight, OBJ_SightGet(), OBJ_BankingGet())
//	f_rot_speed /= TIME_GetDt()
//	v_last_sight = OBJ_SightGet()
}

procedure_local void PNJ_Quadri_Collision_Rot_Speed()
{
	float		tf_delta_speed

	vector	tv_delta_speed
	vector	tv_collision_pos
	
	object	to_collide_object

	return

//	if (COL_CollideType(COL_C_Wall))
//	{
//		to_collide_object	= COL_ObjectGet(COL_C_Wall)
//		if (@to_collide_object OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna))
//			return
//
//		tv_delta_speed = DYN_SpeedGetVector() - v_last_speed
//		tf_delta_speed = MATH_VecSquareNorm(tv_delta_speed) 
//		if (tf_delta_speed > 16.0)
//		{
//			tf_delta_speed = MATH_FloatSqrt(tf_delta_speed)
//			tf_delta_speed = MATH_FloatBlend(0.0, 2.8, (tf_delta_speed - 4.0) * 0.2)
//		
//			tv_collision_pos = COL_CollidedPointGet(COL_C_Wall) - OBJ_PosGet()
//			tv_collision_pos -= MATH_VecDotProduct(tv_collision_pos, OBJ_BankingGet()) * OBJ_BankingGet()
//
//			f_rot_speed	 = MATH_VecDotProduct(MATH_VecCrossProduct(tv_collision_pos, OBJ_SightGet()), OBJ_BankingGet()) * tf_delta_speed
//		}
//	}
}


procedure_local void PNJ_Quadri_Sight_And_Banking(vector tv_sight)
{
	float			tf_speed_coef	

	vector		tv_A
	vector		tv_B
	vector		tv_C
	vector		tv_banking
	
	if (PNJ_Quadri_Get_Rope_Gao(tv_A))
	{
		tv_sight = tv_A
		tv_sight -= OBJ_PosGet()
//		DBG_RenderVector(OBJ_PosGet(), tv_sight, color_cyan)
		MATH_VecSetHorzNormalize(tv_sight)
	}

	if (MATH_VecDotProduct(tv_sight, OBJ_SightGet()) < 0.0)
	{
		if (MATH_VecDotProduct(tv_sight, OBJ_HorizonGet()) > 0.0)
			tv_sight = OBJ_HorizonGet()
		else
			tv_sight = -OBJ_HorizonGet()
	}
	
	f_rot_torque = MATH_VecDotProduct(OBJ_HorizonGet(), tv_sight)
	if (o_eagle)
		f_rot_torque *= 4.0
	else
		f_rot_torque *= f_rot_speed_max

	PNJ_Quadri_Collision_Rot_Speed()

	PNJ_Quadri_Water_Col()

	if (COL_CollideType(COL_C_Wall))
		f_delay_since_last_wall_col = 0.0
	else
		f_delay_since_last_wall_col += TIME_GetDt()

	if (o_Rided_Actor && f_real_speed < 1.0)
	{
		tv_A = OBJ_PosGet()
		tv_A += MATH_VecLocalToGlobal(v_col_front_left)
		
		if (COL_RayObject_Dist(tv_A + Cv_VerticalVector, -Cv_VerticalVector, 2.5, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_A = COL_RayObject_PosGet()
			i_col_gmat_id = COL_GMAT_FlagsGet(COL_C_Ray)
			f_delay_since_last_ground_col = 0.0
		}
		else
			tv_A.z -= 20.0 * TIME_GetDt()
	
		tv_B = OBJ_PosGet()
		tv_B += MATH_VecLocalToGlobal(v_col_front_right)
		
		if (COL_RayObject_Dist(tv_B + Cv_VerticalVector, -Cv_VerticalVector, 2.5, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_B = COL_RayObject_PosGet()
			i_col_gmat_id = COL_GMAT_FlagsGet(COL_C_Ray)
			f_delay_since_last_ground_col = 0.0
		}
		else
			tv_B.z -= 20.0 * TIME_GetDt()
	
		tv_C = OBJ_PosGet()
		tv_C += MATH_VecLocalToGlobal(v_col_back)
		
		if (COL_RayObject_Dist(tv_C + Cv_VerticalVector, -Cv_VerticalVector, 2.5, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		{
			tv_C = COL_RayObject_PosGet()
			i_col_gmat_id = COL_GMAT_FlagsGet(COL_C_Ray)
			f_delay_since_last_ground_col = 0.0
		}
		else
			tv_C.z -= 20.0 * TIME_GetDt()
	
		v_col_ground_pos = tv_C
	
		DBG_RenderVector(tv_A, Cv_VerticalVector, color_bleu)
		DBG_RenderVector(tv_B, Cv_VerticalVector, color_bleu)
		DBG_RenderVector(tv_C, Cv_VerticalVector, color_bleu)
	
		v_col_ground_normal = MATH_VecCrossProduct(tv_B - tv_C, tv_A- tv_C)
		MATH_VecSetNormalize(v_col_ground_normal)
	
		if (COL_CollideType(COL_C_Ground))
			f_delay_since_last_ground_col = 0.0
	}
	else
	{
		v_col_ground_pos = OBJ_PosGet()

		if (COL_CollideType(COL_C_Ground))
		{
			tv_banking = COL_NormalGet(COL_C_Ground)
			if (tv_banking.z > 0.0)
			{
				i_col_gmat_id = COL_GMAT_FlagsGet(COL_C_Ground)	
							
				f_delay_since_last_ground_col = 0.0	
		
				v_col_ground_pos = COL_CollidedPointGet(COL_C_Ground)
				v_col_ground_normal = tv_banking
			}
		}
	}

	if (i_flag_water_col || f_delay_since_last_ground_col < Cf_hysteresis_no_ground_col)
	{	
		tv_banking = v_col_ground_normal
	
		tv_C = OBJ_HorizonGet()
		tv_C.z = 0.0
		MATH_VecSetNormalize(tv_C)
		tv_banking -= MATH_VecDotProduct(tv_banking, tv_C) * tv_C
	
		tv_banking = MATH_VecBlendRotate(OBJ_BankingGet(), tv_banking, 4.0 * TIME_GetDt())
	
		OBJ_BankingGeneralSet(OBJ_SightGet(), tv_banking)
	}

	if (i_flag_jump || f_delay_since_last_ground_col < Cf_hysteresis_no_ground_col)
		f_ground_col_duration += TIME_GetDt()
	else
	 	f_ground_col_duration = 0.0

	 PNJ_Quadri_Rotation_Speed_Compute()

	v_real_sight = OBJ_SightGet()
	v_real_banking = OBJ_BankingGet()
	OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
}

procedure_local void PNJ_Quadri_Choose_Best_Action(float tf_speed)
{
	int			ti_i
	int			ti_start_action_index
	int			ti_last_action_index
	int			ti_action
	int			ti_freq	

	float		tf_dot_product
	float		tf_coef	
	float		tf_action_A_mult_coef
	float		tf_action_B_mult_coef
	float		tf_action_speed
	
	vector	tv_action_offset

	object	to_collide_object

	ti_start_action_index = 0
	ti_last_action_index = 2

	if (ACT_ActionIsTransition())
		return
	
	if ( ACT_ActionFinished() )
	{
		if (f_delay_since_last_ground_col < Cf_hysteresis_no_ground_col)
		{
			switch(ACT_ActionGet())
			{
				case Ci_Action_Saut_Deb :
					f_stop_duration = 0.0
					i_flag_jump = vrai
					f_delay_since_last_ground_col = Cf_Infinit
					DYN_SpeedSetVector(DYN_SpeedGetVector() + cvector(0.0, 0.0, 20.0))
					ACT_ActionSet(Ci_Action_Saut_Impulsion)
					return
					break
			}
		}
		else if ( ! i_flag_water_col )
		{
			switch(ACT_ActionGet())
			{
				case Ci_Action_Saut_Impulsion :
						f_stop_duration = 0.0
						ACT_ActionSet(Ci_Action_Saut_Montee)
						return
					break
				case Ci_Action_Saut_Montee :
						f_stop_duration = 0.0
						ACT_ActionSet(Ci_Action_Saut_Descente)
						return
					break
			}
		}
	}
	else
	{
		switch(ACT_ActionGet())
		{
			case Ci_Action_Reception :
			case Ci_Action_Choc_Mur_G :
			case Ci_Action_Choc_Mur_D :
			case Ci_Action_Saut_Deb :
			case Ci_Action_Saut_Impulsion :
			case Ci_Action_Saut_Fin :
				return
				break

			case Ci_Action_Saut_Montee :
			case Ci_Action_Saut_Descente :
				if ( ! i_flag_water_col && f_delay_since_last_ground_col > Cf_hysteresis_no_ground_col)
					return
				break
		}
	}
	
	if (f_delay_since_last_ground_col > Cf_hysteresis_no_ground_col && ! i_flag_water_col)
	{
		f_stop_duration = 0.0
	
		if (DYN_SpeedGetVector().z < -1.0 && ! o_eagle )
			ACT_ActionSet(Ci_Action_Chute)
		else
			ACT_ActionSet(Ci_Action_Attente)
		return
	}
	else
	{
		switch(ACT_ActionGet())
		{
			case Ci_Action_Chute :
			case Ci_Action_Saut_Montee :
			case Ci_Action_Saut_Descente :

				f_stop_duration = 0.0

				if (v_last_speed.z < -20.0)
					ACT_ActionSet(Ci_Action_Reception)
				else
					ACT_ActionSet(Ci_Action_Saut_Fin)
				return
		}
	}

	if (COL_CollideType(COL_C_Wall))
	{
		to_collide_object	= COL_ObjectGet(COL_C_Wall)
	
		tf_dot_product = MATH_VecDotProduct(DYN_SpeedGetVector() - v_last_speed, OBJ_HorizonGet())
		if (tf_dot_product > big_collision_speed)
		{
			f_stop_duration = 0.0
		
			ACT_ActionSet(Ci_Action_Choc_Mur_D)

			if (AI_HaveSameModel(to_collide_object))
				i_flag_quadri_collision = vrai
			else
				i_flag_quadri_collision = faux
		
			return
		}
		else if (tf_dot_product < -big_collision_speed)
		{
			f_stop_duration = 0.0
			
			ACT_ActionSet(Ci_Action_Choc_Mur_G)

			if (AI_HaveSameModel(to_collide_object))
				i_flag_quadri_collision = vrai
			else
				i_flag_quadri_collision = faux

			return
		}
	}

	if (tf_speed < 0.1)
	{
		if (i_last_action < Ci_Action_Chute)
		{
			if (ACT_ActionGet() != Ci_Action_Attente)
			{
				f_stop_duration += TIME_GetDt()
				if (f_stop_duration > 1.0)
				{
					ACT_ActionSet(Ci_Action_Attente)
					f_stop_duration = 0.0
				}	
				else
				{
					ACT_ActionSet(i_last_action | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_No_Blend)
					ANI_CurrentFrameSet(0, i_last_frame)
					ACT_ActionSet(i_last_action | Ci_ActionSet_Force_SameAction | Ci_ActionSet_Force_No_Blend)
				}
			}
		}
		else
		{
			ACT_ActionSet(Ci_Action_Attente)
		}
	}
	else
	{
		// Plusieurs anim de déplacement
		f_stop_duration = 0.0
	
		for (ti_i = ti_start_action_index; ti_i < ti_last_action_index; ti_i++)
		{
			if (tf_speed < af_action_speed[ti_i])
			{
				ti_action = ti_i
				break
			}
			else if (tf_speed > af_action_speed[ti_i + 1])
			{
				ti_action = ti_i + 1
				continue
			}
			
			tf_action_A_mult_coef = tf_speed / af_action_speed[ti_i]
			tf_action_B_mult_coef = af_action_speed[ti_i + 1] / tf_speed
	
			if (tf_action_A_mult_coef < tf_action_B_mult_coef)
				ti_action = ti_i
			else
				ti_action = ti_i + 1	
		
			break
		}
	
//		if (ti_action == ti_last_action_index)
//		{
//			if (f_speed_angle > 0.1)
//				ti_action += 1
//			else if (f_speed_angle < -0.1)
//				ti_action += 2
//		}

		ACT_ActionSet(ai_action_index[ti_action])
	
		tf_coef = tf_speed
		tf_coef /= af_action_speed[ti_action]
	
		if (ti_action >= ti_last_action_index)
			tf_coef = MATH_FloatMin(tf_coef, 1.5)
	
		ACT_LIB_ActionFrequencyMultiply(tf_coef)
	}
	
	if ( ! ACT_ActionIsTransition() )
	{
		i_last_action = ACT_ActionGet()
		i_last_frame = ANI_CurrentFrameGet(0)
	}
}

procedure_local void PNJ_Quadri_Apply_Traction_And_Choose_Action(float tf_wanted_traction)
{
	int				ti_index	
	int				ti_flag_acceleration

	float			tf_X_friction
	float			tf_Y_friction
	float			tf_traction
	float			tf_speed_coef	

	vector		tv_speed
	vector		tv_traction	

	#define Cv_Text_Friction			cvector(0.01, 0.9, 0.0)

	i_flag_Y_slide = faux

	if ( ! o_current_wp )
		ti_flag_acceleration = vrai
	else if (tf_wanted_traction > f_analog_speed && f_real_speed < f_wanted_speed)
		ti_flag_acceleration = vrai
	else
		ti_flag_acceleration = faux

	if (tf_wanted_traction >= f_wanted_traction)
		f_wanted_traction += MATH_FloatMin(tf_wanted_traction - f_wanted_traction, f_acceleration * TIME_GetDt())
	else
		f_wanted_traction -= MATH_FloatMin(f_wanted_traction, f_decceleration * TIME_GetDt())

	switch (ACT_ActionGet())
	{
		case Ci_Action_Choc_Mur_G :
		case Ci_Action_Choc_Mur_D :
			if ( ! i_flag_quadri_collision )
				f_wanted_traction = MATH_FloatLimit(f_wanted_traction, 0.0, MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet()))
//			if ( ! i_flag_quadri_collision )
//				f_wanted_traction = 0.0
			break
	}

	if ( ! i_flag_water_col && (i_flag_jump || f_delay_since_last_ground_col > Cf_hysteresis_no_ground_col) )
	{
		i_col_gmat_id	= 0
	
		DYN_FlagsSet(DYN_C_GlobalFriction, none)
		DYN_FrictionVectorSet(cvector(0.1, 0.1, 0.0))
		DYN_TractionSet(Cv_NullVector)

		if (o_Rided_Actor && DISPLAY)
		{
			ti_index = STR_CreateText("\h.08\AIR ", Cv_Text_Friction, 0.0)
			STR_AppendFloat(ti_index, 0.1, 2)
		}
	}
	else
	{
		if (i_col_gmat_id & Gmat_RM_Face_de_lave)
		{
			tf_X_friction = 2.0
			tf_Y_friction = 2.0

			tf_traction = f_wanted_traction
		
			if (o_Rided_Actor && DISPLAY)
			{
				ti_index = STR_CreateText("\h.08\LAVE X : ", Cv_Text_Friction, 0.0)
				STR_AppendFloat(ti_index, tf_X_friction, 2)
				STR_AppendText(ti_index, " Y : ")
				STR_AppendFloat(ti_index, tf_Y_friction, 2)
			}
		}
		else if (i_col_gmat_id & Gmat_RM_Face_eau && f_in_water_depth > OBJ_ZoomGet())
		{
			tf_X_friction = 2.0
			tf_Y_friction = 2.0

			tf_traction = f_wanted_traction

			if (o_Rided_Actor && DISPLAY)
			{
				ti_index = STR_CreateText("\h.08\EAU X : ", Cv_Text_Friction, 0.0)
				STR_AppendFloat(ti_index, tf_X_friction, 2)
				STR_AppendText(ti_index, " Y : ")
				STR_AppendFloat(ti_index, tf_Y_friction, 2)
			}
		}
		else if (i_col_gmat_id & Gmat_RM_Ice)
		{
			tf_X_friction = MATH_FloatMax(f_X_friction - 3.0, 1.0)
			tf_Y_friction = MATH_FloatMax(f_Y_friction - 3.0, 1.0)

			if (f_wanted_speed - f_real_speed > f_Y_limit_speed || MATH_AbsFloat(MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_HorizonGet())) > f_X_limit_speed)
			{
				tf_X_friction = MATH_FloatMin(tf_X_friction, f_X_slide_friction)
				tf_Y_friction = MATH_FloatMin(tf_Y_friction, f_Y_slide_friction)
			}
			
			tf_traction = f_wanted_traction * tf_Y_friction // On n'est pas ralenti

			if (o_Rided_Actor && DISPLAY)
			{
				ti_index = STR_CreateText("\h.08\GLACE X : ", Cv_Text_Friction, 0.0)
				STR_AppendFloat(ti_index, tf_X_friction, 2)
				STR_AppendText(ti_index, " Y : ")
				STR_AppendFloat(ti_index, tf_Y_friction, 2)
			}
		}
		else
		{
			if (MATH_AbsFloat(MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_HorizonGet())) > f_X_limit_speed)
				tf_X_friction = f_X_slide_friction
			else
				tf_X_friction = f_X_friction

			if (ti_flag_acceleration)
			{
				if (f_wanted_speed - f_real_speed > f_Y_limit_speed)
				{
					i_flag_Y_slide = vrai
					tf_Y_friction = f_Y_slide_friction
				}
				else
				{
					tf_Y_friction = f_Y_friction
				}
			}
			else
			{
				if (MATH_VecDotProduct(DYN_SpeedGetVector(), OBJ_SightGet()) > 0.0)
					tf_Y_friction = 0.2
				else
					tf_Y_friction = f_Y_slide_friction
			}

			tf_traction = f_wanted_traction * tf_Y_friction

			if (o_Rided_Actor && DISPLAY)
			{
				ti_index = STR_CreateText("\h.08\TERRE X : ", Cv_Text_Friction, 0.0)
				STR_AppendFloat(ti_index, tf_X_friction, 2)
				STR_AppendText(ti_index, " Y : ")
				STR_AppendFloat(ti_index, tf_Y_friction, 2)
			}
		}
	
		DYN_FlagsSet(none, DYN_C_GlobalFriction)
		if (i_flag_water_col)
			DYN_FrictionVectorSet(cvector(tf_X_friction, tf_Y_friction, 3.0))
		else
			DYN_FrictionVectorSet(cvector(tf_X_friction, tf_Y_friction, 0.0))
	
		tv_traction = OBJ_SightGet()
		tv_traction = MATH_VecBlendRotate(tv_traction, -v_col_ground_normal, 0.1)
		tv_traction *= tf_traction
//		tv_traction.z = 0.0
//		tv_traction -= MATH_VecDotProduct(tv_traction, v_col_ground_normal) * v_col_ground_normal
		tv_traction += DYN_TractionVectorGet()
		DYN_TractionSet(tv_traction)
	}

	tv_speed = DYN_SpeedGetVector()
	tv_speed.z = 0.0
	f_real_speed = MATH_VecDotProduct(tv_speed, OBJ_SightGet())
	
//	tv_traction = DYN_TractionVectorGet()
//	tv_traction.z = 0.0
//	tv_traction /= DYN_FrictionVectorGet().y
//	f_wanted_speed = MATH_VecDotProduct(tv_traction, OBJ_SightGet())

	f_wanted_speed = f_wanted_traction
	
	if (f_real_speed > f_wanted_speed * 0.85)
		PNJ_Quadri_Choose_Best_Action(f_real_speed)
	else
		PNJ_Quadri_Choose_Best_Action(f_wanted_speed)

	if (o_Rided_Actor && DISPLAY)
	{
		ti_index = STR_CreateText("\h.08\RPM: ", cvector(0.82, 0.8, 0.0), 0.0)
		STR_AppendFloat(ti_index, f_wanted_traction, 2)

		ti_index = STR_CreateText("\h.08\SPEED: ", cvector(0.79, 0.9, 0.0), 0.0)
		STR_AppendFloat(ti_index, f_real_speed, 2)
	}
}

procedure_local void PNJ_Quadri_Init_Action_Speed_Array()
{
	int			ti_i
	int			ti_start_action_index
	int			ti_last_action_index
	int			ti_action
	int			ti_freq	

	float		tf_coef	
	float		tf_action_A_mult_coef
	float		tf_action_B_mult_coef
	float		tf_action_speed
	
	vector	tv_action_offset

	ti_start_action_index = 0
	ai_action_index[0] = Ci_Action_Marche
	ai_action_index[1] = Ci_Action_Trot
	ai_action_index[2] = Ci_Action_Charge
	ai_action_index[3] = Ci_Action_Charge_G
	ai_action_index[4] = Ci_Action_Charge_D
	ti_last_action_index = 4
	
	for (ti_i = 0; ti_i < ti_last_action_index + 1; ti_i++)
	{
		ACT_MagicBoxMoveGet(&tv_action_offset, &tf_action_speed, ai_action_index[ti_i], 0)
		af_action_speed[ti_i] =  tf_action_speed * OBJ_ZoomGet()
	}
}


procedure_local void PNJ_Quadri_Init_IK()
{
	int			ti_i
	int			ti_k
	int			ti_membre_index
	
	o_bassin = ANI_CanalObjectGet(Anim_Canal_Bassin)

	// IK NECK INIT ================================================================================================
	for (ti_i = 0; ti_i < 4; ti_i++)
	{
		switch(ti_i)
		{
			case Ci_IK_pied_gauche :
				ti_membre_index = Anim_Canal_PiedGauche
				break
			case Ci_IK_pied_droit :
				ti_membre_index = Anim_Canal_PiedDroit
				break
			case Ci_IK_main_gauche :
				ti_membre_index = Anim_Canal_MainGauche
				break
			case Ci_IK_main_droite :
				ti_membre_index = Anim_Canal_MainDroite
				break
		}	
	
		for (ti_k = 0; ti_k < 3; ti_k++)
			ao_IK_bones[ti_i][ti_k] = ANI_CanalObjectGet(ti_membre_index + (2 - ti_k))
	
		af_IK_bones_length[ti_i][0] = MATH_VecNorm(@ao_IK_bones[ti_i][1] OBJ_PosGet() - @ao_IK_bones[ti_i][0] OBJ_PosGet())
		af_IK_bones_length[ti_i][1] = MATH_VecNorm(@ao_IK_bones[ti_i][2] OBJ_PosGet() - @ao_IK_bones[ti_i][1] OBJ_PosGet())
	
		f_IK_leg_length[ti_i] = af_IK_bones_length[ti_i][0]
		f_IK_leg_length[ti_i] += af_IK_bones_length[ti_i][1]
		
		v_IK_ground_normale[ti_i] = Cv_VerticalVector
	}
}

procedure_local void PNJ_Quadri_Reset_IK()
{
	int			ti_i	

	// IK LEG
	f_bassin_Z_offset = 0.0

	v_IK_ref_ground_pos = OBJ_PosGet()

	for (ti_i = 0; ti_i < 4; ti_i++)
	{
		i_flag_leg_IK[ti_i] = faux

		f_IK_Z_offset[ti_i] = 0.0
		f_IK_coef[ti_i] = 0.0
		f_IK_ground_coef[ti_i] = 0.0
	}
}

procedure_local void PNJ_Quadri_GFX_Smoke(int	ti_index, int ti_flag_use_speed)
{
	int		ti_terrain
	
	float		tf_speed

	vector	tv_pos
	vector	tv_wind
	vector	tv_pos_dir

	if (OBJ_LodVisGet()  < 0.6)
	{
		if (GFX_Smoke[ti_index] != -1)
		{
			GFX_Seti(GFX_Smoke[ti_index], 13106, 0)												// *number of sprite to generate
			GFX_Smoke[ti_index] = -1
		}
		return
	}

	if (f_real_speed < 2.0)
	{
		if (GFX_Smoke[ti_index] != -1)
		{
			GFX_Seti(GFX_Smoke[ti_index], 13106, 0)												// *number of sprite to generate
			GFX_Smoke[ti_index] = -1
		}
		return
	}
	
	if (f_delay_since_last_ground_col > Cf_hysteresis_no_ground_col)
	{
		if (GFX_Smoke[ti_index] != -1)
		{
			GFX_Seti(GFX_Smoke[ti_index], 13106, 0)												// *number of sprite to generate
			GFX_Smoke[ti_index] = -1
		}
		return
	}
	
	tv_pos_dir = DYN_SpeedGetVector()
//		tv_pos_dir.z = 0.0
	tf_speed = MATH_VecNorm(tv_pos_dir)

	if (tf_speed > 2.0)
	{
		tv_pos_dir /= tf_speed
		tf_speed = MATH_FloatMin(tf_speed, 10.0)
	}
	else
	{
		tf_speed = 2.0
		tv_pos_dir = OBJ_SightGet()
	}

	tv_pos_dir *= 5.0

//	tv_pos_dir += tv_pos

	if (GFX_Smoke[ti_index] == -1)
	{
		GFX_Smoke[ti_index] = GFX_Add(13)																// Create the boum
		
		GFX_MaterialSet(GFX_Smoke[ti_index], get_SFX_light_and_smoke, -1)						// met le materiau
		GFX_Seti(GFX_Smoke[ti_index], 13101, 8)															// Materiau 0

		GFX_Seti(GFX_Smoke[ti_index], 13100, 20)															// *Buffer number of sprite
		GFX_Seti(GFX_Smoke[ti_index], 13106, 0xFFFFFFFF)												// *number of sprite to generate
	
		GFX_Setf(GFX_Smoke[ti_index], 13003, 0.1)															// Time fase 1
		GFX_Setf(GFX_Smoke[ti_index], 13004, 0.75)															// Time fase 2
	
		GFX_Seti(GFX_Smoke[ti_index], 13107, 0)															// Sprites non triés
	
		GFX_FlagSet(GFX_Smoke[ti_index], 0 , 1)
		GFX_FlagSet(GFX_Smoke[ti_index], 2 , 1)
		
		GFX_Setf(GFX_Smoke[ti_index], 13012, 0.75)														// Time random
	
		GFX_Setv(GFX_Smoke[ti_index], 13203, cvector(0.008, 0.008, 0.05))					// friction speed
		GFX_Setf(GFX_Smoke[ti_index], 13000, 0.5)														// Growing speed min
		GFX_Setf(GFX_Smoke[ti_index], 13001, 1.0)														// Growing speed max
		GFX_Setf(GFX_Smoke[ti_index], 13002, 0.0001)													// Friction Grow

		GFX_Setf(GFX_Smoke[ti_index], 13007, 0.0)														// Gravity

		GFX_Setf(GFX_Smoke[ti_index], 13008, 0.08)														// generation rate
	
		GFX_Setv(GFX_Smoke[ti_index], 13205, Cv_NullVector)										// Mainposspeed
		GFX_Setv(GFX_Smoke[ti_index], 13206, Cv_NullVector)										// Mainpossfriction
	}

	GFX_Seti(GFX_Smoke[ti_index], 13103, COLOR_Blend(0x00456779, 0x00000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 0
	GFX_Seti(GFX_Smoke[ti_index], 13104, COLOR_Blend(0x80456779, 0x80000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 1
	GFX_Seti(GFX_Smoke[ti_index], 13105, COLOR_Blend(0x00456779, WOR_AmbiantColGet(0) & 0x00FFFFFF, 0.5))	// Color fase 2

	if (f_real_speed > f_wanted_speed * 0.8)
	{
		GFX_Setf(GFX_Smoke[ti_index], 13005, 0.15)														// Creation size min
		GFX_Setf(GFX_Smoke[ti_index], 13006, 0.25)														// Creation size max
	}
	else
	{
		GFX_Setf(GFX_Smoke[ti_index], 13005, 0.5)														// Creation size min
		GFX_Setf(GFX_Smoke[ti_index], 13006, 1.0)														// Creation size max
	}
	
	GFX_Setv(GFX_Smoke[ti_index], 13201, tv_pos_dir + cvector(-1.0, -1.0, -1.0))							// Speed min
	GFX_Setv(GFX_Smoke[ti_index], 13202, tv_pos_dir + cvector(1.0, 1.0, 1.0))								// Speed max
	GFX_Setf(GFX_Smoke[ti_index], 13009, tf_speed * 0.75)							// Norm speed min
	GFX_Setf(GFX_Smoke[ti_index], 13010, tf_speed * 1.5)									// Norm speed max

	tv_wind = Cv_NullVector
	GFX_Setv(GFX_Smoke[ti_index], 13204, tv_pos_dir)												// wind

	tv_pos = @ao_IK_bones[ti_index][2] OBJ_PosGet()
	tv_pos -= tv_wind * TIME_GetDt()
	GFX_Setv(GFX_Smoke[ti_index], 13200, tv_pos) 								// Creation Pos
	GFX_Setv(GFX_Smoke[ti_index], 13207, cvector(0.5, 0.0, 0.0))	// CreaPosAxe X
	GFX_Setv(GFX_Smoke[ti_index], 13208, cvector(0.0, 0.5, 0.0))	// CreaPosAxe Y
	GFX_Setv(GFX_Smoke[ti_index], 13209, cvector(0.0, 0.0, 0.25))	// CreaPosAxe Z
}

procedure_local object	PNJ_Quadri_Rided_Get()
{
	int				ti_rank
	
	object		to_serveur
	object		to_client

	message	tmsg_filter	
	
	messageid	EVT_LNK_RIDE_ON_NMI

	ti_rank = -1
	for (	EVT_LNK_RIDE_ON_NMI = MSG_GlobalScan(Ci_LNK_EVENT_OFFSET + Ci_LNK_RIDE_ON_NMI, &ti_rank);
			MSG_GlobalIsValid(EVT_LNK_RIDE_ON_NMI);
			EVT_LNK_RIDE_ON_NMI = MSG_GlobalScan(Ci_LNK_EVENT_OFFSET + Ci_LNK_RIDE_ON_NMI, &ti_rank))
	{
		to_serveur = MSG_GlobalGetGao(EVT_LNK_RIDE_ON_NMI, SERVEUR)
		if (!to_serveur)
			continue
	
		to_client = MSG_GlobalGetSender(EVT_LNK_RIDE_ON_NMI)
		if (to_client == OBJ_Me())
			continue
	
		if (@to_client AI_IsModel(get_PNJ_Quadri_Path))
			return(to_client)
	}

	return(nobody)
}

procedure_local int PNJ_Quadri_Collision(vector tv_dest_pos)
{
	int		ti_i
	int		ti_k
	int		ti_best_index
	int		ti_flag_distance_mode

	float	tf_time_min
	float	tf_dist
	float	tf_best_dist
	float	tf_collision_delay

	vector	tv_me_to_car
	vector	tv_delta_speed
	vector	tv_my_speed
	vector	tv_collision_pos

	object to_car

//	return(-1)

	ti_best_index = -1
	tf_time_min = Cf_Infinit
	tf_best_dist =	-1.0
	ti_flag_distance_mode = faux

	tv_my_speed = DYN_SpeedGetVector()

	for (ti_i = 0; ti_i < @get_Montures_Manager_Path o_montures_manager i_car_nb; ti_i++)
	{
		if (ti_i == i_my_index)
			continue

		to_car = @get_Montures_Manager_Path o_montures_manager ao_car[ti_i]
	
		if (@to_car OBJ_FlagsControlGet() & (OBJ_C_ControlFlag_ForceInactive | OBJ_C_ControlFlag_SectoInactive))
			continue

		if (COL_ObjectCollide(to_car))
			return(ti_i)
		
		if (MATH_VecDotProduct(@to_car OBJ_PosGet() - OBJ_PosGet(), tv_my_speed) < 0.0)
			continue	

		tf_collision_delay = @get_Montures_Manager_Path o_montures_manager af_car_col_time[i_my_index][ti_i]

		if ( ! tf_collision_delay )
		{
			ti_flag_distance_mode	= vrai
		
//			tf_dist = OBJ_SqrDist(to_car)
//			if (tf_dist < tf_best_dist)
//			{
//				ti_best_index = ti_i
//				tf_best_dist = tf_dist
//			}

			tv_me_to_car = @to_car OBJ_PosGet() - OBJ_PosGet()
			MATH_VecSetHorzNormalize(tv_me_to_car)

			tf_dist = MATH_VecDotProduct(OBJ_SightGet(), tv_me_to_car)
			if (tf_dist > tf_best_dist)
			{
				ti_best_index = ti_i
				tf_best_dist = tf_dist
			}
			
			continue
		}
		else
		{
			if (ti_flag_distance_mode)
				continue	
		
			if (tf_collision_delay > 3.0)
				continue

			if (tf_collision_delay < tf_time_min)
			{
				ti_best_index = ti_i
				tf_time_min = tf_collision_delay
			}
		}
	}
	
	return(ti_best_index)
}

procedure_local vector PNJ_Quadri_Get_Next_Wp_Pos(byref object to_next_wp)
{
	float		tf_left_dist
	float		tf_right_dist
	float		tf_X_min
	float		tf_X_max
	float		tf_X_proj_min
	float		tf_X_proj_max
	float		tf_X_offset

	vector	tv_next_door
	vector	tv_sight
	vector	tv_horizon
	vector	tv_pos
	vector	tv_left_pos
	vector	tv_right_pos

	object	to_next_next_wp

	to_next_wp = o_next_wp
	
	tf_X_offset = COL_ZoneSizeGet(C_zdm_pied) * 2.0

	tf_X_max = @to_next_wp OBJ_ScaleGet().x * 0.2
	tf_X_max -= tf_X_offset
	tf_X_min = -tf_X_max

	while(1)
	{
		to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 0)
		if (WAY_LinkCapaGet(n_course_net, to_next_wp, to_next_next_wp) & OBJ_Capa_0)
			to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 1)

		tv_sight = @to_next_wp OBJ_SightGet()
		tv_horizon = @to_next_wp OBJ_HorizonGet()
		tv_next_door = @to_next_wp OBJ_PosGet()
		tv_next_door.z = OBJ_PosGet().z

		tv_right_pos = tv_next_door
		tv_right_pos += tv_horizon * tf_X_min
		tv_right_pos.z = OBJ_PosGet().z
		if ( ! MATH_LIB_Intersection_Line_Plane(OBJ_PosGet(), tv_right_pos - OBJ_PosGet(), @to_next_next_wp OBJ_PosGet(), @to_next_next_wp OBJ_SightGet(), tf_right_dist, tv_pos) )
			break

		if (tf_right_dist > 0.0)
		{
			tf_X_proj_min = MATH_VecDotProduct(tv_pos - @to_next_next_wp OBJ_PosGet(), @to_next_next_wp OBJ_HorizonGet())
			tf_X_proj_min = MATH_FloatMax(tf_X_offset - (@to_next_next_wp OBJ_ScaleGet().x * 0.2), tf_X_proj_min)
		}
		else
		{
			tf_X_proj_min = tf_X_offset
			tf_X_proj_min -= @to_next_next_wp OBJ_ScaleGet().x * 0.2
		}

		tv_left_pos = tv_next_door
		tv_left_pos += tv_horizon * tf_X_max
		tv_left_pos.z = OBJ_PosGet().z
		if ( ! MATH_LIB_Intersection_Line_Plane(OBJ_PosGet(), tv_left_pos  - OBJ_PosGet(), @to_next_next_wp OBJ_PosGet(), @to_next_next_wp OBJ_SightGet(), tf_left_dist, tv_pos) )
			break

		if (tf_left_dist > 0.0)
		{
			tf_X_proj_max = MATH_VecDotProduct(tv_pos - @to_next_next_wp OBJ_PosGet(), @to_next_next_wp OBJ_HorizonGet())
			tf_X_proj_max = MATH_FloatMin((@to_next_next_wp OBJ_ScaleGet().x * 0.2) - tf_X_offset, tf_X_proj_max)
		}
		else
		{
			tf_X_proj_max = @to_next_next_wp OBJ_ScaleGet().x * 0.2
			tf_X_proj_max -= tf_X_offset
		}

		if (tf_X_proj_min >= tf_X_proj_max || (tf_left_dist < 0.0 && tf_right_dist < 0.0) )
		{
			if (MATH_VecDotProduct(@to_next_next_wp OBJ_PosGet() - tv_next_door, tv_horizon) > 0.0)
				tv_pos = tv_left_pos
			else
				tv_pos = tv_right_pos
			break
		}

//		// DEBUG
//		DBG_RenderVector(tv_right_pos, Cv_VerticalVector * 10.0, color_rouge)
//		DBG_RenderVector(tv_left_pos, Cv_VerticalVector * 10.0, color_vert)
//
//		tv_pos = @to_next_next_wp OBJ_PosGet()
//		tv_pos += tf_X_proj_min * @to_next_next_wp OBJ_HorizonGet()
//		DBG_RenderVector(OBJ_PosGet()+ Cv_VerticalVector, tv_pos - OBJ_PosGet(), color_blanc)
//
//		tv_pos = @to_next_next_wp OBJ_PosGet()
//		tv_pos += tf_X_proj_max * @to_next_next_wp OBJ_HorizonGet()
//		DBG_RenderVector(OBJ_PosGet()+ Cv_VerticalVector, tv_pos - OBJ_PosGet(), color_blanc)
//		// DEBUG

		tf_X_min = tf_X_proj_min
		tf_X_max = tf_X_proj_max
		to_next_wp = to_next_next_wp
	}
	
	return(tv_pos)
}


procedure_local void PNJ_Quadri_DBG_Render_Full_Lap_Trajectory(float tf_course_pilotage_coef)
{
	float		tf_coef
	float		tf_link_length	
	float		tf_dot_product
	float		tf_anticipation_dist
	float		tf_coef_A
	float		tf_coef_B
	float		tf_coef_C
	float		tf_coef_D
	float		tf_zdm_size

	vector	tv_link
	vector	tv_pos
	
	vector	tv_A
	vector	tv_B
	vector	tv_C
	vector	tv_D
	vector	tv_sight

	object	to_current_wp
	object	to_next_wp
	object	to_next_next_wp

	int		ti_color

//	switch(i_my_index)
//	{
//		case 0 :
//			ti_color = 0x000000FF
//			break
//		case 1 :
//			ti_color = 0x0000FF00
//			break
//		case 2 :
//			ti_color = 0x00FF0000
//			break
//		case 3 :
//			ti_color = 0x0000FFFF
//			break
//		case 4 :
//			ti_color = 0x00FFFF00
//			break
//		case 5 :
//			ti_color = 0x00FFFFFF
//			break
//		case 6 :
//			ti_color = 0x00008080
//			break
//		case 7 :
//			ti_color = 0x00808000
//			break
//		case 8 :
//			ti_color = 0x00808080
//			break
//	}

	ti_color = COLOR_Blend(color_rouge, color_vert, (tf_course_pilotage_coef + 1.0) * 0.5)
	DBG_RenderSphere(OBJ_PosGet(), 2.0, ti_color)

	tf_zdm_size = COL_ZoneSizeGet(C_zdm_pied)
	tf_zdm_size *= 2.0

	to_current_wp = WAY_RootGet(n_course_net)
	to_next_wp = WAY_NetNextWP(n_course_net, to_current_wp, NetNextWP_Mode_choix_de_lindice, 0)
	if (WAY_LinkCapaGet(n_course_net, to_current_wp, to_next_wp) & OBJ_Capa_0)
		to_next_wp = WAY_NetNextWP(n_course_net, to_current_wp, NetNextWP_Mode_choix_de_lindice, 1)
	to_next_next_wp = nobody

	while(to_next_next_wp == nobody || to_current_wp != WAY_RootGet(n_course_net))
	{
		tv_link = @to_next_wp OBJ_PosGet() - @to_current_wp OBJ_PosGet()
		tf_link_length = WAY_LinkWeightGet(n_course_net, to_current_wp, to_next_wp)
		tv_link /= tf_link_length

		to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 0)
		if (WAY_LinkCapaGet(n_course_net, to_next_wp, to_next_next_wp) & OBJ_Capa_0)
			to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 1)

		tv_A	= @to_current_wp OBJ_PosGet()
		tf_coef_A = @to_current_wp OBJ_ScaleGet().x * 0.2
		tf_coef_A = MATH_FloatMax(tf_coef_A - tf_zdm_size, 0.0)
		tf_coef_A *= MATH_FloatSign(MATH_VecDotProduct(@to_next_wp OBJ_PosGet() - tv_A, @to_current_wp OBJ_HorizonGet()))
		tf_coef_A *= tf_course_pilotage_coef
//		tf_coef = MATH_VecDotProduct(@to_current_wp OBJ_SightGet(), @to_next_wp OBJ_SightGet())
//		tf_coef *= tf_coef
////		tf_coef *= 10.0
//		tf_coef_A *= 1.0 - tf_coef
		tv_A += tf_coef_A * @to_current_wp OBJ_HorizonGet()
	
		tv_D = @to_next_wp OBJ_PosGet()
		tf_coef_D = @to_next_wp OBJ_ScaleGet().x * 0.2
		tf_coef_D = MATH_FloatMax(tf_coef_D - tf_zdm_size, 0.0)
		tf_coef_D *= MATH_FloatSign(MATH_VecDotProduct(@to_next_next_wp OBJ_PosGet() - tv_D, @to_next_wp OBJ_HorizonGet()))
		tf_coef_D *= tf_course_pilotage_coef
//		tf_coef = MATH_VecDotProduct(@to_next_wp OBJ_SightGet(), @to_next_next_wp OBJ_SightGet())
//		tf_coef *= tf_coef
////		tf_coef *= 10.0
//		tf_coef_D *= 1.0 - tf_coef
		tv_D += tf_coef_D * @to_next_wp OBJ_HorizonGet()
	
		tf_link_length = MATH_VecNorm(tv_D - tv_A)

		tf_coef_B = 0.33 * tf_link_length
		tf_coef_C = 0.33 * tf_link_length
		
		tv_B = tv_A + (@to_current_wp OBJ_SightGet() * tf_coef_B)
		tv_C = tv_D - (@to_next_wp OBJ_SightGet() * tf_coef_C)
	
//		tv_A.z = OBJ_PosGet().z + 1.0
//		tv_B.z = tv_A.z
//		tv_C.z = tv_A.z
//		tv_D.z = tv_A.z
	
		MATH_LIB_Bezier_Display(5, tv_A, tv_B, tv_C, tv_D, ti_color)
		
		to_current_wp = to_next_wp
		to_next_wp = to_next_next_wp
	}
}

procedure_local vector PNJ_Quadri_Get_Target_Pos(float tf_course_pilotage_coef)
{
	float		tf_coef
	float		tf_link_length	
	float		tf_dot_product
	float		tf_anticipation_dist
	float		tf_coef_A
	float		tf_coef_B
	float		tf_coef_C
	float		tf_coef_D
	float		tf_zdm_size

	vector	tv_link
	vector	tv_pos
	
	vector	tv_A
	vector	tv_B
	vector	tv_C
	vector	tv_D
	vector	tv_sight

	object	to_current_wp
	object	to_next_wp
	object	to_next_next_wp

	if ( ! o_current_wp )
		return(OBJ_PosGet())

	PNJ_Quadri_DBG_Render_Full_Lap_Trajectory(tf_course_pilotage_coef)

	if (tf_course_pilotage_coef > 0.0)
	{
		tv_pos = PNJ_Quadri_Get_Next_Wp_Pos(to_next_wp)
		tv_sight = tv_pos - OBJ_PosGet()
		tv_sight.z = 0.0
		tf_link_length = MATH_VecSquareNorm(tv_sight) 
		if (tf_link_length > 900.0)
		{
//			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_pos - OBJ_PosGet(), color_blanc)	
		
			tf_link_length = MATH_FloatSqrt(tf_link_length)
			tv_sight /= tf_link_length
	
			tf_anticipation_dist = MATH_FloatBlend(30.0, 100.0, 0.5 + (tf_course_pilotage_coef * 0.5))
			tf_anticipation_dist = MATH_FloatLimit(MATH_VecDotProduct(DYN_SpeedGetVector(), tv_sight), 10.0, tf_anticipation_dist)
			
			tv_pos = OBJ_PosGet()
			tv_pos += tv_sight * tf_anticipation_dist
	
//			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_pos - OBJ_PosGet(), color_cyan)
			return(tv_pos)
		}
	}

	tf_zdm_size = COL_ZoneSizeGet(C_zdm_pied) 
	tf_zdm_size *= 2.0

	to_current_wp = o_current_wp
	to_next_wp = o_next_wp

	tv_link = @to_next_wp OBJ_PosGet()  - @to_current_wp OBJ_PosGet()
	tf_link_length = WAY_LinkWeightGet(n_course_net, to_current_wp, to_next_wp)
//	tf_link_length = MATH_VecNorm(tv_link)
	tv_link /= tf_link_length

	tf_anticipation_dist = MATH_FloatBlend(30.0, 100.0, 0.5 + (tf_course_pilotage_coef * 0.5))
	tf_anticipation_dist = MATH_FloatLimit(MATH_VecDotProduct(DYN_SpeedGetVector(), tv_link), 10.0, tf_anticipation_dist)
	tf_anticipation_dist += MATH_VecDotProduct(OBJ_PosGet() - @to_current_wp OBJ_PosGet(), tv_link)

	while(tf_anticipation_dist > tf_link_length)
	{
		tf_anticipation_dist -= tf_link_length
	
		to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 0)
		if (WAY_LinkCapaGet(n_course_net, to_next_wp, to_next_next_wp) & OBJ_Capa_0)
			to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 1)

		to_current_wp = to_next_wp
		to_next_wp = to_next_next_wp

		tv_link = @to_next_wp OBJ_PosGet()  - @to_current_wp OBJ_PosGet()
		tf_link_length = WAY_LinkWeightGet(n_course_net, to_current_wp, to_next_wp)
//		tf_link_length = MATH_VecNorm(tv_link)
		tv_link /= tf_link_length

		tf_dot_product	 = MATH_VecDotProduct(OBJ_PosGet() - @to_current_wp OBJ_PosGet(), tv_link)
	}

	tf_coef = tf_anticipation_dist
	tf_coef /= tf_link_length
	
	to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 0)
	if (WAY_LinkCapaGet(n_course_net, to_next_wp, to_next_next_wp) & OBJ_Capa_0)
		to_next_next_wp = WAY_NetNextWP(n_course_net, to_next_wp, NetNextWP_Mode_choix_de_lindice, 1)

	tv_A	= @to_current_wp OBJ_PosGet()
	tf_coef_A = @to_current_wp OBJ_ScaleGet().x * 0.2
	tf_coef_A = MATH_FloatMax(tf_coef_A - tf_zdm_size, 0.0)
	tf_coef_A *= MATH_FloatSign(MATH_VecDotProduct(@to_next_wp OBJ_PosGet() - tv_A, @to_current_wp OBJ_HorizonGet()))
	tf_coef_A *= tf_course_pilotage_coef
	tv_A += tf_coef_A * @to_current_wp OBJ_HorizonGet()

	tv_D = @to_next_wp OBJ_PosGet()
	tf_coef_D = @to_next_wp OBJ_ScaleGet().x * 0.2
	tf_coef_D = MATH_FloatMax(tf_coef_D - tf_zdm_size, 0.0)
	tf_coef_D *= MATH_FloatSign(MATH_VecDotProduct(@to_next_next_wp OBJ_PosGet() - tv_D, @to_next_wp OBJ_HorizonGet()))
	tf_coef_D *= tf_course_pilotage_coef
	tv_D += tf_coef_D * @to_next_wp OBJ_HorizonGet()

//	tf_coef_B = 1.0 / f_rand_speed_coef
//	tf_coef_B *= tf_coef_B
//	tf_coef_B *= 0.33 * tf_link_length
	tf_coef_B = 0.33 * tf_link_length

//	tf_coef_C = f_rand_speed_coef
//	tf_coef_C *= tf_coef_C
//	tf_coef_C *= 0.33 * tf_link_length
	tf_coef_C = 0.33 * tf_link_length
	
	tv_B = tv_A + (@to_current_wp OBJ_SightGet() * tf_coef_B)
	tv_C = tv_D - (@to_next_wp OBJ_SightGet() * tf_coef_C)

	tv_A.z = OBJ_PosGet().z + 1.0
	tv_B.z = tv_A.z
	tv_C.z = tv_A.z
	tv_D.z = tv_A.z

//	// DBG ====================================
//	MATH_LIB_Bezier_Display(10, tv_A, tv_B, tv_C, tv_D, color_rouge)
//	// DBG ====================================

	tv_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_A, tv_B, tv_C, tv_D, tv_sight)

	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_pos - OBJ_PosGet(), color_rouge)	

	return	(tv_pos)
}

procedure_local void PNJ_Quadri_Clean_GFX()
{
	int		ti_i

	if (GFX_Halo_G != -1)
	{
		GFX_Del(GFX_Halo_G)
		GFX_Halo_G = -1
	}

	if (GFX_Halo_D != -1)
	{
		GFX_Del(GFX_Halo_D)
		GFX_Halo_D = -1
	}

	for (ti_i = 0; ti_i < 4; ti_i++)
	{
		if (GFX_Smoke[ti_i] != -1)
		{
			GFX_Seti(GFX_Smoke[ti_i], 13106, 0)
			GFX_Smoke[ti_i] = -1
		}
	}
}