Include_UltraProcedure_Header

vector		tv_good_pos
int				ti_loop
int				ti_ok
float			tf_dist
vector		tv_normale
vector		tv_droite
vector		tv_point
object		to_perso
object		to_camera
vector		tv_axis

vector		tv_point_if_not_found
int				ti_ok_if_not_found

// ========= EXEC TRACK BEFORE ===========
if (fct_before)	AI_Execute(fct_before)
// ========= EXEC TRACK BEFORE ===========

to_camera = @get_global o_camera

if (f_active_time_cur<0)		f_active_time_cur = -f_active_time_cur
f_active_time_cur -= MATH_FloatMin(f_active_time_cur, TIME_GetDt())

if (f_autodestroy_life_time >= 0)
{
	// Destruction qd le temps arrive a 0
	f_autodestroy_life_time -= MATH_FloatMin(f_autodestroy_life_time, TIME_GetDt())
}

if (!f_k_GC_TransitionSpeed_In) f_k_GC_TransitionSpeed_In = Cf_Infinit
if (!f_k_GC_TransitionSpeed_Out) f_k_GC_TransitionSpeed_Out = Cf_Infinit
//if (!f_Fight_TransitionSpeed ) f_Fight_TransitionSpeed = Cf_Infinit

// Common
@get_Kamera_Path to_camera o_cc_kam_modifier = OBJ_Me()
@get_Kamera_Path to_camera o_cc_external = o_cam_pos
@get_Kamera_Path to_camera i_cc_kam_KamModifierID_Cur = i_cc_kam_KamModifierID
@get_Kamera_Path to_camera i_cc_kam_modifier_prio = i_prio_modifier_actif
@get_Kamera_Path to_camera f_k_GC_TransitionSpeed_In = f_k_GC_TransitionSpeed_In
@get_Kamera_Path to_camera f_k_GC_TransitionSpeed_Out = f_k_GC_TransitionSpeed_Out
@get_Kamera_Path to_camera i_k_GC_active_occlution = i_k_GC_active_occlution

@get_Kamera_Path to_camera f_cut_if_backshoot = f_cut_if_backshoot 				// Flag & Angle de BackShoot

@get_Kamera_Path to_camera i_kam_family = i_KM_family

@get_Kamera_Path to_camera o_k_GC_fixe_target = o_k_GC_fixe_target

for (ti_loop = 0 ; ti_loop<10; ti_loop++)
{
	@get_Kamera_Path to_camera ATM_KamTransitionFrom[ti_loop] = ATM_KamTransitionFrom[ti_loop]
	if (!ATM_KamTransitionSpeed[ti_loop]) ATM_KamTransitionSpeed[ti_loop] = Cf_Infinit
	@get_Kamera_Path to_camera ATM_KamTransitionSpeed[ti_loop] = ATM_KamTransitionSpeed[ti_loop]
}

@get_Kamera_Path to_camera f_k_GC_DecentrageHorizCoef = f_k_GC_DecentrageHorizCoef 
@get_Kamera_Path to_camera f_k_GC_DecentrageVertiCoef = f_k_GC_DecentrageVertiCoef
@get_Kamera_Path to_camera i_k_GC_offsetZ_Local = i_k_GC_offsetZ_Local

// Pour que le LR ne parte qu'avant ANN et pas entre ANN & KONG
if (i_RefAxis_AKA_OcclutionAvantAnnUniquement && i_RefAxis_mode == 3)
	@get_Kamera_Path to_camera o_k_GC_active_occlution = o_RefAxis_AKA_Ann

//if (!i_Fight_UseSpecialParameter || !@get_Kamera Proc_Kam_IsInFIGHT_Get())
//{
//	// HORS FIGHT ou PAS DE PARAM SPECIFIQUE
//	@get_Kamera_Path to_camera i_k_GC_include_all_ennemies = i_k_GC_include_all_ennemies
//	if (f_INOUT_Blend_Tgt)
//		f_INOUT_Blend_Blend = 0.0
//	f_INOUT_Blend_Tgt = 0.0
//}
//else
//{
//	// IN FIGHT
//	@get_Kamera_Path to_camera i_k_GC_include_all_ennemies = i_k_GC_Finclude_all_ennemies
//	if (f_INOUT_Blend_Tgt != 1.0)
//		f_INOUT_Blend_Blend = 0.0
//	f_INOUT_Blend_Tgt = 1.0
//}

//f_INOUT_Blend_Blend = MATH_FloatBlend(f_INOUT_Blend_Blend, f_Fight_TransitionSpeed, 4.0 * f_kam_infinit * TIME_GetDt())		// Speed du blend
//f_INOUT_Blend = MATH_FloatBlend(f_INOUT_Blend, f_INOUT_Blend_Tgt, f_INOUT_Blend_Blend * f_kam_infinit * TIME_GetDt())			// Progression

//@get_Kamera_Path to_camera f_k_GC_dist_max_a_kong = MATH_FloatBlend(f_k_GC_dist_max_a_kong, f_k_GC_Fdist_max_a_kong, f_INOUT_Blend)
//@get_Kamera_Path to_camera f_k_GC_dist_max_apres_la_cam = MATH_FloatBlend(f_k_GC_dist_max_devant_la_cam, f_k_GC_Fdist_max_devant_la_cam, f_INOUT_Blend)
//@get_Kamera_Path to_camera f_k_GC_dist_max_avant_la_cam = MATH_FloatBlend(f_k_GC_dist_max_derriere_la_cam, f_k_GC_Fdist_max_derriere_la_cam, f_INOUT_Blend)
//@get_Kamera_Path to_camera f_k_GC_recul_max_all_ennemies = MATH_FloatBlend(f_k_GC_recul_max_all_ennemies, f_k_GC_Frecul_max_all_ennemies, f_INOUT_Blend)
//@get_Kamera_Path to_camera f_k_GC_cam_focale = MATH_FloatBlend(f_k_GC_cam_focale, f_k_GC_Fcam_focale, f_INOUT_Blend)
//@get_Kamera_Path to_camera f_k_GC_look_amplitude  = MATH_FloatBlend(f_k_GC_look_amplitude,f_k_GC_Flook_amplitude, f_INOUT_Blend)
//@get_Kamera_Path to_camera f_k_GC_offsetZ = MATH_FloatBlend(f_k_GC_offsetZ, f_k_GC_FoffsetZ, f_INOUT_Blend)

@get_Kamera_Path to_camera f_k_GC_dist_max_a_kong = f_k_GC_dist_max_a_kong
@get_Kamera_Path to_camera f_k_GC_dist_max_apres_la_cam = f_k_GC_dist_max_devant_la_cam
@get_Kamera_Path to_camera f_k_GC_dist_max_avant_la_cam = f_k_GC_dist_max_derriere_la_cam
//@get_Kamera_Path to_camera f_k_GC_recul_max_all_ennemies = f_k_GC_recul_max_all_ennemies
@get_Kamera_Path to_camera f_k_GC_cam_focale = f_k_GC_cam_focale
@get_Kamera_Path to_camera f_k_GC_look_amplitude  = f_k_GC_look_amplitude
@get_Kamera_Path to_camera f_k_GC_offsetZ = f_k_GC_offsetZ


if (i_nbr_wp)
{
	// Il y a NETWORK ------------------------------------------------------------------------------------

	to_perso = Proc_Kam_ActeurReference_Get()

	v_pos_kong = MATH_VecBlend(v_pos_kong, @to_perso OBJ_PosGet(), 100.0 * f_kam_infinit * TIME_GetDt()) 

	if (i_fixed_axis)
		tv_axis = -@o_ref_axis OBJ_SightGet()
	else
		tv_axis = MATH_VecNormalize( v_pos_kong - @o_ref_axis OBJ_PosGet() )
	tv_normale = MATH_VecCrossProduct(tv_axis, Cv_VerticalVector)
	
	#ifndef _FINAL_ // -----------------------------------------------------------------------------------------------------
	if (debug_show_axis_on_ActeurReference)
	{
		DBG_RenderVector(v_pos_kong+Cv_VerticalVector, tv_axis * 100, color_vert)
		if (	!i_axis_single_direction)
			DBG_RenderVector(v_pos_kong+Cv_VerticalVector, -tv_axis * 100, color_vert)
	}
	#endif // -------------------------------------------------------------------------------------------------------------------
			
	ti_ok_if_not_found = faux
	ti_ok = faux
	for (ti_loop = 1; ti_loop < i_nbr_wp; ti_loop ++)	
	{
		//procedure int MATH_LIB_Intersection_Line_Plane(vector tv_start_pos, vector tv_dir, vector tv_plan_pos, vector tv_plan_normale, byref float tf_dist, byref vector tv_collide_pos)
		ti_ok = MATH_LIB_Intersection_Line_Plane(@o_WP_liste[ti_loop-1] OBJ_PosGet(), v_axis_norm[ti_loop-1], v_pos_kong, tv_normale, tf_dist, tv_point)
		if ( ti_loop == 1 && tf_dist<= 0 )
		{
			// Snap sur le premier point
			tv_point = @o_WP_liste[ti_loop-1] OBJ_PosGet()
			tv_droite = tv_point - v_pos_kong
			tv_droite.z = 0
			if ( !i_axis_single_direction || MATH_VecDotProduct(tv_droite, tv_axis)>0 )
			{
				ti_ok_if_not_found = vrai
				tv_point_if_not_found = tv_point
			}
		}
		else if (ti_ok && (tf_dist>= 0 && tf_dist<= f_dist[ti_loop-1]))
		{
			// Ok ce WP est bon on le valide
			tv_droite = tv_point - v_pos_kong
			tv_droite.z = 0
			if ( !i_axis_single_direction || MATH_VecDotProduct(tv_droite, tv_axis)>0 )
				break	
			else
				ti_ok = faux
		}
		else
			// Non toujours rien
			ti_ok = faux
	}

	if (ti_ok)
		tv_good_pos = tv_point														// Ok le WP est trouvé
	else if (ti_ok_if_not_found)
		tv_good_pos = tv_point_if_not_found									// Si au debut on etait a une extremité et qu'on a backuppé on recup cette position
	else		
		tv_good_pos = @o_WP_liste[ti_loop-1] OBJ_PosGet()			// On a rien trouvé donc c'est donc le dernier

	#ifndef _FINAL_ // -----------------------------------------------------------------------------------------------------
	if (debug_show_axis_on_ActeurReference)
		DBG_RenderSphere(tv_good_pos,2.0,color_vert)
	#endif  // -----------------------------------------------------------------------------------------------------
}
else
{
	// Cas c'est un WP SIMPLE ----------------------------------------------------------------------
	tv_good_pos = @o_wp_reseau_pos OBJ_PosGet()
}
	
@o_cam_pos OBJ_PosSet( MATH_VecBlend(@o_cam_pos OBJ_PosGet(), tv_good_pos, 20.0 * f_kam_infinit * TIME_GetDt() ) )	// Blend

f_kam_infinit = 1.0
i_active = vrai

// ========= EXEC TRACK AFTER ===========
if (fct_after)	AI_Execute(fct_after)
// ========= EXEC TRACK AFTER ===========