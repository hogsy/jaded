//#include "Kam_Defines.var"
//
//// ###############################
//// PLAN CUT - PLAN CUT - PLAN CUT
//// ###############################
//
//// Int1 		bit 0 = 1 >> Smooth sinon CUT
//// Int1 		bit 1 = 1 >> Target Non dynamique
//// Int2			Indice du Module sur le GAO Target
//// Int3			Indice du plan
//
//// Gao1		Gao Target
//
//// Vec1.x 	Vitesse du Smooth (utile uniquement en Smoth)
//// Vec1.y 	Distance de la cam a la target
//// Vec1.z 	Durée du Plan
//// Vec2		Axe de la camera
//// Vec3		Offset local a l'os ciblé
//
//int				ti_flags 
//object		to_gao 
//int				ti_module
//vector		tv_vec
//vector		tv_cam_axis
//vector		tv_cam_target_delta_tgt
//
//// Backup Gao pour les Transitions specifique en mode CChant
//o_cc_kam_modifier_old = nobody
//
//ti_flags = m_msg_plan_cut.msg_int1
//
//if (m_msg_plan_cut.msg_id)
//	i_kong_camera_mode = -1
//
//// Position de la TARGET
//if (i_kong_camera_mode != Ci_Kamera_mode_CUT || (!(ti_flags & 0b0010)) )
//{
//	to_gao = m_msg_plan_cut.msg_gao1
//	v_MECA_cam_target = @to_gao OBJ_PosGet()
//
//	ti_module = m_msg_plan_cut.msg_int2
//	if (ti_module >= 0)
//	{
//		to_gao = @to_gao ANI_CanalObjectGet(ti_module)
//		v_MECA_cam_target = @to_gao OBJ_PosGet()
//	}
//	v_MECA_cam_target += @to_gao MATH_VecLocalToGlobal(	vL_plan_cut_offset )
//}
//
//if (i_kong_camera_mode != Ci_Kamera_mode_CUT)
//{
//	// Init
//	i_kong_camera_mode = Ci_Kamera_mode_CUT
//
//	if (ti_flags & 0b0001)
//	{
//		f_chm_coef = 0									// Smooth
//		f_MECA_cam_dist_speed = 10
//	}
//	else
//	{
//		f_chm_coef = 1									// Cut
//		f_MECA_cam_dist_speed = Cf_Infinit
//	}
//
//	tv_vec = m_msg_plan_cut.msg_vec1
//	vL_plan_cut_offset = m_msg_plan_cut.msg_vec3
//	f_change_mode_speed = tv_vec.x
//	f_MECA_cam_dist = tv_vec.y
//	f_plan_cut_duration = tv_vec.z
//}
//
//i_ask_cut = vrai
//
//f_chm_coef = MATH_FloatLimit( f_chm_coef + (f_change_mode_speed * TIME_GetDt()),0, 1)
//
//// Axe donné par le Message
//tv_cam_axis = m_msg_plan_cut.msg_vec2
//
//// Pas d'offset
//tv_cam_target_delta_tgt = Cv_NullVector
//
//v_MECA_cam_sight = MATH_VecBlendRotate(v_MECA_cam_sight , tv_cam_axis, f_chm_coef)			// Blend SIGHT pour les changements de mode.
//v_MECA_cam_target_delta = MATH_VecBlend(v_MECA_cam_target_delta, tv_cam_target_delta_tgt, f_chm_coef)	// Blend DELTA pour les changements de mode.
//
//f_plan_cut_duration -= TIME_GetDt()
//
//f_MECA_cam_focale = 1.2