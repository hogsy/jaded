Include_UltraProcedure_Header
#include "Kam_Defines.var"

vector		tv_meca_cam_target
vector		tv_meca_cam_target_delta
vector		tv_meca_cam_sight
float			tf_meca_cam_dist
float			tf_meca_cam_focale
//float			tf_meca_cam_transitionspeed


object		to_gao_contre_champ
vector		tv_gao_contre_champ_to_kong
vector		tv_gao_contre_champ
int				ti_include_all_ennemies
vector		tv_joyD
float			tf_meca_cam_targetz
float			tf_meca_cam_targetz_norm
float			tf_additionnal_dist 
float			tf_dot_target

//object		to_cc_target
float			tf_cc_target_deltaZ

vector		tv_cam_pos
vector		tv_cross

object		to_ann_module
vector		tv_summ 
int				ti_loop
vector		tv_cc_kong, tv_cc_cam
vector		tv_cc_SRC_offset
vector		tv_axe_kong
float			tf_cc_SRC_dist
float			tf_cc_dist_max_a_kong, tf_cc_dist_max_apres_la_cam, tf_cc_dist_max_avant_la_cam
vector		tv_cc_pos_cam, tv_cc_pos_apres
float			tf_dist_all_ennemies

float			tf_zz

float			tf_k_GC_DecentrageHorizCoef
float			tf_k_GC_DecentrageVertiCoef
int				ti_k_GC_offsetZ_Local
int				ti_dodge_on

int				ti_id

object		to_jack
object		to_kong
object		to_kindigene_3rdP

if (f_kam_infinit)
{
	i_Kamera_mode_init_flag = vrai
	f_Kamera_mode_init_infini = Cf_Infinit
	f_kam_infinit = 0
}

// Acteur filmé par la Kaméra (KONG par DEFAUT)
if (o_k_GC_fixe_target)
{
	o_mf_actor = o_k_GC_fixe_target					// FREE
	tf_cc_target_deltaZ = 0.0								// Delta FREE
}
else if (i_cc_cam_sur_ann_old && i_cc_type == 2 && to_jack)
{
	// GenCam KANN
//	o_mf_actor = get_Kann									// ANN
	o_mf_actor = to_jack
	tf_cc_target_deltaZ = Cf_Kamera_Z_Ann			// Delta ANN
}
else
	tf_cc_target_deltaZ = Cf_Kamera_Z_Ray			// Delta Ray

if (@get_global i_frame_nbr < 15)
	f_cc_meca_cam_transitionspeed = Cf_Infinit

// INIT --------------------------------------------------------------------------------------------------------------------------------------------
if ( (i_kong_camera_mode != Ci_Kamera_mode_CC || i_cc_type != i_cc_type_old ) ||  (o_cc_kam_modifier_old != o_cc_kam_modifier && i_cc_type == 2) )
{
	// INIT du MODE ou CHANGEMENT de PARAM
	KamP_Mode_Set(Ci_Kamera_mode_CC)

	// Backup des Valeurs pour le BLEND entre les modes
	KamP_Backup_Change_Mode_Value()
	
	KamP_JoyD_BlendSet(8.0, 8.0, 4.0, 4.0)

	// Transition SPEED --------------------------------------------------------------
	if (f_chm_speed_forced >= 0)
	{
		// Transition en Entrée Forcé !
		f_cc_meca_cam_transitionspeed = f_chm_speed_forced
		if (!f_cc_meca_cam_transitionspeed)
			f_cc_meca_cam_transitionspeed = Cf_Infinit
	}
	else
//		// Transition en Entrée Precisé par le Kam_Modifier
//		f_cc_meca_cam_transitionspeed = f_k_GC_TransitionSpeed_In
//    else
	{
		// Transition en Entrée Precisé par le Kam_Modifier
		if (o_cc_kam_modifier_old)
		{
			ti_id = ARR_ObjSearch(&ATM_KamTransitionFrom[0],10,o_cc_kam_modifier_old)
			if (ti_id >= 0)
				f_k_GC_TransitionSpeed_In = ATM_KamTransitionSpeed[ti_id]
		}
		f_cc_meca_cam_transitionspeed = f_k_GC_TransitionSpeed_In
	}

	o_cc_kam_modifier_old = o_cc_kam_modifier

	f_chm_speed_forced = f_k_GC_TransitionSpeed_Out			// Transition en Sortie (Transition forcé a l'entrée)

	if (i_cc_cam_sur_ann_old)
	{
		// Cam ANN !
		f_cc_meca_cam_transitionspeed = Cf_Infinit
		f_chm_speed_forced = Cf_Infinit
	}
	// Transition SPEED --------------------------------------------------------------

}
// INIT --------------------------------------------------------------------------------------------------------------------------------------------

if (i_cc_type == 1 && to_jack )
{
	// Param Ann
	DBG_Error("Ce mode de cam ne devrait plus etre utilisé")
//	to_gao_contre_champ = get_Kann
	to_gao_contre_champ = to_jack
	@to_gao_contre_champ OBJ_FlagsTypeSet(none, OBJ_C_TypeFlag_DodgeCamera)
	tv_gao_contre_champ = @to_gao_contre_champ OBJ_PosGet()

	tv_cc_SRC_offset = @to_gao_contre_champ OBJ_SightGet() * 0.75
	tv_cc_SRC_offset *= MATH_AbsFloat( MATH_VecDotProduct(OBJ_HorizonGet(),@to_gao_contre_champ OBJ_SightGet()) )
//	to_ann_module = @get_Kann ANI_CanalObjectGet(Anim_Canal_Torse)
//	tv_cc_SRC_offset.z = @to_ann_module OBJ_PosGet().z - @get_Kann OBJ_PosGet().z //   0.5 //1.1
// VINC
//	to_kindigene_3rdP = @to_jack Proc_Joueur_3rdP_GaoGet()
//	to_ann_module = @to_kindigene_3rdP ANI_CanalObjectGet(Anim_Canal_Torse)
	
	tv_cc_SRC_offset.z = @to_ann_module OBJ_PosGet().z - @to_kindigene_3rdP OBJ_PosGet().z //   0.5 //1.1
	tv_cc_SRC_offset.z += 0.2
	tf_cc_SRC_dist = 0 //0.5 + tv_cc_SRC_offset.z
	tf_additionnal_dist = 1.5

	tf_cc_dist_max_a_kong = 0
	tf_cc_dist_max_apres_la_cam = 0
	tf_cc_dist_max_avant_la_cam = 0
	ti_include_all_ennemies = faux
	f_k_GC_look_amplitude = 0
	i_MECA_TestRayCast = faux
	if( o_cc_ann_look_obj )
		o_mf_actor = o_cc_ann_look_obj		// l'acteur filmé est l'acteur regardé par ANN
	tf_meca_cam_focale = 0.8
//	tf_meca_cam_transitionspeed = Cf_Infinit
//	f_normal_change_mode_speed_forced = Cf_Infinit
	tf_meca_cam_targetz = 0

	tf_k_GC_DecentrageHorizCoef = 1.0
	tf_k_GC_DecentrageVertiCoef = 1.0
	ti_k_GC_offsetZ_Local = vrai
	ti_dodge_on = vrai

}
else if (i_cc_type == 2)
{
	// Param GenCam
	to_gao_contre_champ = o_cc_external_gao
	tv_gao_contre_champ = @to_gao_contre_champ OBJ_PosGet()

	tv_cc_SRC_offset = Cv_NullVector													// Offset sur le point source
	tf_cc_SRC_dist = 0

	tf_additionnal_dist = 0

	if (o_cc_kam_modifier == OBJ_Me())
	{
		tv_cc_SRC_offset = cvector(0,0,0)
		tf_additionnal_dist = 3.0
	}

	// Contraintes
	tf_cc_dist_max_a_kong = f_k_GC_dist_max_a_kong							// Contrainte #1
	tf_cc_dist_max_apres_la_cam = f_k_GC_dist_max_apres_la_cam		// Contrainte #2
	tf_cc_dist_max_avant_la_cam= f_k_GC_dist_max_avant_la_cam			// Contrainte #3

	// Include all ennemies ?
	ti_include_all_ennemies = i_k_GC_include_all_ennemies 					// Flag qui demande d'inclure tous les ennemis

//	// Transition SPEED --------------------------------------------------------------
//	if (@get_global i_frame_nbr < 15)
//		tf_meca_cam_transitionspeed = Cf_Infinit
//	else  if (f_normal_change_mode_speed_forced >= 0)
//		// Transition en Entrée Forcé !
//		tf_meca_cam_transitionspeed = f_normal_change_mode_speed_forced		
//	else
//		// Transition en Entrée Precisé par le Kam_Modifier
//		tf_meca_cam_transitionspeed = f_k_GC_TransitionSpeed_In
//	f_normal_change_mode_speed_forced = f_k_GC_TransitionSpeed_Out			// Transition en Sortie (Transition forcé a l'entrée)
//	
//	if (i_cc_cam_sur_ann_old)
//	{
//		// Cam ANN !
//		tf_meca_cam_transitionspeed = Cf_Infinit
//		f_normal_change_mode_speed_forced = Cf_Infinit
//	}
//	// Transition SPEED --------------------------------------------------------------
	
	// Collision sur decors
	i_MECA_TestRayCast = i_k_GC_active_occlution

	// Prio du Gencam (pour hysteresis)
	if (i_cc_kam_modifier_prio)
		@o_cc_kam_modifier AI_PrioritySet(i_cc_kam_modifier_prio)
//	o_cc_kam_modifier_old = o_cc_kam_modifier // FRED apres Kanada

	// Focale
	tf_meca_cam_focale = f_k_GC_cam_focale

	tf_k_GC_DecentrageHorizCoef = f_k_GC_DecentrageHorizCoef
	tf_k_GC_DecentrageVertiCoef = f_k_GC_DecentrageVertiCoef
	ti_k_GC_offsetZ_Local = i_k_GC_offsetZ_Local 

	ti_dodge_on = i_k_GC_Dodge_on

	// Pour targeter + haut ou plus bas
	tf_meca_cam_targetz = f_k_GC_offsetZ
}

// --- Perso TARGET --------------------------------------------------------------------------------------------------
if (o_cc_kam_modifier == OBJ_Me())
	tf_zz = 2.0
else 
	tf_zz = 1.0
tv_meca_cam_target = KamP_TargetGao_BlendPosGet(o_mf_actor, Cf_BlendPos_DefaultSpeed * tf_zz)
DBG_RenderSphere(tv_meca_cam_target, 1.0, color_jaune)
// --- Perso TARGET --------------------------------------------------------------------------------------------------


// Coef axe horiz visee kong / horiz camera
tv_axe_kong = @o_mf_actor OBJ_SightGet()
if ( i_kong_camera_status_new != Ci_Kcamera_walling)
	tv_axe_kong.z = 0
if (MATH_VecNull(tv_axe_kong))
	tv_axe_kong = -@o_mf_actor OBJ_BankingGet()
if ( i_kong_camera_status_new != Ci_Kcamera_walling)
	MATH_VecSetHorzNormalize(tv_axe_kong)
else
	MATH_VecSetNormalize(tv_axe_kong)

if (i_LockKam_Nbr && o_mf_actor == to_kong)
{
	tv_summ = Cv_NullVector
	for (ti_loop = 0 ; ti_loop < i_LockKam_Nbr ;  ti_loop ++)
		tv_summ += av_LockKam_Pos[ti_loop]
	tv_summ /= i_LockKam_Nbr
	tv_axe_kong = tv_summ - @o_mf_actor OBJ_PosGet()
	tv_axe_kong.z = 0
	if (MATH_VecNull(tv_axe_kong))
		tv_axe_kong = @o_mf_actor OBJ_SightGet()
	else
		MATH_VecSetNormalize(tv_axe_kong)
}

if ( f_LockKam_Blend )
	v_axe_kong_smooth = MATH_VecBlendRotate(tv_axe_kong, v_axe_kong_smooth, f_LockKam_Blend)		// Blend
else
	v_axe_kong_smooth = tv_axe_kong																						// Pas de Blend.

// ================================================================================================
// === CALCUL du POSITIONNEMENT de la Cam SANS TENIR COMPTE du decentrage X-Y (lui meme dependant de la distance) ===
// ================================================================================================

tv_cc_kong = tv_meca_cam_target + cvector(0,0,tf_cc_target_deltaZ)
tv_cc_cam = tv_gao_contre_champ + tv_cc_SRC_offset
tv_meca_cam_sight = tv_cc_kong - tv_cc_cam

if (tf_cc_dist_max_a_kong)
{
	// Il y a une contrainte de distance de entre Kong et la Camera.
	float		tf_meca_cam_sight_norm
	vector	tv_meca_cam_sight_normalized
	float		tf_cc_ideal_dist 

//	if (i_kong_camera_status_new == Ci_Kcamera_walling)
//		tf_cc_dist_max_a_kong+= 5

	tf_meca_cam_dist = tf_cc_dist_max_a_kong

	tf_meca_cam_sight_norm = MATH_VecNorm(tv_meca_cam_sight)
	tv_meca_cam_sight_normalized = tv_meca_cam_sight / tf_meca_cam_sight_norm

	tf_cc_ideal_dist = tf_meca_cam_sight_norm + tf_cc_SRC_dist

	if (tf_cc_dist_max_apres_la_cam)
	{
		// Il y a une contrainte de distance en avant de la camera.
		if (tf_cc_ideal_dist - tf_cc_dist_max_a_kong > tf_cc_dist_max_apres_la_cam)
			tf_meca_cam_dist = tf_cc_ideal_dist - tf_cc_dist_max_apres_la_cam
	}

	if (tf_cc_dist_max_avant_la_cam)
	{
		// Il y a une contrainte de distance a l'arriere de la camera
		tv_cc_pos_cam = tv_cc_kong - (tv_meca_cam_sight_normalized* tf_meca_cam_dist)
		if (MATH_VecDotProduct(tv_cc_pos_cam - (tv_gao_contre_champ - (tv_meca_cam_sight_normalized * tf_cc_dist_max_avant_la_cam)), tv_meca_cam_sight) < 0)
			tf_meca_cam_dist = tf_cc_ideal_dist + tf_cc_dist_max_avant_la_cam
	}
}
else
{
	// Pas de contrainte de dist a Kong donc je suis sur le point du CamModifier
	tf_meca_cam_dist = MATH_VecNorm(tv_meca_cam_sight) + tf_cc_SRC_dist		// Auto DIST
}

// Reculer pour Inclure les ennemis de la scene ------------------------------------------------------------------
if (ti_include_all_ennemies)
{
	// CHEAT TXT ======================================================================================================
	if (@"univ" i_cheat_page == 2)
		STR_CreateText("\cFF00FF00\Kam INCLUDE: ", cvector(0.0, 0.19+(0.04 * (1 + @get_global i_cheat_2_nbr)), 0.0), 0)
	// CHEAT TXT ======================================================================================================

	// Il faut reculer encore plus la cam pour inclure tous les persos actuellement en fight.
	MATH_VecSetNormalize(tv_meca_cam_sight)

	tv_cc_pos_cam = tv_cc_kong - (tv_meca_cam_sight * tf_meca_cam_dist)
 
	tv_cc_pos_apres = MATH_LIB_AllPosInCone(&av_LockKam_Pos[0], i_LockKam_Nbr, tv_cc_pos_cam, tv_meca_cam_sight, 0.94, faux)

	// Contrainte de recul Maximum
	tf_dist_all_ennemies = MATH_FloatMin( MATH_VecDistance(tv_cc_pos_cam,tv_cc_pos_apres), f_k_GC_recul_max_all_ennemies)

	if ( f_LockKam_Blend)
		f_dist_all_ennemies = MATH_FloatBlend(tf_dist_all_ennemies, f_dist_all_ennemies, f_LockKam_Blend)	// Blend
	else
		f_dist_all_ennemies = tf_dist_all_ennemies																			// Pas de Blend.

	tf_meca_cam_dist += f_dist_all_ennemies
}
else
{
	// CHEAT TXT ======================================================================================================
	if (@"univ" i_cheat_page == 2)
		STR_CreateText("\cFF00FF00\Kam CANCEL: ", cvector(0.0, 0.19+(0.04 * (1 + @get_global i_cheat_2_nbr)), 0.0), 0)
	// CHEAT TXT ======================================================================================================
}

// Reculer pour Inclure les ennemis de la scene ------------------------------------------------------------------

// Position de la Camera apres toutes les Contraintes
tv_cam_pos =  tv_cc_kong - (MATH_VecNormalize(tv_meca_cam_sight) * tf_meca_cam_dist)

// ================================================================================================
// === CALCUL du POSITIONNEMENT de la Cam SANS TENIR COMPTE du decentrage X-Y (lui meme dependant de la distance) ===
// ================================================================================================

// --- Target Delta -------------------------------------------------------------------------------------------------------
tv_gao_contre_champ_to_kong = tv_meca_cam_target - tv_gao_contre_champ												// Axe Stable KONG - GAOFIXE
MATH_VecSetHorzNormalize(tv_gao_contre_champ_to_kong)
tv_cross = MATH_VecCrossProduct(tv_gao_contre_champ_to_kong, Cv_VerticalVector)									// Cross de l'Axe Stable

if (i_kong_camera_status_new == Ci_Kcamera_saut_swing_arch)
	tf_dot_target = 0																					// Pas de decentrage
else
	tf_dot_target = MATH_VecDotProduct(tv_cross, v_axe_kong_smooth)			// Decentrage en fonction du DOTPROD
f_cc_dot_target = MATH_FloatBlend(f_cc_dot_target, tf_dot_target, 5.0 * TIME_GetDt() * f_Kamera_mode_init_infini)

tv_meca_cam_target_delta = ( tv_cross * (tf_meca_cam_dist *  0.18)) * f_cc_dot_target										// Offset X-Y
tv_meca_cam_target_delta *= tf_k_GC_DecentrageHorizCoef																			// Amplificateur/Reducteur de decentrage HORIZ

tf_meca_cam_targetz_norm = tf_cc_target_deltaZ 
tf_meca_cam_targetz_norm += tf_k_GC_DecentrageVertiCoef * ((( tv_cam_pos.z - (tv_meca_cam_target.z + tf_cc_target_deltaZ) ) * 0.4))				// Offset Z sur le point dest (Kong)
//tf_meca_cam_targetz_norm *= tf_k_GC_DecentrageVertiCoef																			// Amplificateur/Reducteur de decentrage VERTI

if (ti_k_GC_offsetZ_Local)
	tv_meca_cam_target_delta += @o_mf_actor OBJ_BankingGet() * (tf_meca_cam_targetz_norm + tf_meca_cam_targetz)
else
	tv_meca_cam_target_delta += cvector(0,0, tf_meca_cam_targetz_norm + tf_meca_cam_targetz)

// --- Target Delta ------------------------------------------------------------------------------------------------------

// DODGE ----------------------------------------------------------------------------------------------------------------
if ((!i_cc_cam_sur_ann_old && o_cc_kam_modifier != OBJ_Me()) && ti_dodge_on)
{
	// Cam != ANN !
	f_cc_DodgeZmax = MATH_FloatBlend(f_cc_DodgeZmax, KamP_CheckDodge(tv_cam_pos), TIME_GetDt() * f_Kamera_mode_init_infini)
	tv_cam_pos.z += f_cc_DodgeZmax
}
// DODGE ----------------------------------------------------------------------------------------------------------------

// Recalcul de l'AXE en fonction du Target Delta (X-Y lui dependant de la distance)
tv_meca_cam_sight = (tv_meca_cam_target + tv_meca_cam_target_delta) - tv_cam_pos

// Recalcul de la Distance fonctionn du decalage
tf_meca_cam_dist = MATH_VecNorm(tv_meca_cam_sight)

// JOY-D --------------------------------------------------------------------------------------------------------------
if (f_joyD_blend_norm && f_k_GC_look_amplitude)
{
	tv_joyD = -v_joyD_blend * f_chm_coef 
	tv_joyD.z = tv_joyD.y * f_k_GC_look_amplitude * @"univ" CAM_SensVert
	tv_joyD.y = 1
	tv_joyD.x *= -1 * f_k_GC_look_amplitude
	v_MECA_orientation_locale = MATH_VecNormalize(tv_joyD)
}
// JOY-D --------------------------------------------------------------------------------------------------------------

tf_meca_cam_dist += tf_additionnal_dist

if ( i_Kamera_mode_init_flag && (f_cut_if_backshoot != 666 || i_kong_camera_mode_old == Ci_Kamera_mode_FINISH) )
{
	vector	tv_axis1
	if (i_kong_camera_mode_old == Ci_Kamera_mode_FINISH)
	{
		if (!i_MECA_TestRayCast)
			f_cut_if_backshoot = 10.0
		else
			f_cut_if_backshoot = 0.0
	}
	tv_axis1= tv_meca_cam_sight
	tv_axis1.z = OBJ_SightGet().z
	MATH_VecSetHorzNormalize(tv_axis1)
	if (MATH_VecDotProduct(OBJ_SightGet(), tv_axis1) < f_cut_if_backshoot)
		f_cc_meca_cam_transitionspeed = Cf_Infinit
}

//KamP_MECA_Pos_Blend(tv_meca_cam_target, tv_meca_cam_target_delta, tv_cam_pos , tf_meca_cam_focale, f_cc_meca_cam_transitionspeed)

//DBG_RenderSphere(tv_cam_pos,0.5,color_rose)
KamP_MECA_SightDist_Blend(tv_meca_cam_target, tv_meca_cam_target_delta, tv_meca_cam_sight, tf_meca_cam_dist, tf_meca_cam_focale, f_cc_meca_cam_transitionspeed)
