#include "Kam_Defines.var"

object	to_gao 
object	to_tete_kong
object	to_jack
object	to_kong

float		tf_dot
float		tf_temp
float		tf_new_dist
float		tf_stick_max_z
float		tf_ComputeZ
float		tf_ComputeX
float		tf_cur_dist 
float		tf_dist
float		tf_probeAngleSpan 
float		tf_finalReductionRatio
float		tf_ray_length
float		tf_ray_start_offset

vector	tv_pos
vector	tv_sight
vector	tv_newpos
vector	tv_temp
vector	tv_temp1
vector	tv_temp_look1
vector	tv_temp_look2
vector	tv_real_target_pos
vector	tv_real_cam_pos
vector	tv_cur_sight 
vector	tv_pos_actor
vector	tv_teteToCam
vector	tv_pos_tete_kong
vector	tv_normal 
vector	tv_ray_dir
vector	tv_MECA_cam_sight_backup
vector	tv_relative

int			ti_obstacle

#define DBG_RenderPreemptColl

//to_jack = AI_MainActorGet(C_ID_Joueur)
//to_kong = AI_MainActorGet(C_ID_Kong)

to_tete_kong = @o_mf_actor ANI_CanalObjectGet(0)


// Si il n'y a pas de tete (cas WP special de target alors 
if (to_tete_kong)
	tv_pos_tete_kong = @to_tete_kong OBJ_PosGet()
else
	tv_pos_tete_kong = @o_mf_actor OBJ_PosGet()


switch (i_MECA_Mode)
{
	// ===============================================
	// MECA SIGHT / DIST --------------------------------------------------------------
	// v_MECA_cam_target 			= Position du perso Target
	// v_MECA_cam_target_delta		= Offset Rajouté au perso Targeté
	// v_MECA_cam_sight				= Axe de la camera
	// f_MECA_cam_dist				= Distance a la Target
	// MECA SIGHT / DIST --------------------------------------------------------------
	// ===============================================
	case Ci_MecaMode_SightDist :

//	KamP_MECA_SightDist_DBGRender()

	f_real_cam_dist = f_MECA_cam_dist

	tv_real_target_pos = v_MECA_cam_target + v_MECA_cam_target_delta

	DBG_RenderCircle(tv_real_target_pos,0.5,Cv_NullVector,color_bleu)

	MATH_VecSetNormalize(v_MECA_cam_sight)

	tv_real_cam_pos = tv_real_target_pos - (v_MECA_cam_sight * f_real_cam_dist)

	if (i_kong_camera_status_new == Ci_Kcamera_accroch)
		v_offset_Z_LR_tete = cvector(0,0,5)
	else
		v_offset_Z_LR_tete = MATH_VecBlend(v_offset_Z_LR_tete, Cv_NullVector, 2.0 * TIME_GetDt())

	tv_pos_tete_kong += v_offset_Z_LR_tete
	break

	// ===============================================
	// MECA POSITION / SIGHT -----------------------------------------------------
	// v_MECA_cam_target 			= Position du perso Target
	// v_MECA_cam_target_delta		= Offset Rajouté au perso Targeté
	// v_MECA_cam_pos				= Position de la Camera
	// MECA POSITION / SIGHT -----------------------------------------------------
	// ===============================================
	case Ci_MecaMode_Position :

	tv_real_cam_pos = v_MECA_cam_pos

	tv_real_target_pos = v_MECA_cam_target + v_MECA_cam_target_delta
	v_MECA_cam_sight = tv_real_target_pos - tv_real_cam_pos
	
//	if (i_kong_camera_status_new == Ci_Kcamera_accroch)
//		v_offset_Z_LR_tete = cvector(0,0,5)
//	else
		v_offset_Z_LR_tete = MATH_VecBlend(v_offset_Z_LR_tete, Cv_NullVector, 2.0 * TIME_GetDt())

	tv_pos_tete_kong += v_offset_Z_LR_tete
	break


	// ===============================================
	// MECA POSITION / SIGHT -----------------------------------------------------
	// v_MECA_cam_sight				= Axe de la camera
	// v_MECA_cam_pos				= Position de la Camera
	// MECA POSITION / SIGHT -----------------------------------------------------
	case Ci_MecaMode_FPS :
		tv_real_cam_pos = v_MECA_cam_pos
		i_MECA_TestRayCast = faux
	break	
	
	// MECA POSITION / SIGHT -----------------------------------------------------
	// v_MECA_cam_sight				= Axe de la camera
	// v_MECA_cam_pos				= Position de la Camera
	// MECA POSITION / SIGHT -----------------------------------------------------
	case Ci_MecaMode_Reward :
		tv_real_cam_pos = v_MECA_cam_pos
		i_MECA_TestRayCast = faux
		break

}

// RESTRICTION ORIENTATION LOCALE
if( ! MATH_VecNullToler(v_MECA_orientation_locale, 0.01) )
{
	OBJ_SightGeneralSet(v_MECA_cam_sight, Cv_VerticalVector)
	OBJ_Rotate_FromTo(cvector(0,1,0), v_MECA_orientation_locale )
	v_MECA_cam_sight	= OBJ_SightGet()
	v_MECA_orientation_locale = Cv_NullVector
}

if (i_render_col )
	DBG_RenderVector(tv_pos_tete_kong, tv_real_cam_pos - tv_pos_tete_kong, color_vert)

// LR pour ne pas rentrer dans les murs -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
if (i_MECA_TestRayCast)
{
	tv_ray_dir = tv_real_cam_pos - tv_pos_tete_kong
	tf_ray_length = MATH_VecNorm(tv_ray_dir)
	tv_ray_dir /= tf_ray_length

	if (o_k_GC_active_occlution)
	{
		tf_ray_start_offset = MATH_VecDotProduct(tv_ray_dir, @o_k_GC_active_occlution OBJ_PosGet() - tv_pos_tete_kong)
		tf_ray_start_offset = MATH_FloatLimit(tf_ray_start_offset, 0.0, tf_ray_length)
	}
	else
		tf_ray_start_offset = 0.0

	COL_SpecificCrossableSet( (Gmat_RM_Crossable_Default & ~Gmat_RM_Cross_All_But_Camera) | Gmat_RM_Traversable_par_Camera )
	to_gao = COL_RayObject_Dist(tv_pos_tete_kong + (tv_ray_dir * tf_ray_start_offset), tv_ray_dir, tf_ray_length - tf_ray_start_offset, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet)
//	to_gao = COL_RayObject_Vector(tv_pos_tete_kong, tv_real_cam_pos - tv_pos_tete_kong, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet)
	if (to_gao)
		f_duree_col += TIME_GetDt()
	else
		f_duree_col = 0.0

	if (f_duree_col > 0) // 0.1) //to_gao)
	{
	
		i_ray_col = vrai
		tv_normal = COL_RayObject_NormalGet()
	
		v_normal_delta = MATH_VecBlend(v_normal_delta, COL_RayObject_NormalGet() * 0.15, 5.0 * TIME_GetDt())
	 	tv_real_cam_pos = COL_RayObject_PosGet() + v_normal_delta

		// CHEAT TXT ======================================================================================================
		if (@"univ" i_cheat_page == 2)
		{
			int		ti_txt 
			ti_txt = STR_CreateText("\cFF00FF00\Kam Collision: \cFF8080FF\Colliding on ", cvector(0.0, 0.19+(0.04 * (@get_global i_cheat_2_nbr)), 0.0), 0)
			STR_AppendGao(ti_txt, to_gao)
		}
		// CHEAT TXT ======================================================================================================
	}
	else
	{
		i_ray_col = faux
		v_normal_delta = MATH_VecBlend(v_normal_delta, Cv_NullVector, 5.0 * TIME_GetDt())
	 	tv_real_cam_pos += v_normal_delta
		// CHEAT TXT ======================================================================================================
		if (@"univ" i_cheat_page == 2)
			STR_CreateText("\cFF00FF00\Kam Collision: \cFF80FF80\No Collision", cvector(0.0, 0.19+(0.04 * (@get_global i_cheat_2_nbr)), 0.0), 0)
		// CHEAT TXT ======================================================================================================
	}
}
else
{
	i_ray_col = faux
	f_duree_col = 0.0
	v_normal_delta = MATH_VecBlend(v_normal_delta, Cv_NullVector, 5.0 * TIME_GetDt())
 	tv_real_cam_pos += v_normal_delta
	// CHEAT TXT ======================================================================================================
	if (@"univ" i_cheat_page == 2)
		STR_CreateText("\cFF00FF00\Kam Collision: \cFFFFFFFF\Disable", cvector(0.0, 0.19+(0.04 * (@get_global i_cheat_2_nbr)), 0.0), 0)
	// CHEAT TXT ======================================================================================================
}
// LR pour ne pas rentrer dans les murs -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

if (i_ray_col && i_render_col)
	DBG_RenderVector(tv_pos_tete_kong+cvector(0,0,0.005), tv_real_cam_pos - tv_pos_tete_kong, color_rouge)

if (i_ray_col && tv_normal.z < 0.8)
	f_cc_duration = 0

// POSITION
v_camera_curent_pos = tv_real_cam_pos
OBJ_PosSet( v_camera_curent_pos )

v_delta = v_camera_curent_pos - v_oldpos
v_oldpos = v_camera_curent_pos

// ORIENTATION
OBJ_SightGeneralSet(v_MECA_cam_sight, v_MECA_cam_banking)		// ne pas repositionner si Jack prend un paf

if (f_death_rotation)
	OBJ_RotateLocalY(f_death_rotation)

KamP_Backup_MECACompatible_Value()

i_MECA_Mode = Ci_MecaMode_SightDist		// Camera SightDist par defaut
i_MECA_TestRayCast = vrai							// Test LR actif par defaut
o_k_GC_active_occlution = nobody

if (!i_flag)
	f_tourne = MATH_FloatBlend(f_tourne, 0.0 , 4.0 * TIME_GetDt())



