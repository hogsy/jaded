#include "Kam_Defines.var"

float			tf_max 
float			tf_min
vector		tv_axis 
float			tf_Zmax
vector		tv_summ
float			tf_scolo_dot
vector		tv_cam_pos
vector		tv_banking
vector		tv_cc_pos_apres 
object		to_gao	
float			tf_delta_max
int				ti_loo

float			tf_pond_distance 


// #########################
// AU SOL NORMAL & DEFAUT
// #########################

vector		tv_meca_cam_target
float			tf_camera_dist
vector		tv_cam_sight

float			tf_vitesse_retour_axe_blend
float			tf_vitesse_retour_axe
float			tf_dot
float			tf_angle

vector		tv_cam_target_delta
float			tf_cam_target_delta_blendspeed
float			tf_target_delta_norm

vector		tv_sight_actor
vector		tv_horizon_cam
vector		tv_axe_retour
	vector	tv_pos 

float			tf_joyD_value

float			tf_kong_ground_angle

vector		tv_fig_target_axis_ncross 
vector		tv_fig_target_axis_n
float			tf_zz

//vector		tv_speed_target
//vector		tv_speed_target_horiz
//float			tf_speed_target_horiz_norm 

i_fight_old = i_fight

if (@get_rayman PROC_RM_ModeLookON())
	i_fight = vrai
else
	i_fight = faux

// Temp
if (f_OldMECA_cam_dist < 0.5 && i_fight)
{
	to_gao = @get_rayman ANI_CanalObjectGet(0)
	@to_gao OBJ_FlagInvisibleSet(vrai)						// Invisible
}

if (i_fight && !i_fight_old)
{
	// Passage en mode lock
	v_lock_cam_axis = @get_rayman OBJ_SightGet()
	f_chm_speed_forced = 15.0
	i_kong_camera_mode = -1
//	i_Kamera_mode_init_flag = vrai
	f_time = 0.5
}
	
// Backup Gao pour les Transitions specifique en mode CChant
o_cc_kam_modifier_old = nobody

tv_fig_target_axis_n = Cv_NullVector

//// SPEED de ma TARGET
//tv_speed_target = v_speed_target  //@o_mf_actor DYN_SpeedGetVector()
//tv_speed_target_horiz = tv_speed_target
//tv_speed_target_horiz.z = 0
//tf_speed_target_horiz_norm = MATH_VecNorm(tv_speed_target_horiz)

//f_speed_target = MATH_FloatBlend(f_speed_target, tf_speed_target_horiz_norm, 1.0 * TIME_GetDt() )

if (@get_global i_frame_nbr < 10  ||  IO_ButtonJustPressed(joy_button_StickR))
{
	i_Kamera_mode_init_flag = vrai
	f_Kamera_mode_init_infini = Cf_Infinit
}

// LE RESTE
if ( i_kong_camera_mode != Ci_Kamera_mode_NORMAL || o_mf_actor_old != o_mf_actor)
{
	// INIT du MODE ou CHANGEMENT de PARAM
	KamP_Mode_Set(Ci_Kamera_mode_NORMAL)

	// Backup des Valeurs pour le BLEND entre les modes
	KamP_Backup_Change_Mode_Value()
	f_normal_cam_dist = f_OldMECA_cam_dist

	KamP_JoyD_BlendSet(15.0, 3.0, 7.0, 3.0)

	// Vitesse de retour dans l'axe (le dos si pas kam_modifier)
	f_normal_vitesse_retour_axe = 0

	if (f_chm_speed_forced >= 0)
	{
		f_normal_change_mode_speed = f_chm_speed_forced
		f_chm_speed_forced = -1
	}
	else if (@get_global i_frame_nbr < 10)
		f_normal_change_mode_speed = Cf_Infinit
	else if (i_kong_camera_status_old == Ci_Kcamera_walling)
		f_normal_change_mode_speed = 5.0
	else
		f_normal_change_mode_speed = 4.0
		
	f_blend_vertical = Cf_normal_rotation_vers_la_verticale * 2
}

if (i_mf_actor_Family == Ci_Kam_MontureFamily_Serpent)
{
	tv_banking	= @o_mf_actor OBJ_BankingGet()
	tf_scolo_dot = MATH_VecDotProduct(OBJ_SightGet(),tv_banking)
}

// Position de la TARGET 
tv_meca_cam_target = KamP_TargetGao_BlendPosGet(o_mf_actor, Cf_BlendPos_DefaultSpeed)

// Coef axe horiz visee kong / horiz camera
if (i_mf_actor_Family == Ci_Kam_MontureFamily_Requin)
	tv_sight_actor = @o_mf_actor Proc_PNJ_Shark_VirtualSightGet()
else
	tv_sight_actor = @o_mf_actor OBJ_SightGet()

tv_sight_actor.z = 0
if (MATH_VecNull(tv_sight_actor))
	tv_sight_actor = -@o_mf_actor OBJ_BankingGet()
MATH_VecSetHorzNormalize(tv_sight_actor)
tv_horizon_cam = OBJ_HorizonGet()
MATH_VecSetHorzNormalize(tv_horizon_cam)

// --- Target Delta --------------------------------------------------------------------------------------------------
if (f_joyD_blend_norm && ControlCamJoyD)
{
	// On demande un deplacement de la cam au stickD
	tf_cam_target_delta_blendspeed = f_joyD_blend_norm * 3.0					// Vitesse de changement du Decentrage
	tv_cam_target_delta = Cv_NullVector													// RAZ Decentrage
}
else
{
	if (f_Kamera_mode_init_infini != 1.0)
	{
		tf_cam_target_delta_blendspeed = Cf_Infinit //  1.0
		f_normal_cam_target_delta_norm = 1.0
		tv_cam_target_delta = cvector(0,0,0)
	}
	else
	{
		tf_cam_target_delta_blendspeed = MATH_FloatMin(f_speed_target_horiz_norm, 30) / 5.0		// Vitesse de changement du Decentrage

		tf_target_delta_norm = MATH_VecDotProduct(tv_horizon_cam, tv_sight_actor)

		if ( i_fight  && o_lock )
		{
			tf_cam_target_delta_blendspeed = 2.0//1.0 + (tf_speed_target_horiz_norm / 5.0)
			if ( MATH_AbsFloat(tf_target_delta_norm)>0.5 || i_Kamera_mode_init_flag)
				f_normal_cam_target_delta_norm = MATH_FloatSign(tf_target_delta_norm)
			tf_target_delta_norm = f_normal_cam_target_delta_norm * 1.1
		}	

		tf_target_delta_norm = MATH_FloatLimit(tf_target_delta_norm, -f_normal_camT_TargetHorizDotMin, f_normal_camT_TargetHorizDotMin)
	
		if (i_mf_actor_Family == Ci_Kam_MontureFamily_Serpent)	// ICICICICIC
			tf_target_delta_norm = MATH_VecDotProduct(tv_horizon_cam, tv_banking) * 1.5
	
		tf_pond_distance = MATH_VecDistance(v_OldMECA_cam_pos, @o_mf_actor OBJ_PosGet()) * 0.34 * f_normal_camT_TargetHorizCoef

		if ( i_fight && o_lock )
			tv_cam_target_delta = -OBJ_HorizonGet() * tf_target_delta_norm * tf_pond_distance
		else
			tv_cam_target_delta = OBJ_HorizonGet() * tf_target_delta_norm * tf_pond_distance
	}
}


//if ( (!ti_fight  && i_mf_actor_ID==C_ID_Rayman) && !@get_rayman i_ground_flag ) && !&& !@get_rayman PROC_RM_NAGE())
//{
//	// RM en l'air
//	tv_cam_target_delta.z = 0
//}
if ( ( (!i_fight  && i_mf_actor_ID==C_ID_Rayman) && ( !@get_rayman i_ground_flag  && !@get_rayman PROC_RM_Current_HotSpot_Get()) ) && !@get_rayman PROC_RM_NAGE() )
{
	// RM en l'air
//	if (@o_mf_actor ACT_ActionGet() == 51)
//		tv_cam_target_delta.z = f_normal_camT_TargetZ
//	else
		tv_cam_target_delta.z = 0
}
else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Aigle)
{
	// Bats on vise sous la Bats si on descend.
	tv_cam_target_delta.z = f_normal_camT_TargetZ
//	tv_cam_target_delta.z += MATH_FloatLimit(@o_mf_actor DYN_SpeedGetVector().z * 0.12, -10, 0)
}
else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Serpent)
{
	// SCOLO
	tv_cam_target_delta.z = f_normal_camT_TargetZ
	tv_cam_target_delta.z += tv_banking.z * 1.6
}
else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Requin )
{
	vector tv_vec
	// Shark on vise desous si on descend.
	tv_cam_target_delta.z = f_normal_camT_TargetZ
}
else
	// Standard
	tv_cam_target_delta.z = f_normal_camT_TargetZ

v_normal_target_delta = MATH_VecBlend(v_normal_target_delta, tv_cam_target_delta, tf_cam_target_delta_blendspeed * f_Kamera_mode_init_infini * TIME_GetDt())	// Decalage Horiz
v_normal_target_delta.z = MATH_FloatBlend(v_normal_target_delta.z, tv_cam_target_delta.z, 12.5 * f_Kamera_mode_init_infini * TIME_GetDt())			// Decalage Z Independant
// --- Target Delta --------------------------------------------------------------------------------------------------


// Retour dans le DOS  ou Dans l'Axe Forcé -------------------------------------------------------------------------------------------
if (i_fight || f_time)
	tv_cam_sight = v_lock_cam_axis										// Axe courant
else
	tv_cam_sight = v_OldMECA_cam_sight								// Axe courant



//Proc_Kam_Aniticipationne()												// AAJUSTER

// VITESSE de retour
if (( (f_joyD_blend_norm && ControlCamJoyD) || MATH_AbsFloat(f_tourne) > 0.1) || (i_fight && !o_lock) )
{
	o_lock = nobody
	tf_vitesse_retour_axe = 0.0											// Pas de retour dans le dos
	tf_vitesse_retour_axe_blend = 10.0									// Je vais vers cette valeur tres vite
}
//else if ()
//
else
{
	float		tf_delta
	// Retour dans le dos a la vitesse relative a la vitesse du perso suivi.

	tf_vitesse_retour_axe = f_speed_target_horiz_norm * f_normal_coef_speed	// Vitesse du perso

	switch (i_mf_actor_ID)
	{
		case C_ID_Monture_Rhino :
		case C_ID_Monture_Tigre :
			tf_dot = 0.5
			break

		case C_ID_Monture_Aigle :
		case C_ID_Monture_Bat :
		case C_ID_Monture_Soucoupe :
			tf_vitesse_retour_axe = 6.0 //MATH_FloatMax(.0,MATH_VecNorm(tv_speed_target) * 0.3)	// Vitesse du perso
			tf_dot = 1.0
			break

		case C_ID_Monture_Requin :
		case C_ID_Monture_PoissonLumiere :
			if (!@o_mf_actor  Proc_PNJ_Shark_StatusGet() & Ci_Shark_Status_MarioControlMode)
			{
				tf_dot = 1.0
				if (i_mf_actor_ID == C_ID_Monture_Requin)
					tf_vitesse_retour_axe = 10.0
				else
					tf_vitesse_retour_axe = 3.0 					//MATH_FloatMax(.0,MATH_VecNorm(tv_speed_target) * 0.3)	// Vitesse du perso
			}
			else
			{
				if (glob_joynorm_get)
				{
					tf_max = 0.0
					tf_min = -1.0
					tf_dot = MATH_FloatLimit( (MATH_VecDotProduct( v_sight_camera_horiz, glob_joyvector_get_normalized) - tf_min) / (tf_max - tf_min), 0.0, 1.0)
					tf_dot *= MATH_FloatMax(0.0, MATH_VecDotProduct( tv_sight_actor, glob_joyvector_get_normalized) - 0.75) / 0.25
				}
				else
					tf_dot = 0.0
			}
			break			
	
		case C_ID_Monture_Serpent :
		case C_ID_Monture_Araignee :
		case C_ID_Monture_Quadripode :
		case C_ID_Lapin :
		case C_ID_Rayman :
		default:
			if (glob_joynorm_get )
			{
				if ( @get_rayman PROC_RM_Type_HotspotGet() == C_HS_Type_Crochet && !@get_rayman i_ground_flag )
					tf_dot = 0.0
				else
				{
					tf_max = -0.5
					tf_min = -1.0
					tf_dot = MATH_FloatLimit( (MATH_VecDotProduct( v_sight_camera_horiz, glob_joyvector_get_normalized) - tf_min) / (tf_max - tf_min), 0.0, 1.0)
//					Str_DisplayFloatOnce(tf_dot, Cv_NullVector)
					DBG_RenderVector(@get_rayman OBJ_PosGet(), tv_sight_actor, color_jaune)
//					tf_dot *= MATH_VecDotProduct( tv_sight_actor, glob_joyvector_get_normalized)
					tf_dot *= MATH_FloatMax(0.0, MATH_VecDotProduct( tv_sight_actor, glob_joyvector_get_normalized ))
//					Str_DisplayFloatOnce(tf_dot, cvector(0.2,0,0))

				}
			}
			else
				tf_dot = 0.0
			break
		}

	tf_vitesse_retour_axe *= tf_dot
	tf_vitesse_retour_axe_blend = 12.0									// Je vais vers cette valeur progressivement.
}

// AXE de retour
tv_axe_retour = @o_mf_actor OBJ_SightGet()		

if (f_Kam_ComboFinish)
{
	tf_vitesse_retour_axe = f_Kam_ComboFinish
	tf_vitesse_retour_axe_blend = 12.0									// Je vais vers cette valeur progressivement.

	tv_axe_retour = @o_Kam_ComboFinish OBJ_PosGet() - @get_rayman OBJ_PosGet()
	tv_axe_retour = Proc_Vec_HorzNormalise(tv_axe_retour, @get_rayman OBJ_SightGet())
}
else
	f_Kam_ComboFinish =f_Kam_ComboFinish 


f_normal_vitesse_retour_axe = MATH_FloatBlend(f_normal_vitesse_retour_axe, tf_vitesse_retour_axe, tf_vitesse_retour_axe_blend * TIME_GetDt())
//Str_DisplayFloatOnce(f_normal_vitesse_retour_axe, cvector(0,0.1,0))
					// Axe = DOS DU PERSO

//if (i_LockKam_Nbr && i_kam_enable_fight_trame)
if (i_fight && o_lock)
{
	tv_axe_retour = v_lock - (@o_mf_actor OBJ_PosGet() + (OBJ_BankingGet() * 0.75))
	if (MATH_VecNullEpsilon(tv_axe_retour))
		tv_axe_retour  = @o_mf_actor OBJ_SightGet()

	f_normal_vitesse_retour_axe = 5.0
}
else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Requin)
	tv_axe_retour  = @o_mf_actor Proc_PNJ_Shark_VirtualSightGet()
//else
//	tv_axe_retour  = @o_mf_actor OBJ_SightGet()

if (i_Kamera_mode_init_flag)
	tv_cam_sight = tv_axe_retour
else if ( f_normal_vitesse_retour_axe && MATH_AbsFloat(v_joyD_blend.x) < 0.01)
{
	tv_cam_sight = MATH_VecBlendRotate(tv_cam_sight, tv_axe_retour, f_normal_vitesse_retour_axe * TIME_GetDt())		// Retour dans le dos (vitesse fct vitesse de Kong)
}

DBG_RenderVector(@o_mf_actor OBJ_PosGet(), tv_axe_retour, color_jaune * 10)

MATH_VecSetHorzNormalize(tv_cam_sight)
// Retour dans le DOS -------------------------------------------------------------------------------------------

// JOY1 - X -----------------------------------------------------------------------------------------------------------------
if (MATH_AbsFloat(v_joyD_blend.x)>=0.01 && ControlCamJoyD)
	tv_cam_sight = MATH_VecBlendRotate(tv_cam_sight, - MATH_FloatSign(v_joyD_blend.x) * OBJ_HorizonGet(), MATH_AbsFloat((v_joyD_blend.x * 2.5) * TIME_GetDt()) )
else if (MATH_AbsFloat(f_tourne) >= 0.02)
	tv_cam_sight = MATH_VecBlendRotate(tv_cam_sight, OBJ_HorizonGet() * -MATH_FloatSign(f_tourne) , (TIME_GetDt() * 2.5) * MATH_AbsFloat(f_tourne) )
else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Serpent)
{
	if (tf_scolo_dot>-0.2 && MATH_AbsFloat(tv_banking.z) < 0.5 )
	{
		tv_cam_sight = MATH_VecBlendRotate(tv_cam_sight, - MATH_FloatSign( MATH_VecDotProduct(OBJ_HorizonGet(),tv_banking) ) * OBJ_HorizonGet(), MATH_AbsFloat((tf_scolo_dot+0.2) * 2.5) * TIME_GetDt() )
	}
}
// JOY1 - X -----------------------------------------------------------------------------------------------------------------

if (i_mf_actor_Family == Ci_Kam_MontureFamily_Serpent || i_mf_actor_Family == Ci_Kam_MontureFamily_Aigle )
	tf_angle = 0.0
else
{
	// GROUND Managment ==============================================
//	if (i_mf_actor_ID == C_ID_Rayman)
//		f_ground_normale = @o_mf_actor PROC_RM_GroundNormalGet()
//	else
	{
		if (@o_mf_actor COL_CollideType(COL_C_Ground))
		{
			f_ground_normale = @o_mf_actor COL_NormalGet(COL_C_Ground)
			f_ground_timer = 0.1
		}
		else if (f_ground_timer)
			f_ground_timer -= MATH_FloatMin(f_ground_timer,TIME_GetDt())
		else
			f_ground_normale = Cv_VerticalVector
	}
	// GROUND Managment ==============================================
	if ( ! MATH_VecNullEpsilon(f_ground_normale))
	{
		tf_angle = MATH_VecAngle(Cv_VerticalVector, f_ground_normale, @o_mf_actor OBJ_HorizonGet()) * f_normal_cam_GroundAngleCoef
	
		// Coef entre 0 et 1 evoluant linerairement entre 5 et 15m
		tf_angle *= 1.0 - ( MATH_FloatLimit( MATH_VecDistance(v_OldMECA_cam_pos, @o_mf_actor OBJ_PosGet()) - 5.0, 0.0, 10.0) * 0.1)
	}
	else
	 	tf_angle = 0
	tf_angle *= MATH_VecDotProduct(OBJ_SightGet(), @o_mf_actor OBJ_SightGet() )						// DOT sight cam
}
f_normal_AngleGroundMainActor = MATH_FloatBlend(f_normal_AngleGroundMainActor, tf_angle, 8.0 * TIME_GetDt() * f_Kamera_mode_init_infini)


if (!i_fight || (glob_joynorm_get || (i_fight && o_lock) ) )
{
	if (	i_fight && o_lock)
	{
		vector tv_axis2
		tv_axis = v_lock - (@o_mf_actor OBJ_PosGet() + (OBJ_BankingGet() * 0.75))
		MATH_VecSetNormalize(tv_axis)
		tf_angle = -tv_axis.z * 0.6
		tf_angle += f_normal_cam_AngleGround
	}
	else if ((( i_mf_actor_ID==C_ID_Rayman && !@get_rayman i_ground_flag) && v_speed_target.z < 6.0 ) && !@get_rayman PROC_RM_NAGE())	// RM en l'air
	{
			if (@o_mf_actor ACT_ActionGet() == 51)
			{
				if (	f_KMAdjust_ChuteTornade != 666)
					tf_angle = f_KMAdjust_ChuteTornade
				else
				{
					tf_angle = 0.2 * (- MATH_FloatMax((v_speed_target.z - 6.0) / 10.0, -2.5)) //35
				 	tf_angle = MATH_FloatMin(0.25, tf_angle )
				 }
			 }
			else if (@o_mf_actor ACT_ActionGet() == 54)
			{
				if (	f_KMAdjust_ChutePlat != 666)
					tf_angle = f_KMAdjust_ChutePlat
				else
					tf_angle = 0.4
			}
			// STEPH STEPH : essayer de faire redescendre la cam qd RM bat des ailes(effet ouverture de parachute)
			else if ( @o_mf_actor ACT_ActionGet() == 53 || @o_mf_actor ACT_ActionGet() == 48)
			{
				if (	f_KMAdjust_ChutePlat != 666)
					tf_angle = f_KMAdjust_ChutePlat
				else
					tf_angle = 0.2
			}
			// STEPH STEPH : essayer de faire redescendre la cam qd RM bat des ailes(effet ouverture de parachute)
			else
				tf_angle = 0.2 * (- MATH_FloatMax((v_speed_target.z - 6.0) / 10.0, -2.5)) //35
	}
	else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Requin)
	{
		vector tv_vec 
		tv_vec = @o_mf_actor Proc_PNJ_Shark_VirtualSightGet()
		tf_angle = -tv_vec.z * 0.5
	}
	else if (i_mf_actor_Family == Ci_Kam_MontureFamily_Aigle)		// RM en l'air
		tf_angle = @o_mf_actor OBJ_SightGet().z * -0.75
	else
		tf_angle = 0.0
	
	if (i_mf_actor_Family == Ci_Kam_MontureFamily_Serpent)
		tf_angle = tv_banking.z / 10.0
	
	f_blend_vertical = MATH_FloatBlend(f_blend_vertical, tf_angle + f_normal_cam_AngleGround + f_normal_AngleGroundMainActor, f_Kamera_mode_init_infini * 5.0 * TIME_GetDt()) 	// Au sol
}


if ((MATH_AbsFloat(v_joyD_blend.y)>0.01 && ControlCamJoyD) && i_fight)
{
	f_blend_vertical += MATH_FloatSign(v_joyD_blend.y) * (v_joyD_blend.y * v_joyD_blend.y) * -@"univ" CAM_SensVert * (4.0 * TIME_GetDt())
	f_blend_vertical = MATH_FloatLimit(f_blend_vertical, -0.9,0.9)
}
else if (MATH_AbsFloat(v_joyD_blend.y)>0.01 && ControlCamJoyD)
{
	if (v_joyD_blend.y* @"univ" CAM_SensVert >0)
		tf_joyD_value = v_joyD_blend.y * f_normal_PadD_Zmin * -@"univ" CAM_SensVert
	else
		tf_joyD_value = v_joyD_blend.y * f_normal_PadD_Zmax * -@"univ" CAM_SensVert
	f_blend_vertical = tf_joyD_value + f_normal_cam_AngleGround
	f_blend_vertical = MATH_FloatLimit(f_blend_vertical, -0.9,0.9)
}
tv_cam_sight = MATH_VecBlendRotate(tv_cam_sight, -Cv_VerticalVector * MATH_FloatSign(f_blend_vertical), MATH_AbsFloat(f_blend_vertical))

if (i_fight || f_time)
	v_lock_cam_axis = tv_cam_sight								// Axe courant

f_time -= MATH_FloatMin(f_time,TIME_GetDt())

// JOY1 - Y -----------------------------------------------------------------------------------------------------------------
//if (MATH_AbsFloat(v_joyD_blend.y)>=0.01)
////if (f_joyD_norm && MATH_AbsFloat(v_joyD_blend.y)>=0.01)
//{
//	if (ti_fight)
//	{
//		f_blend_vertical += v_joyD_blend.y * -@"univ" CAM_SensVert * (3.0 * TIME_GetDt())
//		f_blend_vertical = MATH_FloatLimit(f_blend_vertical, -0.9,0.9)
//	}
//	else
//	{
//		if (v_joyD_blend.y* @"univ" CAM_SensVert >0)
//			tf_joyD_value = v_joyD_blend.y * f_normal_PadD_Zmin * -@"univ" CAM_SensVert
//		else
//			tf_joyD_value = v_joyD_blend.y * f_normal_PadD_Zmax * -@"univ" CAM_SensVert
//		
//		f_blend_vertical = tf_joyD_value
//	}
//
//	tv_cam_sight = MATH_VecBlendRotate(tv_cam_sight, -Cv_VerticalVector * MATH_FloatSign(f_blend_vertical), MATH_AbsFloat(f_blend_vertical))
//}
// JOY1 - Y -----------------------------------------------------------------------------------------------------------------


// Dist ------------------------------------------------------------------------------------------------------------------------
tf_camera_dist = f_normal_cam_Dist								// Distance nominal en normal

if (i_mf_actor_ID== C_ID_Lapin)
	tf_camera_dist *= MATH_FloatMax(1.5,@o_mf_actor OBJ_ZoomGet())
else if (i_mf_actor_ID==C_ID_Rayman && !@get_rayman i_ground_flag && @get_rayman PROC_RM_Type_HotspotGet() == C_HS_Type_Crochet)
		tf_camera_dist *= 1.5
else
	tf_camera_dist *= @o_mf_actor OBJ_ZoomGet()			// Ponderation Zoom

f_normal_cam_dist = MATH_FloatBlend(f_normal_cam_dist, tf_camera_dist, 5.0 * f_Kamera_mode_init_infini * TIME_GetDt())
// Dist ------------------------------------------------------------------------------------------------------------------------


// DODGE ----------------------------------------------------------------------------------------------------------------

tv_cam_pos = (tv_meca_cam_target + v_normal_target_delta) - ( MATH_VecNormalize(tv_cam_sight) * f_normal_cam_dist )

if (!i_fight)
{
	if (MATH_AbsFloat(v_joyD_blend.y)<=0.01)
	{
		tf_Zmax = KamP_CheckDodge(tv_cam_pos)
		if (tf_Zmax>f_cc_DodgeZmax)
			f_cc_DodgeZmax = MATH_FloatBlend(f_cc_DodgeZmax, tf_Zmax, TIME_GetDt() * f_Kamera_mode_init_infini * 4.0)
		else
			f_cc_DodgeZmax = MATH_FloatBlend(f_cc_DodgeZmax, tf_Zmax, TIME_GetDt() * f_Kamera_mode_init_infini * 1.5)
	}
	else
		f_cc_DodgeZmax = MATH_FloatBlend(f_cc_DodgeZmax, 0, TIME_GetDt() * f_Kamera_mode_init_infini)
	
	tv_cam_pos += cvector(0,0,f_cc_DodgeZmax)
}

//// MECA SPECIALE ------------------------
i_MECA_Mode = Ci_MecaMode_Position
//// MECA SPECIALE ------------------------

// DODGE ----------------------------------------------------------------------------------------------------------------


KamP_MECA_Pos_Blend(tv_meca_cam_target, v_normal_target_delta, tv_cam_pos, 1.2, f_normal_change_mode_speed)
//KamP_MECA_SightDist_Blend(tv_meca_cam_target, v_normal_target_delta, tv_cam_sight, f_normal_cam_dist, 1.2, f_normal_change_mode_speed)