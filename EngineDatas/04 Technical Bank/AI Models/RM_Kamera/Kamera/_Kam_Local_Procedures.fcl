#include "Kam_Defines.var"



procedure_local void Proc_Kam_Aniticipationne()
{
	vector		tv_pos_tete_kong	
	object		to_tete_kong 
	vector		tv_axis 
	object		to_gao 
	vector		tv_OldMECA_cam_sight
	float			tv_norm 

	int				ti_a
	int				ti_b

	i_flag = faux
	
	to_tete_kong = @get_rayman ANI_CanalObjectGet(0)
	tv_pos_tete_kong = @to_tete_kong OBJ_PosGet()

	tv_OldMECA_cam_sight = OBJ_PosGet() - tv_pos_tete_kong
	tv_norm = MATH_VecNorm(tv_OldMECA_cam_sight)
	tv_OldMECA_cam_sight /= tv_norm

	tv_axis = MATH_VecRotate(tv_OldMECA_cam_sight,Cv_VerticalVector,0.2)
	DBG_RenderVector(tv_pos_tete_kong - (OBJ_HorizonGet()*0.4), tv_axis*tv_norm ,color_jaune)
	COL_SpecificCrossableSet( (Gmat_RM_Crossable_Default & ~Gmat_RM_Cross_All_But_Camera) | Gmat_RM_Traversable_par_Camera )
	if (COL_RayIsCut_Dist(tv_pos_tete_kong - (OBJ_HorizonGet()*0.4), tv_axis, tv_norm , all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet))
		ti_a = vrai
	else
		ti_a = faux

	tv_axis = MATH_VecRotate(tv_OldMECA_cam_sight,Cv_VerticalVector,-0.2)
	DBG_RenderVector(tv_pos_tete_kong + (OBJ_HorizonGet()*0.4), tv_axis*tv_norm ,color_jaune)
	COL_SpecificCrossableSet( (Gmat_RM_Crossable_Default & ~Gmat_RM_Cross_All_But_Camera) | Gmat_RM_Traversable_par_Camera )
	if (COL_RayIsCut_Dist(tv_pos_tete_kong + (OBJ_HorizonGet()*0.4), tv_axis, tv_norm , all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet))
		ti_b = vrai
	else
		ti_b = faux
	
	if (ti_a && ti_b)
		f_tourne = 0
	else if (ti_b)
	{
		
		f_tourne = MATH_FloatMin(-0.01,MATH_FloatBlend(f_tourne, -1.0, 5.0*TIME_GetDt()))
		Str_DisplayFloatOnce(f_tourne, Cv_NullVector)
		i_flag = vrai
	}
	else if (ti_a)
	{
		f_tourne = MATH_FloatMax(0.01,MATH_FloatBlend(f_tourne, 1.0, 5.0*TIME_GetDt()))
		Str_DisplayFloatOnce(f_tourne, Cv_NullVector)
		i_flag = vrai
	}
}

procedure_local void KamP_SettingsFctGaoTarget(object o_gao)
{
	if (@get_rayman PROC_RM_ModeLookON())
	{
//		o_mf_actor = get_rayman
		i_mf_actor_Family = Ci_Kam_MontureFamily_RM
		f_normal_cam_Dist = Cf_RM_Dist_LOCK - (MATH_FloatMax(0,OBJ_SightGet().z) * Cf_RM_Dist_LOCK)
		f_normal_coef_speed = 0.5
		f_normal_cam_AngleGround = Cf_RM_AngleGround_LOCK
		f_normal_camT_TargetHorizCoef = Cf_RM_TargetHorizCoef_LOCK
		f_normal_camT_TargetZ = Cf_RM_TargetZ
		f_normal_camT_TargetHorizDotMin = Cf_RM_TargetDotMin
		f_normal_cam_GroundAngleCoef = Cf_RM_GroundAngleCoef
		f_normal_PadD_Zmin  = Cf_RM_PadD_Zmin
		f_normal_PadD_Zmax = Cf_RM_PadD_Zmax
	}
	else
	{
		switch (i_mf_actor_ID)
		{
			case C_ID_Monture_Rhino :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Rhino
				f_normal_cam_Dist = Cf_RHI_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_RHI_AngleGround
				f_normal_camT_TargetZ = Cf_RHI_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_RHI_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_RHI_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_RHI_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_RHI_PadD_Zmin
				f_normal_PadD_Zmax = Cf_RHI_PadD_Zmax
				break
	
			case C_ID_Monture_Tigre :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Rhino
				f_normal_cam_Dist = Cf_TIG_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_TIG_AngleGround
				f_normal_camT_TargetZ = Cf_TIG_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_TIG_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_TIG_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_TIG_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_TIG_PadD_Zmin
				f_normal_PadD_Zmax = Cf_TIG_PadD_Zmax
				break
	
			case C_ID_Monture_Aigle :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Aigle
				f_normal_cam_Dist = Cf_AIG_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_AIG_AngleGround
				f_normal_camT_TargetZ = Cf_AIG_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_AIG_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_AIG_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_AIG_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_AIG_PadD_Zmin
				f_normal_PadD_Zmax = Cf_AIG_PadD_Zmax
				break

			case C_ID_Monture_Soucoupe :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Aigle
				f_normal_cam_Dist = Cf_SOU_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_SOU_AngleGround
				f_normal_camT_TargetZ = Cf_SOU_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_SOU_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_SOU_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_SOU_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_SOU_PadD_Zmin
				f_normal_PadD_Zmax = Cf_SOU_PadD_Zmax
				break
	
			case C_ID_Monture_Bat :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Aigle
				f_normal_cam_Dist = Cf_BAT_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_BAT_AngleGround
				f_normal_camT_TargetZ = Cf_BAT_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_BAT_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_BAT_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_BAT_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_BAT_PadD_Zmin
				f_normal_PadD_Zmax = Cf_BAT_PadD_Zmax
				break
	
			case C_ID_Monture_Requin :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Requin
				f_normal_cam_Dist = Cf_SRK_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_SRK_AngleGround
				f_normal_camT_TargetZ = Cf_SRK_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_SRK_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_SRK_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_SRK_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_SRK_PadD_Zmin
				f_normal_PadD_Zmax = Cf_SRK_PadD_Zmax
				break

			case C_ID_Monture_PoissonLumiere :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Requin
				f_normal_cam_Dist = Cf_POI_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_POI_AngleGround
				f_normal_camT_TargetZ = Cf_POI_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_POI_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_POI_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_POI_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_POI_PadD_Zmin
				f_normal_PadD_Zmax = Cf_POI_PadD_Zmax
				break
	
			case C_ID_Monture_Serpent :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Serpent
				f_normal_cam_Dist = Cf_SNK_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_SNK_AngleGround
				f_normal_camT_TargetZ = Cf_SNK_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_SNK_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_SNK_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_SNK_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_SNK_PadD_Zmin
				f_normal_PadD_Zmax = Cf_SNK_PadD_Zmax
	
			case C_ID_Monture_Araignee :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Serpent
				f_normal_cam_Dist = Cf_SPI_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_SPI_AngleGround
				f_normal_camT_TargetZ = Cf_SPI_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_SPI_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_SPI_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_SPI_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_SPI_PadD_Zmin
				f_normal_PadD_Zmax = Cf_SPI_PadD_Zmax
				break

			case C_ID_Monture_Quadripode :
				i_mf_actor_Family = Ci_Kam_MontureFamily_Serpent
				f_normal_cam_Dist = Cf_QUA_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_QUA_AngleGround
				f_normal_camT_TargetZ = Cf_QUA_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_QUA_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_QUA_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_QUA_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_QUA_PadD_Zmin
				f_normal_PadD_Zmax = Cf_QUA_PadD_Zmax
				break
	
			case C_ID_Lapin :
				i_mf_actor_Family = Ci_Kam_MontureFamily_RM
				f_normal_cam_Dist = Cf_LAP_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_LAP_AngleGround
				f_normal_camT_TargetZ = Cf_LAP_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_LAP_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_LAP_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_LAP_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_LAP_PadD_Zmin
				f_normal_PadD_Zmax = Cf_LAP_PadD_Zmax
				break
				
			case C_ID_Scooter :
				i_mf_actor_Family = Ci_Kam_MontureFamily_RM
				f_normal_cam_Dist = Cf_SCO_Dist
				f_normal_coef_speed = 0.7
				f_normal_cam_AngleGround = Cf_SCO_AngleGround
				f_normal_camT_TargetZ = Cf_SCO_TargetZ
				f_normal_camT_TargetHorizCoef = Cf_SCO_TargetHorizCoef
				f_normal_camT_TargetHorizDotMin = Cf_SCO_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_SCO_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_SCO_PadD_Zmin
				f_normal_PadD_Zmax = Cf_SCO_PadD_Zmax
				break
			case C_ID_Rayman :
			default:
				i_mf_actor_Family = Ci_Kam_MontureFamily_RM
	
	//			if (@get_rayman PROC_RM_ModeLookON())
	//			{
	//				f_normal_cam_Dist = Cf_RM_Dist_LOCK
	//				f_normal_cam_AngleGround = Cf_RM_AngleGround_LOCK
	//				f_normal_camT_TargetHorizCoef = Cf_RM_TargetHorizCoef_LOCK
	//			}
	//			else
				{
					f_normal_cam_Dist = Cf_RM_Dist
					f_normal_coef_speed = 0.5
					f_normal_cam_AngleGround = Cf_RM_AngleGround
					f_normal_camT_TargetHorizCoef = Cf_RM_TargetHorizCoef
				}
	
				f_normal_camT_TargetZ = Cf_RM_TargetZ
				f_normal_camT_TargetHorizDotMin = Cf_RM_TargetDotMin
				f_normal_cam_GroundAngleCoef = Cf_RM_GroundAngleCoef
				f_normal_PadD_Zmin  = Cf_RM_PadD_Zmin
				f_normal_PadD_Zmax = Cf_RM_PadD_Zmax
				break
		}
	}
	
	if ( !@get_rayman PROC_RM_ModeLookON() )
	{
		// Kamera Modifier
		if(f_KMAdjust_Distance)
			f_normal_cam_Dist = f_KMAdjust_Distance
		if(f_KMAdjust_Angle)
			f_normal_cam_AngleGround = f_KMAdjust_Angle
		if (f_KMAdjust_CoefDecentrageHoriz != 1.0)
			f_normal_camT_TargetHorizCoef = f_KMAdjust_CoefDecentrageHoriz 
	}
}

procedure_local void KamP_Backup_MECACompatible_Value()
{
	// Recupere des valeurs compatible avec la meca

	v_OldMECA_cam_target = v_MECA_cam_target						// Position de la Target
	v_OldMECA_cam_sight = OBJ_SightGet()								// Axis
	v_OldMECA_cam_pos = OBJ_PosGet()									// Position de la camera

	//procedure int MATH_LIB_Intersection_Dir_Plane(vector tv_start_pos, vector tv_dir, vector tv_plan_pos, vector tv_plan_normale, byref float tf_dist, byref vector tv_collide_pos)
	MATH_LIB_Intersection_Dir_Plane(v_OldMECA_cam_pos, v_OldMECA_cam_sight, v_OldMECA_cam_target, OBJ_SightGet(), f_OldMECA_cam_dist, v_OldMECA_cam_target_delta)

	v_OldMECA_cam_target_delta -= v_OldMECA_cam_target
}

procedure_local void KamP_Backup_Change_Mode_Value()
{	
	// Backup et Init des valeurs pour le Changement de mode
	vG_chm_cam_target = v_OldMECA_cam_target						// Backup Position
	vG_chm_cam_target_delta = v_OldMECA_cam_target_delta		// Backup Delta
	vG_chm_cam_sight = v_OldMECA_cam_sight 							// Backup Axis
	fG_chm_cam_dist = f_OldMECA_cam_dist								// Backup Dist
	vG_chm_cam_pos = v_OldMECA_cam_pos								// Backup Position
	fG_chm_cam_focale = f_MECA_cam_focale								// Backup Focale

	f_chm_coef = 0																	// Init change mode progression value (0>1)
	f_chm_coef_bis = 0																// Init change mode speed progression value

	i_chm_flags = 0																	// Flags
	if (!o_mf_actor_blend || o_mf_actor_blend != o_mf_actor)				// Si on garde le meme acteur alors on peut ne pas faire de blend sur la target.
		i_chm_flags |= 0b00000001
//	DBG_TraceString("BLEND Flags:")
//	DBG_TraceInt(i_chm_flags)
//	DBG_TraceEOL()
}

procedure_local void KamP_Exit_FPS_Value_Restore()
{	
	// Restore les Backup et Init des valeurs pour le Changement de mode
	v_OldMECA_cam_target = vG_chm_cam_target						// Backup Position
	v_OldMECA_cam_target_delta = vG_chm_cam_target_delta 		// Backup Delta
	v_OldMECA_cam_sight  = vG_chm_cam_sight							// Backup Axis
	f_OldMECA_cam_dist = fG_chm_cam_dist								// Backup Dist
	v_OldMECA_cam_pos = vG_chm_cam_pos								// Backup Position
	f_MECA_cam_focale = fG_chm_cam_focale								// Backup Focale
}
procedure_local void KamP_MECA_SightDist_Blend( vector tv_target, vector tv_target_delta, vector tv_cam_sight, float tf_cam_dist, float tf_cam_focale, float tf_bend_speed )
{
	// Blend les valeurs de MECA avec les Valeurs Backupé
	
	f_chm_coef_bis = MATH_FloatBlend(f_chm_coef_bis, tf_bend_speed, 4.0 *TIME_GetDt())				// Speed du blend
	f_chm_coef = MATH_FloatBlend(f_chm_coef, 1.0, f_chm_coef_bis * TIME_GetDt())							// Progression

	if (i_chm_flags & 0b00000001)
		v_MECA_cam_target = MATH_VecBlend(vG_chm_cam_target, tv_target, f_chm_coef)				// Blend Target
	else
		v_MECA_cam_target = tv_target																							// No blend Target
		
	v_MECA_cam_target_delta = MATH_VecBlend(vG_chm_cam_target_delta, tv_target_delta, f_chm_coef)   	// Blend Delta
	v_MECA_cam_sight	= MATH_VecBlendRotate(vG_chm_cam_sight, tv_cam_sight, f_chm_coef) 			// Blend Sight
	f_MECA_cam_dist = MATH_FloatBlend(fG_chm_cam_dist, tf_cam_dist, f_chm_coef)						// Blend Dist
	f_MECA_cam_focale = MATH_FloatBlend(fG_chm_cam_focale, tf_cam_focale, f_chm_coef)			// Blend Focale
}

procedure_local void KamP_MECA_Pos_Blend( vector tv_target, vector tv_target_delta, vector tv_cam_pos, float tf_cam_focale, float tf_bend_speed )
{
	// Blend les valeurs de MECA avec les Valeurs Backupé
	
	f_chm_coef_bis = MATH_FloatBlend(f_chm_coef_bis, tf_bend_speed, 4.0 *TIME_GetDt())				// Speed du blend
	f_chm_coef = MATH_FloatBlend(f_chm_coef, 1.0, f_chm_coef_bis * TIME_GetDt())							// Progression

	if (i_chm_flags & 0b00000001)
		v_MECA_cam_target = MATH_VecBlend(vG_chm_cam_target, tv_target, f_chm_coef) 				// Blend Target
	else
		v_MECA_cam_target = tv_target																							// No blend Target
	
	v_MECA_cam_target = MATH_VecBlend(vG_chm_cam_target, tv_target, f_chm_coef)																							// No blend Target
	v_MECA_cam_target_delta = MATH_VecBlend(vG_chm_cam_target_delta, tv_target_delta, f_chm_coef)   	// Blend Delta
	v_MECA_cam_pos = MATH_VecBlend(vG_chm_cam_pos, tv_cam_pos, f_chm_coef) 					// Blend Position
	f_MECA_cam_focale = MATH_FloatBlend(fG_chm_cam_focale, tf_cam_focale, f_chm_coef)			// Blend Focale
}


procedure_local void KamP_MECA_Fps_Blend( vector tv_cam_pos, vector tv_cam_sight, float tf_cam_focale,  float tf_bend_speed )
{
	// Blend les valeurs de MECA avec les Valeurs Backupé
	float tf_norm
	if( tf_bend_speed == Cf_Infinit )
	{
		// cut cam
		f_chm_coef_bis = 1.0
		f_chm_coef = 1.0
	}
	else
	{
		f_chm_coef_bis = MATH_FloatBlend(f_chm_coef_bis, tf_bend_speed, 4.0 *TIME_GetDt())			// Speed du blend
		f_chm_coef = MATH_FloatBlend(f_chm_coef, 1.0, f_chm_coef_bis * TIME_GetDt())						// Progression
	}
	v_MECA_cam_pos = MATH_VecBlend(vG_chm_cam_pos, tv_cam_pos, f_chm_coef) 					// Blend Position

	v_MECA_cam_sight	= MATH_VecBlendRotate(vG_chm_cam_sight, tv_cam_sight, f_chm_coef) 			// Blend Sight

	tf_norm = MATH_VecNorm(v_MECA_cam_pos - tv_cam_pos)
	v_MECA_cam_pos = tv_cam_pos - (v_MECA_cam_sight * tf_norm)

	f_MECA_cam_focale = MATH_FloatBlend(fG_chm_cam_focale, tf_cam_focale, f_chm_coef)			// Blend Focale
	v_MECA_cam_target = v_MECA_cam_pos + (v_MECA_cam_sight * 1.0)									// Target n metres devant Cam
	
//	DBG_RenderSphere(v_MECA_cam_target, 0.1,color_rouge)
	v_MECA_cam_target_delta = MATH_VecBlend(vG_chm_cam_target_delta, Cv_NullVector, f_chm_coef)   	// Blend Delta
}


procedure_local void KamP_MECA_Reward_Blend( vector tv_cam_pos, vector tv_cam_sight, float tf_cam_focale,  float tf_bend_speed )
{
	// Blend les valeurs de MECA avec les Valeurs Backupé
	if( tf_bend_speed == Cf_Infinit )
	{
		// cut cam
		f_chm_coef_bis = 1.0
		f_chm_coef = 1.0
	}
	else
	{
		f_chm_coef_bis = MATH_FloatBlend(f_chm_coef_bis, tf_bend_speed, 4.0 *TIME_GetDt())				// Speed du blend
		f_chm_coef = MATH_FloatBlend(f_chm_coef, 1.0, f_chm_coef_bis * TIME_GetDt())							// Progression
	}
	v_MECA_cam_pos = MATH_VecBlend(vG_chm_cam_pos, tv_cam_pos, f_chm_coef) 			// Blend Position
	v_MECA_cam_sight	= MATH_VecBlendRotate(vG_chm_cam_sight, tv_cam_sight, f_chm_coef) 			// Blend Sight
	f_MECA_cam_focale = MATH_FloatBlend(fG_chm_cam_focale, tf_cam_focale, f_chm_coef)			// Blend Focale
	v_MECA_cam_target = v_MECA_cam_pos + (v_MECA_cam_sight * 15.0)									// Target n metres devant Cam
	v_MECA_cam_target_delta = MATH_VecBlend(vG_chm_cam_target_delta, Cv_NullVector, f_chm_coef)   	// Blend Delta
}


procedure_local void KamP_JoyD_Get()
{
	float	tf_joy_value
	
	v_joyD = IO_JoyGetMove1()
	if ( @"univ"  CAM_Rotation)
		v_joyD.x = -v_joyD.x
	if ( @get_rayman i_cheat_mode )
	{
		f_joyD_norm = 0
		v_joyD = Cv_NullVector
		i_MECA_TestRayCast = faux
	}
	else 
	{
		// VECTEUR
		if (MATH_VecNullToler(v_joyD, tolerance_joynull))
		{
			f_joyD_norm = 0
			v_joyD = Cv_NullVector
		}
		else
		{
			f_joyD_norm = MATH_FloatMin(MATH_VecNorm(v_joyD), 1.0) - tolerance_joynull
			f_joyD_norm /= 1.0 - tolerance_joynull
			MATH_VecSetNorm(v_joyD, f_joyD_norm)
		}

		// X-Y DISSOCIE
		if ( MATH_AbsFloat(v_joyD.x) > tolerance_joynull)
		{
			tf_joy_value = (v_joyD.x - (MATH_FloatSign(v_joyD.x) * tolerance_joynull)) / (1-tolerance_joynull)
			v_joyD_blend.x = MATH_FloatBlend(v_joyD_blend.x, tf_joy_value, f_joyDx * TIME_GetDt())
		}
		else
		{
			if (!i_flag)
				v_joyD_blend.x = MATH_FloatBlend(v_joyD_blend.x, 0, f_joyDx_null * TIME_GetDt())
		}
		if ( MATH_AbsFloat(v_joyD.y) > tolerance_joynull)
		{
			tf_joy_value = (v_joyD.y - (MATH_FloatSign(v_joyD.y) * tolerance_joynull)) / (1-tolerance_joynull)
			v_joyD_blend.y = MATH_FloatBlend(v_joyD_blend.y, tf_joy_value, f_joyDx * TIME_GetDt())
		}
		else
			v_joyD_blend.y = MATH_FloatBlend(v_joyD_blend.y, 0, f_joyDx_null * TIME_GetDt())
		
		f_joyD_blend_norm = MATH_VecNorm(v_joyD_blend)
		if (f_joyD_blend_norm < 0.01)
			f_joyD_blend_norm = 0
	}
}

procedure_local void KamP_JoyD_BlendSet(float tf_joyDx_null, float tf_joyDy_null, float tf_joyDx, float  tf_joyDy)
{
	f_joyDx_null = tf_joyDx_null
	f_joyDy_null = tf_joyDy_null
	f_joyDx = tf_joyDx
	f_joyDy = tf_joyDy
}
	
procedure_local void KamP_Mode_Set(int ti_mode)
{
	// Change de mode et fait quelques inits systematiques
	i_kong_camera_mode = ti_mode
	i_Kamera_mode_init_flag = vrai
	f_Kamera_mode_init_infini = Cf_Infinit
}

procedure_local void KamP_MECA_SightDist_DBGRender()
{
	DBG_RenderSphere(v_MECA_cam_target,0.25,color_rouge)
	DBG_RenderVector(v_MECA_cam_target,v_MECA_cam_target_delta, color_blanc)
	DBG_RenderSphere(v_MECA_cam_target+v_MECA_cam_target_delta,0.25,color_vert)
	DBG_RenderVector(v_MECA_cam_target+v_MECA_cam_target_delta, -MATH_VecNormalize(v_MECA_cam_sight) * f_MECA_cam_dist, color_blanc)
	DBG_RenderSphere((v_MECA_cam_target+v_MECA_cam_target_delta) - (MATH_VecNormalize(v_MECA_cam_sight) * f_MECA_cam_dist), 0.25, color_bleu)
}

procedure_local float KamP_CheckDodge(vector tv_cam_pos)
{
	// 1 Check Dodge Collide
	// 2 Get Dodge ZMax
	// Change Tv_Cam_Pos
	object		to_gao[40], to_obj
	int				ti_nbr, ti_loop
	vector		tv_bv_max
	float			tf_Zmax
	int				ti_k
	object		to_bone_BV
	int				ti_CreatureType 

	OBJ_PosSet(tv_cam_pos)
	tf_Zmax = tv_cam_pos.z
	
	ti_nbr = COL_BVGetAllOverlaps(&to_gao[0],OBJ_C_TypeFlag_DodgeCamera,none,Ci_Filter_TypeFlag)
//	ti_nbr = COL_Pivot_BVListGet(&to_gao[0],OBJ_C_TypeFlag_DodgeCamera,none,Ci_Filter_TypeFlag)
	if (ti_nbr)
	{
		// Il y a collision avec une BV
		for (ti_loop = 0; ti_loop < ti_nbr; ti_loop++)
		{
			to_obj = to_gao[ti_loop]
			
			if (@to_obj AI_IsModel(get_PNJ_Snake_path))
			{
				ti_CreatureType = @to_obj Proc_PNJ_Snake_CreatureTypeGet()
//				if (ti_CreatureType != -1)
//				{
//				}

				for (ti_k = 0; ti_k < 15; ti_k+=3)
				{
					switch(ti_CreatureType)
					{
						case C_ID_Monture_Araignee :
						case C_ID_Monture_Quadripode :
							to_bone_BV = to_obj
							ti_k = 15
							break
							
						case C_ID_Monture_Serpent :
							if (ti_k == 14)
								to_bone_BV = @to_obj ANI_CanalObjectGet(Anim_Canal_Bassin)
							else
								to_bone_BV = @to_obj ANI_CanalObjectGet(ti_k)
							break
					}
				
					if (@to_bone_BV OBJ_BankingGet().z > 0.0)
					{
						tv_bv_max = @to_bone_BV BV_MaxGet()
						tv_bv_max.z -= 0.1
						tv_bv_max += @to_bone_BV OBJ_PosGet()
						
						if (tf_Zmax < tv_bv_max.z)
						{
							DBG_RenderVector(tv_cam_pos, cvector(0.0, 0.0, tv_bv_max.z - tv_cam_pos.z), color_blanc)
							tf_Zmax = tv_bv_max.z
						}
					}
					else
					{
						tv_bv_max = @to_bone_BV BV_MinGet()
						tv_bv_max.z += 0.1
						tv_bv_max += @to_bone_BV OBJ_PosGet()
						
						if (tf_Zmax > tv_bv_max.z)
						{
							DBG_RenderVector(tv_cam_pos, cvector(0.0, 0.0, tv_bv_max.z - tv_cam_pos.z), color_blanc)
							tf_Zmax = tv_bv_max.z
							tf_Zmax -= 2.0 * Cf_Taille_Bv
						}
					}
				}
			}
			else
			{
				tv_bv_max = @to_obj BV_MaxGet()
				tf_Zmax = MATH_FloatMax( @to_obj OBJ_PosGet().z + (tv_bv_max.z - 0.1), tf_Zmax)
			}
		}	
	}

	if (tf_Zmax - tv_cam_pos.z)
	{
		tf_Zmax += Cf_Taille_Bv 
			if (@"univ" i_cheat_page == 2 && f_cc_DodgeZmax)
		STR_CreateText("\cFFFF5555\D", cvector(0.017, 0.11+(0.04 * (@get_global i_cheat_2_nbr)), 0.0), 0)
	}

	return ((tf_Zmax - tv_cam_pos.z))
}


procedure_local vector KamP_TargetGao_BlendPosGet( object to_gao, float tf_blendspeed)
{
	if ( (f_chm_coef <= 0.999 || to_gao != o_MECA_cam_target) || MATH_VecDotProduct(v_MECA_cam_target- @to_gao OBJ_PosGet(), v_MECA_cam_target- @to_gao OBJ_PosGet()) > 100.0 )
	{
		// GAO DIFFERENT ou Perso TELEPORTé
		o_MECA_cam_target = to_gao
		tf_blendspeed = Cf_Infinit
	}
	return MATH_VecBlend(v_MECA_cam_target, @to_gao OBJ_PosGet(), f_Kamera_mode_init_infini * tf_blendspeed * TIME_GetDt() )
//	return MATH_VecBlend(v_MECA_cam_target, @to_gao OBJ_PosGet(), Cf_Infinit* TIME_GetDt() )
}

procedure_local vector KamP_TargetVec_BlendPosGet( vector tv_vec, float tf_blendspeed)
{
	return MATH_VecBlend(v_MECA_cam_target, tv_vec, tf_blendspeed * TIME_GetDt() )
}


