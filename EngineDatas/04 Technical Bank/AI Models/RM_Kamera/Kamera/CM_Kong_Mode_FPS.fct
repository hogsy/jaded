#include "Kam_Defines.var"

// ######################
// MODE FPS
// ######################

#define C_JoyTolX						0.15
#define C_JoyTolY						0.15

#define SPEED_X_NORMAL			3.0 
#define SPEED_Y_NORMAL			1.75
#define SPEED_AX_NORMAL		1.2 

#define SPEED_X_WEAPON			2.0 
#define SPEED_Y_WEAPON		1.75
#define SPEED_AX_WEAPON		1.2

#define SPEED_X_LOCK				1.5	//2.0
#define SPEED_Y_LOCK				1.31	//1.0
#define SPEED_AX_LOCK			1.0


object	to_gao

vector	tv_look_axis 

vector	tv_fps_new_pos
vector	tv_fps_new_sight

float		tf_normX
float		tf_normY
float		tf_sight_Z
float		tf_cote 
float		tf_meca_cam_transitionspeed
float		tf_bestsight
float		tf_dot
float		tf_temp
float		tf_hauteur
float		tf_speed_rot_x
float		tf_speed_rot_y
float		tf_speed_rot_ax
float		tf_focal
float		tf_look_amplitude

vector	tv_joy_sight
vector	tv_joy_move
vector	tv_hor
vector	tv_joy_speed
vector	tv_speed
vector	tv_temp
vector	tv_temp2
vector	tv_master_joy1
vector	tv_joy1

vector	tv_fps_new_banking
vector	tv_joyD
vector	tv_relative
vector	tv_sight_init

object	to_jack
object	to_kong
object	to_bestsight
object	tao_obj[100]
object	to_obj
object	to_obj1
object	to_camera_animee
object	to_target
object	to_bone
object	to_bone2
object	to_tete

int			ti_weapon
int			ti_best_prio
int			ti_num
int			ti_prio
int			ti_bambou
int			ti_Reward_to_Fps_flag
int			ti_dbg_info_photo

// MECA SPECIALE ------------------------
i_MECA_Mode = Ci_MecaMode_FPS
// MECA SPECIALE ------------------------

ti_Reward_to_Fps_flag = faux
if (i_kong_camera_mode != Ci_Kamera_mode_FPS)
{
//	if (f_normal_change_mode_speed_forced >= 0 )
//		f_normal_change_mode_speed = f_normal_change_mode_speed_forced
//	else
	f_normal_change_mode_speed =   20.0
		
	// INIT du MODE ou CHANGEMENT de PARAM
	KamP_Mode_Set(Ci_Kamera_mode_FPS)

	// Backup des Valeurs pour le BLEND entre les modes
	KamP_Backup_Change_Mode_Value()

	i_FPS_Flag = vrai

	v_look_axis = @get_rayman OBJ_SightGet()

	i_fps_Jack_visible = faux
	f_fps_duration = 0.0
	f_blend_z = 0.0
	f_fps_effet_marche_hauteur = 0.0
	v_fps_effet_marche_vertical = Cv_NullVector
	f_fps_angle = Cf_fps_angle_non_defini
	f_fps_time_auto = 0.0

	to_target = nobody		// target de kong
	
	// CONTROLE DE LA CAMERA SUR L'EPAULE
	i_fps_epaule_cone_kong = faux
	i_fps_epaule_relative_kong = faux
	i_fps_epaule_kong_rotation_flag = faux

	f_chm_speed_forced = 10.0		// cut cam en sortant du mode
}
else
	f_fps_duration += TIME_GetDt()



if ( i_mf_actor_ID != C_ID_Rayman && (glob_joynorm_get || i_FPS_Flag) )
{
	// Je regarde dans la visé de la monture
	if (f_joyD_norm)
		i_FPS_Flag = faux
	else		
		i_FPS_Flag = vrai
		
	switch (i_mf_actor_ID)
	{
		case C_ID_Monture_Requin :
		case C_ID_Monture_PoissonLumiere :
			tv_look_axis = @o_mf_actor Proc_PNJ_Shark_VirtualSightGet()
			break
			
		case C_ID_Monture_Rhino :
		case C_ID_Monture_Tigre :
		case C_ID_Monture_Aigle :
		case C_ID_Monture_Bat :
		case C_ID_Monture_Soucoupe :
		case C_ID_Monture_Serpent :
		case C_ID_Monture_Araignee :
		case C_ID_Monture_Quadripode :
		default:	
			tv_look_axis = @o_mf_actor OBJ_SightGet()
			v_MECA_cam_banking = @o_mf_actor OBJ_BankingGet()
	}
	v_look_axis = MATH_VecBlendRotate(v_look_axis, tv_look_axis, 5.0 * TIME_GetDt() * f_Kamera_mode_init_infini)

	// Regarde en local au JoyD
	tv_joyD = -v_joyD_blend
	tv_joyD.z = tv_joyD.y * 0.5 * @"univ" CAM_SensVert
	tv_joyD.y = 1
	tv_joyD.x *= -1 * 0.5
	v_MECA_orientation_locale = MATH_VecNormalize(tv_joyD)

//	if (o_lock)
//		f_lock_blend = 1.0

}
else
{
	// CONTROL JOY
	if ( f_chm_coef > 0.90 )
	{
		tv_joy1 = IO_JoyGetMove1()

		if (f_joyD_norm)
		{
//			o_lock = nobody
			
			// Lecture du JOY
			tv_joy1.x = MATH_FloatLimit(tv_joy1.x, -1, 1)
			tv_joy1.y = MATH_FloatLimit(tv_joy1.y, -1, 1)
			
			tf_speed_rot_x = 5.0
			tf_speed_rot_y = 5.0
	
			if(MATH_AbsFloat(tv_joy1.x) > C_JoyTolX)
			{
				tv_joy1.x -= C_JoyTolX * MATH_FloatSign(tv_joy1.x)
				tv_joy1.x = (tv_joy1.x * tv_joy1.x) * MATH_FloatSign(tv_joy1.x)
				tv_joy1.x *= (TIME_GetDt() * tf_speed_rot_x)
				v_look_axis = MATH_VecRotate(v_look_axis, Cv_VerticalVector, tv_joy1.x * @"univ" CAM_SensHoriz)
			}
			
			if(MATH_AbsFloat(tv_joy1.y) > C_JoyTolY)
			{
				tv_joy1.y -= C_JoyTolY * MATH_FloatSign(tv_joy1.y)
				tv_joy1.y = (tv_joy1.y * tv_joy1.y) * tv_joy1.y
				tv_joy1.y *= (TIME_GetDt() * tf_speed_rot_y)
				v_look_axis = MATH_VecRotate(v_look_axis, -OBJ_HorizonGet(), tv_joy1.y * @"univ" CAM_SensVert)
			}
		}
			
		// CONTRAINTE Z
		if ( v_look_axis.z > 0.95 )
		{
			v_look_axis.z = 0
			MATH_VecSetNormalize( v_look_axis )
			v_look_axis *= 0.31225  // = sqrt( 1 - (0.95*0.95) )
			v_look_axis.z = 0.95
		}
		else if ( v_look_axis.z < -0.95 )
		{
			v_look_axis.z = 0
			MATH_VecSetNormalize( v_look_axis)
			v_look_axis *= 0.31225  // = sqrt( 1 - (0.95*0.95) )
			v_look_axis.z = -0.95
		}
	}

//	if (o_lock && !f_joyD_norm )
//	{
//		f_lock_blend = MATH_FloatMin(1.0, f_lock_blend + (TIME_GetDt() * 2.0))
//		v_look_axis = MATH_VecBlendRotate(v_lock_axis, MATH_VecNormalize( @o_lock OBJ_PosGet() - OBJ_PosGet() ), f_lock_blend)
//	}
}


tv_fps_new_pos = @get_rayman OBJ_PosGet() + (@get_rayman OBJ_BankingGet() * 1.15)


KamP_MECA_Fps_Blend(tv_fps_new_pos, v_look_axis, 1.2, f_normal_change_mode_speed)

if (f_chm_coef > 0.9) //  MATH_VecDotProduct(tv_fps_new_pos - OBJ_PosGet(), tv_fps_new_pos - OBJ_PosGet()) < 1.0)
{
	to_gao = @get_rayman ANI_CanalObjectGet(Anim_Canal_EpauleGauche )
	@to_gao OBJ_FlagInvisibleSet(vrai)						// Invisible
	to_gao = @get_rayman ANI_CanalObjectGet(Anim_Canal_EpauleDroite)
	@to_gao OBJ_FlagInvisibleSet(vrai)						// Invisible
	to_gao = @get_rayman ANI_CanalObjectGet(Anim_Canal_Tete)
	@to_gao OBJ_FlagInvisibleSet(vrai)						// Invisible
	
	if (i_mf_actor_ID == C_ID_Rayman && @get_rayman PROC_RM_ModeLookORIENT())
	{
		tv_temp = v_look_axis
		tv_temp.z = 0
		@get_rayman OBJ_SightSet(tv_temp)
	}
}

Str_DisplayTextOnce("\jxy\\h0.15\\c444444\X", cvector(0.5,0.5,0))

to_gao = @get_rayman PROC_RM_ITEM_Has_Key()
if (to_gao)
	@to_gao OBJ_FlagInvisibleSet(vrai)
