int			i, ripple
vector 	tv_temp
float		sizez
int 		i_Gfx
int			ti_inst 
object	to_main

if( @get_global i_Player_is_Kong )
	to_main = AI_MainActorGet(C_ID_Kong)
else
	to_main = AI_MainActorGet(C_ID_Joueur)

// On fait descendre les gouttes
OBJ_CapaSet(OBJ_Capa_1, 0)
for(i = 0; i <= i_cur_gouttes; i++)
{
	tv_temp = av_pos_gouttes[i]
	if(!MATH_VecNull(tv_temp))
	{
		OBJ_CapaSet(0, OBJ_Capa_1)
		af_speed_gouttes[i] += af_vit_gouttes[i] * TIME_GetDt()
		tv_temp.z -= af_speed_gouttes[i]
		av_pos_gouttes[i] = tv_temp
		sizez = (des_f_longueur_g + (3 * af_speed_gouttes[i]))
		
		// Sol atteind ?
		if(tv_temp.z <= f_ZSol )
		{
			av_pos_gouttes[i] = Cv_NullVector
			GFX_Del(ai_id_gouttes[i])
			
			i_Gfx = GFX_Add(9)  // ajout de l’effet
 			GFX_FlagSet(i_Gfx,0,1) // activation de l’effet
 			GFX_FlagSet(i_Gfx, 2, 1) // matériau transparent
 			GFX_MaterialSet(i_Gfx, get_SFX_light_and_smoke,5)	// matériau
 		    tv_temp.z = f_ZSol
			GFX_Setv( i_Gfx, 9200, tv_temp) //position
			GFX_Setv( i_Gfx, 9201, cvector( 0, 0, 0.1)) // axe du cone de vitesse
			 GFX_Setv( i_Gfx, 9202, cvector( 0, 0, -5) )	 // gravité
			 GFX_Seti( i_Gfx, 9100, 10)	 // nb max d’étincelles
			 if(des_i_color_spark)
			 	GFX_Seti( i_Gfx, 9101, des_c_spark)	 // couleur
			 else
			 	GFX_Seti( i_Gfx, 9101, des_c_ripple)	 // couleur
			 GFX_Seti (i_Gfx, 9102, 24) // flags : 16 => bit 4 à 1 => temps de mort
			 GFX_Setf( i_Gfx, 9000, 0.1 )	 // angle
			 GFX_Setf( i_Gfx, 9001, 15) // speed min
			 GFX_Setf( i_Gfx, 9002, 25) // speed max
			 GFX_Setf( i_Gfx, 9003, 0.99) // friction
			 GFX_Setf( i_Gfx, 9004, 0.02 ) // width
			 GFX_Setf( i_Gfx, 9005, 0.1 ) // time min
			 GFX_Setf( i_Gfx, 9006, 0.2 ) // time max
			 GFX_Setf( i_Gfx, 9007, 2 ) // scale
			 GFX_Setf( i_Gfx, 9008, 0.01  ) // period
			 GFX_Setf( i_Gfx, 9009, 0.2  ) // temps de mort minimum
			 GFX_Setf( i_Gfx, 9010, 0.3  ) // temps de mort maxi
 

			// Generation ripple
			if(des_i_gen_ripple)
			{
				ripple = GFX_Add(20)
				GFX_MaterialSet(ripple, get_SFX_light_and_smoke, 16 )
				GFX_Setf(ripple,20000,des_f_ripple_baselife + MATH_RandFloat(des_f_ripple_lifemin, des_f_ripple_lifemax))		// durée de vie
				GFX_Setf(ripple,20001,des_f_ripple_basespeed + MATH_RandFloat(des_f_ripple_speedmin, des_f_ripple_speedmax))		// vitesse 
				GFX_Setf(ripple,20002,0)		// frequence gen sprites
				GFX_Setf(ripple,20003,0)		// speed
				
				GFX_Seti(ripple, 20100, 1)		// Nbre
				GFX_Seti(ripple, 20100, -2)	// Pour destruction auto
				GFX_Seti(ripple, 20101, des_c_ripple)
				GFX_Seti(ripple, 20102, 0x00000000)
				
				tv_temp.z = f_ZSol
				GFX_Setv(ripple,20200, tv_temp)	// pos			
			}
			
			// SND -------------------------------------------------------------
			if (MATH_VecDotProduct(tv_temp - @to_main OBJ_PosGet(),tv_temp - @to_main OBJ_PosGet()) < 100)
			{
//				ti_inst = SND_Request(MATH_RandInt(0,2), C_SND_Request_DestroyWhenFinished)
//				SND_Play(ti_inst)
//				SND_FlagSet(ti_inst, C_SND_Request_3DSound)
//				SND_FreqSet(ti_inst, SND_FreqGet(ti_inst) * MATH_RandFloat(0.7,1))
//				SND_VolSet(ti_inst, SND_VolGet(ti_inst) * f_coef_volume)
//				SND_InstPosUpdate(ti_inst, tv_temp)
			}
			// SND -------------------------------------------------------------
		}
		
		// Affichage de la goutte
		else
		{
			tv_temp = av_pos_gouttes[i]
			if (tv_temp.z < f_ZSol)
				tv_temp.z = f_ZSol
			GFX_Setv(ai_id_gouttes[i], 1200, tv_temp)
			tv_temp.z += sizez
			GFX_Setv(ai_id_gouttes[i], 1201, tv_temp)
		}
	}
}

if(OBJ_CapaTest(OBJ_Capa_1))
{
	f_time_rien += TIME_GetDt()
	if(f_time_rien < 1.0) OBJ_CapaSet(0, OBJ_Capa_1)
}