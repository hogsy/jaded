#include "GFX_Chain_defines.var"

procedure_local void GFX_Chain_Display(int ti_color)
{
	int		ti_i	
	int		ti_k

	vector		tv_sight
	vector		tv_banking

	for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
	{
		for (ti_k = 0; ti_k < Ci_modules_nb; ti_k++)
		{
			@ao_modules[ti_i][ti_k] OBJ_PosSet(av_modules_pos[ti_i][ti_k])	
			if (!ti_i)
				tv_banking = av_modules_pos[ti_i][ti_k] - av_modules_pos[ti_i + 1][ti_k]
		 	else if (ti_i == Ci_modules_nb - 1)
				tv_banking = av_modules_pos[ti_i - 1][ti_k] - av_modules_pos[ti_i][ti_k]
			else
				tv_banking = av_modules_pos[ti_i - 1][ti_k] - av_modules_pos[ti_i + 1][ti_k]
			
			if (!ti_k)
				tv_sight = av_modules_pos[ti_i][ti_k] - av_modules_pos[ti_i][ti_k + 1]
			else if (ti_k == Ci_modules_nb - 1)
				tv_sight = av_modules_pos[ti_i][ti_k - 1] - av_modules_pos[ti_i][ti_k]
			else
				tv_sight = av_modules_pos[ti_i][ti_k - 1] - av_modules_pos[ti_i][ti_k + 1]
		
			@ao_modules[ti_i][ti_k] OBJ_BankingGeneralSet(tv_sight, tv_banking)

#ifndef _FINAL_
			if (AI_GetCurSystem() == 10)
			{
				DBG_RenderVector(av_modules_pos[ti_i][ti_k], tv_sight, color_vert)
				DBG_RenderVector(av_modules_pos[ti_i][ti_k], tv_banking, color_bleu)
	
				if (ti_i)
					DBG_RenderVector(av_modules_pos[ti_i][ti_k], av_modules_pos[ti_i - 1][ti_k] - av_modules_pos[ti_i][ti_k], ti_color)
				if (ti_k)
					DBG_RenderVector(av_modules_pos[ti_i][ti_k], av_modules_pos[ti_i][ti_k - 1] - av_modules_pos[ti_i][ti_k], ti_color)
			}
#endif
		}
	}
}

procedure_local void GFX_Chain_Init()
{
	int		ti_i
	int		ti_k

	vector	tv_pos
	vector		tv_min
	vector		tv_max

	f_gravity = -60.0

	if (i_flag_fall)
	{
		f_bend_coef = 0.4
	
		if (shadow)
		{
			tv_pos = @shadow OBJ_PosGet()
			tv_pos += OBJ_HorizonGet() * (f_bend_coef - 1.0) * ((Ci_modules_nb - 1) * f_width)
			@shadow OBJ_PosSet(tv_pos)
		}
	}

	for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
	{
		for (ti_k = 0; ti_k < Ci_modules_nb; ti_k++)
		{
			ao_modules[ti_i][ti_k] = ANI_CanalObjectGet((Ci_modules_nb * ti_i) + ti_k)
			av_modules_pos[ti_i][ti_k] = @ao_modules[ti_i][ti_k] OBJ_PosGet()

			if ( ! ti_i )
				ai_modules_locked[ti_i][ti_k] = vrai
				
			DBG_RenderSphere(av_modules_pos[ti_i][ti_k], 0.5, 0x80C0A0B0)
		}
	}

	f_height = MATH_VecNorm(@ao_modules[1][0] OBJ_PosGet() - @ao_modules[2][0] OBJ_PosGet())
	f_width = MATH_VecNorm(@ao_modules[1][0] OBJ_PosGet() - @ao_modules[1][1] OBJ_PosGet())

	if (i_flag_fall)
	{
		// On positionne la partie supérieure
		for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
		{
			for (ti_k = 0; ti_k < Ci_modules_nb; ti_k++)
			{
				av_modules_pos[ti_i][ti_k] = OBJ_PosGet()
				av_modules_pos[ti_i][ti_k].z -= f_height * ti_i
				av_modules_pos[ti_i][ti_k] += OBJ_HorizonGet() * (f_width * ti_k * f_bend_coef)
				if (MATH_Modulo(ti_k, 2))
					av_modules_pos[ti_i][ti_k] += OBJ_SightGet() * f_width * 0.4
				else
					av_modules_pos[ti_i][ti_k] -= OBJ_SightGet() * f_width * 0.4
			}
		}
		
		GFX_Chain_Display(color_rose)
	}

	tv_min = -OBJ_HorizonGet()
	tv_min -= OBJ_SightGet() * ((f_height * Ci_modules_nb) + 1.0)
	tv_min -= OBJ_BankingGet() * ((f_height * Ci_modules_nb) + 1.0)

	tv_max = OBJ_HorizonGet() * ((f_width * Ci_modules_nb) + 1.0)
	tv_max += OBJ_SightGet() * ((f_height * Ci_modules_nb) + 1.0)
	tv_max += OBJ_BankingGet()

	BV_MinSet(cvector(MATH_FloatMin(tv_min.x, tv_max.x), MATH_FloatMin(tv_min.y, tv_max.y), MATH_FloatMin(tv_min.z, tv_max.z)))
	BV_MaxSet(cvector(MATH_FloatMax(tv_min.x, tv_max.x), MATH_FloatMax(tv_min.y, tv_max.y), MATH_FloatMax(tv_min.z, tv_max.z)))
	
	return
}

procedure_local void GFX_Chain_Renormalisation(int ti_first_index, int ti_last_index, int ti_iteration_nb)
{
	int			ti_i
	int			ti_k
	int			ti_m

	float		tf_norm
	float		tf_dot_product
	float		tf_inv_dt
	float		tf_move_length

	vector	tv_temp	
	vector	tv_col_pos
	vector	tv_col_normal

	tf_inv_dt = 1.0 / f_dt

	// LES POINTS ONT BOUGE
	for (ti_k = 0; ti_k < ti_iteration_nb; ti_k++)
	{
		for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
		{
			for (ti_m = 0; ti_m < Ci_modules_nb; ti_m++)
			{
//				DBG_RenderSphere(av_modules_pos[ti_i][ti_m], Cf_chain_module_length * 0.5, 0x80C0A0B0)

				av_renormalisation[ti_i][ti_m] = Cv_NullVector
				
				if (ti_i)
				{
					tv_temp = av_modules_pos[ti_i - 1][ti_m] - av_modules_pos[ti_i][ti_m]
				
//					DBG_RenderVector(av_modules_pos[ti_i][ti_m], tv_temp, color_blanc)	
				
					tf_norm = MATH_VecDotProduct(tv_temp, tv_temp)
					if (tf_norm > 0.001)
					{
						tf_norm = MATH_FloatSqrt(tf_norm)
						tv_temp /= tf_norm
						tf_norm -= f_height
						tv_temp  *= tf_norm
					}
					else
					{
						tv_temp = -Cv_VerticalVector
						tv_temp *= f_height
					}
		
					av_renormalisation[ti_i - 1][ti_m] -= tv_temp * 0.5
					av_renormalisation[ti_i][ti_m] += tv_temp * 0.5
				}

				if (ti_m)
				{
					tv_temp = av_modules_pos[ti_i][ti_m - 1] - av_modules_pos[ti_i][ti_m]
				
//					DBG_RenderVector(av_modules_pos[ti_i][ti_m], tv_temp, color_cyan)	
				
					tf_norm = MATH_VecDotProduct(tv_temp, tv_temp)
					if (tf_norm > 0.001)
					{
						tf_norm = MATH_FloatSqrt(tf_norm)
						tv_temp /= tf_norm
						tf_norm -= f_width
						tv_temp  *= tf_norm
					}
					else
					{
						tv_temp = -Cv_VerticalVector
						tv_temp *= f_width
					}
		
					av_renormalisation[ti_i][ti_m - 1] -= tv_temp * 0.5
					av_renormalisation[ti_i][ti_m] += tv_temp * 0.5
				}
			}
		}
		
		for (ti_m = 0; ti_m < Ci_modules_nb; ti_m++)
		{
			for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
			{
				if (!ai_modules_locked[ti_i][ti_m])
				{
					av_renormalisation[ti_i][ti_m] -= MATH_FloatMin(MATH_VecDotProduct(av_renormalisation[ti_i][ti_m], av_modules_normal[ti_i][ti_m]), 0.0) * av_modules_normal[ti_i][ti_m]
					
//					tf_norm = MATH_VecSquareNorm(av_renormalisation[ti_i][ti_m])
//					if (tf_norm > 100.0)
//					{
//						tf_norm = MATH_FloatSqrt(tf_norm)
//						av_renormalisation[ti_i][ti_m] /= tf_norm
//						av_renormalisation[ti_i][ti_m] *= 10.0
//					}
			
					av_modules_pos[ti_i][ti_m] += av_renormalisation[ti_i][ti_m]
				}
			}
		}
		
		AI_ClearStack()
	}

	return
}


procedure_local void GFX_Chain_Compute_Module_Speed()
{
	int				ti_i
	int				ti_k

	float			tf_friction
	float			tf_dt
	float			tf_exp

	AI_ClearStack()

	tf_dt = f_dt
	tf_friction = 1.5
	tf_exp = MATH_Exp(-tf_dt * tf_friction)
	
	for (ti_i = 0; ti_i < Ci_modules_nb; ti_i++)
	{
		AI_ClearStack()
		
		for (ti_k = 0; ti_k < Ci_modules_nb; ti_k++)
		{
			if (ai_modules_locked[ti_i][ti_k])
			{
				av_modules_speed[ti_i][ti_k] = Cv_NullVector
				continue
			}	
	
			av_modules_speed[ti_i][ti_k].x = av_modules_speed[ti_i][ti_k].x * tf_exp
			av_modules_speed[ti_i][ti_k].y = av_modules_speed[ti_i][ti_k].y * tf_exp
//			av_modules_speed[ti_i][ti_k].z += f_gravity * TIME_GetDt()
			av_modules_speed[ti_i][ti_k].z -= 5.0
			av_modules_speed[ti_i][ti_k] *= f_ragdoll_damping
		}
	}
}

procedure_local void GFX_Chain_Rag_Doll(int ti_first_index)
{
	int			ti_i
	int			ti_k
	int			ti_iterations
	int			ti_bone_index

	float		tf_norm
	float		tf_dot_product
	float		tf_dt
	float		tf_inv_dt
	float		tf_move_length
	float		tf_dist
	float		tf_speed

	vector	tv_temp
	vector	tv_col_pos
	vector	tv_col_normal
	vector	tv_force
	vector	tv_dest_banking
	vector	tv_delta_pos
	vector	tv_delta_speed
	vector	tv_A
	vector	tv_B
	vector	tv_prec
	vector	tv_next
	
	object	to_collided_object

	if (ti_first_index == Ci_modules_nb - 1)
		return

	if ( ! f_ragdoll_damping )
		return

	// On positionne la partie supérieure
	ti_i = 0
	for (ti_k = 0; ti_k < Ci_modules_nb; ti_k++)
	{
		av_modules_pos[ti_i][ti_k] = OBJ_PosGet()
		av_modules_pos[ti_i][ti_k] += OBJ_HorizonGet() * (f_width * ti_k * f_bend_coef)
		ai_modules_locked[ti_i][ti_k] = vrai
	}

	tf_dt = f_dt
	tf_inv_dt = 1.0 / tf_dt

	// DYNAMIQUE DES MODULES
	for (ti_i = ti_first_index; ti_i < Ci_modules_nb; ti_i++)
	{
		for (ti_k = ti_first_index; ti_k < Ci_modules_nb; ti_k++)
		{
			av_modules_last_pos[ti_i][ti_k] = av_modules_pos[ti_i][ti_k]
//			av_modules_normal[ti_i][ti_k] = Cv_NullVector
		}
	}

	// CALCUL DE LA DYNAMIQUE
	GFX_Chain_Compute_Module_Speed()

	AI_ClearStack()

	// DEPLACEMENT
	for (ti_i = ti_first_index; ti_i < Ci_modules_nb; ti_i++)
	{
		for (ti_k = ti_first_index; ti_k < Ci_modules_nb; ti_k++)
		{
			av_modules_pos[ti_i][ti_k] += av_modules_speed[ti_i][ti_k] * tf_dt
			if (f_bend_coef < 1.0)
			{
				if (MATH_Modulo(ti_k, 2))
					av_modules_pos[ti_i][ti_k] += OBJ_SightGet() * 0.01
				else
					av_modules_pos[ti_i][ti_k] -= OBJ_SightGet() * 0.01
			}
			
			av_modules_normal[ti_i][ti_k] = av_modules_pos[ti_i][ti_k] - v_sphere_center 
			tf_dist = MATH_VecSquareNorm(av_modules_normal[ti_i][ti_k])
			if (tf_dist > 0.01 && tf_dist < f_sphere_sqr_size)
			{
				tf_dist = MATH_FloatSqrt(tf_dist)
				av_modules_normal[ti_i][ti_k] /= tf_dist

				av_modules_pos[ti_i][ti_k] = v_sphere_center 
				av_modules_pos[ti_i][ti_k] += av_modules_normal[ti_i][ti_k] * f_sphere_size
			}
			else
			{
				av_modules_normal[ti_i][ti_k] = Cv_NullVector
			}

//			av_modules_pos[ti_i][ti_k].z = MATH_FloatMax(av_modules_pos[ti_i][ti_k].z, f_Z_min)
			av_modules_pos[ti_i][ti_k] += MATH_FloatMax(MATH_VecDotProduct(av_modules_pos[ti_i][ti_k] - OBJ_PosGet(), -OBJ_HorizonGet()), 0.0) * OBJ_HorizonGet()
		}
	}
		
	GFX_Chain_Renormalisation(0, Ci_modules_nb, 10)

	// CALCUL DES SPEED ET DES ORIENTATIONS
	for (ti_i = ti_first_index; ti_i < Ci_modules_nb; ti_i++)
	{
		AI_ClearStack()	
	
		for (ti_k = ti_first_index; ti_k < Ci_modules_nb; ti_k++)
		{
			tv_temp = av_modules_pos[ti_i][ti_k] - av_modules_last_pos[ti_i][ti_k]
			tv_temp *= tf_inv_dt
		
			tf_speed = MATH_VecSquareNorm(tv_temp)
			if (tf_speed > 1600.0)
			{
				tf_speed = MATH_FloatSqrt(tf_speed)
				tv_temp /= tf_speed
				tv_temp *= 40.0
			}
		
			av_modules_speed[ti_i][ti_k] = tv_temp
		}
	}

//	if (!i_flag_start_ragdoll_damping && i_on_ground_modules_nb == 15)
//		i_flag_start_ragdoll_damping = vrai

	return
}

