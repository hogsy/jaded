#include '"GST_StalkManager_defines.var"

int 			wp, nb, i
object 		o_wp
float			f_Dt
message	msg

// Count enemy number ?
mi_Enemy_StalkNb = 0
for ( i = 0; i < mi_Enemy_StalkMax ; i++)
{
	if ( mao_StalkEnemy[ i ] != nobody )
		mi_Enemy_StalkNb++
	else if (mai_StalkEnemy_OnWay[ i ] != -1)
	{
		mai_StalkWay_Flag[ mai_StalkEnemy_OnWay[ i ] ] &= ~STALK_Way_Occupied
		mai_StalkEnemy_OnWay[ i ] = -1
	}
}
mi_Enemy_FightNb = 0
for ( i = 0; i < mi_Enemy_FightMax ; i++)
{
	if ( mao_FightEnemy[ i ] != nobody )
		mi_Enemy_FightNb++
}

// Is there enough enemy ?
if ( mi_Enemy_StalkNb + mi_Enemy_FightNb >= mi_Enemy_Max )
	return
	
// no, can eventually add one 
f_Dt = TIME_GetDt()
for ( wp = 0; wp < STALK_MaxFightWP; wp++)
	maf_Fight_Timer[ wp ] -= f_Dt

if ( mi_Enemy_FightNb < mi_Enemy_FightMax )
{
	if (  AI_TriggerIsValid( mt_Fight_Trigger ) )
	{
		msg.msg_sender = OBJ_Me()
		for ( wp = 0; wp < STALK_MaxFightWP; wp++)
		{
			if (maf_Fight_Timer[ wp ] > 0 )
				continue
			msg.msg_gao1 = mao_Fight_WP[ wp ]
			if ( msg.msg_gao1 == nobody )
				break
			
			AI_TriggerSetMsg( mt_Fight_Trigger, msg)			
			if ( call_trigger( mt_Fight_Trigger ) )
			{
				push ( wp )
				AI_Execute( "GSTSM_GenerateFight" )
				return
			}
		}
	}
	else
	{
		mo_Fight_Target = AI_MainActorGet( 0 )
		for ( wp = 0; wp < STALK_MaxFightWP; wp++)
		{
			if (maf_Fight_Timer[ wp ] > 0 )
				continue
			
			o_wp = mao_Fight_WP[ wp ]
			if ( o_wp == nobody )
				break
		
			if ( @o_wp COL_BV_PivotCollide( mo_Fight_Target ) )
			{
				push ( wp )
				AI_Execute( "GSTSM_GenerateFight" )
				return
			}
		}
	}
}

// no fight added can ! add a stalk ?
if ( mi_Enemy_StalkNb < mi_Enemy_StalkMax )
{
	mf_StalkTimer_Cur -= TIME_GetDt()
	if (mf_StalkTimer_Cur > 0)
		return
	mf_StalkTimer_Cur = MATH_RandFloat( mf_StalkTimer_Min, mf_StalkTimer_Max)
	
	// add a stalk
	nb = 0
	for (wp = 0; wp< STALK_MaxStalkWP; wp++)
	{
			if ( mao_StalkWay_WPFrom[ wp ] == nobody )
				break
			if ( !(mai_StalkWay_Flag[ wp ] & STALK_Way_Occupied ) )
				nb++
	}
	if (nb == 0)
		return
	
	nb = MATH_RandInt(0,nb) + 1
	for (wp = 0; wp< STALK_MaxStalkWP; wp++)
	{
			if ( mao_StalkWay_WPFrom[ wp ] == nobody )
				break
			if ( !(mai_StalkWay_Flag[ wp ] & STALK_Way_Occupied ) )
				nb--
			if (nb == 0)
			{
				push ( wp )
				AI_Execute( "GSTSM_GenerateStalk" )
				return
			}
	}
}

	
