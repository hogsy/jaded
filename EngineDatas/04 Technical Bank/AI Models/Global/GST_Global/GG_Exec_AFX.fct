int			ti_loop 
float		tf_dt

// Gere l'evolution et la gestion des valeurs d'AFX AI temporaire et les valeur par defaut =================================
tf_dt = TIME_GetDt()
for (ti_loop = 0; ti_loop < Param_AE_Number; ti_loop++)
{
	AFE_BlendValue[ti_loop] -= MATH_FloatMin(AFE_BlendValue[ti_loop], AFE_BlendSpeedValue[ti_loop]*tf_dt)	// reduit le blend
	if (AFE_Flags[ti_loop])
	{
		AFE_Flags[ti_loop] = faux										// Asknowledge.
		AFE_CurrentValue[ti_loop] = AFE_AiValue[ti_loop]	// Qd on precise en AI on donne la bonne valeur.
		AFE_BlendValue[ti_loop] = 1.0								// Set blend to top
	}
	else
		AFE_CurrentValue[ti_loop] = MATH_FloatBlend(AFE_DefaultValue[ti_loop], AFE_AiValue[ti_loop], AFE_BlendValue[ti_loop])
}
// Gere l'evolution et la gestion des valeurs d'AFX AI temporaire et les valeur par defaut =================================

if (OBJ_CapaTest(OBJ_Capa_0))
	return

// Balance les valeurs au moteur =======================================================================
AE_BlackAndWhite(AFE_CurrentValue[Param_AE_BlackAndWhite])
AE_Blur(AFE_CurrentValue[Param_AE_Blur])
AE_Brightness(AFE_CurrentValue[Param_AE_Brightness])
AE_ColorBalance(AFE_CurrentValue[Param_AE_ColorBalance1], AFE_CurrentValue[Param_AE_ColorBalance2])
AE_Contraste(AFE_CurrentValue[Param_AE_Contraste])
AE_MotionBlur(AFE_CurrentValue[Param_AE_MotionBlur])
AE_MotionSmooth(AFE_CurrentValue[Param_AE_MotionSmooth])
AE_Remanece(AFE_CurrentValue[Param_AE_Remanence])
AE_RotationSmooth(AFE_CurrentValue[Param_AE_RotationSmooth])
AE_Wrap(AFE_CurrentValue[Param_AE_Wrap])
AE_ZoomSmooth(AFE_CurrentValue[Param_AE_ZoomSmooth])
AE_Glow(AFE_CurrentValue[Param_AE_Glow])
AE_ZoomSmoothCenter(AFE_CurrentValue[Param_AE_ZoomSmoothCenter], AFE_ZoomSmoothPos)
// Balance les valeurs au moteur =======================================================================