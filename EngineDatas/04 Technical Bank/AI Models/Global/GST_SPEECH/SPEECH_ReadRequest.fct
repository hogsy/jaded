//---------------------------------------------------------------------------------------------------------------------------
// INCLUDE
//---------------------------------------------------------------------------------------------------------------------------
#include "SPEECH_Constant.var"


//---------------------------------------------------------------------------------------------------------------------------
// VAR
//---------------------------------------------------------------------------------------------------------------------------
int 				ti
int  				ti_istalking, ti_rq
int 				i 
int					found, numfound
messageid 		MSG_ID
//
object 			to_sender, to_target, to_object 
int					ti_txgfile, ti_entry, ti_random, ti_maxrandom
float				tf_timeout
int 				ti_priority
int					ti_listid, ti_listindex
text				tt_text, tt_text2
int 				ti_flag, ti_genperso, ti_genidx
string 			ts_hole
float				taf_time[SPEECH_Cte_RandomSize]
float				tf_last
int					ti_last
//


//---------------------------------------------------------------------------------------------------------------------------
// CODE
//---------------------------------------------------------------------------------------------------------------------------

// --- reset the array ---
//------------------------------
for(ti=0; ti<G_NombreMax; ti++)
{
	mai_GenTextUsed[ti] = 0
}


ti = -1
MSG_ID = MSG_GlobalScan(C_EVENT_TYPE_Speech, &ti)
while(MSG_GlobalIsValid(MSG_ID))
{
		// ---- update the stack size ----
		//------------------------------------------
		if( (i_request_number+1) >= Cte_StackSize)
		{
			DBG_BreakPoint() // overflow
			break
		}
		
	
		// ---- get new rq -----
		//---------------------------
		ti_flag = SPEECH_FlagsGet(MSG_ID)
		ti_priority = SPEECH_PriorityGet(MSG_ID)
		to_sender = SPEECH_SenderGet(MSG_ID)
		to_target = SPEECH_TargetGet(MSG_ID)
		ti_txgfile = SPEECH_TxgKeyGet(MSG_ID)
		ti_entry = SPEECH_EntryKeyGet(MSG_ID)
		ti_random = SPEECH_RandomSizeGet(MSG_ID)
		tf_timeout = SPEECH_TimeOutGet(MSG_ID)
		ti_listid = SPEECH_ListIdGet(MSG_ID)
		ti_listindex = SPEECH_ListIndexGet(MSG_ID)
	

		// --- treat all flags ---
		//---------------------------
		ti_genperso = -1
		ti_genidx = -1
		
		if(ti_flag & SPEECH_Cte_FlagsUseHumanId)
		{	
			// --- treat generic text ---
			//----------------------------------
			if( (ti_entry & 0xFF000000) == 0 )
			{
				// this is a ganeric text
				if( (ti_entry >= 0) && (ti_entry < G_NombreMax) )
				{
					switch(ti_txgfile)
					{
					case C_ID_Kong :	
						ti_genperso = ti_txgfile
						ti_genidx = ti_entry
						ti_txgfile = SPEECH_CteTxg_GenKong 
						break
					case	C_ID_Joueur : 
						ti_genperso = ti_txgfile
						ti_genidx = ti_entry
						ti_txgfile = SPEECH_CteTxg_GenJack 
						break
//					case	C_ID_Ann : 
//						ti_genperso = ti_txgfile
//						ti_genidx = ti_entry
//						ti_txgfile = SPEECH_CteTxg_GenAnn  
//						break
//					case	C_ID_Hayes : 
//						ti_genperso = ti_txgfile
//						ti_genidx = ti_entry
//						ti_txgfile = SPEECH_CteTxg_GenHayes  
//						break
//					case	C_ID_Denham : 
//						ti_genperso = ti_txgfile
//						ti_genidx = ti_entry
//						ti_txgfile = SPEECH_CteTxg_GenDenham  
//						break
//					case	C_ID_Jimmy : 
//						ti_genperso = ti_txgfile
//						ti_genidx = ti_entry
//						ti_txgfile = SPEECH_CteTxg_GenJimmy  
//						break
					default: 
						ti_entry = 0xFFFFFFFF
						ti_txgfile = 0xFFFFFFFF 
						break 
					}
					
					if( (ti_genperso != -1) && (ti_genidx != -1) )
					{
						// get the last time...
						if( ! TIME_Elapsed(maf_GenericLastTime[ti_genidx], maf_GenericPeriodMin[ti_genidx]) )
						{
							// no enougth time elapsed => skip the request
							speech_dbg_print("RqCanceled : too less time since the last one", to_sender, ti_txgfile, ai_TextConfig[ti_genperso][ti_genidx], -1)
							
							MSG_ID = MSG_GlobalScan(C_EVENT_TYPE_Speech, &ti)
							continue
						}
						
						// register the las display date	
						maf_GenericLastTime[ti_genidx] = TIME_Get()
				
						// get the entry key
						ti_entry = ai_TextConfig[ti_genperso][ti_genidx]
						
						// reset the gen-request-id as long as the push is not done
						mai_GenRequestId[ti_genperso][ti_genidx] = -1
					 }
				}
				else
				{
					ti_entry = 0xFFFFFFFF
				}
			}
			else
			{
				// this is a character specific text
				switch(ti_txgfile)
				{
				case C_ID_Kong : 
					ti_txgfile = SPEECH_CteTxg_SpeKong 
					break
				case	C_ID_Joueur : 
					ti_txgfile = SPEECH_CteTxg_SpeJack 
					break
//				case	C_ID_Ann :
//					if(mi_MapIsJaks)
//						ti_txgfile = SPEECH_CteTxg_SpeAnn  // map jak
//					else
//						ti_txgfile = SPEECH_CteTxg_SpeKann  // map kong
//					break
//				case	C_ID_Hayes : 
//					ti_txgfile = SPEECH_CteTxg_SpeHayes  
//					break
//				case	C_ID_Denham : 
//					ti_txgfile = SPEECH_CteTxg_SpeDenham  
//					break
//				case	C_ID_Jimmy : 
//					ti_txgfile = SPEECH_CteTxg_SpeJimmy  
//					break
//				case C_ID_Indigene1 :
//				case	C_ID_Indigene2 :
//				case	C_ID_Indigene3 :
//				case	C_ID_Indigene4 :
//				case	C_ID_Indigene5 :
//					ti_txgfile = SPEECH_CteTxg_SpeIndigene  
//					break

				default: 
					ti_txgfile = 0xFFFFFFFF 
					break 
				}
			}
		}	
		
	
		

		// --- get the text ---
		//-------------------------
		tt_text = TEXT_Get(ti_txgfile, ti_entry)
		if( ! TEXT_IsEmpty(tt_text) )  	
		{
			ti_maxrandom = 0
			tf_last = 0.0
			ti_last = -1
					
			for(i=0; i<ti_random; i++)
			{
				tt_text2 = TEXT_RankShift(tt_text, i)	
				if( TEXT_IsEmpty(tt_text2) ) continue // empty text
				
				ts_hole = TEXT_ToString(tt_text2)
				if(TEXT_Compare(ts_hole, "<hole>") ) continue // hole text
				if(TEXT_Compare(ts_hole, "<todo>") ) continue // temp hole text
				
				// we get the oldest text
				taf_time[i] = TEXT_TimeGet(tt_text2)
				if(!taf_time[i]) 
				{
					taf_time[i] = TIME_Get() - MATH_RandFloat(1, 20)
					TEXT_TimeSet(tt_text2, taf_time[i])
				}
				
				if(ti_last == -1)
				{
					ti_last = i
					tf_last = taf_time[i]
				}
				else if(taf_time[i] <= tf_last)
				{
					ti_last = i
					tf_last = taf_time[i]
				}
				
				ti_maxrandom++
			}
			
			if( ti_last != -1)
			{
				// get the oldest text
				tt_text = TEXT_RankShift(tt_text, ti_last)	
				TEXT_TimeSet(tt_text, TIME_Get())
			}
		}
		
		if(TEXT_IsEmpty(tt_text) || (!ti_maxrandom && ti_random))  	
		{
			speech_dbg_print("RqCanceled : text is empty", to_sender, -1, -1, -1)
			MSG_ID = MSG_GlobalScan(C_EVENT_TYPE_Speech, &ti)
			continue
		}
		
	
		// --- get settings ---
		//-------------------
		if( ! to_target ) 	to_target = TEXT_ObjectGet(tt_text)
		if(ti_priority == -1) 
		{
			ti_priority = TEXT_PriorityGet(tt_text)
		}
			

		// --- store data ---
		//-----------------------
		mi_urgent_rq_is_part_of_list = -1
		ti_rq = SPEECH_WriteDataRq
				(
						to_sender,
						to_target,
						tt_text,
						ti_priority,
						tf_timeout,
						ti_flag,
						ti_listid,
						ti_listindex
				)
		
		if( ti_rq < 0 )
		{
			if(ti_rq == -1)
			{
				speech_dbg_print("RqCanceled : no more space into the stack or yet present", to_sender, ti_txgfile, ti_entry, -1)
			}
			MSG_ID = MSG_GlobalScan(C_EVENT_TYPE_Speech, &ti)
			continue // data can not be store
		}


		// --- is the character talking ? ---
		//---------------------------------------------
		found = faux
		numfound = 0
		for(i=0; i<Cte_DialogNb; i++)
		{
			if(ao_current_target[i]) numfound++
			if(ao_current_target[i] != to_target) continue
			
			found = vrai
			if( ai_current_priority[i] > ti_priority ) 
			{
				// new rq is more important
				// -> replace the current
				
				if(ai_urgent_request[i] == -1)
				{
					// this is the 1st urgent rq
					if(mi_urgent_rq_is_part_of_list == -1)
						ai_urgent_request[i] = ti_rq
					else
						ai_urgent_request[i] = mi_urgent_rq_is_part_of_list // the ti_rq is the last txt of one list => play the first one !
						
					af_current_playtime[i] = 0.0
					//ti_rq = -1
				}
				else if(ai_data_priority[ai_urgent_request[i]] > ti_priority)
				{
					// the previous urgent rq has a lower priority
					//SPEECH_PushRq(ai_urgent_request[i])
					
					if(mi_urgent_rq_is_part_of_list == -1)
						ai_urgent_request[i] = ti_rq
					else
						ai_urgent_request[i] = mi_urgent_rq_is_part_of_list // the ti_rq is the last txt of one list => play the first one !

					af_current_playtime[i] = 0.0
				}
				// the previous urgent rq has a higher priority
				// => nothing todo
				
			}
			
			break
		}

		// Est ce qu'on veut parler, et que toutes les pistes sont déjà occupées par d'autres persos
		// (si oui, faut checker les prios pour en couper un)		
		if(!found && numfound == Cte_DialogNb)
		{
			found = 0
			for(i=0; i<Cte_DialogNb; i++)
			{
				if(ai_current_priority[i] > found) 
				{
					found = ai_current_priority[i]
					numfound = i
				}
			}
			
			if(found > ti_priority)
			{
				if(ai_urgent_request[numfound] == -1)
				{
					if(mi_urgent_rq_is_part_of_list == -1)
						ai_urgent_request[numfound] = ti_rq
					else
						ai_urgent_request[numfound]  = mi_urgent_rq_is_part_of_list // the ti_rq is the last txt of one list => play the first one !

					af_current_playtime[numfound] = 0.0
					
//					if(ao_current_target[numfound] == AI_MainActorGet(0) && mi_MapIsJaks )
//					{
//						// jak is cut
//						//mi_VolFadeMode = 10
//					}
				}
				else if(ai_data_priority[ai_urgent_request[numfound]] > ti_priority)
				{
					if(mi_urgent_rq_is_part_of_list == -1)
						ai_urgent_request[numfound] = ti_rq
					else
						ai_urgent_request[numfound]  = mi_urgent_rq_is_part_of_list // the ti_rq is the last txt of one list => play the first one !

					af_current_playtime[numfound] = 0.0
					
//					if(ao_current_target[numfound] == AI_MainActorGet(0) && mi_MapIsJaks )
//					{
//						// jak is cut
//						//mi_VolFadeMode = 10
//					}
				}
			}
		}
						
		// --- push the rq in the stack ---
		//-------------------------------------------
		SPEECH_PushRq(ti_rq)
	


		// --- register all gen used ---
		//---------------------------------------
		if( (ti_genperso != -1) && (ti_genidx != -1) && (ti_rq != -1) )
		{
			mai_GenTextUsed[ti_genidx] |= (1<<ti_genperso)
			mai_GenRequestId[ti_genperso][ti_genidx] = ti_rq
		}


		// ---- get next message ----
		//-------------------------------------
		MSG_ID = MSG_GlobalScan(C_EVENT_TYPE_Speech, &ti)
}



// --- filter equivalent request ---
//------------------------------------------
int ti_userscount, ti_let, tj

for(ti_genidx=0; ti_genidx<G_NombreMax; ti_genidx++)
{
	ti_userscount = SPEECH_GetUsersCount(mai_GenTextUsed[ti_genidx])

	// there is one equivalent request used by almost 2 gao ?
	if( ti_userscount < 2 ) continue
	
	// choose one of them
	ti_let = MATH_RandInt(1, ti_userscount+1)
	
	for(ti_genperso=C_ID_Kong ; ti_genperso<= C_ID_Last_Compagnon ; ti_genperso++)
	{
		// this gen is used by this perso ?
		
		if(mai_GenTextUsed[ti_genidx] & (1<<ti_genperso))
		{
			// we let it ?
			ti_let--
			if(ti_let == 0) continue
			
			speech_dbg_print("RqDeleted : it was yet present into the stack (or equivalent)", to_sender, ti_txgfile, ti_entry, -1)
			
			// we delete it from the request list
			SPEECH_DeleteRq(mai_GenRequestId[ti_genperso][ti_genidx])
			SPEECH_DeleteDataRq(mai_GenRequestId[ti_genperso][ti_genidx])
		}
	} 	
}


























