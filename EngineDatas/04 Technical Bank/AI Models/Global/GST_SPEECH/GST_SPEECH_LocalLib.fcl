#include "SPEECH_Constant.var"

//-----------------------------------------------------------------------------------------------------------------------
// debug printing
//
procedure_local void SPEECH_DebugPrintTxt(string args_debug, object argo_sender, text argt_text, int argi_track)
{
//	string tt_str
//	int		ti_entry
	
	if(i_DebugMode)
	{
		DBG_TraceString("[GST_SPEECH][ ")
		DBG_TraceInt(argi_track)
		DBG_TraceString("] ")
		DBG_TraceFloat(TIME_Get())
		DBG_TraceString(" ")
		DBG_TraceString(args_debug)
		
		if(argo_sender)
		{
// FRED
//			if( @argo_sender AI_IsModel("KingKong/Humain") )
//			{
//				DBG_TraceString(" [from Human] ")
//			}
			DBG_TraceObject(argo_sender)			
		}

		DBG_TraceText(argt_text)
	
		DBG_TraceEOL()
	}
}


//-----------------------------------------------------------------------------------------------------------------------
// debug printing
//
procedure_local void SPEECH_DebugPrint(string args_debug, object argo_sender, int argi_txg, int argi_entry,  int argi_track)
{
	text tt_text
	string tt_str
	
	if(i_DebugMode)
	{
		DBG_TraceString("[GST_SPEECH][ ")
		DBG_TraceInt(argi_track)
		DBG_TraceString("] ")
		DBG_TraceFloat(TIME_Get())
		DBG_TraceString(" ")
		DBG_TraceString(args_debug)
		
		if(argo_sender)
		{
// FRED
//			if( @argo_sender AI_IsModel("KingKong/Humain") )
//			{
//				DBG_TraceString(" [from Human] ")
//			}
			DBG_TraceObject(argo_sender)						
		}

		if( (argi_txg != -1) && (argi_entry != -1) )
		{
			tt_text = TEXT_Get(argi_txg, argi_entry)
			DBG_TraceText(tt_text)
		}
		
		DBG_TraceEOL()
	}
}


//-----------------------------------------------------------------------------------------------------------------------
// return the user number
//
procedure_local int SPEECH_GetUsersCount(int argi_Users)
{
	int i, ret
	
	if(!argi_Users) return 0
	ret = 0
	
	for(i=0; i<32; i++)
	{
		if( argi_Users & (1<<i) )
			ret++
	}
	
	return ret
}



//-----------------------------------------------------------------------------------------------------------------------
// extract a rq from the sorted list
//
procedure_local void SPEECH_DeleteRq(int argi_RqId)
{
	int i, j
	
	for(i=0; i<i_request_number; i++)
	{
		if(ai_request_sortedlist[i] != argi_RqId) continue
		
		i_request_number--
		for(j=i; j<i_request_number; j++)
		{
			ai_request_sortedlist[j] = ai_request_sortedlist[j+1]
			ai_request_sortedlist[j+1] = -1
		}
		i--
	}
}



//-----------------------------------------------------------------------------------------------------------------------
// extract a rq from the sorted list
//
procedure_local int SPEECH_PopRq(object argo_TargetForbidden, int argi_Prevlistid)
{
	int i, j, i_return
	
	for(i=0; i<i_request_number; i++)
	{
		// we wait the current gao stop speaking
		if( !argi_Prevlistid && argo_TargetForbidden)
		{
			if(ao_data_target[ai_request_sortedlist[i]] == argo_TargetForbidden) return -1
		}
		
		i_request_number--
		
		i_return = ai_request_sortedlist[i]
		for(j=i; j<i_request_number; j++)
		{
			ai_request_sortedlist[j] = ai_request_sortedlist[j+1]
			ai_request_sortedlist[j+1] = -1
		}
		
		return i_return
	}
	
	return -1
}



//-----------------------------------------------------------------------------------------------------------------------
// add a new rq in the sorted list
//
procedure_local int SPEECH_PushRq(int argi_RqId)
{
	int x
	int tmi_begin, tmi_end
	int tmi_middle, i
	
	if(argi_RqId < 0) return 0
	
	
	if(i_request_number == 0)
	{
		ai_request_sortedlist[0] = argi_RqId
		i_request_number++
	}
	else if(i_request_number == 1)	
	{
		if( ai_data_priority[ai_request_sortedlist[0]] <= ai_data_priority[argi_RqId] )
			ai_request_sortedlist[1] = argi_RqId
		else
		{
			ai_request_sortedlist[1] = ai_request_sortedlist[0]
			ai_request_sortedlist[0] = argi_RqId
		}
		i_request_number ++
	}
	else
	{
		tmi_begin = 0
		tmi_end = i_request_number - 1
		
		if( ai_data_priority[ai_request_sortedlist[tmi_end]] <= ai_data_priority[argi_RqId])
		{
			x = tmi_end + 1
		}
		else if( ai_data_priority[argi_RqId] < ai_data_priority[ai_request_sortedlist[tmi_begin]] )
		{
			x = tmi_begin 
		}
		else
		{
			while( (tmi_end - tmi_begin) > 1 )
			{
					tmi_middle = (tmi_begin + tmi_end) / 2
					
					if( ai_data_priority[argi_RqId] <= ai_data_priority[ai_request_sortedlist[tmi_middle]]   )
					{
						tmi_end = tmi_middle
					}
					else
					{
						tmi_begin = tmi_middle
					}
			}
			
			while( ai_data_priority[argi_RqId] == ai_data_priority[ai_request_sortedlist[tmi_end]] )
			{
				tmi_end++
			}
			
			x = tmi_end
		}
		
		if( (x < 0) || (x>=Cte_StackSize ) )
		{
			DBG_BreakPoint()
			return -1
		}
		
		for(i=i_request_number-1; i>=x; i--)
		{
			ai_request_sortedlist[i+1] = ai_request_sortedlist[i]
		}
		
		ai_request_sortedlist[x] = argi_RqId
		i_request_number++
	}

	return i_request_number 
}

procedure_local int SPEECH_AddTmp(int argi_RqId);


//-----------------------------------------------------------------------------------------------------------------------
// store the new request in the data array
// except the request exists yet or there is no more space
//
procedure_local int SPEECH_WriteDataRq(object argo_sender, object argo_target, text argt_text, int argi_priority, float argf_timeout, int argi_flag, int argi_listid, int argi_listindex)
{
	int i, i_free
	
	i_free = -1
	for(i=0; i<Cte_StackSize; i++)
	{
		if(ao_data_target[i] == argo_target)
		{
			// if text is yet registered, update timeout + cancel the new request
			if( TEXT_IsEqual(at_data_text[i], argt_text) )
			{
				af_data_timeout[i] = argf_timeout
				return -1
			}
		}
		
		// register the 1st free element
		if( (i_free == -1) && (ai_data_priority[i] == -1) )
			i_free = i
	}
	
	if(i_free == -1)
	{
		DBG_BreakPoint() // overflow of the data array
		return -2
	}
	
	// store data
	ao_data_sender[i_free] = argo_sender
	ao_data_target[i_free] = argo_target
 	at_data_text[i_free] = argt_text
 	ai_data_priority[i_free] = argi_priority
	af_data_timeout[i_free] = argf_timeout
 	ai_data_flag[i_free] = argi_flag
 	ai_data_listid[i_free] = argi_listid
 	ai_data_listindex[i_free] = argi_listindex
		
	
	// if data is a dialog list element
	if(argi_listid)
	{
		i_free = SPEECH_AddTmp(i_free)
	}
	
	return i_free
}


procedure_local int SPEECH_AddTmp(int argi_RqId)
{
	int i, i_free, j
	int i_listid
	int i_listsize
	int i_listindex 
	int i_id
	int i_listprio
	
	i_free = -1
	i_listid = ai_data_listid[argi_RqId]
	i_listsize = i_listid & 0x0000000F
	i_listindex = ai_data_listindex[argi_RqId]
	
	//
	// ai_tmp_dialoglist is used to save the rq while the list is not complete
	// ai_tmp_dialoglist[5n] == 0x8000 0000 -> elements [5n]-[5n+5] are used
	// ai_tmp_dialoglist[i] == 0xFXXX XXXX -> elem [i] is used, XXX XXXX is the rd id
	//
	
	for(i=0; i<Cte_StackSize; i+= TXT_Cte_ReferenceSize)
	{
		if( !ai_tmp_dialoglist[i] )
		{
			// free space
			if( i_free == -1 ) i_free = i
			continue
		}
		
		// get the 1st valid rq id
		for(j=0; j<TXT_Cte_ReferenceSize; j++)
		{
			if( (ai_tmp_dialoglist[i + j] & 0x70000000) == 0 ) continue
			i_id = ai_tmp_dialoglist[i+j] & 0x0FFFFFFF
			break
		}
			
		if( j>=TXT_Cte_ReferenceSize)
		{
			DBG_BreakPoint() // space is used, but there is no valid rq registered
			return -1
		}
				
		if( ai_data_listid[i_id] == i_listid ) 
		{
			// match the listid, register the new rq
			ai_tmp_dialoglist[i + i_listindex] = 0xF0000000 | argi_RqId
						
			// now count the number of present rq
			for(j=0; j<i_listsize; j++)
			{
				if( (ai_tmp_dialoglist[i + j] & 0x70000000) == 0  ) return -3
			}
			
			// list is complete, register all elements
			// but first register the first element index
			mi_urgent_rq_is_part_of_list = ai_tmp_dialoglist[i + 0] & 0x0FFFFFFF
			i_listprio = ai_data_priority[mi_urgent_rq_is_part_of_list] // security, all element of one list has the same prio

			for(j=0; j<i_listsize-1; j++)
			{
				i_id = ai_tmp_dialoglist[i + j] & 0x0FFFFFFF
				ai_data_priority[i_id] = i_listprio // security, all element of one list has the same prio
				
				SPEECH_PushRq(i_id)				
				ai_tmp_dialoglist[i + j] = 0
			}
			
			i_id = ai_tmp_dialoglist[i + i_listsize-1] & 0x0FFFFFFF
			ai_tmp_dialoglist[i +i_listsize-1] = 0
			return i_id
		}
	}
	
	// list not yet registered
	if( i_free == -1 )
	{
		DBG_BreakPoint() // overflow
		return -1
	}

	// register this space is used	
	ai_tmp_dialoglist[i_free+0] = 0x80000000 
	
	// register the rq
	ai_tmp_dialoglist[i_free+i_listindex] = 0xF0000000 | argi_RqId
	
	return -3
}


//-----------------------------------------------------------------------------------------------------------------------
//  read request identified by "argi_RdId"
//
procedure_local int SPEECH_ReadDataRq
(
	int 				argi_RqId, 
	byref object 	argo_sender, 
	byref object 	argo_target, 
	byref text 		argt_text, 
	byref int 			argi_priority, 
	byref float 		argf_timeout, 
	byref int 			argi_flag, 
	byref int 			argi_listid, 
	byref int 			argi_listindex
)
{
	if( (argi_RqId < 0 ) || (argi_RqId >= Cte_StackSize) )
	{
		DBG_BreakPoint()	// bad index
		return -1
	}
	
	argo_sender = ao_data_sender[argi_RqId] 
	argo_target = ao_data_target[argi_RqId]
 	argt_text = at_data_text[argi_RqId] 
 	argi_priority = ai_data_priority[argi_RqId]
	argf_timeout = af_data_timeout[argi_RqId]
 	argi_flag = ai_data_flag[argi_RqId] 
 	argi_listid = ai_data_listid[argi_RqId]
 	argi_listindex = ai_data_listindex[argi_RqId]
	
	return argi_RqId 
}



//-----------------------------------------------------------------------------------------------------------------------
// delete the request in the data array
//
procedure_local int SPEECH_DeleteDataRq(int argi_RqId)
{
	if( (argi_RqId < 0 ) || (argi_RqId >= Cte_StackSize) )
	{
		DBG_BreakPoint()	// bad index
		return -1
	}
	
	ao_data_sender[argi_RqId] = nobody
	ao_data_target[argi_RqId] = nobody
 	at_data_text[argi_RqId] = M_GetNullText
 	ai_data_priority[argi_RqId] = -1
	af_data_timeout[argi_RqId] = 0.0
 	ai_data_flag[argi_RqId] = 0
 	ai_data_listid[argi_RqId] = 0
 	ai_data_listindex[argi_RqId] = 0
	
	return argi_RqId
}


//-----------------------------------------------------------------------------------------------------------------------
// delete all rq with the "listid"
//
procedure_local int SPEECH_DeleteDataListRq(int argi_listid)
{
	int i, j
	
	for(i=0; i<i_request_number; i++ )
	{
		if( ai_data_listid[ai_request_sortedlist[i]] != argi_listid ) continue
				
		SPEECH_DeleteDataRq(ai_request_sortedlist[i])
		
		for(j=i; j<i_request_number; j++)
		{
			ai_request_sortedlist[j] = ai_request_sortedlist[j+1]
			ai_request_sortedlist[j+1] = -1
		}
		
		i_request_number--		
		i--
	}
	return 0
}

























