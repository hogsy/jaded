vector	tv_temp
float		f_norm

if ( mi_CameraDyn && mo_Camera ) 
{
	if ( !mi_CamStart )
	{
		mi_CamStart = 1
		mv_CamPos = @mo_Camera OBJ_PosGet()
		mv_CamY = @mo_Camera OBJ_SightGet()
		mv_CamZ = @mo_Camera OBJ_BankingGet()
		mv_CamX = @mo_Camera OBJ_HorizonGet()
		mi_CamCorner = 0
		
		mv_CamTgt = mv_CamPos + mv_CamY
		mv_CamTgtEnd = mv_CamTgt + (mv_CamZ * 0.4)
		mv_CamTgtSpeed = Cv_NullVector
		mf_CamSpeed = 0
		mi_CamLinear = 1
	}
	
	tv_temp = mv_CamTgtEnd - mv_CamTgt
	if ( MATH_VecDotProduct( tv_temp, tv_temp) < 0.1 )
	{
		if (mi_CamStart == 1)	mi_CamStart++
		mi_CamCorner = MATH_Modulo( mi_CamCorner + MATH_RandInt(1, 3), 4 )			
		mv_CamTgtEnd = mv_CamPos + mv_CamY
		switch( mi_CamCorner )
		{
		case 0:	mv_CamTgtEnd += MATH_RandFloat( 0, 0.4) * mv_CamZ
					mv_CamTgtEnd += MATH_RandFloat( 0.1, 0.5) * mv_CamX
					break
		case 1:	mv_CamTgtEnd += MATH_RandFloat( 0.6, 1) * mv_CamZ
					mv_CamTgtEnd += MATH_RandFloat( 0.1, 0.5) * mv_CamX
					break
		case 2:	mv_CamTgtEnd += MATH_RandFloat( 0.6, 1) * mv_CamZ
					mv_CamTgtEnd -= MATH_RandFloat( 0.1, 0.5) * mv_CamX
					break
		case 3:	mv_CamTgtEnd += MATH_RandFloat( 0, 0.4) * mv_CamZ
					mv_CamTgtEnd -= MATH_RandFloat( 0.1, 0.5) * mv_CamX
					break
		}
		mi_CamLinear = 1
		tv_temp = mv_CamTgtEnd - mv_CamTgt
	}
		
	mv_CamTgtSpeed *= 0.999
	mv_CamTgtSpeed += MATH_VecNormalize( tv_temp ) * 0.01
	f_norm = MATH_VecNorm( mv_CamTgtSpeed )
	if ( f_norm > mf_CamSpeed )
	{
		mf_CamSpeed += TIME_GetDt() / 5
		if (mf_CamSpeed > 0.04)
			mf_CamSpeed = 0.04
		mv_CamTgtSpeed *= mf_CamSpeed / f_norm
	}
	else
	{
		mf_CamSpeed -= TIME_GetDt() / 5
		if (mf_CamSpeed < 0)
		{
			mf_CamSpeed = 0
			mv_CamTgtSpeed = Cv_NullVector
		}
		else
			mv_CamTgtSpeed *= mf_CamSpeed / f_norm
	}
	mv_CamTgt += mv_CamTgtSpeed * TIME_GetDt()
		
	tv_temp = mv_CamTgt - @mo_Camera OBJ_PosGet()
	@mo_Camera OBJ_SightGeneralSet( tv_temp, Cv_VerticalVector )
}


