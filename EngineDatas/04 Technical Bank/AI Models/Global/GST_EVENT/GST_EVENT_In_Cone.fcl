//
//procedure int	EVENT_IsInCone( int EVT_Indice, vector EVT_Sommet, vector EVT_Axe, float EVT_AngleCos, float EVT_Longueur, int EVT_LRay, float EVT_Visibilite)
//{
//	
////float			EVT_Longueur
////float			wEVT_AngleCos
////vector		EVT_Axe
////vector		EVT_Sommet
////int				EVT_Indice
////int				EVT_LRay
//
//	vector		tv_center
//	vector		tv_vct
//	vector		tv_vct1
//	vector		tv_vct2
//	vector		tv_vct_ortho
//	vector		tv_vct_norm
//	object		to_obj
//	int				i_test
//	float			tf_dist_carre
//	
//	if ( @get_Event Valid_Alfa[EVT_Indice] < EVT_Visibilite)
//		return( 0)
//	tf_dist_carre = EVT_Longueur * EVT_Longueur
//	
//	// Calcul du vecteur Sommet - Position de l EVENT
//	tv_center = @get_Event Valid_Position[EVT_Indice]
//	if ( !MATH_VecNullEpsilon( tv_center) )
//	{
//		// L' EVENT a une position
//		tv_vct = tv_center - EVT_Sommet
//	}
//	else
//	{
//		// L' EVENT n'a pas de position prendre celle de son Gao
//		to_obj = @get_Event Valid_PereDeLEvent[EVT_Indice]
//		tv_center = @to_obj OBJ_PosGet()
//		tv_vct = tv_center - EVT_Sommet
//	}
//
//	tv_vct_norm = tv_vct
//	MATH_VecSetHorzNormalize( tv_vct_norm)
//	// Calcul du vecteur orthogonal au vecteur sommet-centre du cercle
//	tv_vct_ortho.x  = -tv_vct_norm.y
//	tv_vct_ortho.y  = tv_vct_norm.x
//	tv_vct_ortho.z = 0
//	// Approximation des 2 points les plus extérieurs du cercle
//	tv_vct1 = tv_center + ( tv_vct_ortho * @get_Event Valid_Size[EVT_Indice])
//	tv_vct1 -= EVT_Sommet
//	MATH_VecSetHorzNormalize( tv_vct1)
//	tv_vct2 = tv_center - ( tv_vct_ortho * @get_Event Valid_Size[EVT_Indice])
//	tv_vct2 -= EVT_Sommet	
//	MATH_VecSetHorzNormalize( tv_vct2)
//	// Test du dot product pour verifier si le Pt est dans le cone
//	if ( MATH_VecDotProduct( tv_vct, tv_vct) < tf_dist_carre)
//	{
//		// dans le cone
//		MATH_VecSetHorzNormalize( EVT_Axe)
//		// Test du dot product pour verifier si un des 2 extremums est dans le cone
//		if ( MATH_VecDotProduct( EVT_Axe, tv_vct1) >= EVT_AngleCos || MATH_VecDotProduct( EVT_Axe, tv_vct2) >= EVT_AngleCos )	
////		if ( MATH_VecDotProduct( EVT_Axe, tv_vct_norm) >= EVT_AngleCos)
//		{
//			i_test = vrai
//			if ( !EVT_LRay)
//				return( 1)		// La cible est visible
//			else
//			{
//				to_obj = COL_RayObject_Vector( OBJ_PosGet(), tv_vct, all, none, 0, COL_C_Ray_on_visuel)
//				DBG_RenderVector( OBJ_PosGet(), COL_RayObject_PosGet() - OBJ_PosGet(), 0xFF00)
//				if ( !to_obj || to_obj == @get_Event Valid_PereDeLEvent[EVT_Indice])
//					return(1)	// La cible est visible
//				else
//					return(0)	// La cible est cachée visible
//			}		
//		}
//		else
//			return(0)	// La cible n'est pas dans le cone
//	}
//	else
//		return(0)	// La cible n'est pas dans le cone
//}