//------------------------------------------------------------------------------------------------------------------------------------------
// VAR
//------------------------------------------------------------------------------------------------------------------------------------------
int imode, ti_pattern
int ti
float tf_vol, tf


//------------------------------------------------------------------------------------------------------------------------------------------
// CODE
//------------------------------------------------------------------------------------------------------------------------------------------
	

for(ti=SND_Cte_GrpSpecialFX; ti < SND_Cte_MasterGrp; ti++)
{
	//----------------------------------------------------------------------------------------------------------------------------
	// SET USER RQ VOL
	//----------------------------------------------------------------------------------------------------------------------------
	tf_vol = @ "univ" SND_gaf_GroupVolRq[ti]
	@ "univ" SND_gaf_GroupVolRq[ti] = -1.0
	
	if( tf_vol == -1.0)	
	{
		tf_vol = 1.0	// nobody access it
	}
	else
	{
		SND_TraceGrpVol(ti, "vol rq", tf_vol)
	}
	SND_GroupVolRqSend(ti, mai_GroupRqId[ti], tf_vol )
	
	
	//----------------------------------------------------------------------------------------------------------------------------
	// CURRENT VOLUME
	//----------------------------------------------------------------------------------------------------------------------------
	tf_vol = SND_GroupVolumeGet(ti)
	

	//----------------------------------------------------------------------------------------------------------------------------
	// PATTERN
	//----------------------------------------------------------------------------------------------------------------------------
	// get a reset index command ?
	if( @ "univ" SND_gai_GroupVolumePatternNew[ti] )	
	{
		SND_TraceGrpVol(ti, "[pattern] nouvelle sequence de pattern", 0.0)
		mai_GroupPatternIdx[ti] = 0		
	}
	@ "univ" SND_gai_GroupVolumePatternNew[ti] = 0
	
	// get pattern index
	ti_pattern = mai_GroupPatternIdx[ti]  

	//----------------- if there is a pattern (setvol during delay) -----------------
	if( @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] > 0.0 )
	{
		// *** get volume ***
		@ "univ" SND_gaf_GroupVolume[ti] = @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+ 1]
		
		// *** update timer ***
		@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern]  -= TIME_GetDt()
		if(@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] < 0.0)  @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] = 0.0
		
		// *** pattern is finished ? ***
		if(@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] == 0.0)		
		{
			tf = @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1]
			SND_TraceGrpVol(ti, "[pattern] fin du palier a ", tf)
			
			// reset the pattern
			@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] = 0.0
			@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1] = 0.0
			
			// update the pattern index
			ti_pattern++
			if( (2*ti_pattern) >= SND_Cte_VolPattern) ti_pattern = 0
			mai_GroupPatternIdx[ti] = ti_pattern
		}
	
		// *** register we need activation during the next frame ***
		@ "univ" SND_gi_GlobalCommand |= SND_Cte_exec_GrpVol
		
		//*** the pattern has been used this frame ***
		ti_pattern = -1
	}
	//----------------- if there is a pattern (fade during delay) -----------------
	else if( @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] < 0.0 )
	{
		tf = @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1]
		SND_TraceGrpVol(ti, "[pattern] nouveau fade vers ", tf)
		
		SND_M_FadeGroup(ti, @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1], - @ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern])
		
		// set the pattern in waiting mode
		@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] = 0.0
		@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1] = -1.0
	}

	
	//----------------------------------------------------------------------------------------------------------------------------
	// CHOOSE THE GROUP MODE
	//----------------------------------------------------------------------------------------------------------------------------
	// is there a new fade command ?
	if( @ "univ" SND_gaf_GroupVolumeDuration[ti] != 0.0 )
	{
		tf = @ "univ" SND_gaf_GroupVolumeFinal[ti]
		SND_TraceGrpVol(ti, "prepare un nouveau fade vers ", tf)
		
		maf_GroupFadeFactor[ti] = ( @ "univ" SND_gaf_GroupVolumeFinal[ti] - tf_vol ) / @ "univ" SND_gaf_GroupVolumeDuration[ti]
		maf_GroupFadeDate[ti] = TIME_Get()
		maf_GroupFadeFinal[ti] = @ "univ" SND_gaf_GroupVolumeFinal[ti]
		
		if( maf_GroupFadeFactor[ti] > 0.0 )
			mai_GroupFadeMode[ti] = 1 // fade in
		else
			mai_GroupFadeMode[ti] = 2 // fade out
			
		@ "univ" SND_gaf_GroupVolumeDuration[ti] = 0.0
		@ "univ" SND_gaf_GroupVolumeFinal[ti] = 0.0
	}
	else if( (@ "univ" SND_gaf_GroupVolume[ti] != tf_vol)  && (mai_GroupFadeMode[ti] == 0))
	{
		// il n y a pas de fade (mode 0) && le volume courant est different de celui demande
		// => on demande un changement de volume (mode 3)
		tf = @ "univ" SND_gaf_GroupVolume[ti]
		SND_TraceGrpVol(ti, "un nouveau nouveau volume ", tf)
		mai_GroupFadeMode[ti] = 3
	}

	
	//----------------------------------------------------------------------------------------------------------------------------
	// SET VOLUME
	//----------------------------------------------------------------------------------------------------------------------------
	switch(mai_GroupFadeMode[ti])
	{
		//- no thing -----------------------------------------------------------------------
		case 0:
			break
		
		//- fade in -------------------------------------------------------------------------
		case 1:
			af_GroupVolume[ti] += maf_GroupFadeFactor[ti] * TIME_GetDt()
			if(af_GroupVolume[ti] >= maf_GroupFadeFinal[ti])
			{
				af_GroupVolume[ti] = maf_GroupFadeFinal[ti]
				mai_GroupFadeMode[ti] = 0
				
				//*** is it a pattern ***
				if( (ti_pattern != -1) && (@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1] == -1.0) )
				{
					// reset the pattern
					@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] = 0.0
					@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1] = 0.0
					
					// update the pattern index
					ti_pattern++
					if( (2*ti_pattern) >= SND_Cte_VolPattern) ti_pattern = 0
					mai_GroupPatternIdx[ti] = ti_pattern
				}
			}
//			DBG_TraceString("fade in ")
//			DBG_TraceFloat(af_GroupVolume[ti])
//			DBG_TraceEOL()
			SND_TraceGrpVol(ti, "fading in ", af_GroupVolume[ti])
			SND_GroupVolumeSet(ti, af_GroupVolume[ti])
			@ "univ" SND_gaf_GroupVolume[ti] = af_GroupVolume[ti]
			@ "univ" SND_gi_GlobalCommand |= SND_Cte_exec_GrpVol	
			break
			
		//- fade out -----------------------------------------------------------------------
		case 2:
			af_GroupVolume[ti] += maf_GroupFadeFactor[ti] * TIME_GetDt()
			if(af_GroupVolume[ti] <= maf_GroupFadeFinal[ti])
			{
				af_GroupVolume[ti] = maf_GroupFadeFinal[ti]
				mai_GroupFadeMode[ti] = 0
				
				//*** is it a pattern ***
				if( (ti_pattern != -1) && (@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1] == -1.0) )
				{
					// reset the pattern
					@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern] = 0.0
					@ "univ" SND_gaf_GroupVolumePattern[ti][2*ti_pattern+1] = 0.0
					
					// update the pattern index
					ti_pattern++
					if( (2*ti_pattern) >= SND_Cte_VolPattern) ti_pattern = 0
					mai_GroupPatternIdx[ti] = ti_pattern
				}
			}
//			DBG_TraceString("fade out ")
//			DBG_TraceFloat(af_GroupVolume[ti])
//			DBG_TraceEOL()
			SND_TraceGrpVol(ti, "fading out ", af_GroupVolume[ti])
			SND_GroupVolumeSet(ti, af_GroupVolume[ti])
			@ "univ" SND_gaf_GroupVolume[ti] = af_GroupVolume[ti]
			@ "univ" SND_gi_GlobalCommand |= SND_Cte_exec_GrpVol	
			break

		//- set value  -----------------------------------------------------------------------
		case 3:
			SND_TraceGrpVol(ti, "setting value ", af_GroupVolume[ti])
			SND_GroupVolumeSet(ti, @ "univ" SND_gaf_GroupVolume[ti] )
			af_GroupVolume[ti] = @ "univ" SND_gaf_GroupVolume[ti]
			mai_GroupFadeMode[ti] = 0
//			DBG_TraceString("set vol ")
//			DBG_TraceFloat(af_GroupVolume[ti])
//			DBG_TraceEOL()
			break
			
		//- error ----------------------------------------------------------------------------
		default:
			SND_M_Assert(0, "[GST_SOUND] bad group mode")
			mai_GroupFadeMode[ti] = 0
			break
	}	
}
