#include "PNJ_Pigeon_defines.var"

vector				tv_pos
vector				tv_travel_sight
vector				tv_v1
vector				tv_v2

float					tf_cos

object				to_nmi

// SORTIE ETAT 	===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	
	return
}

// INIT ETAT 	=====================================================================
if( i_etat_courant != ETAT_PIGEON_ATTERIT)
{
	i_etat_courant = ETAT_PIGEON_ATTERIT
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	
	DYN_GravitySet(Cv_NullVector)
	v_travel_start = OBJ_PosGet()
	v_travel_start_sight = OBJ_SightGet()

	tv_v1 = v_boot_camp - OBJ_PosGet()
	tv_v1.x += MATH_RandFloat(-f_boot_camp_size * 0.7, f_boot_camp_size * 0.7)
	tv_v1.y += MATH_RandFloat(-f_boot_camp_size * 0.7, f_boot_camp_size * 0.7)
	if (COL_RayObject_Dist(OBJ_PosGet(), tv_v1, 50.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
		v_travel_end = COL_RayObject_PosGet() + cvector(0.0, 0.0, 0.3)
	else
		v_travel_end = OBJ_PosGet() - (OBJ_BankingGet() * 5.0)
	v_travel_end_sight = -OBJ_SightGet()
	f_travel_coef = 0.0
	f_travel_length = MATH_VecNorm(v_travel_end - v_travel_start)
	f_factor = 1.0
	
	f_time_start_etat = 0.0
} 
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI ========================================================================
AI_Execute("Pigeon_exec_DetectPaf")
f_flying_speed = MATH_FloatBlend(f_flying_speed, f_flying_speed_normal, 0.5 * TIME_GetDt())

o_rided_actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)

to_nmi = Pigeon_GetNearestNMI()
if (to_nmi)
{
	i_bored_by_someone = 1
	AI_TrackCurChangeNow("Pigeon_ETAT_decolle")
}

// COMPORTEMENT ================================================================

if (f_travel_coef < 1.0)
{
	// Déplacement le long de la courbe
//	MATH_LIB_Bezier_Display(30, v_travel_start, v_travel_start + (v_travel_start_sight * 5.0), v_travel_end + (v_travel_end_sight * 2.0), v_travel_end, color_blanc)
	DBG_RenderVector(v_travel_start, v_travel_start_sight, color_bleu)
	DBG_RenderVector(v_travel_end, v_travel_end_sight, color_bleu)
	tv_pos = MATH_LIB_Bezier_Pos_Get(f_travel_coef, v_travel_start, v_travel_start + (v_travel_start_sight * 5.0), v_travel_end + (v_travel_end_sight * 2.0), v_travel_end, tv_travel_sight)
	tv_travel_sight.z *= -1.0
	
	// Battement d'ailes
	if (f_battement >= 1.0)
		i_battement_sens = 1
	else if (f_battement <= -1.0)
		i_battement_sens = 0
	
	tv_v1 = OBJ_PosGet() - tv_pos
	tv_v1.z = 0.0
	if (MATH_VecNullEpsilon(tv_v1))
		tf_cos = 1.5
	else
	{
		tf_cos = (0.3 - MATH_VecNorm(tv_v1)) * 5.0
		tf_cos = MATH_FloatLimit(tf_cos, -1.5, 1.5)
	}
	if (!i_battement_sens)
		f_battement += tf_cos * 10.0 * TIME_GetDt() / (1.0 - f_battement)
	else
		f_battement -= tf_cos * 10.0 * TIME_GetDt()
	f_battement = MATH_FloatLimit(f_battement, -1.0, 1.0)
	tv_pos.z += f_battement / 12.0
	
	// Position
	OBJ_PosSet(tv_pos)
	
	// Sight & banking
	tv_travel_sight = MATH_VecBlend(OBJ_SightGet(), tv_travel_sight, 2.0 * TIME_GetDt())
	tv_v1 = MATH_VecBlend(OBJ_BankingGet(), Cv_VerticalVector, 2.0 * TIME_GetDt())
	tf_cos = MATH_VecDotProduct(OBJ_BankingGet(), Cv_VerticalVector)
	if (tf_cos < Cf_Cos20)
	{
		if (f_battement > 0.0)
			tv_v1 = MATH_VecBlend(tv_v1, tv_travel_sight, f_battement / 20.0)
		OBJ_BankingGeneralSet(tv_travel_sight, tv_v1)
	}
	else
	{
		if (f_battement > 0.0)
			tv_travel_sight = MATH_VecBlend(tv_travel_sight, -Cv_VerticalVector, f_battement / 20.0)
		OBJ_SightGeneralSet(tv_travel_sight, tv_v1)
	}
	
	// Coefficient de déplacement le long de la courbe
	f_travel_coef += (TIME_GetDt() / f_travel_length) * f_flying_speed * f_factor
	//if (f_travel_coef > 0.8)
	//	f_factor = MATH_FloatLimit(f_factor - (TIME_GetDt() / 1.0), 0.1, 1.0)
}
else
{
	DYN_GravitySet(Cv_NormalGravity)
	tv_v1 = OBJ_BankingGet()
	tf_cos = MATH_VecDotProduct(tv_v1, Cv_VerticalVector)
	if (tf_cos > 0.999)
	{
		OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
		AI_TrackCurChangeNow("Pigeon_ETAT_au_sol")
	}
	tv_v1 = MATH_VecBlend(tv_v1, Cv_VerticalVector, 6.0 * TIME_GetDt())
	OBJ_BankingGeneralSet(OBJ_SightGet(), tv_v1)
}

DBG_RenderVector(OBJ_PosGet(), v_travel_end - OBJ_PosGet(), color_bleu)
DBG_RenderVector(v_travel_start, OBJ_PosGet() - v_travel_start, color_bleu)
