#include "PNJ_Pigeon_defines.var"

int					ti_can_change_state

vector			tv_vec
vector			tv_tmp

object			to_nmi

float				tf_speed

// SORTIE ETAT 	===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	return
}

// INIT ETAT 	=====================================================================
if( i_etat_courant != ETAT_PIGEON_AU_SOL)
{
	i_etat_courant = ETAT_PIGEON_AU_SOL
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()

	DYN_GravitySet(Cv_NormalGravity)
	f_change_state_timer = MATH_RandFloat(1.0, 5.0)
	f_factor = 0.0
	i_etat_au_sol = -1
	
	f_time_start_etat = 0.0
} 
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI ========================================================================
f_change_state_timer -= TIME_GetDt()
ti_can_change_state = 0
AI_Execute("Pigeon_exec_DetectPaf")

o_rided_actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)

to_nmi = Pigeon_GetNearestNMI()
if (to_nmi)
{
	f_factor += TIME_GetDt()
	if ((MATH_VecSquareNorm(OBJ_PosGet() - @to_nmi OBJ_PosGet()) < 4.0) && (f_factor >= 3.0))
	{
		f_flying_speed = 4.0
		f_factor = 1.0
		i_bored_by_someone = 1
		AI_TrackCurChangeNow("Pigeon_ETAT_decolle")
	}
	else
	{
		v_cur_dir = MATH_VecNormalize(OBJ_PosGet() - @to_nmi OBJ_PosGet())
		i_etat_au_sol = ACTION_PIGEON_MARCHE
	}
}
else f_factor = 0.0

// COMPORTEMENT ================================================================
switch (i_etat_au_sol)
{
	case ACTION_PIGEON_MARCHE :
		if (f_battement >= 0.3)
			i_battement_sens = 1
		else if (f_battement <= -0.3)
			i_battement_sens = 0
		
			tv_tmp = OBJ_HorizonGet()
			if (f_battement < 0.0)
				tv_tmp *= -1.0
			if (MATH_AbsFloat(f_battement) > 0.1)
				tv_vec = MATH_VecBlend(Cv_VerticalVector, tv_tmp, (MATH_AbsFloat(f_battement) - 0.1) * 0.3)
			else
				tv_vec = Cv_VerticalVector
			if ((f_change_state_timer <= 0.0) && MATH_FloatNullToler(f_battement, 0.01))
			{
				ti_can_change_state = 1
				OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
			}
			else
			{
				if (to_nmi != nobody)
					tf_speed = 3.0
				else
					tf_speed = 2.0
				
				if (i_battement_sens)
					f_battement -= tf_speed * TIME_GetDt()
				else
					f_battement += tf_speed * TIME_GetDt()
				tv_tmp = MATH_VecBlend(OBJ_SightGet(), v_cur_dir, tf_speed * 3.0 * TIME_GetDt())
				OBJ_BankingGeneralSet(tv_tmp, tv_vec)
				if (MATH_AbsFloat(f_battement) > 0.1)
					OBJ_PosSet(OBJ_PosGet() + (tf_speed * 3.0 * MATH_AbsFloat(f_battement) * OBJ_SightGet() * TIME_GetDt()))
			}
		break
	case ACTION_PIGEON_ATTENTE :
		ti_can_change_state = 1
		break
	case ACTION_PIGEON_PICORE :
		if (f_battement > 0.0)
		{
			if (f_battement < 0.5)
				tv_vec = MATH_VecBlend(Cv_VerticalVector, OBJ_SightGet(), (f_battement * 0.7))
			else
				tv_vec = MATH_VecBlend(Cv_VerticalVector, OBJ_SightGet(), (1.0 - f_battement) * 0.7)
			OBJ_BankingGeneralSet(OBJ_SightGet(), tv_vec)
			f_battement += 6.0 * TIME_GetDt()
			if (f_battement >= 1.0)
			{
				f_battement = 0			
				OBJ_BankingGeneralSet(OBJ_SightGet(), Cv_VerticalVector)
			}
		}
		else
		{
			if (f_change_state_timer <= 0.0)
				ti_can_change_state = 1
			else if (MATH_RandInt(-1, 10) < 0.0)
				f_battement = 0.01
		}
		break
	case ACTION_PIGEON_VOLE :
		break
	default:
		f_change_state_timer = -1.0
		ti_can_change_state = 1
		break
}

// Changement d'état
if ((f_change_state_timer <= 0.0) && ti_can_change_state)
{
	if (MATH_VecSquareNorm(v_boot_camp - OBJ_PosGet()) > f_boot_camp_size * f_boot_camp_size)
	{
		i_etat_au_sol = ACTION_PIGEON_MARCHE
		v_cur_dir = MATH_VecNormalize(v_boot_camp - OBJ_PosGet() + cvector(MATH_RandFloat(-2.0, 2.0), MATH_RandFloat(-2.0, 2.0), 0.0))
		f_battement = 0.0
		i_battement_sens = 0
	}
	else
	{
		i_etat_au_sol = MATH_RandInt(0, 100)
		if (i_etat_au_sol < 40)
			i_etat_au_sol = ACTION_PIGEON_MARCHE
		else if (i_etat_au_sol < 60)
			i_etat_au_sol = ACTION_PIGEON_ATTENTE
		else if (i_etat_au_sol < 90)
			i_etat_au_sol = ACTION_PIGEON_PICORE
		else 
			i_etat_au_sol = ACTION_PIGEON_VOLE
		
		switch (i_etat_au_sol)
		{
			case ACTION_PIGEON_MARCHE :
				f_battement = 0.0
				i_battement_sens = 0
				v_cur_dir.x = MATH_RandFloat(-1.0, 1.0)
				v_cur_dir.y = MATH_RandFloat(-1.0, 1.0)
				break
			case ACTION_PIGEON_ATTENTE :
				break
			case ACTION_PIGEON_PICORE :
				f_battement = 0.0
				i_battement_sens = 0
				break
			case ACTION_PIGEON_VOLE :
				f_factor = 0.0
				AI_TrackCurChangeNow("Pigeon_ETAT_decolle")
				break
		}
	}
	
	f_change_state_timer = MATH_RandFloat(1.0, 5.0)
}
