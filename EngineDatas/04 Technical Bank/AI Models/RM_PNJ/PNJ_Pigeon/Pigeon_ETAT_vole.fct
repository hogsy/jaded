#include "PNJ_Pigeon_defines.var"

vector				tv_v1
vector				tv_v2
vector				tv_pos
vector				tv_travel_sight

float					tf_cos

// SORTIE ETAT 	===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	
	COL_ColSetActivationSet(all, none)
	COL_ColMapActivationSet(all, none)
	
	return
}

// INIT ETAT 	=====================================================================
if( i_etat_courant != ETAT_PIGEON_VOLE)
{
	i_etat_courant = ETAT_PIGEON_VOLE
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()

	COL_ColSetActivationSet(none, all)
	COL_ColMapActivationSet(none, all)
	
	f_change_state_timer = MATH_RandFloat(5.0, 10.0)

	Pigeon_NextWP(o_travel_wp_from)
		
	f_time_start_etat = 0.0
} 
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI ========================================================================
f_flying_speed = MATH_FloatBlend(f_flying_speed, f_flying_speed_normal, 0.5 * TIME_GetDt())
f_change_state_timer -= TIME_GetDt()
if (f_change_state_timer <= 0.0)
	AI_TrackCurChangeNow("Pigeon_ETAT_atterit")

o_rided_actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)

// COMPORTEMENT ================================================================
//MATH_LIB_Bezier_Display(30, v_travel_start, v_travel_start + (v_travel_start_sight * 5.0), v_travel_end + (v_travel_end_sight * 5.0), v_travel_end, color_blanc)
DBG_RenderVector(v_travel_start, v_travel_start_sight, color_bleu)
DBG_RenderVector(v_travel_end, v_travel_end_sight, color_bleu)
tv_pos = MATH_LIB_Bezier_Pos_Get(f_travel_coef, v_travel_start, v_travel_start + (v_travel_start_sight * 5.0), v_travel_end + (v_travel_end_sight * 5.0), v_travel_end, tv_travel_sight)

// Battement d'ailes
if (f_battement >= 1.0)
	i_battement_sens = 1
else if (f_battement <= -1.0)
	i_battement_sens = 0

tv_v1 = OBJ_PosGet() - tv_pos
//tv_v1.z = 0.0
if (MATH_VecNullEpsilon(tv_v1))
	tf_cos = 1.5
else
{
	tf_cos = MATH_VecNorm(tv_v1) / TIME_GetDt()
	tf_cos = 20.0 / (tf_cos * tf_cos)
	tf_cos = MATH_FloatLimit(tf_cos, -1.5, 1.5)
}

if (!i_battement_sens)
	f_battement += tf_cos * 10.0 * TIME_GetDt() / (1.0 - f_battement)
else
	f_battement -= tf_cos * 10.0 * TIME_GetDt()
f_battement = MATH_FloatLimit(f_battement, -1.0, 1.0)
tv_pos.z += f_battement / 12.0

//tv_travel_sight.z = MATH_FloatLimit(tv_travel_sight.z, -0.3, 0.3)
tv_travel_sight = MATH_VecBlend(OBJ_SightGet(), tv_travel_sight, 2.0 * TIME_GetDt())
tf_cos = MATH_VecDotProduct(OBJ_BankingGet(), Cv_VerticalVector)
tv_v1 = MATH_VecBlend(OBJ_BankingGet(), Cv_VerticalVector, 3.0 * TIME_GetDt())

if (tf_cos < Cf_Cos20)
{
	if (f_battement > 0.0)
		tv_v1 = MATH_VecBlend(tv_v1, tv_travel_sight, f_battement / 20.0)
	OBJ_BankingGeneralSet(tv_travel_sight, tv_v1)
}
else
{
	if (f_battement > 0.0)
		tv_travel_sight = MATH_VecBlend(tv_travel_sight, -Cv_VerticalVector, f_battement / 20.0)
	OBJ_SightGeneralSet(tv_travel_sight, tv_v1)
}

tv_v1 = v_travel_end - OBJ_PosGet()
//tv_v2 = @o_travel_wp_to OBJ_PosGet() - tv_pos
if (MATH_VecNullToler(tv_v1, 0.01))
//if (f_travel_coef >= 1.0)
{
	Pigeon_NextWP(o_travel_wp_to)
	f_change_state_timer += MATH_RandFloat(0.5, 1.0)
}    
else
{
	OBJ_PosSet(tv_pos)
	f_travel_coef += (TIME_GetDt() / f_travel_length) * f_flying_speed
}
	
DBG_RenderVector(OBJ_PosGet(), v_travel_end - OBJ_PosGet(), color_bleu)
DBG_RenderVector(v_travel_start, OBJ_PosGet() - v_travel_start, color_bleu)
