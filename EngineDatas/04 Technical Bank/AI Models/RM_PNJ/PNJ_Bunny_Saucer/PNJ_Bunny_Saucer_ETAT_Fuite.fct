#include "PNJ_Bunny_Saucer_defines.var"

Include_UltraProcedure_Header

int				ti_car_index
int				ti_flag_complex_dodge

object		to_monture

float			tf_main_speed
float			tf_coef
float			tf_dist
float			tf_speed_coef
float			tf_delay_before_collision
float			tf_lateral_speed
float			tf_move_length
float			tf_wanted_traction
float			tf_rot_speed
float			tf_wanted_rot_angle
float			tf_next_rot_angle
float			tf_rot_torque
float			tf_angle_delta
float			tf_time
float			tf_hor_speed
float			tf_max_speed

vector		tv_pos
vector		tv_joy_dir
vector		tv_speed
vector		tv_traction
vector		tv_collision_pos
vector		tv_X
vector		tv_Y
vector		tv_main_speed
vector		tv_target_pos
vector		tv_move_dir

network		tn_net

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux
	return
}

if (i_etat_courant != ETAT_Fuite)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Fuite
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_NeverDynamicFather | DYN_C_NeverDynamicHierarchy | DYN_C_HorizontalGrounds | DYN_C_ApplyRec | DYN_C_Col, none)
	DYN_GravitySet(cvector(0.0, 0.0, -40.0))

//	f_acceleration = 40.0
//	f_decceleration = 40.0

	COL_UnCollidableAdd(o_main_actor)

//	f_fuite_duree_2 = f_fuite_duree

	f_boost_duration = 1.0
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
//EVENT_AddEventEnemy(OBJ_Me())
EVENT_AddEventLockCam(OBJ_Me(), 0, OBJ_BankingGet())

if ( ! AI_TriggerIsValid(trigger_agressif) || ! call_trigger(trigger_agressif) )
	macro_change_etat("PNJ_Bunny_Saucer_ETAT_Ronde")

PNJ_Bunny_Sauver_check_paf()
if (i_flag_paf)
	macro_change_etat("PNJ_Bunny_Saucer_ETAT_Paf")

o_Rided_Actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)
if ( ! o_Rided_Actor || o_Rided_Actor == o_main_actor )
	macro_change_etat("PNJ_Bunny_Saucer_ETAT_Basic")

to_monture = @o_main_actor PROC_RM_MontureGet()
if (to_monture)
	tv_main_speed = @to_monture DYN_SpeedGetVector()
else
	tv_main_speed = @o_main_actor DYN_SpeedGetVector()
tv_main_speed.z = 0.0
tf_main_speed = MATH_VecNorm(tv_main_speed)

if (tf_main_speed < 5.0)
	f_main_low_speed_duration += TIME_GetDt()
else
	f_main_low_speed_duration = 0.0

switch(mode)
{
	case Ci_Mode_Agressif :

		if ( @o_main_actor PROC_RM_MontureIDGet() != C_ID_Scooter)
			macro_change_etat("PNJ_Bunny_Saucer_ETAT_Fight")
			
		break
		
	case Ci_Mode_Fuite :
//		if (f_time_start_etat > 3.0 && f_main_low_speed_duration > 2.0)
//			macro_change_etat("PNJ_Bunny_Saucer_ETAT_Fight")
		break
}

OBJ_CapaSet(OBJ_Capa_0, none)

tf_speed_coef = 1.0

if (COL_Pivot_BVCollide(o_start_wp))
{
	f_boost_duration = 0.5
	o_start_wp = WAY_NetNextWP(@o_start_wp WAY_NetOfObj(), o_start_wp, NetNextWP_Mode_aleatoire, 0)
}

tv_target_pos = @o_start_wp OBJ_PosGet()

tv_target_pos = PNJ_Bunny_Saucer_Dodge(tv_target_pos)

tv_joy_dir = tv_target_pos
tv_joy_dir -= OBJ_PosGet()
tv_joy_dir.z = 0.0
tf_dist = MATH_VecNorm(tv_joy_dir)
tv_joy_dir /= tf_dist

// ANTICIPATION LIEE A LA DERIVE =======================================
tv_joy_dir.z = tv_joy_dir.x
tv_joy_dir.x = tv_joy_dir.y
tv_joy_dir.y = - tv_joy_dir.z
tv_joy_dir.z = 0.0

tf_lateral_speed = MATH_VecDotProduct(DYN_SpeedGetVector(),  - tv_joy_dir)
if (f_embardee_duration)
{
	f_embardee_duration -= MATH_FloatMin(f_embardee_duration, TIME_GetDt())
	tf_lateral_speed += f_embardee_offset
}
else if (f_embardee_before_duration)
{
	f_embardee_before_duration -= MATH_FloatMin(f_embardee_before_duration, TIME_GetDt())
}
else
{
	f_embardee_before_duration = MATH_RandFloat(1.0, 2.0)
	f_embardee_duration = MATH_RandFloat(0.2, 0.3)
	f_embardee_offset = MATH_RandFloat(-tf_dist, tf_dist)
}

tv_joy_dir = tf_lateral_speed * tv_joy_dir
tv_joy_dir += tv_target_pos
tv_joy_dir -= OBJ_PosGet()

DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_joy_dir, color_jaune)

tv_joy_dir.z = 0.0
tf_dist = MATH_VecNorm(tv_joy_dir)
tv_joy_dir /= tf_dist

tf_coef = 1.0 + (MATH_VecDotProduct(OBJ_SightGet(), tv_joy_dir) * 2.0)
tf_coef *= 0.5
tf_speed_coef *= MATH_FloatBlend(0.5, 1.0, tf_coef)

to_monture = @o_main_actor PROC_RM_MontureGet()
if (to_monture)
	tv_Y = @to_monture OBJ_PosGet()
else
	tv_Y = @o_main_actor OBJ_PosGet()
tv_Y -= OBJ_PosGet()
tf_coef = MATH_VecNorm(tv_Y)
tf_coef = MATH_FloatMax(tf_coef - 5.0, 0.0)

if ( tf_coef < 11.0 && ! f_delay_since_last_boost)
 	f_boost_duration = 0.5

tf_coef /= 50.0

if (tf_coef < 1.0)
	f_fuite_duree_2 -= MATH_FloatMin(f_fuite_duree_2, TIME_GetDt())

tf_max_speed = MATH_FloatBlend(f_min_speed, f_max_speed, f_fuite_duree_2 / f_fuite_duree)

if (PNJ_Bunny_Saucer_Get_Rope_Gao(tv_X))
{
	tf_wanted_traction = 150.0
}
else if (f_boost_duration)
{
	f_delay_since_last_boost = MATH_RandFloat(6.0, 10.0)
	tf_wanted_traction = tf_main_speed + 20.0
}
else
{
	tf_wanted_traction = MATH_FloatBlend(tf_main_speed + MATH_RandFloat(1.0, 10.0), 0.0, tf_coef)
}

tf_wanted_traction = MATH_FloatMin(tf_wanted_traction, tf_max_speed)

// ANTICIPATION LIEE A L'INERTIE ANGULAIRE =================================

// ANGLE DEST
tf_wanted_rot_angle = MATH_VecAngle(OBJ_SightGet(), tv_joy_dir, OBJ_BankingGet())

// COMPORTEMENT =========================================================

PNJ_Bunny_Saucer_Sight_And_Banking(tv_joy_dir)
PNJ_Bunny_Saucer_Apply_Traction_And_Choose_Action(tf_wanted_traction)

