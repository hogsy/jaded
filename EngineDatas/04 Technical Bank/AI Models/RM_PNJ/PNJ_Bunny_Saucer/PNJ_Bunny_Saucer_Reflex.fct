#include "PNJ_Bunny_Saucer_defines.var"

procedure_ultra void RM_Projectiles_Fire(object to_launcher, object to_target, vector tv_init_speed);
procedure_ultra int RM_Projectiles_IsStarted();
procedure_ultra int RM_Projectiles_IsMine();
procedure_ultra int RM_Projectiles_IsMissile();
procedure_ultra int RM_Projectiles_TimeMaxGet();

object		to_proj
object		to_target
object		to_net_start
object		to_net_end

vector		tv_vec
vector		tv_pos
vector		tv_axis

int				ti_idx
int				ti_i
int				ti_nb
int				ti_proj_needed
int				ti_nb_miss
int				ti_near_enough

float			tf_coeff
float			tf_dist

if (i_cam_cut)
	i_cam_cut--

if (IO_ButtonJustPressed(joy_button_StickR))
	i_cam_cut = 2

f_delay_since_last_ground_col += TIME_GetDt()

f_boost_duration -= MATH_FloatMin(f_boost_duration, TIME_GetDt())
f_delay_since_last_boost -= MATH_FloatMin(f_delay_since_last_boost, TIME_GetDt())

// TRACTION
if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
{
	DYN_FlagsSet(DYN_C_OptimizeColDisable, none)	

	DYN_TractionSet(Cv_NullVector)
//	DYN_TractionSet(v_Traction_Exterieure)
}

OBJ_BankingGeneralSet(OBJ_SightGet(), v_last_real_banking)

OBJ_CapaSet(none, all)

// Tir de projectiles
to_target = AI_MainActorGet(0)
if (MATH_VecNorm(@to_target OBJ_PosGet() - OBJ_PosGet()) < 100.0)
	ti_near_enough = 1
else
	ti_near_enough = 0

if ((o_projectile_current != nobody) && @o_projectile_current RM_Projectiles_IsStarted())
	o_projectile_current = nobody

if (((i_etat_courant == ETAT_Fuite) || (i_etat_courant == ETAT_Ronde)) && i_has_projectile && ti_near_enough)
{
	// MAJ du délai entre deux tirs
	f_proj_delay -= TIME_GetDt()
	
	if ((f_proj_delay <= 0.0) && (@to_target PROC_RM_Mode() != ETAT_RM_main))
		f_proj_delay = MATH_RandFloat(1.0, 1.5)
		
	// Délai écoulé et le projectile précédent est parti ?
	if ((f_proj_delay <= 0.0) && (o_projectile_current == nobody))
	{
		// Le waypoint courant a changé ?
		if (o_proj_last_wp != o_start_wp)
		{
			// Oui, recalculer les autorisations de tir
			for (ti_i=0; ti_i < 5; ti_i++) {
				i_proj_allowed[ti_i] = @o_proj_last_wp OBJ_CapaTest((1 << (ti_i * 2)))
				i_proj_allowed[ti_i] += (@o_proj_last_wp OBJ_CapaTest((1 << (ti_i * 2 + 1))) * 10)
			}
			o_proj_prev_wp = o_proj_last_wp
			o_proj_last_wp = o_start_wp
			
			// Finir la rafale si son type de projectile n'est plus autorisé
			if (i_proj_rafale_nb && (!i_proj_allowed[i_proj_rafale_type]))
				i_proj_rafale_nb = 0
		}
		
		// Peut-on tirer des projectiles ? 
		ti_proj_needed = 0
		for (ti_i=0; ti_i < 5; ti_i++)
			if (o_projectiles[ti_i] != nobody)
				ti_proj_needed += i_proj_allowed[ti_i]
		if (!ti_proj_needed)
			i_proj_rafale_nb = 0

		// Tirer des projectiles
		o_projectile_current = nobody
		ti_nb_miss = i_proj_rafale_miss
		while ((o_projectile_current == nobody) && (ti_proj_needed))
		{
			// Si pas de rafale, type de projectile au hasard
			if (!i_proj_rafale_nb)
				ti_idx = MATH_RandInt(0, 5)
			else
				ti_idx = i_proj_rafale_type
			
			// Si on peut tirer ce type de projectile
			if ((o_projectiles[ti_idx] != nobody) && (i_proj_allowed[ti_idx]))
			{
				// Ne pas tirer si que des mines et à l'arrêt
				if ((!@o_projectiles[ti_idx] RM_Projectiles_IsMine()) || (DYN_SpeedGet() > 5.0))
				{
					// Pas de rafale -> déterminer le nombre de projectiles à tirer
					if (!i_proj_rafale_nb)
					{
						if ((i_proj_allowed[ti_idx] == 10) || ((i_proj_allowed[ti_idx] == 11) && (MATH_RandInt(0, 2) == 1)))
						{
							i_proj_rafale_nb = i_proj_rafale_size
							i_proj_rafale_type = ti_idx
						}
						ti_i = 0
					}
					else
					{
						// Tirer le nième projectile
						ti_i = i_proj_rafale_size - i_proj_rafale_nb
					}
					
					// Position du projectile
					if (i_proj_rafale_nb && (!@o_projectiles[ti_idx] RM_Projectiles_IsMissile()))
						tv_vec = OBJ_PosGet() + (OBJ_BankingGet() *(2.0 - (MATH_AbsFloat((i_proj_rafale_size / 2.0) - (ti_i + 0.5)) / 2.0)))- (OBJ_SightGet()) - ((OBJ_HorizonGet() * ((i_proj_rafale_size / 2.0) - ti_i)) * 1.3)
					else
						tv_vec = OBJ_PosGet() + (OBJ_BankingGet() * 2.0) - (OBJ_SightGet() * 2.0)
					
					// Dupliquer le projectile
					o_projectile_current = @o_projectiles[ti_idx] OBJ_Duplicate(tv_vec)
					@o_projectile_current OBJ_FlagInvisibleSet(vrai)
	
					// Vitesse initiale et orientation du projectile				
					if (i_proj_rafale_nb)
						tf_coeff = MATH_FloatLimit((i_proj_rafale_size / 2.0) - ti_i - 1, -50.0, 50.0)
					else
						tf_coeff = 1.0
	//					tv_vec = ((@get_camera OBJ_BankingGet() * 1.0) + ( @get_camera OBJ_SightGet() * 2.5) + (@get_camera OBJ_HorizonGet()* tf_coeff))
					tv_vec = -OBJ_SightGet() + (OBJ_HorizonGet() * tf_coeff)
					
					MATH_VecSetNorm(tv_vec, 150.0)
	//				DBG_RenderVector(OBJ_PosGet(), tv_vec, color_bleu)
	 				@o_projectile_current OBJ_BankingGeneralSet(-OBJ_SightGet(), tv_vec)
	 
					// Cible du projectile				
					to_target = AI_MainActorGet(0)
					if (@o_projectile_current RM_Projectiles_IsMine())
					{
						tf_coeff = DYN_SpeedGet() * @o_projectile_current RM_Projectiles_TimeMaxGet() * 1.7
						to_net_start = OBJ_Me()
						to_net_end = o_proj_last_wp
						while (tf_coeff > 0.0)
						{
							tf_dist = tf_coeff
							tf_coeff -= MATH_VecNorm(@to_net_end OBJ_PosGet() - @to_net_start OBJ_PosGet())
							if (tf_coeff > 0.0)
							{
								to_net_start = to_net_end
								to_net_end = WAY_NetNextWP(@to_net_end WAY_NetOfObj(), to_net_end, NetNextWP_Mode_aleatoire, 0)
							}
						}
						
						tv_axis = MATH_VecNormalize(@to_net_end OBJ_PosGet() - @to_net_start OBJ_PosGet())
						tv_pos = @to_net_start OBJ_PosGet() + (tv_axis * tf_dist)
						
						to_target = @get_WP OBJ_Duplicate(tv_pos)
						@to_target OBJ_FlagsIdentitySet(OBJ_C_IdentityFlag_ExtendedObject, none)
						@to_target OBJ_CapaSet(0xFF,none)
					}
					else if (i_proj_rafale_nb && ti_nb_miss && ((MATH_RandInt(0, 2) == 1) || (ti_nb_miss >= (i_proj_rafale_nb - ti_i - 1))))
					{
						to_target = @get_WP OBJ_Duplicate(@to_target OBJ_PosGet() + cvector(1.0, 1.0,  0.0))
						@to_target OBJ_FlagsIdentitySet(OBJ_C_IdentityFlag_ExtendedObject, none)
						@to_target OBJ_CapaSet(0xFF,none)
						ti_nb_miss--
					}
					
					DBG_RenderVector(OBJ_PosGet(), @to_target OBJ_PosGet() - OBJ_PosGet(), color_rouge)
					
					// Tirer le projectile
					@o_projectile_current RM_Projectiles_Fire(OBJ_Me(), to_target, tv_vec)
					
					// Mettre à jour le délai de tir
					if (i_proj_rafale_nb)
						i_proj_rafale_nb--
						
					if (i_proj_rafale_nb > 0)
						f_proj_delay = f_proj_rafale_delay
					else
						f_proj_delay = MATH_RandFloat(f_projectiles_delay[ti_idx], f_projectiles_delay[ti_idx] * 1.5)
				}
				else if (ti_proj_needed == i_proj_allowed[ti_idx])
					ti_proj_needed = 0
			}
		}
	}
}

i_flag_paf_check_done = faux
