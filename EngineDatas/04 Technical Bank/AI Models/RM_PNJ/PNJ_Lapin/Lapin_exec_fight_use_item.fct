#include "PNJ_Lapin_defines.var"

int			ti_i
int			ti_flag_ok
int			ti_interet_cpt
int			ti_target_item_checked
int			ti_gao_ray_insensitive

float		tf_test_dist
float		tf_dist, tf_dist2
float		tf_dot_product
float		tf_sqr_dist
float		tf_norm
float		tf_me_to_target_dist
float		tf_range

vector	tv_temp
vector	tv_sight
vector	tv_pos
vector	tv_me_to_target 
vector	tv_ray_start
vector	tv_ray_dir

object	to_target
object	to_target_ref_bone
object	to_obj
object	to_gao


if( o_cache_just_leave )
	return

if( Mode_Compagnon )
	return				// TEMP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

if( i_is_in_water )
	return

if( ! o_item )
	return

//if( Lapin_ITEM_Has_Key() )
//	return				// TEMP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

if( Lapin_ITEM_Has_Gourdin() )
	return			// gourdin => état mélée pas état use

if( Proc_Monture_ChargeAttack_Available(Proc_PNJ_Lapin_MontureGet()) )
	return			// utiliser l'attaque de la monture au lieu du gun

//if( Proc_PNJ_Lapin_MontureIDTest(C_ID_Monture_Araignee) )
//	return			// utiliser l'attaque de l'araignée et pas d'item			// TEMP !!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
//if( Proc_PNJ_Lapin_MontureIDTest(C_ID_Monture_Quadripode) )
//	return			// utiliser l'attaque de l'araignée et pas d'item			// TEMP !!!!!!!!!!!!!!!!!!!!!!!!!!!!

if( Proc_PNJ_Lapin_MontureIDTest(C_ID_Monture_Rope) )
	return			// impossible d'utiliser une arme quand je descend la corde

if( f_item_weapon_use_delai )
	return

if( ! i_flag_in_my_territory )
	return

if( i_perceived_best_actor_index == -1)
	return

to_target = ao_perceived_actor[i_perceived_best_actor_index]


if( Lapin_ITEM_Has_Carotte() )
{
	goto USE
}

if( Lapin_ITEM_Has_Weapon() )
{
	if( f_OnScreen_Pct < 0.9 )
		return		// HORS CHAMP !!!!
}
else
{
	return		// pas de weapon ???
}


if( ! Lapin_Atk_Simultannees_IsValid(to_target, ti_interet_cpt) )
{
	i_item_cant_use = Ci_item_cant_use_interest_maxnb
	return		// nb d'interet !!!!
}

ti_flag_ok = faux
ti_target_item_checked = faux

// range ?
tf_range = f_item_range
if( o_RideMount_Actor && i_RideMount_ID == C_ID_Scooter )
	tf_range *= 3.0			// sur 1 soucoupe je tire de + loin
tf_sqr_dist = tf_range
tf_sqr_dist *= tf_sqr_dist

BEGIN:

if( ! ti_target_item_checked )
{
	to_gao = Lapin_Get_Target(to_target)
	if( to_gao == to_target )
		ti_target_item_checked = vrai		// rayman en traine pas de mine, je considère que j'ai checké la mine
}
else
	to_gao = to_target

to_target_ref_bone = @to_gao ANI_CanalObjectGet(Anim_Canal_Tete)
if ( ! to_target_ref_bone )
	to_target_ref_bone = to_gao

tv_temp = @to_gao OBJ_PosGet()
tv_temp -= OBJ_PosGet()
tv_me_to_target = tv_temp

if( Att_Protect_Gao 		// pas de dot dans ce cas car je cours vers le gao
	|| MATH_VecDotProduct(OBJ_SightGet(), tv_temp) > 0.0 ) // && tv_temp.z > -2.0 && tv_temp.z < 3.5)
{
	tv_ray_start = v_look_head_pos
	if( Lapin_ITEM_Has_Weapon() )
	{
		switch( i_item_ID )
		{
			case RM_WEAPON_TYPE_GRENADE :
				tv_ray_start = OBJ_PosGet() + MATH_VecLocalToGlobal(v_use_grenade_offset)
				break
			case RM_WEAPON_TYPE_GUN :
				tv_ray_start = OBJ_PosGet() + MATH_VecLocalToGlobal(v_use_gun_offset)
				break
		}
	}
	
	tv_temp = @to_target_ref_bone OBJ_PosGet()
	tv_temp -= tv_ray_start
//	tv_temp.z = 0.0

	tf_dist = MATH_VecDotProduct(tv_temp, tv_temp)

	if( ! @to_gao AI_IsModel(get_PNJ_Pigeon_path) && tf_dist < f_item_dist_too_close * f_item_dist_too_close )
	{
		i_item_cant_use = Ci_item_cant_use_too_close
		return		// too close !!!!
	}
	else if (tf_dist > tf_sqr_dist)
	{
		i_item_cant_use = Ci_item_cant_use_too_far
		return		// too far !!!!
	}
	else if( Lapin_ITEM_Is_Reloading() )
	{
		i_item_cant_use = Ci_item_cant_use_wait_reload
		return		// reload !!!
	}
	else
	{	
		tf_dist = MATH_FloatSqrt(tf_dist)
		tv_temp /= tf_dist
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp, color_rouge)
		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_look_virtual_sight, color_vert)
		tv_temp.z = 0.0
		MATH_VecSetNormalize(tv_temp)
		tv_sight = v_look_virtual_sight
		tv_sight.z = 0.0
		MATH_VecSetNormalize(tv_sight)
//		if( @o_item AI_IsModel(get_RM_Weapon_path) && @o_item PROC_WEAPON_TypeGet() == RM_WEAPON_TYPE_GRENADE )
//		if( Lapin_ITEM_Has_Weapon() && i_item_ID == RM_WEAPON_TYPE_GRENADE )
//			ti_flag_ok = vrai
//		else 
//		if( MATH_VecDotProduct(tv_temp, tv_sight) > Cf_Cos10 )
		{
			// test LRAY
//			tf_dist = MATH_VecDotProduct(tv_me_to_target, tv_me_to_target)
			tv_ray_dir = @to_target_ref_bone OBJ_PosGet() - tv_ray_start
			
			if( to_gao != to_target )		// je vise une bombox et pas rayman
				tv_ray_dir += Cv_VerticalVector
			
			tf_dist = MATH_VecDotProduct(tv_ray_dir, tv_ray_dir)
			
			tf_dist = MATH_FloatSqrt(tf_dist)
//			DBG_RenderVector(tv_ray_start, tv_me_to_target, 0xCCCCCCCC)
			DBG_RenderVector(tv_ray_start, tv_ray_dir, 0xCCCCCCCC)
			
//			MATH_VecSetNormalize(tv_me_to_target)
			MATH_VecSetNormalize(tv_ray_dir)
			tv_me_to_target /= tf_dist
			
			ti_gao_ray_insensitive = faux
			if( @to_gao OBJ_FlagsControlGet() & OBJ_C_ControlFlag_RayInsensitive )
				ti_gao_ray_insensitive = vrai
			else
				@to_gao OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
			
//			to_obj = COL_RayObject_Dist(tv_ray_start, tv_me_to_target, tf_dist, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			to_obj = COL_RayObject_Dist(tv_ray_start, tv_ray_dir, tf_dist, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
			if( ! to_obj )
				ti_flag_ok = vrai		// pas d'obstacle
			else
			{
				to_obj = to_obj
				i_item_cant_use = Ci_item_cant_use_obstacle		// obstacle
			}
			
			if( ! ti_gao_ray_insensitive )
				@to_gao OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)			
		}
	}
}


// On peut tirer / lancer
if( ti_flag_ok )
{
	USE:
	if( to_gao != to_target )
		i_Atk_Activate_Explosive_Box_flag = vrai		// frapper la bombox !!!
	macro_change_etat("Lapin_ETAT_USE_ITEM")
}
else
{
	if( ! ti_target_item_checked )
	{
		ti_target_item_checked = vrai
		goto BEGIN
	}
}

