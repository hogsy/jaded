#include "PNJ_Lapin_defines.var"

vector	tv_sight
vector	tv_pos
vector	tv_best_pos
vector	tv_min_pos
vector	tv_max_pos
vector	tv_door_pos
vector	tv_temp
vector	tv_temp1
float		tf_dist
float		tf_dist_safe
float		tf_size
float		tf_dot
float		tf_best_dot
float		tf_offset
int			ti_Fuite_Deplacement
int			ti_i
int			ti_link_nb
object	to_bv
object	to_best_bv
object	to_start_bv


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_fuite_grenades_flag = faux
	i_sort_etat = faux
	Lapin_EXPRESSION(Cf_Expr_Mouth_Closed)
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Lapin_FUITE) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Lapin_FUITE
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	if( i_1st_ingame_valid_pos_goback )
		Lapin_DBG_Trace_String(DBG_Trace_Etat, "FUITE (GO BACK TO SAFE POS !!)")
	else if( i_fuite_grenades_flag )
		Lapin_DBG_Trace_String(DBG_Trace_Etat, "FUITE (GRENADES !)")
	else
		Lapin_DBG_Trace_String(DBG_Trace_Etat, "FUITE")
	fct_previous_etat = fct_last_etat
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	i_fuite_flag = faux		// ok now
	i_fuite_pos_safe = faux
	i_fuite_sous_terre_pos_atteinte = faux
	i_FuiteBV_safe_flag = faux
	f_Fuite_delai_Safe = 0.0
	i_path_way_force_recompute_flag = vrai
	
	if( Fuite_Si_Clef && ( Lapin_ITEM_Has_Key() || Lapin_LUMS_Cage_Has() ) )
		f_fuite_delai = Cf_Infinit			// tu me rattrapperas jamais !!!! =)
	else if( i_fuite_grenades_flag )
	{
		// aux abriiiiiis !!!
		f_fuite_delai = 5.0
		Lapin_GFX_GoutteSueur_Creation()
		SND_RequestPlay(Ci_SND_FUITE_AuxAbris)
	}
	else
	{
		// aïe le con !!! ;'(
		f_fuite_delai = MATH_RandFloat(5.0, 10.0)
		if( MATH_RandFloat(0.0, 1.0) < 0.33 )
			Lapin_GFX_GoutteSueur_Creation()
		SND_RequestPlay(Ci_SND_FUITE_Oscour)
	}
	
	if( Item_Prioritaire != Ci_Item_Prioritaire_CLE || ! Lapin_ITEM_Has_Key() )
		Lapin_EXPRESSION(Cf_Expr_Mouth_Full)
	
	i_fuite_oppose_wall = faux
}
else
{
	f_time_start_etat += TIME_GetDt()
}


// STIMULI ===========================================================================
if( ! i_1st_ingame_valid_pos_goback )		// anti bug position de merde => pas d'analyse!!!
{
	o_Grabbed_Actor = LNK_ServeurGet(Ci_LNK_GRAB_EAGLE, mid_Grabbed_LNK_ID, vrai, nofunc, nofunc)
	if( o_Grabbed_Actor )
		macro_change_etat("Lapin_ETAT_GRABBED")
	
	o_Rided_Actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)
	if( o_Rided_Actor )
		macro_change_etat("Lapin_ETAT_RIDED")
	
	AI_Execute("Lapin_exec_check_vision")
	
	MACRO_CHECK_PAFS
	
	if( Lapin_ROPE_Gogo_Mode() )
		macro_change_etat("Lapin_ETAT_GOGO")
	
	if( i_ventilo_flag )
		macro_change_etat("Lapin_ETAT_ASPIRE")
	
	if( o_piege )
		macro_change_etat("Lapin_ETAT_PIEGE")
	
	AI_Execute("Lapin_exec_update_best_interest")
		
	if( ! i_fuite_grenades_flag )
	{
		if( ! MSG_GlobalIsValid(mid_best_interet) )
			MACRO_GO_IDLE(0)
	
		if( ! o_fuite_actor )
			MACRO_GO_IDLE(0)
	}
}

// COMPORTEMENT ===================================================================

ti_Fuite_Deplacement = Fuite_Deplacement
if( ti_Fuite_Deplacement == Ci_Fuite_Deplacement_Rentre_dans_le_Sol && o_RideMount_Actor )
	ti_Fuite_Deplacement = Ci_Fuite_Deplacement_OpposeNmi
if( i_fuite_grenades_flag )
	ti_Fuite_Deplacement = Ci_Fuite_Deplacement_Grenades


// position pour rentrer dans lo sol atteinte ?
if( ! i_fuite_sous_terre_pos_atteinte )
{
	if( ti_Fuite_Deplacement == Ci_Fuite_Deplacement_Rentre_dans_le_Sol 
		|| i_1st_ingame_valid_pos_goback 
		|| ( ti_Fuite_Deplacement == Ci_Fuite_Deplacement_WP_Speficique 
			&& o_fuite_wp
			&& @o_fuite_wp OBJ_CustomBitsTest(Cbit_ACTION_Rentrer_dans_Sol)
			&& OBJ_SqrDist(o_fuite_wp) < 1.0 ) )
	{
		if( ! o_RideMount_Actor )
			macro_change_etat("Lapin_ETAT_TAUPE")		// else attendre
	}
}

if( ! f_fuite_delai )
	MACRO_GO_IDLE(0)

MACRO_CHECK_CHUTE

// anti_mashing ?
AI_Execute("Lapin_exec_check_anti_mashing")
if( i_anti_mashing_flag )
	MACRO_GO_IDLE(0)

AI_Execute("Lapin_exec_check_grappin")

AI_Execute("Lapin_exec_check_shoot")

if( Lapin_ITEM_Has_Key() )
	AI_Execute("Lapin_exec_fight_melee")

switch( ti_Fuite_Deplacement )
{
	case Ci_Fuite_Deplacement_WP_Speficique :
		if( Fuite_dist_min_moi_rayman )
			tf_dist_safe = Fuite_dist_min_moi_rayman		// je m'arrete avant le wp si je suis à distance safe
		else
			tf_dist_safe = Fuite_dist_min_wp_rayman				// je vais jusqu'au wp
		if( i_fuite_pos_safe )
			tf_dist_safe = tf_dist_safe - Cf_fuite_dist_safe_hysteresis		// hystérésis ce n'est plus safe pour repartir
		if( ! Fuite_dist_min_moi_rayman || OBJ_SqrDist(o_fuite_actor) < (tf_dist_safe * tf_dist_safe) )
		{
			i_fuite_pos_safe = faux
			// je vais jusqu'au wp ou je ne suis pas à distance safe = move on !
			o_fuite_wp = Lapin_CACHE_Specific_WP_Get(o_fuite_actor, o_fuite_wp)
			if( ! o_fuite_wp )
			{
				goto FUITE_TOUT_DROIT
			}
			v_way_destpos = @o_fuite_wp OBJ_PosGet()
			i_target_territory_ID = Lapin_PROC_POS_GET_TERRITORY_ID(v_way_destpos)
			AI_Execute("Lapin_exec_way_find")
			v_force_move_occluder_sight = OBJ_PosGet() - @o_fuite_actor OBJ_PosGet()
			AI_Execute("Lapin_exec_way_move")
		}
		else
		{
			i_fuite_pos_safe = vrai
			// je suis à distance safe
			v_way_destpos = Cv_NullVector
			i_target_territory_ID = Lapin_PROC_POS_GET_TERRITORY_ID(v_way_destpos)
			AI_Execute("Lapin_exec_way_find")
			v_force_move_occluder_sight = OBJ_PosGet() - @o_fuite_actor OBJ_PosGet()
			AI_Execute("Lapin_exec_way_move")
		}
		break
		
	case Ci_Fuite_Deplacement_Caches :
		o_cache = Lapin_CACHE_Fuite_Nearest_Get(i_my_territory_ID, o_cache_not_safe, o_fuite_actor)
		if( o_cache )
		{
			o_cache_actor = o_fuite_actor
			i_cache_mode = Ci_CACHE_Mode_Fuite
			macro_change_etat("Lapin_ETAT_CACHE")
		}
		else
		{
			goto FUITE_TOUT_DROIT
		}
		break
	
	case Ci_Fuite_Deplacement_OpposeNmi :
		FUITE_TOUT_DROIT:
		i_AI_computed_dest_pos_flag = vrai
		i_way_moving = faux
		tv_sight = OBJ_PosGet() - @o_fuite_actor OBJ_PosGet()
		tf_dist = MATH_VecNorm(tv_sight)
		if( Fuite_dist_min_moi_rayman )
			tf_dist_safe = Fuite_dist_min_moi_rayman
		else
			tf_dist_safe = Fuite_dist_min_wp_rayman
		if( f_wall_col_duration > 0.5 )
			i_fuite_oppose_wall = vrai
		if( ! i_fuite_oppose_wall && tf_dist < tf_dist_safe )
		{
			// go go go !!!
			i_fuite_pos_safe = faux
			MATH_VecSetNorm(tv_sight, tf_dist_safe)
			v_way_destpos = @o_fuite_actor OBJ_PosGet() + tv_sight
			i_target_territory_ID = Lapin_PROC_POS_GET_TERRITORY_ID(v_way_destpos)
			AI_Execute("Lapin_exec_way_find")
			v_force_move_occluder_sight = OBJ_PosGet() - @o_fuite_actor OBJ_PosGet()
			AI_Execute("Lapin_exec_way_move")
		}
		else
			i_fuite_pos_safe = vrai
		break
		
	case Ci_Fuite_Deplacement_Grenades :
		i_AI_computed_dest_pos_flag = vrai
		i_way_moving = faux
		tv_sight = v_fuite_grenades_dest_pos - OBJ_PosGet()
		tf_dist = MATH_VecNorm(tv_sight)
		tf_dist_safe = 10.0
		if( f_wall_col_duration > 0.5 )
			i_fuite_grenades_wall = vrai
		if( ! i_fuite_grenades_wall && tf_dist > 1.0 )
		{
			// go go go !!!
			i_fuite_pos_safe = faux
			v_way_destpos = v_fuite_grenades_dest_pos
			i_target_territory_ID = Lapin_PROC_POS_GET_TERRITORY_ID(v_way_destpos)
			AI_Execute("Lapin_exec_way_find")
			v_force_move_occluder_sight = OBJ_PosGet() - v_fuite_grenades_dest_pos
			AI_Execute("Lapin_exec_way_move")
		}
		else
			i_fuite_pos_safe = vrai
		break
		
//	case Ci_Fuite_Deplacement_BV_Voisine :
//		// LISTER LES BV VOISINES POUR FAIRE DU TEST PIVOT/BV AU LIEU DE FAIRE DU A*
//		if( ! Territory_Path )
//			DBG_Error("Un lapin est en mode fuite bv voisine et il n'a pas de path")
//		
//		v_way_destpos = Cv_NullVector
//		i_way_moving = faux
//		
//		// check dist to fuite actor
//		tv_temp1 = @o_fuite_actor OBJ_PosGet() - OBJ_PosGet()
//		tf_dist = MATH_VecDotProduct(tv_temp1, tv_temp1)
//		tf_dist = MATH_FloatSqrt(tf_dist)
//		if( i_FuiteBV_safe_flag )
//			tf_offset = 0.0
//		else
//			tf_offset = 3.0
//		if( tf_dist < FuiteBV_dist_min_moi_rayman + tf_offset)
//		{
//			i_FuiteBV_safe_flag = faux
//			tf_best_dot = 1.0
//			tv_best_pos = Cv_NullVector
//			i_action_traction_force_faster = vrai
//			to_start_bv = o_path_current_wp
//			ti_link_nb = WAY_GetNumLinks(Territory_Path, to_start_bv)
//			for (ti_i = 0; ti_i < ti_link_nb; ti_i++)
//			{
//				to_bv = WAY_NetNextWP(Territory_Path, to_start_bv, NetNextWP_Mode_choix_de_lindice, ti_i)	
//				
//				if (WAY_LinkCapaGet(Territory_Path, to_start_bv, to_bv)	& OBJ_Capa_0)
//					continue
//				
// 				tf_size = 1.0
//				PATH_LIB_Get_Door(to_start_bv, to_bv, tf_size, tv_min_pos, tv_max_pos)
//				tv_min_pos.z = OBJ_PosGet().z
//				tv_max_pos.z = OBJ_PosGet().z
//				DBG_RenderVector(tv_max_pos, tv_min_pos - tv_max_pos, color_bleu)
//				tv_door_pos = MATH_VecBlend(tv_min_pos, tv_max_pos, 0.5)		// le milieu de la porte
//				tv_pos = tv_door_pos
//				DBG_RenderVector(OBJ_PosGet(), tv_pos - OBJ_PosGet(), color_bleu)
//				tv_temp = tv_pos - OBJ_PosGet()
//				if( MATH_VecDotProduct(tv_temp, tv_temp) < 4.0 )
//					tv_temp = @to_bv OBJ_PosGet() - OBJ_PosGet()
//				if( MATH_VecNullToler(tv_temp,0.01) )
//					continue
//					MATH_VecSetNormalize(tv_temp)
//				tv_temp1 = @o_fuite_actor OBJ_PosGet() - OBJ_PosGet()
//				if( MATH_VecNullToler(tv_temp1,0.01) )
//					continue
//				MATH_VecSetNormalize(tv_temp1)
//				tf_dot = MATH_VecDotProduct(tv_temp, tv_temp1)
////				Str_DisplayFloatOnce(tf_dot, VIEW_3dWorldTo2d(0,tv_door_pos))
//				if( tf_dot < tf_best_dot )
//				{
//					tf_best_dot = tf_dot
////					tv_temp = Proc_Vec_HorzNormalise(tv_temp, OBJ_SightGet())
////					tv_best_pos = tv_pos + tv_temp
//					tv_best_pos = @to_bv OBJ_PosGet()
//					to_best_bv = to_bv
//				}
//			}
//			// j'ai une position de fuite
//			if( ! MATH_VecNullToler(tv_best_pos, 0.01) )
//			{
//				v_way_destpos = tv_best_pos
//				tv_temp = v_way_destpos - OBJ_PosGet()
//				if( tf_best_dot > Cf_Cos45 )
//				{
//					// ma meilleure solution va me faire passer par rayman
//					if( o_path_current_wp != o_path_main_actor_wp  )
//					{
////						v_way_destpos = Cv_NullVector		// attendre tant qu'on n'est pas dans la même BV
//						v_way_destpos = @o_path_current_wp OBJ_PosGet()
//						i_action_traction_force_faster = faux
//						i_depl_jump_cpt = 0		// spécial
//					}
//					
//					// dodge roulade ????
//					if( ti_link_nb < 2 )
//					{
//						// Q de sac
//						tf_dist = (1.5 * OBJ_ZoomGet())
//						tf_dist *= tf_dist
//						if( TIME_Elapsed(f_Counter_DodgeOnly_last_time, 10.0) && OBJ_SqrDist(o_main_actor) < tf_dist )
//						{
//							i_Counter_DodgeOnly_flag = vrai
//							f_Counter_DodgeOnly_last_time = TIME_Get()
//							i_Counter_flag = vrai
//							macro_change_etat("Lapin_ETAT_COUNTER")
//						}
//					}
//				}
//			}
//		}
//		else
//			i_FuiteBV_safe_flag = vrai
//		
//		// délai ré-apparition ???
//		if( i_FuiteBV_safe_flag )
//		{
//			f_Fuite_delai_Safe += TIME_GetDt()
//			if( Fuite_delai_Safe_for_Apparition && f_Fuite_delai_Safe > Fuite_delai_Safe_for_Apparition && f_OnScreen_Pct < 0.05 )
//			{
//				// délai dépassé, hors champ
//				Lapin_APPARITION_Initialisation()
//				macro_change_etat("Lapin_ETAT_APPARITION")
//			}
//		}
//		else
//			f_Fuite_delai_Safe = 0.0
//		
//		if( ! MATH_VecNullToler(v_way_destpos, 0.01) )
//			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_way_destpos - OBJ_PosGet(), color_rouge)
//		
//		// move !!!!
//		i_target_territory_ID = Lapin_PROC_POS_GET_TERRITORY_ID(v_way_destpos)
//		AI_Execute("Lapin_exec_way_find")
//		AI_Execute("Lapin_exec_way_move")
//		break
		
	
	case Ci_Fuite_Deplacement_BV_Voisine :
		// LISTER LES BV VOISINES POUR FAIRE DU TEST PIVOT/BV AU LIEU DE FAIRE DU A*
		if( ! Territory_Path )
			DBG_Error("Un lapin est en mode fuite bv voisine et il n'a pas de path")
		
		// WAY FIND
		v_way_destpos = Cv_NullVector
		tf_dist_safe = FuiteBV_dist_min_moi_rayman
		if( ! i_FuiteBV_safe_flag )
			tf_dist_safe += 3.0
		v_next_pos = PATH_LIB_Flee_Get_Next_Pos(OBJ_PosGet(),			// POSITION DE DEPART
																		OBJ_Me(),					// ACTEUR DU DEPART
																		o_path_start_wp,			// WP DE DEPART (BYREF)
																		o_path_dead_end_wp, 	// ANTI OSCILLATION
																		@o_main_actor OBJ_PosGet(),		// POSITION A FUIR (RAYMAN)
																		tf_dist_safe,		// DISTANCE DE FUITE
																		1.5 + Lapin_MOVE_Offset_Get(),	// EXTRUSION (LA TAILLE DE L'ACTEUR)
																		Territory_Path,				// LE RESEAU UTILISE
																		i_path_net_wp_nb,		// LE NOMBRE DE POINTS DU RESEAU
																		&ao_path_net_wp[0],	// LES WPS DU RESEAU
																		i_path_way_wp_nb,		// LE NOMBRE DE WP DU CHEMIN (BYREF)
																		&ao_path_way_wp[0])	// LES WPS DU CHEMIN (BYREF)
		
		if( i_path_way_wp_nb )
		{
			i_way_moving = vrai
			AI_Execute("Lapin_exec_way_move")
			i_FuiteBV_safe_flag = faux
			i_fuite_pos_safe = faux
		}
		else
		{
			i_way_moving = faux
			i_FuiteBV_safe_flag = vrai
			i_fuite_pos_safe = vrai
		}
		break
}


// orientation
if( ! i_way_moving && MATH_VecNullToler(v_traction_stream,0.01))
{
	// à l'arrêt je me retourne
	if( i_fuite_grenades_flag )
		v_force_sight = v_fuite_grenades_dangerous_pos - OBJ_PosGet()
	else
		v_force_sight = @o_fuite_actor OBJ_PosGet() - OBJ_PosGet()
}

AI_Execute("Lapin_exec_way_orientation")

// action ?
if( i_fuite_pos_safe && Lapin_LUMS_Cage_Has() )
{
	Lapin_ACTION_Set(Action_Attente_Torture_Lums)
	i_disable_select_action = vrai
}
AI_Execute("Lapin_exec_way_select_action")


//Str_DisplayGaoOnce(o_path_current_wp, MACRO_2D+cvector(0,0.05,0))
