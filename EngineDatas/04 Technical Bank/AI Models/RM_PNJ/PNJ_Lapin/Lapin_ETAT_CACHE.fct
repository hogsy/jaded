#include "PNJ_Lapin_defines.var"

vector	tv_temp
vector	tv_temp1
vector	tv_temp2
vector	tv_temp3
vector	tv_occluderNextPos
vector	tv_occluder_pos
vector	tv_nmi_pos
float		tf_occluder_size
float		tf_occluder_length
float		taf_fake[10]
float		tf_dist
object	to_occluderJump
object	tao_fake[10]
object	tao_wp[20]
object	to_target
network	tway_occluder
int			ti_occluderResult
int			ti_way_wp_nb
int			ti_way_closed
int			ti_i
int			ti_index
int			ti_check_dodge


// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	f_item_weapon_use_delai = 0.75		// pas d'arme pendant un délai
	i_occluder_to_main_actor_last = vrai		// considérer que l'occluder me gène cette trame ci pour utiliser mon arme
	if( i_cache_type == Ci_cache_type_Geometrie )
		o_cache_just_leave = nobody
	else
		o_cache_just_leave = o_cache
	Lapin_EXPRESSION(Cf_Expr_Mouth_Closed)
	i_sort_etat = faux
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Lapin_CACHE) 
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Lapin_CACHE
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	REINIT:
	fct_previous_etat = fct_last_etat
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	if( ! o_cache )
		DBG_Error("pas de cache précalculée ????")

	if( ACT_ActionGet() == Action_Cache_SurpriseTest )
		Lapin_ACTION_Set(Lapin_ACTION_Attente_Get())		// REINIT
	
	Lapin_EXPRESSION(Cf_Expr_Mouth_Closed)
	o_cache_last = o_cache
	v_cache_pos_last = v_cache_pos
	switch( i_cache_mode )
	{
		case Ci_CACHE_Mode_Fuite :
			Lapin_DBG_Trace_String(DBG_Trace_Etat, "CACHE / Fuite")
			if( Item_Prioritaire != Ci_Item_Prioritaire_CLE || ! Lapin_ITEM_Has_Key() )
				Lapin_EXPRESSION(Cf_Expr_Mouth_Full)
			break
		case Ci_CACHE_Mode_Progression :
			Lapin_DBG_Trace_String(DBG_Trace_Etat, "CACHE / Progression")
			break
		default:
			DBG_Error("???")
	}
	
	if( i_cache_type == Ci_cache_type_Geometrie )
		f_cache_temps_restant = 0.5
	else
		f_cache_temps_restant = MATH_RandFloat(2.0, 4.0)
	
	i_cache_reached_once = faux
	v_cache_wait_dir = Cv_NullVector		// calcul un fois planqué
	f_cache_not_safe_timer = 0.0
	f_cache_safe_timer = 0.0
	o_cache_not_safe = nobody
	v_cache_look_pos = @o_cache_actor OBJ_PosGet()		// backup de la pos à regarder
	i_cache_global_index = ARR_ObjSearch(&@get_list_manager ao_occluder[0], @get_list_manager i_occluder_nb, o_cache)
	i_cache_inside_occluder = faux		// jamais la 1ère trame de cet état
	i_path_way_force_recompute_flag = vrai
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI ===========================================================================
o_Grabbed_Actor = LNK_ServeurGet(Ci_LNK_GRAB_EAGLE, mid_Grabbed_LNK_ID, vrai, nofunc, nofunc)
if( o_Grabbed_Actor )
	macro_change_etat("Lapin_ETAT_GRABBED")

o_Rided_Actor = LNK_ServeurGet(Ci_LNK_RIDE_ON_NMI, mid_Rided_LNK_ID, vrai, nofunc, nofunc)
if( o_Rided_Actor )
	macro_change_etat("Lapin_ETAT_RIDED")

AI_Execute("Lapin_exec_check_vision")

AI_Execute("Lapin_exec_check_paf")
if( i_flag_paf || ! f_LIFE_cur ) // ! EVENT_LIFE_CurLifeGet(ID_LIFE) )
{
	if( i_cache_reached_once )
		o_cache_not_safe = o_cache			// si j'étais planqué alors cette planque est pourrie !!!
	if( i_flag_paf_stun )
		macro_change_etat("Lapin_ETAT_PAF_STUN")
	else
		macro_change_etat("Lapin_ETAT_PAF")
}

if( Lapin_ROPE_Gogo_Mode() )
	macro_change_etat("Lapin_ETAT_GOGO")

MACRO_CHECK_CHUTE

if( i_ventilo_flag )
	macro_change_etat("Lapin_ETAT_ASPIRE")

if( o_piege )
	macro_change_etat("Lapin_ETAT_PIEGE")

AI_Execute("Lapin_exec_update_best_interest")
if( ! MSG_GlobalIsValid(mid_best_interet) )
	MACRO_GO_IDLE(0)

if( ACT_ActionGet() != Action_Cache_SurpriseTest )
	if( ! f_cache_temps_restant )
		MACRO_GO_IDLE(0)

if( ! o_cache )
	MACRO_GO_IDLE(0)

if( ACT_ActionGet() != Action_Cache_SurpriseTest )
{
	ti_check_dodge = vrai
	if( i_cache_type == Ci_cache_type_Occluder )
	{
		ti_index = ARR_ObjSearch(&@get_list_manager ao_occluder[0], @get_list_manager i_occluder_nb, o_cache)
		if( ti_index == -1 )
		{
			//	goto CACHE_FUITE			// ma cache a été détruite !!!!
			ti_check_dodge = faux
			Lapin_ACTION_Set(Action_Cache_SurpriseTest)
			Lapin_GFX_GoutteSueur_Creation()
			Lapin_EXPRESSION(Cf_Expr_Mouth_Full)
			
			if( ! i_cache_reached_once )
			{
				// si ma cache a été détruite avant même que j'y arrive
				v_cache_look_pos = @o_cache_actor OBJ_PosGet()
				i_cache_reached_once = vrai
			}
		}
	}
	if( ti_check_dodge )
	{
		AI_Execute("Lapin_exec_check_grappin")
		AI_Execute("Lapin_exec_check_shoot")
	}
}

// anti_mashing ?
AI_Execute("Lapin_exec_check_anti_mashing")
if( i_anti_mashing_flag )
	MACRO_GO_IDLE(0)


// COMPORTEMENT ===================================================================

// suis-je caché ?
ti_occluderResult = faux
tv_nmi_pos = @o_cache_actor OBJ_PosGet()
if( ACT_ActionGet() == Action_Cache_SurpriseTest )
	ti_occluderResult = faux		// forcer le passage dans if( i_cache_reached_once )
else
{
	switch(i_cache_type)
	{
		case Ci_cache_type_Occluder :
//			if ( i_cache_inside_occluder )
//			{
//				ti_occluderResult = vrai
//				v_way_destpos = OBJ_PosGet()
//			}
//			else
			{
				v_way_destpos = Lapin_CACHE_Hide_Pos_Get(i_cache_global_index, o_cache, o_cache_actor)
				ti_occluderResult = WAY_LIB_Collide_Occluder(i_cache_global_index,
																				OBJ_PosGet(), 
																				tv_nmi_pos,
																				0.0,	// Lapin_MOVE_Offset_Get(),
																				tv_occluderNextPos)
			}
			v_cache_pos = v_way_destpos
			break
		case Ci_cache_type_Geometrie :
			v_way_destpos = v_cache_pos
			tv_temp3 = v_cache_pos - OBJ_PosGet()
			tv_temp3.z = 0.0
			if( MATH_VecSquareNorm(tv_temp3) < 1.0 )
			{
				ti_occluderResult = vrai
				if (i_path_way_to_main_wp_nb)
				{
					tv_occluderNextPos = v_path_way_to_main_next_pos
					tv_occluderNextPos.z = OBJ_PosGet().z + 1.5
				}
				else
				{
					tv_occluderNextPos = OBJ_PosGet() + (OBJ_SightGet() * 5.0)
				}
			}
			break
	}
}


if( ti_occluderResult )
{
	// c'est bon je suis caché
	DBG_RenderVector(v_look_head_pos, tv_occluderNextPos - v_look_head_pos, 0x84A5B8)
	tv_temp = v_way_destpos - OBJ_PosGet()
	tv_temp.z = 0.0
	DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp, color_cyan)
	// je ne suis pas occludé si je suis occludé de trop loin (je me rapproche)
	if( MATH_VecNorm(tv_temp) < (4.0 * Lapin_MOVE_Offset_Get()) )
	{
		if( ! i_cache_reached_once )
		{
			// ça y est je suis caché
			v_cache_look_pos = tv_occluderNextPos		// regarder 
			Lapin_SND_Cache()
			Lapin_EXPRESSION(Cf_Expr_Mouth_Closed)
		}
		i_cache_reached_once = vrai		// decr cache timer
		f_cache_safe_timer += TIME_GetDt()
	}
}
else if( i_cache_reached_once )
{
	// je ne suis plus caché donc mon enemi a bougé et veut me débusquer
	if( ACT_ActionGet() != Action_Cache_SurpriseTest )
	{
		// si je le vois je suis surpris
		if( Lapin_VISION_Test(@o_cache_actor OBJ_PosGet(), @o_cache_actor DYN_SpeedGet()) )
		{
			f_cache_not_safe_timer += TIME_GetDt()
			if( f_cache_not_safe_timer > 0.25 )
			{
				Lapin_ACTION_Set(Action_Cache_SurpriseTest)
				Lapin_GFX_GoutteSueur_Creation()
				Lapin_EXPRESSION(Cf_Expr_Mouth_Full)
			}
		}
	}
	else
	{
		// je suis en train d'être surpris
//		f_cache_not_safe_timer += TIME_GetDt()
//		if( f_cache_not_safe_timer > MATH_RandFloat(0.75, 1.25) )	// je n'étais plus poursuivi, délai surprise
		if( ACT_ActionFinished() )
		{
			if( Lapin_ITEM_Has_Weapon() )
			{
				// j'ai une arme 
				if( ! Lapin_ITEM_Is_Reloading() )		// tirer ou attendre reload
				{
					o_cache_not_safe = o_cache
					macro_change_etat("Lapin_ETAT_USE_ITEM")
				}
			}
			else
			{
				// je suis désarmé
				switch( i_cache_mode )
				{
					case Ci_CACHE_Mode_Fuite :
						// timer avant de fuir
//						CACHE_FUITE:
						if( ! @o_cache OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Links) )
						{
							// ce n'est pas un occluder réseau
							o_cache_not_safe = o_cache			// si j'étais planqué alors cette planque est pourrie !!!
						}
						o_cache = Lapin_CACHE_Fuite_Nearest_Get(i_my_territory_ID, o_cache_not_safe, o_cache_actor)
						if( o_cache )
						{
							goto REINIT		// il y a une autre cache safe dispo
						}
						else
						{
							Lapin_FUITE(o_cache_actor)
							MACRO_GO_IDLE(0)
						}
						break
					case Ci_CACHE_Mode_Progression :
						// je suis débusqué : ça va saigner !!!!
						MACRO_GO_IDLE(0)
						break
				}
			}
		}
	}
	// il arrive dans mon dos : il a bien joué :)
}

// si je suis (ou j'étais) caché ----------------------------
if( i_cache_reached_once )
{
	v_way_destpos = Cv_NullVector		// je ne bouge pas (backstab rules !)
	if( MATH_VecNullToler(v_cache_wait_dir, 0.01) )
	{
		if( i_cache_type == Ci_cache_type_Occluder )
		{
			tv_temp2 = WAY_LIB_Occluder_Position_Get(o_cache) - OBJ_PosGet()
			tv_temp2.z = 0.0
			v_cache_wait_dir = MATH_VecCrossProduct(Cv_VerticalVector, tv_temp2)
			if( MATH_VecDotProduct(OBJ_SightGet(), v_cache_wait_dir) > 0.0 )
			v_cache_wait_dir *= -1.0
		}
		else
		{
			v_cache_wait_dir = OBJ_SightGet()
		}
	}	
	v_force_sight = v_cache_wait_dir
//	v_force_sight = OBJ_PosGet() - WAY_LIB_Occluder_Position_Get(o_cache)
}

i_target_territory_ID = Lapin_PROC_GAO_GET_TERRITORY_ID(o_cache)
AI_Execute("Lapin_exec_way_find")

// sens de déplacement : ne pas passer devant mon nmi pour aller me cacher
v_force_move_occluder_sight = OBJ_PosGet() - @o_cache_actor OBJ_PosGet()
//if( ! MATH_VecNullToler(v_force_move_occluder_sight_last, 0.01) )
//{
//	// attention pour éviter de passer devant mon nmi je dois changer d'un coup de sens d'occluder ???
//	if( MATH_VecDotProduct(v_force_move_occluder_sight, v_force_move_occluder_sight_last) < 0.0 )
//		v_force_move_occluder_sight = Cv_NullVector
//}
AI_Execute("Lapin_exec_way_move")
v_force_move_occluder_sight = v_joy_sight		// backup pour test hystérésis next trame (cf au dessus)

// orientation
if( f_cache_not_safe_timer )		// je te vois
	v_force_sight = @o_cache_actor OBJ_PosGet() - OBJ_PosGet()
AI_Execute("Lapin_exec_way_orientation")


if( ACT_ActionGet() != Action_Cache_SurpriseTest )
	AI_Execute("Lapin_exec_way_select_action")

if( i_cache_reached_once )
	f_cache_temps_restant -= MATH_FloatMin(f_cache_temps_restant, TIME_GetDt())
else if( f_time_start_etat > ( 2.0 * f_cache_temps_restant ) )
	f_cache_temps_restant = 0.0		// pas encore caché et pourtant ça 2x plus de temps que je tourne : il me suis -> baston !!!


// Regard ----------------------------------------------------------
i_flag_look = vrai
if( i_path_way_to_main_wp_nb && o_cache_actor == o_main_actor )
{
	v_look_pos = v_path_way_to_main_next_pos
}
else if( f_cache_not_safe_timer )
{
	to_target = EVENT_InteretTargetGet(mid_best_interet)
	v_look_pos = @to_target OBJ_PosGet()
}
else
{
	v_look_pos = v_cache_look_pos
}

DBG_RenderVector(v_look_head_pos, v_look_pos - v_look_head_pos, color_rouge)


if( i_cache_mode == Ci_CACHE_Mode_Progression )
	OBJ_CapaSet(Obj_Capa_Fight, none)
