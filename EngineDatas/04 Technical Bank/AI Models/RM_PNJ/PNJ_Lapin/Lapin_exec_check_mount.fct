#include "PNJ_Lapin_defines.var"

message	tmsg_filter
messageid	tmid_ID
int				ti_rank
int				ti_type
object		to_monture
object		to_owner
vector		tv_pos
vector		tv_dir
float			tf_best_dist
float			tf_dist
//int				ti_path_voisin_nb
//object		tao_path_voisin[20]
int				ti_ok
int				ti_i
object		to_bv
float			tf_test


if( i_flag_monture_check_done )
	return
i_flag_monture_check_done = vrai

if( o_RideMount_Actor )
	return		// déjà une :)

if( f_RideMount_check_delai )
	return

if( f_RideMount_Jump_to_Get_Item )
	return

tf_best_dist = Cf_Infinit
o_RideMount_Nearest = nobody


// LISTER LES BV VOISINES POUR FAIRE DU TEST PIVOT/BV AU LIEU DE FAIRE DU A*
if( Territory_Path && o_path_current_wp )		// ne pas appeler la fct avec un gao vide
{
	i_path_voisin_wp_nb = 50		// taille
	PATH_LIB_Fill_Wp_Array(o_path_current_wp, 
										Territory_Path, 
										&ao_path_net_wp[0],				// LES WPS DU RESEAU
										i_path_net_wp_nb,					// LE NOMBRE DE POINTS DU RESEAU
										&ao_path_voisin_wp[0],
										i_path_voisin_wp_nb,
										3)
}
else
	i_path_voisin_wp_nb = 0


MSG_SetNull(tmsg_filter)
ti_rank = -1
for (	tmid_ID = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_RIDE_ON_NMI, &ti_rank, tmsg_filter);
		MSG_GlobalIsValid(tmid_ID);
		tmid_ID = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_RIDE_ON_NMI, &ti_rank, tmsg_filter) )
{
	to_monture = EVENT_PereGet(tmid_ID)
	to_owner = EVENT_Gao1Get(tmid_ID)
	
	if( to_owner )
		continue		// déjà ridé
	
	if( OBJ_SqrDist(to_monture) > 10000 )
		continue		// trop loin !
	
	if( Territory_BV && ! Lapin_Pos_in_Territory_BV(@to_monture OBJ_PosGet()) )
		continue		// pas sur mon territoire
	
	if( Lapin_PROC_GAO_GET_TERRITORY_ID(to_monture) != i_my_territory_ID )
		continue		// pas sur mon territoire
	
	// distance autour de l'objectif à protéger
	if( Att_Protect_Gao )
	{
		tf_test = Att_Protect_Gao_Dist + 5.0		// dist + offset pout récupérer les items
		tf_test *= tf_test
		if( @to_monture OBJ_SqrDist(Att_Protect_Gao) > tf_test )
			continue
	}
	
	tv_pos = @to_monture OBJ_PosGet()
	tv_dir = tv_pos - OBJ_PosGet()
	tf_dist = MATH_VecNorm(tv_dir)
	
	ti_type = Proc_CreatureTypeGet(to_monture)
	switch( ti_type )
	{
		case C_ID_Monture_Aigle :
			if( ! Monture_Aigle )
				continue
			break
		case C_ID_Monture_Araignee :
		case C_ID_Monture_Quadripode :
			if( ! Monture_Araignee )
				continue
			break
		case C_ID_Monture_Bat :
			if( ! Monture_Bat )
				continue
			break
		case C_ID_Monture_PoissonLumiere :
			if( ! Monture_PoissonLumiere )
				continue
			break
		case C_ID_Monture_Requin :
			if( ! Monture_Requin )
				continue
			break
		case C_ID_Monture_Rhino :
			if( ! Monture_Rhino )
				continue
			break
		case C_ID_Monture_Serpent :
			if( ! Monture_Serpent )
				continue
			break
		case C_ID_Monture_Tigre :
			if( ! Monture_Tigre )
				continue
			break
		case C_ID_Scooter :
			if( ! Monture_Scooter )
				continue
			break
		default:
			continue
			break
	}
	
	if( tf_dist < tf_best_dist )
	{
		// BEST
		ti_ok = vrai
		
		if( Territory_Path )
		{
			ti_ok = faux
			// TEST PIVOT/BV AU LIEU DU A* !!!! =)
			for( ti_i = 0; ti_i < i_path_voisin_wp_nb; ti_i++ )
			{
				to_bv = ao_path_voisin_wp[ti_i]
				if( @to_monture COL_Pivot_BVCollide(to_bv) )
				{
					ti_ok = vrai		// dans une BV voisine avec accès
					break
				}
			}
		}
		
		// BEST & ACCESSIBLE
		if( ti_ok )
		{
			tf_best_dist = tf_dist
			o_RideMount_Nearest = to_monture
			i_RideMount_Nearest_ID = ti_type
		}
	}
}


// DELAI NEW CHECK
if( i_frame_nb > 2 )
{
	f_RideMount_check_delai = 0.5
}

