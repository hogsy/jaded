#include "PNJ_Lapin_defines.var"

int			ti_i
int			ti_flag_ok
int			ti_interet_cpt
int			ti_target_item_checked

float		tf_test_dist
float		tf_dist
float		tf_dist2
float		tf_dot_product
float		tf_sqr_dist
float		tf_norm
float		tf_me_to_target_dist
float		tf_zmin
float		tf_zmax

vector	tv_temp
vector	tv_temp0
vector	tv_sight
vector	tv_pos
vector	tv_me_to_target

object	to_target
object	to_gao


if( Mode_Compagnon )
	return				// TEMP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// délai ???
switch( i_etat_courant )
{
	case ETAT_Lapin_GRAPPIN_CONTROL :
	case ETAT_Lapin_FUITE :
		break
	default:
		if( ! i_anti_mashing_flag && ! i_flag_jump_to_attack )		// délai ignoré pour ces actions spécifiques
		{
			if( f_melee_delai )
				return
		}
		break
}

if ( ! i_flag_in_my_territory )
	return

if (i_perceived_best_actor_index == -1)
	return

to_target = ao_perceived_actor[i_perceived_best_actor_index]
if( ! to_target )
	return

if( ! i_anti_mashing_flag )
{
	if( ! Lapin_Atk_Simultannees_IsValid(to_target, ti_interet_cpt) )
		return		// nb d'interet !!!!
}

ti_target_item_checked = faux

BEGIN:

if( ! ti_target_item_checked )
{
	to_gao = Lapin_Get_Target(to_target)
	if( to_gao == to_target )
		ti_target_item_checked = vrai		// rayman en traine pas de mine, je considère que j'ai checké la mine
}
else
	to_gao = to_target

tf_sqr_dist = Lapin_Fight_Melee_Dist_Get()
tf_sqr_dist *= tf_sqr_dist
tf_sqr_dist = MATH_FloatMax(tf_sqr_dist, 1.0)		// pour les ptits lapins

to_gao = Lapin_Get_Target(to_target)
//if( @to_gao COL_ColSetActivationGet() & C_bit_zde_corps )
//	tv_temp0 = @to_gao COL_ZonePosGet(C_zde_corps) + ( @to_gao COL_ZoneSizeGet(C_zde_corps) * cvector(0,0,-1) )
if( @to_gao AI_IsModel(get_RM_Prune_path) )
	tv_temp0 = @to_gao OBJ_PosGet() + cvector(0,0,-2.0)
else
	tv_temp0 = @to_gao OBJ_PosGet()
tv_temp0 -= OBJ_PosGet()
//DBG_RenderVector(OBJ_PosGet(), tv_temp0, color_jaune)

if( i_flag_jump_to_attack )
{
	tf_zmin = -1.0
	tf_zmax = 0.0
}
else
{
	tf_zmin = -2.0
	tf_zmax = 2.5
}

ti_flag_ok = faux

//if( MATH_VecDotProduct(OBJ_SightGet(), tv_temp0) > 0.0 	// TEST SIGHT
if( tv_temp0.z > (tf_zmin * OBJ_ZoomGet()) 					//  TEST Z
	&& tv_temp0.z < (tf_zmax * OBJ_ZoomGet()) )					//  TEST Z
{
	ti_flag_ok = faux
	if( i_anti_mashing_flag )
		ti_flag_ok = vrai
	else if( i_flag_jump_to_attack )
		ti_flag_ok = vrai
	else if( i_etat_courant == ETAT_Lapin_GRAPPIN_CONTROL )
		ti_flag_ok = vrai
	else if( to_target != o_main_actor )
		ti_flag_ok = vrai
	else if( @get_Rayman_Path o_main_actor i_ground_flag )
		ti_flag_ok = vrai
	else if( @get_Rayman_Path o_main_actor i_is_in_water )
		ti_flag_ok = vrai
	if( ti_flag_ok )
	{
		ti_flag_ok = faux		// flag go in melee
		
		// pas rayman ou pas besoin de checker qu'il n'est pas accroché ou rayman pas accroché
		tv_temp = @to_gao OBJ_PosGet()
		tv_temp -= OBJ_PosGet()
		tv_temp.z = 0.0
		
		tf_dist = MATH_VecDotProduct(tv_temp, tv_temp)
		if( tf_dist < tf_sqr_dist )
		{
			if( to_gao != to_target )
				ti_flag_ok = vrai		// je ne frappe pas rayman mais sa bombox
			else 
			{
				tf_dist = MATH_FloatSqrt(tf_dist)
				tv_temp /= tf_dist	
		//		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_temp, color_rouge)
		//		DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_look_virtual_sight, color_vert)
				if( MATH_VecDotProduct(tv_temp, v_look_virtual_sight) > Cf_Cos60 )
					ti_flag_ok = vrai
			}
		}
	}
}

// MUR ENTRE MOI ET MA CIBLE ?
if (ti_flag_ok)
{
	if( Lapin_Target_Reachable(to_target) )
	{
		if( i_etat_courant == ETAT_Lapin_GRAPPIN_CONTROL )
			i_Grappin_Control_attack_flag = vrai
		if( i_anti_mashing_flag )
			i_anti_mashing_attack_flag = vrai
		if( to_gao != to_target )
			i_Atk_Activate_Explosive_Box_flag = vrai		// frapper la bombox !!!
		macro_change_etat("Lapin_ETAT_MELEE")
	}
}	
else
{
	if( ! ti_target_item_checked )
	{
		ti_target_item_checked = vrai
		goto BEGIN
	}
}

