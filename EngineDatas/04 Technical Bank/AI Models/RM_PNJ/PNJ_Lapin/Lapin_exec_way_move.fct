#include "PNJ_Lapin_defines.var"

#define	Cf_rayon_requin_declenchement		5.0
#define	Cf_rayon_requin_detect_copains		12.0


//	PARAMETRES D'ENTREE =============================================
//	
//	v_next_pos
//
message	tmsg_filter
messageid	tmid_interet

int			ti_report
int			ti_force_full_move
int			ti_target_fight_actor_nb
int			ti_rank
int			ti_requin_mode
int			ti_territory

vector	tv_Y
vector	tv_way_sight 
vector	tv_depl
vector	tv_traction_joy
vector	tv_sight
vector	tv_dest_pos
vector	tv_dest_pos_new
vector	tv_pos
vector	tv_temp
vector	tv_main_actor_pos
vector	tv_wall_normale
vector	tv_temp1
vector	tv_temp2
vector	tv_requin
vector	tv_3d_next_pos

float		tf_dot1
float		tf_dot2
float		tf_dist
float		tf_dist_move
float		tf_dist_max
float		tf_dist_ok
float		tf_joy_norm
float		tf_occluder_size
float		tf_occluder_dist
float		tf_jump_hauteur
float		taf_occluder_size[100]
float		tf_z_max

object	to_cache
object	to_target
object	to_occluder
object	to_main_actor
object	to_wp
object	to_gao
object	to_obj

i_v_joy_sight_computed = vrai


// JOY MOVE =======================================================
if( o_Rided_Actor )
{
	f_joy_norm = glob_joynorm_get
	if( MATH_FloatNullEpsilon(f_joy_norm) )
	{
		// à l'arrêt
		i_way_moving = faux
		v_joy_sight = OBJ_SightGet()
		
		// boost = avancer
		if( Proc_JOY_Boost_Pressed() )
		{
			f_joy_norm = 1.0
			i_way_moving = vrai
			v_joy_sight = OBJ_SightGet()
		}		
	}
	else
	{
		// joy
		i_way_moving = vrai
		v_joy_sight = glob_joyvector_get
	}
}
else if( DBG_Use_Joy )
{
	f_joy_norm = glob_joynorm_get
	if( MATH_FloatNullEpsilon(f_joy_norm) )
	{
		i_way_moving = faux
		v_joy_sight = OBJ_SightGet()
	}
	else
	{
		i_way_moving = vrai
		v_joy_sight = glob_joyvector_get
	}
}
// AI MOVE =======================================================
else
{
	// OCCLUDERS TEST
	DBG_StartRaster(0,"Lapin Occluder Test")
	tv_3d_next_pos = v_next_pos
	if( ! MATH_VecNullEpsilon(v_next_pos) )
	{
		i_way_moving = vrai
		tv_Y = Lapin_Compute_Deplacement(v_next_pos, 4.0, 64.0, vrai, ti_report, to_cache)		// 4.0, 64.0
		
		if( o_cache_just_leave && f_dest_pos_is_main_duree > 0.1)
		{
			if (ti_report & (Ci_OCCLUDER_COLLISION | Ci_OCCLUDER_START_POS_IS_IN_OCCLUDER) )	
			{
				if (@get_global WAY_LIB_used_occluder_index == -1 || @get_list_manager ao_occluder[@get_global WAY_LIB_used_occluder_index] != o_cache_just_leave)
					o_cache_just_leave = nobody
			}
			else
			{
				o_cache_just_leave = nobody
			}
		}
		if( i_cache_type == Ci_cache_type_Geometrie )
			o_cache_just_leave = nobody
		
		if( ti_report & Ci_OCCLUDER_DEST_POS_IS_IN_OCCLUDER) 
			tv_Y = v_next_pos
		
//		if( (ti_report & Ci_OCCLUDER_DEST_POS_IS_IN_OCCLUDER) 
//			&& ! (ti_report & Ci_OCCLUDER_COLLISION) )
//		{
//			// ma cible est dans un occluder, et il n'y a pas d'autre occluder qui gène
//			tv_pos = VIEW_3dWorldTo2d(0, OBJ_PosGet())
//			tv_pos += cvector(-0.05,0.1,0)
//			if( v_next_pos == @o_main_actor OBJ_PosGet() )
//			{
//				if( @get_global WAY_LIB_Main_Actor_Occluder_index == -1 )
//				{
//					tv_dest_pos = @o_main_actor OBJ_PosGet()
//					ti_territory = Lapin_PROC_POS_GET_TERRITORY_ID(tv_dest_pos)
//					if( WAY_LIB_Test_Pos_In_Occluder(tv_dest_pos, @o_main_actor OBJ_SightGet(), 1.0, ti_territory, tv_dest_pos_new, &ao_Territory_BV_Occluders[0], &taf_occluder_size[0], i_Territory_BV_Occluders_nb, 0) )
//						@get_global WAY_LIB_Main_Actor_Occluder_index = @get_global WAY_LIB_used_occluder_index
//				}
//				if( @get_global WAY_LIB_Main_Actor_Occluder_index > -1 )
//					to_occluder = @get_list_manager ao_occluder[@get_global WAY_LIB_Main_Actor_Occluder_index]
//				else
//					to_occluder = nobody
////				Str_DisplayGaoOnce(to_occluder, tv_pos)
//				tv_pos += cvector(0,0.05,0)
//				if( to_occluder )
//				{
//					tv_temp = @to_occluder OBJ_PosGet() - OBJ_PosGet()
//					tv_temp.z = 0.0
//					tf_occluder_dist = MATH_FloatSqrt(MATH_VecDotProduct(tv_temp, tv_temp))
//					tf_occluder_size = WAY_LIB_Occluder_Size_Get(to_occluder)
//					if( tf_occluder_dist < (tf_occluder_size + 2.0)) //Lapin_MOVE_Offset_Get()))
//					{
//						i_way_moving = faux
//						tv_Y = Cv_NullVector
//						ti_report = 0
//						i_way_dont_move_dest_in_occluder = vrai		// pour l'orientation
//					}
//					tv_pos += cvector(0,0.05,0)
//				}
//			}
//		}
	}
	else
	{
		i_way_moving = faux
		tv_Y = Cv_NullVector
		ti_report = 0
	}
	DBG_StopRaster(0)
	
	// JOY NORM
	tv_Y.z = 0.0
	tv_way_sight = tv_Y
	if( MATH_VecNullToler(tv_way_sight, 0.01) )
	{
		v_joy_sight = OBJ_SightGet()
		tf_joy_norm = 0.0
	}
	else
	{
		v_joy_sight = MATH_VecNormalize(tv_way_sight)
		
		// GLISSER SUR LES MURS si je vais vers le main actor
//		if( COL_CollideType(COL_C_Wall) 
//		&& Territory_Path && i_path_way_to_main_wp_nb && MATH_VecNullToler(v_next_pos - v_path_way_to_main_next_pos, 0.05) )
//		{
//			tv_wall_normale = COL_NormalGet(COL_C_Wall)
//			tv_wall_normale.z = 0.0
//			tv_wall_normale = MATH_VecCrossProduct(tv_wall_normale, Cv_VerticalVector)
//			if( i_path_way_to_main_wp_nb > 1 )
//				to_wp = ao_path_way_to_main_wp[1]		// le prochain
//			else
//				to_wp = ao_path_way_to_main_wp[0]		// l'actuel
//			tv_temp = @to_wp OBJ_PosGet() - OBJ_PosGet()
//			tv_temp.z = 0.0
//			if( MATH_VecDotProduct(tv_wall_normale, tv_temp) < 0.0 )
//				tv_wall_normale *= -1.0
//			v_joy_sight = tv_wall_normale
//			v_joy_sight = MATH_VecBlendRotate(v_joy_sight, COL_NormalGet(COL_C_Wall), 0.1)	// rester collé au mur
//			DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, v_joy_sight * 10, 0xCCCCCC)
//		}
//		else
//			v_joy_sight = v_joy_sight
		
		// Distance a l'objectif
		if( MSG_GlobalIsValid(mid_best_interet) )
			to_target = EVENT_InteretTargetGet(mid_best_interet)
		else
			to_target = nobody
		
		// calcul en 2D pour le choix de la vitesse et de l'anim (attendre si dessous ou dessus et pas courrir)
		v_way_destpos.z = OBJ_PosGet().z
		
		tv_depl = v_way_destpos - OBJ_PosGet()
		tf_dist = MATH_VecNorm(tv_depl)
		tf_dist_max = 5.0
		tf_dist = MATH_FloatMin(tf_dist, tf_dist_max)
		
		ti_force_full_move = faux
		if( i_action_traction_force_faster )
			tf_dist_ok = 0.0		// ne pas s'arrêter
		else if( i_is_in_water )
			tf_dist_ok = 0.0		// forcer à aller jusqu'au point comme ça si c'est un rebord il sautera
		else
		{
			switch( i_etat_courant )
			{
				case ETAT_Lapin_BULLRUSH :
				case ETAT_Lapin_COUNTER :
					ti_force_full_move = vrai
					break
				case ETAT_Lapin_CACHE :
				case ETAT_Lapin_FUITE :
					tf_dist_ok = Lapin_Cache_Dist_Get()
					break
				case ETAT_Lapin_GET_ITEM :
					tf_dist_ok = Lapin_Get_Item_Dist_Get()
					break
				case ETAT_Lapin_GET_MOUNT :
					tf_dist_ok = 1.0	// s'avancer au max et puis on jumpe !!! 5.0
					break
				case ETAT_Lapin_ATTENTE :
					if( Att_Mode == Att_Mode_AnimWP )
						ti_force_full_move = vrai
					else
						tf_dist_ok = Lapin_Attente_Dist_Get()
					break
				default:
					if( to_target )
						tf_dist_ok = Lapin_Fight_Melee_Dist_Get()
					else
						tf_dist_ok = Lapin_Attente_Dist_Get()
					break
			}
		}
		
		if( i_action_traction_force_faster )
			tf_joy_norm = 1.0
		else if( ti_force_full_move )
			tf_joy_norm = 1.0
		else if( ti_report & Ci_OCCLUDER_COLLISION )
			tf_joy_norm = 1.0
		else if( tf_dist < tf_dist_ok )
			tf_joy_norm = 0.0
		else
			tf_joy_norm = tf_dist / tf_dist_max
	}
	f_joy_norm = MATH_FloatBlend(f_joy_norm, tf_joy_norm, 10 * TIME_GetDt())
}



// DUREE DEPLACEMENT VERS MAIN ACTOR (pour être sûr d'avoir fait le test d'occluder) =======================================
tv_temp = @o_main_actor OBJ_PosGet()
tv_temp -= v_next_pos
tv_temp.z = 0.0
if( MATH_VecSquareNorm(tv_temp) < 0.01)
	f_dest_pos_is_main_duree += TIME_GetDt()
else
	f_dest_pos_is_main_duree = 0.0



// JUMP OU TAUPE SI COLLISION MUR ??? =============================================================================
switch( Type )
{
	case Lapin_Type_Petit :
		tf_jump_hauteur = 5.0
		break
	case Lapin_Type_Moyen :
		tf_jump_hauteur = 5.0
		break
	case Lapin_Type_Geant :
		tf_jump_hauteur = 10.0
		break
	default:
		DBG_Error("???")
}
switch( i_etat_courant )
{
	case ETAT_Lapin_FIGHT :
	case ETAT_Lapin_FUITE :
	case ETAT_Lapin_CACHE :
	case ETAT_Lapin_GET_ITEM :
	case ETAT_Lapin_GET_MOUNT :
		if( ! f_jump_to_keep_moving )
		{
			if( f_wall_col_duration > 0.1 )
			{
				tv_temp = tv_3d_next_pos - OBJ_PosGet()
				if( tv_temp.z >= -1.0 )
				{
					if( Depl_Jump && i_depl_jump_cpt < 3 )
					{
						tv_temp = COL_TipTopPointGet(Cv_VerticalVector, // Direction du "rayon"
																	0.5, 	// Longueur mini par rapport au bord de l'edge (inactif en dehors du vecteur direction vertical) 
																	faux, 	// FALSE = On avance en direction du rayon; TRUE = On avance dans la direction inverse 
																	faux, 	// Utilise t'on les données du dernier lancer de rayon comme point de départ ou le résultat des dernieres collisions MUR (si la direction demandée est verticale ou derniere collision SOL sinon
																	faux, // S'arrete t'on quand on change d'element ? 
																	vrai)	// S'arrete t'on quand on change de type de face (Sol/Mur) ou (Mur/Sol)
						if( ! MATH_VecNullToler(tv_temp, 0.5) )
						{
							DBG_RenderVector(OBJ_PosGet(), tv_temp - OBJ_PosGet(), color_bleu)
							
							v_jump_dest_pos = tv_temp + ( 3.0 * OBJ_SightGet() )
							tv_temp -= OBJ_PosGet()
							tf_jump_hauteur = MATH_FloatLimit(0.0, tv_temp.z, tf_jump_hauteur)
							
							DBG_RenderVector(v_jump_dest_pos + cvector(0,0,10), cvector(0,0,-20), color_cyan)
							to_obj = COL_RayObject_Dist(v_jump_dest_pos + cvector(0,0,10), - Cv_VerticalVector, 20.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
							if( to_obj )
								v_jump_dest_pos = COL_RayObject_PosGet()
							i_flag_jump_to_keep_moving = vrai
							i_depl_jump_cpt++
							v_jump_to_keep_moving_initpos = OBJ_PosGet()
							DBG_RenderVector(OBJ_PosGet(), v_jump_dest_pos - OBJ_PosGet(), color_jaune)
							macro_change_etat("Lapin_ETAT_JUMP")
						}
					}
					else if( Depl_Taupe && ! i_is_in_water )
					{
						i_taupe_to_keep_moving_flag = vrai
						v_taupe_to_keep_moving_pos = tv_3d_next_pos
//						DBG_RenderVector(v_taupe_to_keep_moving_pos + cvector(0,0,4), cvector(0,0,-8), color_vert)
						if( COL_RayIsCut_Dist(v_taupe_to_keep_moving_pos + cvector(0,0,4), cvector(0,0,-8), 8.0 , all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable) )
							macro_change_etat("Lapin_ETAT_TAUPE")
						else
							f_jump_to_keep_moving = 0.5		// no lray next trame
					}
				}
			}
		}
		break
	default:	
		i_depl_jump_cpt = 0
		break
}


// JUMP TO ATTACK ??? =======================================================================================
if( i_etat_courant == ETAT_Lapin_FIGHT 
&& Depl_Jump 
&& ! f_melee_delai 
&& ! f_jump_to_attack 
&& ! o_RideMount_Actor )
{
	to_target = EVENT_InteretTargetGet(mid_best_interet)
	if( OBJ_SqrDistHorz(to_target) < 25.0 )
	{
		tv_temp = @to_target OBJ_PosGet() - OBJ_PosGet()
		tf_z_max = 5.0
		if( @to_target AI_IsModel(get_RM_Prune_path) )
			tf_z_max = 10.0
		if( tv_temp.z > (1.0 * OBJ_ZoomGet()) && tv_temp.z < tf_z_max )
		{
			// si je suis sous ma cible
			if( to_target == o_main_actor || ! @to_target COL_CollideType(COL_C_Ground) )
			{
				// si ma cible n'est pas au sol
				v_jump_dest_pos = @to_target OBJ_PosGet()
				i_flag_jump_to_attack = vrai
				f_jump_to_attack = MATH_RandFloat(2.0, 4.0)
				macro_change_etat("Lapin_ETAT_JUMP")
			}
		}
	}
}


// TRACTION ==================================================================================================
if( i_way_moving && ! MATH_FloatNullToler(f_joy_norm, 0.01) )
{
	tv_traction_joy = MATH_VecCrossProduct(v_joy_sight , v_ground_normale)
	tv_traction_joy = MATH_VecCrossProduct(v_ground_normale, tv_traction_joy)
	tv_traction_joy *= f_joy_norm

	// REQUIN ? ================================================================================================
	if( MSG_GlobalIsValid(mid_best_interet) )
		to_target = EVENT_InteretTargetGet(mid_best_interet)
	else
		to_target = nobody
	
	ti_target_fight_actor_nb = 0
	ti_requin_mode = faux
//	if( to_target && to_target == o_main_actor && @get_rayman o_fight_actor == OBJ_Me() )
//		to_target = nobody			// pas si rayman me regarde
	if( to_target )
	{
		// si je ne suis pas configuré en requin, je teste des autres lapins pour passer quand même en requin
		ti_rank = -1
		MSG_SetNull(tmsg_filter)
		tmsg_filter.msg_gao1 = to_target
//		tmsg_filter.msg_int2 = C_EVENT_InteretStatusLock
		tmsg_filter.msg_int3 = i_Perso_ID
		tmid_interet = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
		while (MSG_GlobalIsValid(tmid_interet))
		{
			to_gao = EVENT_PereGet(tmid_interet)
			if( to_gao != OBJ_Me() && @to_target OBJ_SqrDistHorz(to_gao) < (Cf_rayon_requin_declenchement * Cf_rayon_requin_declenchement) && @to_target OBJ_SqrDistHorz(to_gao) < (Cf_rayon_requin_declenchement * Cf_rayon_requin_declenchement) )
			{
				if( @to_gao AI_IsModel(get_PNJ_Lapin_path) )
				{
					switch( @to_gao Proc_PNJ_Lapin_ETAT_Courant_Get() )
					{
						case ETAT_Lapin_FIGHT :
						case ETAT_Lapin_MELEE :
						case ETAT_Lapin_PAF :
						case ETAT_Lapin_PAF_STUN :
							ti_target_fight_actor_nb++
							ti_requin_mode = vrai
							break
						case ETAT_Lapin_JUMP :
							if( @get_PNJ_Lapin_path to_gao i_flag_jump_to_attack || @get_PNJ_Lapin_path to_gao i_flag_jump_in_back )
							{
								ti_target_fight_actor_nb++
								ti_requin_mode = vrai
							}
							break
						default:
							break
					}
				}
			}
			tmid_interet = MSG_GlobalSearchIntGao(C_EVENT_TYPE_Interet, &ti_rank, tmsg_filter)
		}
	}
	// durée max de requin
	if( f_Atk_Encerclement_duree > 15.0 )
	{
		f_Atk_Encerclement_duree = 0.0
		f_Atk_Encerclement_forbidden = MATH_RandFloat(5.0, 10.0)
	}
	// requin !!!!
	if( ti_requin_mode && f_wall_col_duration < 0.5 )		// si je suis pas collé dans le mur à cause du requin
	{
		tv_sight = tv_traction_joy
		switch( i_etat_courant )
		{
			case ETAT_Lapin_FIGHT :
				tv_temp1 = OBJ_PosGet() - v_way_destpos
				tv_temp1.z = 0.0
				tf_dist_move = MATH_VecNorm(tv_temp1)
				MATH_VecSetNormalize(tv_temp1)
				DBG_RenderVector(v_way_destpos + cvector(0,0,2), tv_temp1 * 10, color_bleu)
				tv_temp2 = @to_target OBJ_SightGet()
				tv_temp2.z = 0.0
				MATH_VecSetNormalize(tv_temp2)
				DBG_RenderVector(OBJ_PosGet() + cvector(0,0,2), tv_temp2 * 10, color_jaune)
				tf_dot1 = MATH_VecDotProduct(tv_temp1, tv_temp2)
				
				// need requin ???
				if( tf_dot1 > - Cf_Cos45 && tf_dist_move <= Cf_rayon_requin_declenchement )
					f_Atk_Encerclement_coef += MATH_FloatMin(1.0 - f_Atk_Encerclement_coef, 2.0 * TIME_GetDt())
				else
					f_Atk_Encerclement_coef -= MATH_FloatMin(f_Atk_Encerclement_coef, 3.0 * TIME_GetDt())
				
				if( f_Atk_Encerclement_coef )
				{
					// côté de requin
					if( ! f_Atk_Encerclement_sign_countdown )
					{
						f_Atk_Encerclement_sign_countdown = MATH_RandFloat(6.0, 12.0)
						f_Atk_Encerclement_sign = 0.0
					}
					if( f_Atk_Encerclement_sign == 0.0 )
					{
						f_Atk_Encerclement_sign = @get_global f_Lapin_Encerclement_last_sign * -1.0
						@get_global f_Lapin_Encerclement_last_sign = f_Atk_Encerclement_sign
					}
					
					f_Atk_Encerclement_duree += TIME_GetDt()
					
					tv_requin = f_Atk_Encerclement_sign * MATH_VecCrossProduct(Cv_VerticalVector, tv_sight)
//					DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_requin, color_rouge)
//					if( tf_dist_move < 3.0 )
					tv_requin = MATH_VecRotate(tv_requin, Cv_VerticalVector, -0.2)
					DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_requin * 5, color_rouge)
					
//					tf_dot1 = MATH_FloatMax(tf_dot1, 0.0) + 0.5
//					tf_dot1 *= f_Atk_Encerclement_coef
//					tv_sight = MATH_VecBlendRotate(tv_sight, tv_requin, f_Atk_Encerclement_coef * tf_dot1)
					
					tv_sight = MATH_VecBlendRotate(tv_sight, tv_requin, f_Atk_Encerclement_coef)
					DBG_RenderVector(OBJ_PosGet() + Cv_VerticalVector, tv_sight * 10, color_rouge)
					tv_traction_joy = tv_sight
					v_joy_sight = tv_sight
				}
				else
					f_Atk_Encerclement_sign = 0.0
				break
	
			default:
				f_Atk_Encerclement_sign = 0.0
				f_Atk_Encerclement_coef = 0.0
				break
		}
	}
	
	// TRACTION
	f_traction_courante = MATH_FloatBlend(f_traction_courante, Lapin_Traction_Walk_Get(), 2.5 * TIME_GetDt())
	tv_traction_joy *= f_traction_courante
	
	// INFLUENCE DE LA PENTE
	if ( MATH_VecDotProduct( OBJ_BankingGet(), v_ground_normale) > Cf_Cos5)
		tv_traction_joy = tv_traction_joy 
	else if ( MATH_VecDotProduct( OBJ_SightGet(), v_ground_normale) > 0.0)
		tv_traction_joy *= ( 2 - (v_ground_normale.z * 0.8)) // ANGLE A 45° : = 1.3
	
	v_traction_joy = tv_traction_joy
}
else
{
	f_joy_norm = 0.0
	i_way_moving = faux
	v_traction_joy = Cv_NullVector
}

