#include "PNJ_Lapin_defines.var"

message	tmsg_filter
messageid	tmid_ID
int				ti_rank
int				ti_i
object		to_item
object		to_owner
object		to_bv
vector		tv_pos
vector		tv_dir
float			tf_dist
float			tf_best_dist
int				ti_type
object		to_path_current_wp
object		to_path_dest_wp
vector		tv_next_pos
int				ti_path_way_wp_nb
object		tao_path_way_wp[50]
int				ti_ok
int				ti_client_ID
float			tf_test


if( ! Item_Lums_Cage_enabled )
	return
	
if( i_flag_lums_cage_check_done )
	return
	
i_flag_lums_cage_check_done = vrai

if( f_lums_cage_find_delai )
	return

o_item_nearest = nobody

// LISTER LES BV VOISINES POUR FAIRE DU TEST PIVOT/BV AU LIEU DE FAIRE DU A*
if( Territory_Path && o_path_current_wp )		// ne pas appeler la fct avec un gao vide
{
	i_path_voisin_wp_nb = 50		// taille
	PATH_LIB_Fill_Wp_Array(o_path_current_wp, 
										Territory_Path, 
										&ao_path_net_wp[0],				// LES WPS DU RESEAU
										i_path_net_wp_nb,					// LE NOMBRE DE POINTS DU RESEAU
										&ao_path_voisin_wp[0],
										i_path_voisin_wp_nb,
										3)
}
else
	i_path_voisin_wp_nb = 0

tf_best_dist = Cf_Infinit
MSG_SetNull(tmsg_filter)
ti_rank = -1
for (	tmid_ID = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_GRAB_OBJECT, &ti_rank, tmsg_filter);
		MSG_GlobalIsValid(tmid_ID);
		tmid_ID = MSG_GlobalSearchIntGao(Ci_LNK_EVENT_OFFSET + Ci_LNK_GRAB_OBJECT, &ti_rank, tmsg_filter) )
{
	to_item = EVENT_PereGet(tmid_ID)
	to_owner = EVENT_Gao1Get(tmid_ID)
	
	if( to_owner )
		continue		// déjà grabbée :(:(:(
	
	if( o_item_to_get && to_item != o_item_to_get )
		continue		// c'est pas l'item vers lequel je cours donc je l'ignore !!!
	
	if( OBJ_SqrDist(to_item) > 10000 )
		continue		// trop loin !
	
	if( ! @to_item AI_IsModel(get_RM_Lums_Cage_path) )
		continue
	
	tv_pos = @to_item OBJ_PosGet()
	tv_dir = tv_pos - OBJ_PosGet()
	tf_dist = MATH_VecNorm(tv_dir)
	
	if( tf_dist < tf_best_dist )
	{
		// BEST
		ti_ok = vrai
		
		if( Territory_Path )
		{
			ti_ok = faux
			
			// TEST PIVOT/BV AU LIEU DU A* !!!! =)
			for( ti_i = 0; ti_i < i_path_voisin_wp_nb; ti_i++ )
			{
				to_bv = ao_path_voisin_wp[ti_i]
				if( @to_item COL_Pivot_BVCollide(to_bv) )
				{
					ti_ok = vrai		// dans une BV voisine avec accès
					break
				}
			}
		}
		
		// BEST & ACCESSIBLE
		if( ti_ok )
		{
			tf_best_dist = tf_dist
			o_item_nearest = to_item
			i_item_to_get_ID = -1		// LUMS CAGE !!!!
		}
	}
}

o_item_nearest = o_item_nearest
o_item_to_get = nobody

// DELAI NEW CHECK
if( i_frame_nb > 2 )
{
	f_lums_cage_find_delai = 0.5
}

