#include "PNJ_mr_defines.var"

procedure_ultra float PNJ_MiniRobot_SpeedGet();
procedure_ultra int Proc_PNJ_MiniRobot_EstDispo();
procedure_ultra void Proc_PNJ_MiniRobot_Link(object po_chef,int pi_NbLink);
procedure_ultra void Proc_PNJ_MiniRobot_Unlink();
procedure_ultra void Proc_PNJ_MiniRobot_Glow();
procedure_ultra vector PNJ_MR_PosGetEclair();

procedure_local vector PNJ_MR_BestSpeedTarget(vector pv_Speed)
{
	vector	tv_BestSpeed
	int			ti_i
	object	to_Target 
	float		tf_BestAngle
	object	to_BestTarget 
	float		tf_Dot
	vector	tv_Speed
	float		tf_Speed
	float		tf_Dist

	tf_BestAngle = Cf_Cos20
	tf_Speed = MATH_VecNorm(pv_Speed)
	pv_Speed /= tf_Speed
	tv_BestSpeed = pv_Speed
	
	for ( ti_i = 0; ti_i < @get_list_manager i_target_nb; ti_i++)
	{
		to_Target = @get_list_manager ao_target[ti_i]
		if(to_Target!=OBJ_Me())
		{
			tv_Speed=@to_Target OBJ_PosGet() - OBJ_PosGet()
			tf_Dist=MATH_VecNorm(tv_Speed)
			if(tf_Dist<20.0)
			{
				tv_Speed/=tf_Dist
				tf_Dot=MATH_VecDotProduct(pv_Speed,tv_Speed)
				if(tf_Dot>tf_BestAngle)
				{
					tv_BestSpeed=tv_Speed
					tf_BestAngle=tf_Dot
				}
			}
		}
	}
	tv_BestSpeed *= tf_Speed
	return tv_BestSpeed
}

procedure_local vector PNJ_MR_PosGetOeil()
{
	if(i_Grappinable)
		return OBJ_PosGet()+(OBJ_SightGet()*OBJ_ZoomGet()*0.6)+(OBJ_BankingGet()*OBJ_ZoomGet()*0.9)
	else
		return OBJ_PosGet()+(OBJ_SightGet()*OBJ_ZoomGet()*0.6)+(OBJ_BankingGet()*OBJ_ZoomGet()*1.4)
}

procedure_local vector PNJ_MR_Soft_Col()
{
	int		ti_i
	
	float		tf_dist
	float		tf_test_dist
	float		tf_test_sqr_dist

	vector	tv_me_to_budy
	vector	tv_col_move_axis
	vector	tv_traction_softcol
	
	tv_traction_softcol = Cv_NullVector
	
	tv_col_move_axis = Cv_NullVector
	
	for (ti_i = 0; ti_i < i_budy_nb; ti_i++)
	{
			
		tf_test_dist = 0.9 * OBJ_ZoomGet()
		tf_test_dist += 0.9 * @ao_budy[ti_i] OBJ_ZoomGet()
		tf_test_sqr_dist = tf_test_dist * tf_test_dist
	
		tv_me_to_budy = @ao_budy[ti_i] OBJ_PosGet() - OBJ_PosGet()
		tv_me_to_budy.z = 0.0
		
		tf_dist = MATH_VecDotProduct(tv_me_to_budy, tv_me_to_budy) 

		if (tf_dist < tf_test_sqr_dist) // && OBJ_LIB_Virtual_Colmap_Collision(OBJ_Me(), ao_budy[ti_i], vrai) )
		{
			tf_dist = MATH_FloatSqrt(tf_dist)

			if (tf_dist)
				tv_me_to_budy /= tf_dist
			else
				tv_me_to_budy = OBJ_HorizonGet()

			tv_me_to_budy *= 1.0 - (tf_dist / tf_test_dist)
			
			tv_col_move_axis -= tv_me_to_budy
		}
	}
	
	tv_col_move_axis -= MATH_FloatMin(MATH_VecDotProduct(tv_col_move_axis, OBJ_SightGet()), 0.0) * OBJ_SightGet()
	tv_col_move_axis *= 40.0 // * DYN_FrictionGet()
//	tv_col_move_axis += DYN_TractionVectorGet()
 	tv_traction_softcol = tv_col_move_axis
 	return tv_traction_softcol
}

procedure_local object ROBOT_ROPE_Get_Gao(byref vector tv_pos_A, byref vector tv_pos_B, byref int ti_flag_tension)
{
	object	to_gao	

	float		tf_sqr_rope_length
	float 		tf_rope_length
	float 		tf_rope_ratio

	vector	tv_offset_A
	vector	tv_offset_B
	vector	tv_rope_AB

	ti_flag_tension = faux

	to_gao = @o_rope_manager Rope_Manager_Get_Linked_Gao(OBJ_Me(), tf_rope_length, tf_rope_ratio, tv_offset_A, tv_offset_B)
	if (to_gao)
	{
		if (tf_rope_ratio <  1.0)
		{
			tv_pos_A = OBJ_PosGet() + MATH_VecLocalToGlobal(tv_offset_A)
			tv_pos_B = @to_gao OBJ_PosGet() + @to_gao MATH_VecLocalToGlobal(tv_offset_B)
		
//			DBG_RenderVector(tv_rope_pos, -tv_rope_AB, color_cyan)	
	
			tf_sqr_rope_length = tf_rope_length * 0.7
			tf_sqr_rope_length *= tf_sqr_rope_length
			
			if (MATH_VecSquareNorm(tv_pos_B - tv_pos_A) > tf_sqr_rope_length)
				ti_flag_tension = vrai

			return(to_gao)
		}
	}
	
	return(nobody)
}



procedure_local int ROBOT_ROPE_Gogo_Mode()
{
	int			ti_return	
	int			ti_flag_tension

	float		tf_speed
	float		tf_duree

	vector	tv_pos_A
	vector	tv_pos_B
	vector	tv_AB
	vector	tv_temp
	vector	tv_main_sight
	object	to_rope_gao

	ti_return = faux
	
	if( i_gogo_test_done )
		return i_gogo_last_result
	
	i_gogo_test_done = vrai

	tv_main_sight = IO_JoyGetMove()
	if ( MATH_VecSquareNorm(tv_main_sight) < tolerance_joynull * tolerance_joynull )
		tv_main_sight = Cv_NullVector
	else
		MATH_VecSetNormalize(tv_main_sight)
		
//	DBG_RenderVector(@get_rayman OBJ_PosGet(),tv_main_sight,color_blanc)
	
//	tv_main_sight = @get_rayman OBJ_SightGet()
	to_rope_gao = ROBOT_ROPE_Get_Gao(tv_pos_A, tv_pos_B, ti_flag_tension)
	if ( to_rope_gao && ( to_rope_gao == get_rayman || to_rope_gao == @get_rayman PROC_RM_MontureGet() ) )
	{
		tv_AB = tv_pos_B - tv_pos_A
			
		tf_speed = MATH_VecSquareNorm(DYN_SpeedGetVector())

		tv_temp = MATH_VecCrossProduct(tv_main_sight, v_last_main_sight)
	
		if (MATH_AbsFloat(tv_temp.z) > 3.5 * TIME_GetDt()) // 0.1)
		{
			if (tf_speed < 64.0 || MATH_FloatSign(tv_temp.z) == MATH_FloatSign(MATH_VecCrossProduct(tv_AB, DYN_SpeedGetVector()).z))
			{
				f_main_gogo_duration += MATH_FloatMin(1.0 - f_main_gogo_duration, TIME_GetDt())
			}
			else
			{
				f_main_gogo_duration -= MATH_FloatMin(f_main_gogo_duration, TIME_GetDt())
				DBG_RenderSphere(@to_rope_gao OBJ_PosGet(), 2.0, color_jaune)
			}
		}
		else
		{
			f_main_gogo_duration -= MATH_FloatMin(f_main_gogo_duration, 0.5 * TIME_GetDt())
			DBG_RenderSphere(@to_rope_gao OBJ_PosGet(), 2.0, color_rouge)
		}
		
		// passage en gogo ?
		tf_duree = 0.3
		
		if (f_main_gogo_duration > tf_duree)
		{
			ti_return	= vrai
		
			if (tf_speed < 64.0 && ! MATH_VecNullEpsilon(tv_temp) )
			{
				tv_AB = MATH_VecCrossProduct(tv_temp, tv_AB)
			}
			else
			{
				tv_temp = MATH_VecCrossProduct(tv_AB, DYN_SpeedGetVector())	

				if( MATH_VecNullEpsilon(tv_temp) )
					tv_temp	= Cv_VerticalVector

				tv_AB = MATH_VecCrossProduct(tv_AB, tv_temp)

				if( MATH_VecNullEpsilon(tv_AB) )
					tv_AB = cvector(1.0, 0.0, 0.0)

				tv_AB *= MATH_FloatSign(MATH_VecDotProduct(tv_AB, DYN_SpeedGetVector()))
			}
	
			MATH_VecSetNormalize(tv_AB)
			tv_AB.z=0.0
			tv_AB *= 20.0	
			DBG_RenderVector( OBJ_PosGet(), tv_AB, color_bleu)
			v_traction_GOGO += tv_AB
		}
	}
	else
	{
		f_main_gogo_duration = 0.0
	}
	
	f_gogo_backup_joy_dt += TIME_GetDt()
	if (f_gogo_backup_joy_dt > 0.05)
	{
		f_gogo_backup_joy_dt -= 0.05
		v_last_main_sight = tv_main_sight
	}
	i_gogo_last_result = ti_return
	return(ti_return)
}




procedure_local 	int	ROBOT_Detect_Target( object	to_target)
{
	float tf_dot
	vector tv_sens

	if( ( i_etat_courant != ETAT_PNJ_MR_Attaque && OBJ_SqrDist(to_target) < Cf_Min_Attack2)
	|| ( i_etat_courant == ETAT_PNJ_MR_Attaque && OBJ_SqrDist(to_target) < Cf_Max_Attack2))
	{
		tv_sens=MATH_VecNormalize(@to_target OBJ_PosGet()-OBJ_PosGet())
		tf_dot = MATH_VecDotProduct( OBJ_SightGet(), tv_sens) 
//		Str_DisplayFloatOnce(tf_dot , VIEW_3dWorldTo2d(0,OBJ_PosGet()))
		if ( tf_dot > Cf_Cos30)
			return vrai
	}
	return faux
}

procedure_local void ROBOT_GFX_Lightning()
{
	object	to_main
	vector	tv_pos, tv_sens
	if( i_GFX_BOLT == -1 )
	{
		i_GFX_BOLT = GFX_Add(2)				// création de l’éclair
		GFX_FlagSet(i_GFX_BOLT, 0, 1)		// activation
		GFX_FlagSet(i_GFX_BOLT, 2, vrai)		// matériau transparent
		GFX_MaterialSet(i_GFX_BOLT, get_SFX_light_and_smoke, 3)     // affectation du matériau
		GFX_Seti(i_GFX_BOLT, 2100, 5)			// nombre de découpe (arrondie à 8)
		GFX_Seti(i_GFX_BOLT, 2101, 2)			// la texture est plaquée qu’une fois sur tout le faisceau
		GFX_Seti(i_GFX_BOLT, 2102, 0x7F60FFFF)		// couleur
		GFX_Setf(i_GFX_BOLT, 2000, 0.07)		// épaisseur
		GFX_Setf(i_GFX_BOLT, 2001, 0.3)	// rayon du cylindre dans lequel évolue l'éclair
	}
}

procedure_local int PNJ_MR_InBV(vector tv_pos)
{
	if(o_BV_Zone)
	{
		return @o_BV_Zone COL_BV_PointCollide(tv_pos)
	}
	else
		return vrai
}


procedure_local void PNJ_MR_SEND_PAF(float pf_Damage,int pf_Mode,float pf_taille)
{
	//MODE:
	// 0 : Explosion
	// 1 : Gogo
	// 2 : PAF
	vector	tv_sens, tv_pos
	object	tao_zde_zde_list[20]
	object	to_target
	int			ti_i
	int			ti_nb
	int			ti_type
	float		tf_speed

//	SND_RequestPlay(Ci_SND_Explode)
	COL_ColSetActivationSet(C_bit_zde_fight, none)
	COL_ZonePosSet(C_zde_fight,cvector(0.0, 0.0, 3.0 * OBJ_ZoomGet()))
	COL_ZoneSizeSet(C_zde_fight,cvector(pf_taille, pf_taille, pf_taille))

	ti_nb = COL_ZDE_ZDEListGet( &tao_zde_zde_list[0], C_zde_fight, C_zde_corps, all, none, Ci_Filter_IdentityFlag)
	for (ti_i = 0; ti_i < ti_nb; ti_i++)
	{
		to_target = tao_zde_zde_list[ti_i]
		tv_pos = OBJ_PosGet()
		tv_sens = @to_target OBJ_PosGet() - OBJ_PosGet()
		switch(pf_Mode)
		{
			case 0:
				ti_type = C_PAF_RM_Fort 
				ti_type |= C_PAF_RM_Grenade
				EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_target, -1, pf_Damage, tv_sens, tv_pos)
				break
			case 1:
				if(tao_zde_zde_list[ti_i]!=o_fight_target)
				{
					ti_type = C_PAF_RM_Fort 
//					tv_sens = MATH_VecNormalize(tv_sens) * 10.0
					tv_sens = DYN_SpeedGetVector() * 0.5
					EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_target, -1, pf_Damage, tv_sens, tv_pos)
					if(AI_HaveSameModel(tao_zde_zde_list[ti_i])) EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type, to_target, Cf_EVENT_Duree_1Trame, OBJ_Me(), -1, pf_Damage, -tv_sens, @to_target OBJ_PosGet())
					@get_global i_grappin_hotspot_nmi_died = vrai	
				}
				break
			case 2:
				if((tao_zde_zde_list[ti_i]!=o_fight_target) && i_CollidePaf)
				{
					ti_type = C_PAF_RM_Moyen
//					tf_speed=DYN_SpeedGet()
//					DBG_RenderVector(OBJ_PosGet(),tv_sens,color_rouge) 
//					DBG_RenderVector(OBJ_PosGet(),MATH_VecNormalize(tv_sens),color_vert) 
//					DBG_RenderVector(OBJ_PosGet(),MATH_VecNormalize(tv_sens)*DYN_SpeedGet(),color_bleu) 
//					DBG_RenderVector(OBJ_PosGet(),MATH_VecNormalize(tv_sens)*DYN_SpeedGet()*0.2,color_rose) 
// 					tv_sens = MATH_VecNormalize(tv_sens)*DYN_SpeedGet()*0.3
					tv_sens = Cv_VerticalVector * 0.1
					EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_target, -1, pf_Damage, tv_sens, tv_pos)
					if(AI_HaveSameModel(tao_zde_zde_list[ti_i])) EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type, to_target, Cf_EVENT_Duree_1Trame, OBJ_Me(), -1, pf_Damage, -tv_sens, @to_target OBJ_PosGet())
				}
				break
		}
	}
	COL_ColSetActivationSet(none, C_bit_zde_fight)
}


procedure_local void PNJ_MR_SFX_Etincelles()
{
	vector tv_pos
	tv_pos=OBJ_PosGet()+cvector(MATH_RandFloat(-OBJ_ZoomGet(),OBJ_ZoomGet())*1.0,MATH_RandFloat(-OBJ_ZoomGet(),OBJ_ZoomGet())*1.0,MATH_RandFloat(0.0,OBJ_ZoomGet())*2.0)
	i_GFX_Etincelle = GFX_Add(9)
	GFX_FlagSet(i_GFX_Etincelle, 0,1)
	GFX_FlagSet(i_GFX_Etincelle, 2, 1)
	GFX_MaterialSet(i_GFX_Etincelle, get_SFX_light_and_smoke, 5)
	GFX_Seti(i_GFX_Etincelle, 9101, 0x40448DAB)											// Couleur des particules
	GFX_Setv(i_GFX_Etincelle, 9200, tv_pos + cvector(0.0,0.0,0.25))						// Position
	GFX_Setv(i_GFX_Etincelle, 9201, cvector(0.0, 0.0, 1.0) )								// Axe principal de génération
	GFX_Setv(i_GFX_Etincelle, 9202, cvector(0, 0, 0.0))										// Gravité
	GFX_Seti(i_GFX_Etincelle, 9100, 5)															// Nombre de particules max
	GFX_Seti (i_GFX_Etincelle, 9102, 10)															// Flags
	GFX_Setf(i_GFX_Etincelle, 9000, 3.0 )															// Angle du cône, en radians
	GFX_Setf(i_GFX_Etincelle, 9001, 5)															// Vitesse min
	GFX_Setf(i_GFX_Etincelle, 9002, 6)															// Vitesse max
	GFX_Setf(i_GFX_Etincelle, 9003, 0.8)															// Friction
	GFX_Setf(i_GFX_Etincelle, 9004, MATH_RandFloat(0.01,0.03))						// Epaisseur des étincelles
	GFX_Setf(i_GFX_Etincelle, 9005, 0.5)															// Temps de vie minimum
	GFX_Setf(i_GFX_Etincelle, 9006, 0.6)															// Temps de vie max
	GFX_Setf(i_GFX_Etincelle, 9007, 1.0)															// Multiplicateur de longueur
	GFX_Setf(i_GFX_Etincelle, 9008, 0.0)															// Temps entre la génération de 2 étincelles
	GFX_Setf(i_GFX_Etincelle, 9009, 0.2)															// Temps de mort minimum
	GFX_Setf(i_GFX_Etincelle, 9010, 0.2)															// Temps de mort maximum
}

procedure_local void PNJ_MR_Move(vector tv_pos,vector tv_mapos)
{
	vector tv_sens
	float tf_dot
	int ti_move
	float tf_norm

	if(f_FreezeMove>0.0)
		i_rotate = vrai		
	
	tv_sens = tv_pos - tv_mapos
	tv_sens.z = 0.0
	
	tf_norm=MATH_VecNorm(tv_sens)
	if(tf_norm==0.0)
	{
		v_traction_MOVE = Cv_NullVector
		return		
	}
	else
		tv_sens/=tf_norm

	DBG_RenderVector(tv_mapos,tv_sens,color_bleu)	

	tf_dot = MATH_VecDotProduct( OBJ_SightGet(), tv_sens) 
	switch ( i_model)
	{
		case 1 :
			ti_move = faux
			if ( ( ( ( i_rotate && tf_dot < Cf_Cos5) || (tf_dot < Cf_Cos85) ) || ( !PNJ_MR_InBV(OBJ_PosGet() + OBJ_SightGet()) ) ) && (f_PasDeRotate<=0.0) )
				i_rotate = vrai
			else
				i_rotate = faux
				ti_move = !i_rotate
			break
		case 2 :
			i_rotate = vrai
			ti_move = vrai
			break
		case 3 :
			ti_move = faux
			i_rotate = vrai
	}
	
	if ( i_rotate)
	{
		if ( tf_dot < Cf_Cos5)
			OBJ_RotateLocalZ( f_orient_speed * MATH_FloatSign( MATH_VecCrossProduct(OBJ_SightGet(), tv_sens).z) * TIME_GetDt())
		else
			OBJ_SightSet(tv_sens)
	}
	
	
	if ( ti_move)
	{
		// Move
		if(f_FreezeMove>0.0)
			v_traction_MOVE = Cv_NullVector	
		else
			v_traction_MOVE = OBJ_SightGet() * f_move_speed
	}
	else
	{
		v_traction_MOVE = Cv_NullVector
	}
}



procedure_local void PNJ_MR_GFX_Smoke(vector tv_pos)
{
	vector	tv_wind

//	if (OBJ_LodVisGet()  < 0.6)
//	{
//		if (GFX_Smoke != -1)
//		{
//			GFX_Seti(GFX_Smoke, 13106, 0)												// *number of sprite to generate
//			GFX_Smoke = -1
//		}
//		return
//	}

	if (i_GFX_Smoke == -1)
	{
		i_GFX_Smoke= GFX_Add(13)																// Create the boum
		
		GFX_MaterialSet(i_GFX_Smoke, get_SFX_light_and_smoke, -1)						// met le materiau
		GFX_Seti(i_GFX_Smoke, 13101, 8)															// Materiau 0

		GFX_Seti(i_GFX_Smoke, 13100, 50)															// *Buffer number of sprite
		GFX_Seti(i_GFX_Smoke, 13106, 0xFFFFFFFF)											// *number of sprite to generate
	
		GFX_Setf(i_GFX_Smoke, 13003, 0.1)															// Time fase 1
		GFX_Setf(i_GFX_Smoke, 13004, 0.75)															// Time fase 2
	
		GFX_Seti(i_GFX_Smoke, 13107, 0)															// Sprites non triés
	
		GFX_FlagSet(i_GFX_Smoke, 0 , 1)
		GFX_FlagSet(i_GFX_Smoke, 2 , 1)
		
		GFX_Setf(i_GFX_Smoke, 13012, 0.75)														// Time random
	
		GFX_Setv(i_GFX_Smoke, 13203, cvector(0.01, 0.01, 0.01))					// friction speed

		GFX_Setf(i_GFX_Smoke, 13000, 0.2)														// Growing speed min
		GFX_Setf(i_GFX_Smoke, 13001, 0.25)														// Growing speed max
		GFX_Setf(i_GFX_Smoke, 13002, 0.001)													// Friction Grow

		GFX_Setf(i_GFX_Smoke, 13007, 0.0)														// Gravity

		GFX_Setf(i_GFX_Smoke, 13008, 0.09)														// generation rate
	
		GFX_Setv(i_GFX_Smoke, 13205, Cv_NullVector)										// Mainposspeed
		GFX_Setv(i_GFX_Smoke, 13206, Cv_NullVector)										// Mainpossfriction

//		GFX_Setv(i_GFX_Smoke, 13201, cvector(-1.0, -1.0, 0.0))							// Speed min
//		GFX_Setv(i_GFX_Smoke, 13202, cvector(1.0, 1.0, 0.0))								// Speed max
		GFX_Setf(i_GFX_Smoke, 13009, 1.0)							// Norm speed min
		GFX_Setf(i_GFX_Smoke, 13010, 3.0)									// Norm speed max
		GFX_Setf(i_GFX_Smoke, 13005, 0.1)														// Creation size min
		GFX_Setf(i_GFX_Smoke, 13006, 0.2)														// Creation size max
	}

	GFX_Seti(i_GFX_Smoke, 13103, COLOR_Blend(0x40FFFFFF, 0x00000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 0
	GFX_Seti(i_GFX_Smoke, 13104, COLOR_Blend(0x90FFFFFF, 0x80000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 1
	GFX_Seti(i_GFX_Smoke, 13105, COLOR_Blend(0x00FFFFFF, WOR_AmbiantColGet(0) & 0x00FFFFFF, 0.5))	// Color fase 2

	GFX_Setv(i_GFX_Smoke, 13201, (-OBJ_SightGet() * 2.0) + cvector(-1.0, -1.0, -1.0))							// Speed min
	GFX_Setv(i_GFX_Smoke, 13202, (-OBJ_SightGet() * 2.0) + cvector(1.0, 1.0, -1.0))								// Speed max


	tv_wind = Cv_NullVector
	GFX_Setv(i_GFX_Smoke, 13204, tv_wind)												// wind
	tv_pos -= tv_wind * TIME_GetDt()

	GFX_Setv(i_GFX_Smoke, 13200, tv_pos) 								// Creation Pos
//	GFX_Setv(i_GFX_Smoke, 13207, cvector(0.5, 0.0, 0.0))	// CreaPosAxe X
//	GFX_Setv(i_GFX_Smoke, 13208, cvector(0.0, 0.5, 0.0))	// CreaPosAxe Y
//	GFX_Setv(i_GFX_Smoke, 13209, cvector(0.0, 0.0, 0.25))	// CreaPosAxe Z

	GFX_Setf(i_GFX_Smoke, 13011, OBJ_PosGet().z) // Z min
}

procedure_local void PNJ_MR_GFX_Link(vector tv_pos1,vector tv_pos2, byref int i_GFX_Link)
{
	if(i_GFX_Link  == -1 )
	{
		i_GFX_Link = @get_global GFX_Add(2)									// création de l’éclair
//		i_GFX_Link = GFX_Add(2)														// création de l’éclair
		GFX_FlagSet(i_GFX_Link, 0, 1)												// activation
		GFX_FlagSet(i_GFX_Link, 2, vrai)											// matériau transparent
		GFX_MaterialSet(i_GFX_Link, get_SFX_light_and_smoke, 3)     	// affectation du matériau
		GFX_Seti(i_GFX_Link, 2100, 8)												// nombre de découpe (arrondie à 8)
		GFX_Seti(i_GFX_Link, 2101, 2)												// la texture est plaquée qu’une fois sur tout le faisceau
		GFX_Seti(i_GFX_Link, 2102, c_Eclair)										// couleur
		GFX_Setf(i_GFX_Link, 2000, 0.1)											// épaisseur
		GFX_Setf(i_GFX_Link, 2001, 0.4)											// rayon du cylindre dans lequel évolue l'éclair
	}
	GFX_Setv(i_GFX_Link, 2200,tv_pos1)
	GFX_Setv(i_GFX_Link, 2201,tv_pos2)
}

procedure_local void PNJ_MiniRobot_GFX_Halo_Poignet()
{
	if(i_GFX_Halo_Poignet==-1)
	{
		i_GFX_Halo_Poignet  = GFX_Add(21)
		GFX_FlagSet(i_GFX_Halo_Poignet , 4, 1)
		GFX_MaterialSet(i_GFX_Halo_Poignet , get_SFX_light_and_smoke, 0)	
		GFX_Setf(i_GFX_Halo_Poignet, 21002, -1.0)							// extraction par rapport au point de génération (vers la cam)
		GFX_Seti(i_GFX_Halo_Poignet , 21103, 1)		
//		GFX_Seti(i_GFX_Glow , 21101, 0x00FF00)
		GFX_Seti(i_GFX_Halo_Poignet , 21101, color_rose)

	}	
	GFX_Setv(i_GFX_Halo_Poignet, 21200, OBJ_PosGet()+(OBJ_BankingGet()*OBJ_ZoomGet()*Cf_MR_Hauteur_Poignet))
	GFX_Setf(i_GFX_Halo_Poignet, 21000, MATH_RandFloat(0.5, 0.8))	
}

procedure_local void PNJ_MiniRobot_GFX_Glow()
{
	if(i_GFX_Glow==-1)
	{
		i_GFX_Glow  = GFX_Add(21)
		GFX_FlagSet(i_GFX_Glow , 4, 1)
		GFX_MaterialSet(i_GFX_Glow , get_SFX_light_and_smoke, 0)	
		GFX_Setf(i_GFX_Glow , 21002, 2.0)							// extraction par rapport au point de génération (vers la cam)
		GFX_Seti(i_GFX_Glow , 21103, 1)		
//		GFX_Seti(i_GFX_Glow , 21101, 0x00FF00)
		GFX_Seti(i_GFX_Glow , 21101, c_Eclair)

	}	
	GFX_Setv(i_GFX_Glow, 21200, OBJ_PosGet()+(OBJ_BankingGet()*0.9))
	GFX_Setf(i_GFX_Glow, 21000, MATH_RandFloat(0.1, 1.0))	
}
procedure_local void PNJ_MiniRobot_GFX_HaloLink()
{
// Halo ---------------------------------------------------------
	i_GFX_Halo_Link = GFX_Add(21)
	GFX_MaterialSet(i_GFX_Halo_Link,get_SFX_light_and_smoke, 0)  
	GFX_FlagSet(i_GFX_Halo_Link, 4,1)												// Destruction avec redusction de taille.
	GFX_Setf(i_GFX_Halo_Link, 21000, 1.0)											// taille
	GFX_Setf(i_GFX_Halo_Link, 21002, 2)												// extraction par rapport au point de génération (vers la cam)
	GFX_Seti(i_GFX_Halo_Link, 21103, 1)												// type de halo
	GFX_Seti(i_GFX_Halo_Link, 21101, c_Eclair)									// couleur
	GFX_Setv(i_GFX_Halo_Link, 21200, OBJ_PosGet()+(OBJ_BankingGet()*0.9))							// position du halo
	GFX_Setf(i_GFX_Halo_Link, 21005, Cf_MR_Link_DelayActivation*0.8)	// temps de mort
	GFX_Seti(i_GFX_Halo_Link, 21100, 16 )											// flags qui dit que la mort va entrainer une réduction de la taille
	GFX_LifeTimeSet(i_GFX_Halo_Link,Cf_MR_Link_DelayActivation*0.2)	// Durée de vie
//	if (!i_SF_baton)
//		GFX_Seti(i_GFX_Halo_Link, 21101, 0x00106EDE)						// couleur
// Halo ---------------------------------------------------------
}

procedure_local void PNJ_MR_GFXDel_Link()
{
	if ( i_GFX_Link1!= -1)
	{
		GFX_Del(i_GFX_Link1)
		i_GFX_Link1=-1
	}
	if ( i_GFX_Link2!= -1)
	{
		GFX_Del(i_GFX_Link2)
		i_GFX_Link2=-1
	}
	if ( i_GFX_Link3!= -1)
	{
		GFX_Del(i_GFX_Link3)
		i_GFX_Link3=-1
	}
}

procedure_local void PNJ_MR_Unlink_Partenaires()
{
	if(i_Chef==-1)
	{
		if(i_NbLink>=1) 
			@o_Partenaire[0] Proc_PNJ_MiniRobot_Unlink()
		if(i_NbLink>=2)
			@o_Partenaire[1] Proc_PNJ_MiniRobot_Unlink()
	}
	i_NbLink=0
	o_Partenaire[0]=nobody
	o_Partenaire[1]=nobody
}

procedure_local int PNJ_MiniRobot_SearchThird()
{
	int ti_i
	int ti_exit_value
	int ti_InTri
	object to_sauve
	for (ti_i = 0; ti_i < i_budy_nb; ti_i++)
	{
		if(@ao_budy[ti_i] Proc_PNJ_MiniRobot_EstDispo())																// un MR dispo ?
		{
//			if(MATH_VecSquareDistance(@o_fight_target OBJ_PosGet(),@ao_budy[ti_i] OBJ_PosGet())<Cf_MR_Max_Link_Dist2)	// un MR pas loin ?
			{
				if(MATH_LIB_PointInTriangle(@o_fight_target OBJ_PosGet(), OBJ_PosGet(),@o_Partenaire[0] OBJ_PosGet(),@ao_budy[ti_i] OBJ_PosGet(), Cv_VerticalVector,ti_exit_value))
					ti_InTri=vrai
				else if(MATH_LIB_PointInTriangle(@o_fight_target OBJ_PosGet(), OBJ_PosGet(),@o_Partenaire[0] OBJ_PosGet(),@ao_budy[ti_i] OBJ_PosGet(), -Cv_VerticalVector,ti_exit_value))
					ti_InTri=vrai
				else
					ti_InTri=faux	
				if(ti_InTri)
				{
					to_sauve=o_Partenaire[0]
					PNJ_MR_Unlink_Partenaires()
					@to_sauve Proc_PNJ_MiniRobot_Link(OBJ_Me(),2)
					@ao_budy[ti_i] Proc_PNJ_MiniRobot_Link(OBJ_Me(),2)
					o_Partenaire[0]=to_sauve
					o_Partenaire[1]=ao_budy[ti_i]
					i_Chef=-1
					i_NbLink=2
					f_LinkDelayAct=Cf_MR_Link_DelayActivation
					PNJ_MiniRobot_GFX_HaloLink()
					f_FreezeMove=Cf_MR_Link_DelayActivation
					return	 vrai
				}
			}
		}
	}		
	return faux
}


procedure_local int PNJ_MR_PartenairesVivants()
{
	int ti_i
	for(ti_i=0;ti_i<i_NbLink;ti_i++)
	{
		if(@o_Partenaire[ti_i] OBJ_CapaTest(OBJ_Capa_15)) 									// Partenaire mort
		{
			return faux
		}	
	}
	return vrai
}

procedure_local void	PNJ_MiniRobot_Chef_Unlink()
{
	PNJ_MR_GFXDel_Link()
	SND_Stop(i_SND_MR_Arc_Elec_Loop)
	i_SND_MR_Arc_Elec_Loop=-1	
	@get_global i_MR_Nblink--
	PNJ_MR_Unlink_Partenaires()
}

procedure_local int PNJ_MR_DistPatenairesOK()
{
	int ti_InTri
	int ti_exit_value
	int ti_Ok
	ti_Ok=vrai
	
	if(i_NbLink==1)
	{
		if(MATH_VecSquareDistance(OBJ_PosGet(),@o_Partenaire[0] OBJ_PosGet())>Cf_MR_Max_Link_Dist2)
			return faux
//			ti_Ok=faux
	}
	else if(i_NbLink==2)
	{
//		if(MATH_VecSquareDistance(OBJ_PosGet(),@o_Partenaire[1] OBJ_PosGet())>Cf_MR_Max_Link_Dist2)
//			return faux
//		if(MATH_VecSquareDistance(@o_Partenaire[0] OBJ_PosGet(),@o_Partenaire[1] OBJ_PosGet())>Cf_MR_Max_Link_Dist2)
//			return faux
		if(MATH_LIB_PointInTriangle(@o_fight_target OBJ_PosGet(), OBJ_PosGet(),@o_Partenaire[0] OBJ_PosGet(),@o_Partenaire[1] OBJ_PosGet(), Cv_VerticalVector,ti_exit_value))
			ti_InTri=vrai
		else if(MATH_LIB_PointInTriangle(@o_fight_target OBJ_PosGet(), OBJ_PosGet(),@o_Partenaire[0] OBJ_PosGet(),@o_Partenaire[1] OBJ_PosGet(), -Cv_VerticalVector,ti_exit_value))
			ti_InTri=vrai
		else
			ti_InTri=faux	
		if(!ti_InTri)
			ti_Ok=faux
		}
		
	if(ti_Ok)
	{
		f_UnlinkDelay=Cf_MR_Delay_Unlink
		return vrai
	}
	else
	{
		if(f_UnlinkDelay<=0.0)
		{
			return faux
		}
		else
		{
			f_UnlinkDelay-=TIME_GetDt()
			return vrai
		}
	}
}

procedure_local void PNJ_MR_DetectLinkCut(object po_obj1,object po_obj2)
{							
	int ti_cm_rm
	vector tv_obj1
	vector tv_obj2
	object to_touche
	
	tv_obj1=@po_obj1 PNJ_MR_PosGetEclair()
	tv_obj2=@po_obj2 PNJ_MR_PosGetEclair()

	ti_cm_rm = @o_fight_target COL_ColMapActivationGet()
	@o_fight_target COL_ColMapActivationSet(all,none)
	to_touche=COL_RayObject_Vector(tv_obj1,tv_obj2-tv_obj1, all,none,Ci_Filter_IdentityFlag,COL_C_Ray_on_ColMap_NoCrossable)
	@o_fight_target COL_ColMapActivationSet(ti_cm_rm ,~ti_cm_rm )
	if(f_repaf<=0.0)	
	{
		if(to_touche)
		{
			if(to_touche==o_fight_target)
			{
				if(i_FrappeATerre || (@o_fight_target PROC_RM_Paf_Mode_Get()==0))
				{
					f_repaf=Cf_MR_Link_DelayRepaf
					PNJ_MiniRobot_Chef_Unlink()
					SND_RequestPlay(Ci_SND_MR_Arc_Elec_Paf)
					EVENT_AddEventPaf(C_EVENT_FILTER_All, C_PAF_RM_Moyen, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_touche, 10.0, Cv_VerticalVector)
				}
			}
			else if(@to_touche AI_IsModel(get_PNJ_MiniRobot_path))
			{
				if(to_touche!=po_obj2)
					@to_touche Proc_PNJ_MiniRobot_Glow()
			}
		}
	}
}

procedure_local void	PNJ_MiniRobot_CheckLink()
{
	
	if(o_Partenaire[0])
	{
		if(i_Chef==-1) 																							// JE SUIS LE CHEF
		{	
			if(!PNJ_MR_PartenairesVivants())
			{
				PNJ_MiniRobot_Chef_Unlink()
			}
			else																									// Partenaire vivant
			{
				if(!PNJ_MR_DistPatenairesOK())
				{
					PNJ_MiniRobot_Chef_Unlink()
				}
				else																								// Toujours Assez proche
				{
					if(i_NbLink!=0)
					{
						if(f_repaf>0.0)
						{
							f_repaf-=TIME_GetDt()
						}
						if(f_LinkDelayAct<=0.0)
						{
							if(i_SND_MR_Charge!=-1)
							{
								SND_Stop(i_SND_MR_Charge)
								i_SND_MR_Charge = -1
								SND_RequestPlay(Ci_SND_MR_Arc_Elec_Start)
								i_SND_MR_Arc_Elec_Loop =  SND_RequestPlayLoop(Ci_SND_MR_Arc_Elec_Loop)
							}
							PNJ_MR_GFX_Link(PNJ_MR_PosGetEclair(),@o_Partenaire[0] PNJ_MR_PosGetEclair(),i_GFX_Link1)
							PNJ_MR_DetectLinkCut(OBJ_Me(),o_Partenaire[0])
							if(i_NbLink==2)
							{
								PNJ_MR_GFX_Link(PNJ_MR_PosGetEclair(),@o_Partenaire[1] PNJ_MR_PosGetEclair(),i_GFX_Link2)
								PNJ_MR_GFX_Link(@o_Partenaire[0] PNJ_MR_PosGetEclair(),@o_Partenaire[1] PNJ_MR_PosGetEclair(),i_GFX_Link3)
								PNJ_MR_DetectLinkCut(OBJ_Me(),o_Partenaire[1])
								PNJ_MR_DetectLinkCut(o_Partenaire[0],o_Partenaire[1])
							}
							else
							{
								if(i_ATrois)
									PNJ_MiniRobot_SearchThird()
							}
						}
						else
						{
							if(i_SND_MR_Charge==-1)
								i_SND_MR_Charge = SND_RequestPlayLoop(Ci_SND_MR_Charge)	
							f_LinkDelayAct-=TIME_GetDt()
						}			
					}
				}
			}
		}
	}
}

procedure_local void PNJ_MR_GFXDel()	
{
	if ( i_GFX_Halo_Charge  != -1)
	{
		GFX_Del(i_GFX_Halo_Charge)
		i_GFX_Halo_Charge =-1
	}
	if ( i_GFX_BOLT  != -1)
	{
		GFX_Del(i_GFX_BOLT)
		i_GFX_BOLT=-1
	}
	if ( i_GFX_Etincelle  != -1)
	{
		GFX_Del(i_GFX_Etincelle)
		i_GFX_Etincelle=-1
	}
	if ( i_GFX_Laser != -1)
	{
		GFX_Del(i_GFX_Laser)
		i_GFX_Laser =-1
	}
	if ( i_GFX_Smoke != -1)
	{
		GFX_Del(i_GFX_Smoke )
		i_GFX_Smoke =-1
	}
	if ( i_GFX_Glow!= -1)
	{
		GFX_Del(i_GFX_Glow)
		i_GFX_Glow=-1
	}
	if ( i_GFX_Halo_Poignet!= -1)
	{
		GFX_Del(i_GFX_Halo_Poignet)
		i_GFX_Halo_Poignet=-1
	}
	if ( i_GFX_Reactor!= -1)
	{
		GFX_Del(i_GFX_Reactor)
		i_GFX_Reactor=-1
	}	
	PNJ_MR_GFXDel_Link()	
}


procedure_local void PNJ_MR_Clean()
{
	if( i_grabbed )
		@get_global i_grappin_hotspot_nmi_died = vrai	
	if(i_Grappinable)
		HotSpot_Del_Obj(OBJ_Me())

	RM_TARGET_Del(OBJ_Me())
	
	OBJ_CapaSet(OBJ_Capa_15,none)
	
	PNJ_MR_GFXDel()
	
	PNJ_MR_Unlink_Partenaires()
}

procedure_local void PNJ_MR_Destroy()
{
	int ti_i
	int	ti_SND
	object	to_gao
	
	for(ti_i=0;ti_i<2;ti_i++)
	{
		to_gao = Proc_RM_GenerateLifeMana(faux,vrai,OBJ_PosGet()+OBJ_BankingGet(),MATH_RandFloat(5.0,10.0) * cvector(MATH_RandFloat(-0.5,0.5),MATH_RandFloat(-0.5,0.5),MATH_RandFloat(0.75,1.5)))
		if(ti_i==0)
		{
			ti_SND = @to_gao SND_Request(1, 0)
			SND_Play(ti_SND)
		}
		to_gao = Proc_RM_GenerateLifeMana(vrai,faux,OBJ_PosGet()+OBJ_BankingGet(),MATH_RandFloat(5.0,10.0) * cvector(MATH_RandFloat(-0.5,0.5),MATH_RandFloat(-0.5,0.5),MATH_RandFloat(0.75,1.5)))
	}
	
	//Proc_RM_GenerateLums()
	PNJ_MR_Clean()
}


procedure_local void PNJ_MiniRobot_SearchLink()
{
	int ti_i
	for (ti_i = 0; ti_i < i_budy_nb; ti_i++)
	{
		if(@ao_budy[ti_i] Proc_PNJ_MiniRobot_EstDispo())																// un MR dispo ?
		{
			if(MATH_VecSquareDistance(OBJ_PosGet(),@ao_budy[ti_i] OBJ_PosGet())<Cf_MR_Min_Link_Dist2)	// un MR pas loin ?
			{
				@ao_budy[ti_i] Proc_PNJ_MiniRobot_Link(OBJ_Me(),1)
				o_Partenaire[0]=ao_budy[ti_i]
				i_Chef=-1
				f_LinkDelayAct=Cf_MR_Link_DelayActivation
				f_FreezeMove=Cf_MR_Link_DelayActivation
				i_NbLink=1
				@get_global i_MR_Nblink++
				PNJ_MiniRobot_GFX_HaloLink()
				return				
			}
		}
	}	
}

procedure_local void PNJ_MR_Flash()
{
	int ti_halo
	ti_halo = @get_global GFX_Add(21)
	GFX_MaterialSet(ti_halo, get_SFX_light_and_smoke, 0)
	GFX_FlagSet(ti_halo, 4,1)								// Destruction avec redusction de taille.
	GFX_Setf(ti_halo, 21000, 4.0)							// taille
	GFX_Setf(ti_halo, 21002, 3.0)							// extraction par rapport au point de génération (vers la cam)
	GFX_Seti(ti_halo, 21103, 1)							// type de halo
	GFX_Seti(ti_halo, 21101, 0x004471E6)			// couleur
	GFX_Setv(ti_halo, 21200, OBJ_PosGet() + (OBJ_BankingGet() * OBJ_ZoomGet() * 1.0) )				// position du halo
	GFX_Setf(ti_halo, 21005, 0.5)							// temps de mort
	GFX_Seti(ti_halo, 21100, 16 )							// flags qui dit que la mort va entrainer une réduction de la taille
	GFX_LifeTimeSet(ti_halo,0.1)						// Durée de vie
//	if (!i_SF_baton)
//	GFX_Seti(halo, 21101, 0x00106EDE)// couleur
	// Halo ---------------------------------------------------------
}

procedure_local void PNJ_MR_Explosion()
{
	vector	tv_Offset
	
	PNJ_MR_SFX_Etincelles()
	if(i_Tremble)
	{
		if(f_PetardDelay<=0.0)
		{
			f_PetardDelay = MATH_RandFloat(0.2,1.0)
			SND_RequestPlay(Ci_SND_MR_Petard)			
		}
		else
		{
			f_PetardDelay-=TIME_GetDt()
		}
		
		v_PosInit=OBJ_PosGet()
		f_CptDelayExplosion+=TIME_GetDt()	
		tv_Offset=cvector(MATH_RandFloat(-0.5,0.5),MATH_RandFloat(-0.5,0.5),MATH_RandFloat(-0.5,0.5))
		OBJ_PosSet(v_PosInit+((tv_Offset*f_CptDelayExplosion)*0.04))
		if(f_CptDelayExplosion>f_DelayExplosion)
		{
			if(i_Detruit)
			{
				if(f_CptDelayExplosion>f_DelayExplosion+1.0)
				{
					i_ADetruire=vrai
				}				
			}
			else
			{
				SND_Stop(i_SND_MR_Voix_Casse)
				i_SND_MR_Voix_Casse = -1
				PNJ_MR_SEND_PAF(Cf_MR_Damage_Explo,Ci_MR_ModePaf_Explo,5.0)
				SND_RequestPlay(Ci_SND_MR_Explose)
//				PROC_SFX_EXPLOSION_CARTOON( OBJ_PosGet())
				PROC_SFX_EXPLOSION_LAPIN (OBJ_PosGet(), 1.0)
				PNJ_MR_Flash()
				OBJ_FlagInvisibleSet(vrai)
				PNJ_MR_Destroy()
				i_Detruit=vrai
			}
		}
	}
	else
	{
		if(COL_CollideType(COL_C_Ground) || i_is_in_water==vrai )
		{
			i_Tremble=vrai
			i_SND_MR_Voix_Casse = SND_RequestPlayLoop(Ci_SND_MR_Voix_Casse)
		}	
	}
}

procedure_local int PNJ_MR_DBG_Display()
{
	if( @get_global i_DBG_PNJ_MiniRobot && @"univ" i_cheat_page == 1 )
		return vrai
	else
		return faux
}




procedure_local void PNJ_MR_GFX_Reactor(vector tv_pos,float pf_ZMin,float pf_dispertion)
{
	vector	tv_wind

//	if (OBJ_LodVisGet()  < 0.6)
//	{
//		if (GFX_Smoke != -1)
//		{
//			GFX_Seti(GFX_Smoke, 13106, 0)												// *number of sprite to generate
//			GFX_Smoke = -1
//		}
//		return
//	}

	if (i_GFX_Reactor == -1)
	{
		i_GFX_Reactor= GFX_Add(13)																// Create the boum
		
		GFX_MaterialSet(i_GFX_Reactor, get_SFX_light_and_smoke, -1)						// met le materiau
		GFX_Seti(i_GFX_Reactor, 13101, 8)															// Materiau 0

		GFX_Seti(i_GFX_Reactor, 13100, 200)															// *Buffer number of sprite
		GFX_Seti(i_GFX_Reactor, 13106, 0xFFFFFFFF)											// *number of sprite to generate
	
		GFX_Setf(i_GFX_Reactor, 13003, 0.1)															// Time fase 1
		GFX_Setf(i_GFX_Reactor, 13004, 0.75)															// Time fase 2
	
		GFX_Seti(i_GFX_Reactor, 13107, 0)															// Sprites non triés
	
		GFX_FlagSet(i_GFX_Reactor, 0 , 1)
		GFX_FlagSet(i_GFX_Reactor, 2 , 1)
		
		GFX_Setf(i_GFX_Reactor, 13012, 0.75)														// Time random
	
		GFX_Setv(i_GFX_Reactor, 13203, cvector(0.01, 0.01, 0.01))						// friction speed

		GFX_Setf(i_GFX_Reactor, 13000, 0.2)														// Growing speed min
		GFX_Setf(i_GFX_Reactor, 13001, 0.25)													// Growing speed max
		GFX_Setf(i_GFX_Reactor, 13002, 0.001)													// Friction Grow

		GFX_Setf(i_GFX_Reactor, 13007, 0.0)														// Gravity

		GFX_Setf(i_GFX_Reactor, 13008, 0.01)														// generation rate
	
		GFX_Setv(i_GFX_Reactor, 13205, Cv_NullVector)										// Mainposspeed
		GFX_Setv(i_GFX_Reactor, 13206, Cv_NullVector)										// Mainpossfriction

		GFX_Setf(i_GFX_Reactor, 13009, 2.0)														// Norm speed min
		GFX_Setf(i_GFX_Reactor, 13010, 5.0)														// Norm speed max
		GFX_Setf(i_GFX_Reactor, 13005, 0.1)														// Creation size min
		GFX_Setf(i_GFX_Reactor, 13006, 0.5)														// Creation size max
		GFX_Seti(i_GFX_Reactor, 13103, 0xFF202020)											// Color fase 0
		GFX_Seti(i_GFX_Reactor, 13104, 0x80202020)											// Color fase 1
		GFX_Seti(i_GFX_Reactor, 13105, 0x00)													// Color fase 2
		GFX_Setv(i_GFX_Reactor, 13201, cvector(-2.0,-2.0,-1.0))							// Speed min
		GFX_Setv(i_GFX_Reactor, 13202, cvector(2.0,2.0,-2.0))							// Speed max
	}

	GFX_Setv(i_GFX_Reactor, 13200, tv_pos) 								// Creation Pos
//	GFX_Setv(i_GFX_Smoke, 13207, cvector(0.5, 0.0, 0.0))	// CreaPosAxe X
//	GFX_Setv(i_GFX_Smoke, 13208, cvector(0.0, 0.5, 0.0))	// CreaPosAxe Y
//	GFX_Setv(i_GFX_Smoke, 13209, cvector(0.0, 0.0, 0.25))	// CreaPosAxe Z

	GFX_Setf(i_GFX_Reactor, 13011, pf_ZMin) // Z min
	GFX_Setv(i_GFX_Reactor, 13201, MATH_VecBlend(cvector(-1.0,-1.0,0.0),-Cv_VerticalVector,pf_dispertion))							// Speed min
	GFX_Setv(i_GFX_Reactor, 13202, MATH_VecBlend(cvector(1.0,1.0,0.5),-Cv_VerticalVector ,pf_dispertion))							// Speed max
}
