#include "PNJ_Slalomator_defines.var"

Include_UltraProcedure_Header

procedure_local void PNJ_Slalomator_Bomb()
{
	int			ti_i
	int			ti_kill_them_all
	int			ti_modulo
	
	float		tf_coef
	float		tf_dt
	float		tf_sqr_dt
	float		tf_grav_dt
	float		tf_grav_sqr_dt
	float		tf_duration
	float		tf_main_dist
	float		tf_temp
	float		tf_main_speed
	float		tf_speed_coef
	float		tf_cadence
	float		tf_radius

	vector	tv_pos
	vector	tv_normal
	vector	tv_me_to_main
	vector	tv_orth_main
	vector	tv_temp
	vector	tv_main_speed_axis
	vector	tv_wall_pos

	#define Cf_Bomb_Gravity				-40.0
	#define Cf_Bomb_Start_Speed		100.0
	#define Cf_Bomb_Rand_Radius		3.0
	#define Cf_Bomb_Wall_Radius		1.0

	if ( ! OBJ_CapaTest(OBJ_Capa_0) )
		ti_kill_them_all = vrai
	else if (i_laser_state != Ci_Laser_Wait)
		ti_kill_them_all = vrai
	else
		ti_kill_them_all = @o_main_actor PROC_RM_Paf_Mode_Get()

	tf_dt = TIME_GetDt()
	tf_sqr_dt = tf_dt * tf_dt

	tf_grav_dt = Cf_Bomb_Gravity * tf_dt
	tf_grav_sqr_dt = Cf_Bomb_Gravity * tf_sqr_dt

	tv_main_speed_axis = @o_main_actor DYN_SpeedGetVector()
	tv_main_speed_axis.z = 0.0
	tf_main_speed = MATH_VecNorm(tv_main_speed_axis)
	if (tf_main_speed > 20.0)
		tv_main_speed_axis *= 1.5
	else
		tv_main_speed_axis	= @o_main_actor OBJ_SightGet() * 10.0

	tf_speed_coef = MATH_FloatBlend(0.0, 1.0, tf_main_speed * 0.1)

	tv_me_to_main = @o_main_actor OBJ_PosGet()
	tv_me_to_main -= OBJ_PosGet()
	tv_me_to_main.z = 0.0
	tf_main_dist = MATH_VecNorm(tv_me_to_main)
	if (tf_main_dist)
		tv_me_to_main /= tf_main_dist
	else
		tv_me_to_main = OBJ_SightGet()
	
	tv_orth_main = tv_me_to_main
	tv_orth_main.z = tv_orth_main.x
	tv_orth_main.x = -tv_orth_main.y
	tv_orth_main.z = 0.0

	tv_wall_pos = @o_main_actor OBJ_PosGet()
	if (tf_main_speed > 20.0)
		tv_wall_pos += @o_main_actor DYN_SpeedGetVector() * 1.8
	else
		tv_wall_pos -= tv_me_to_main * 10.0
	v_wall_dest_pos = MATH_VecBlend(v_wall_dest_pos, tv_wall_pos, 12.0 * TIME_GetDt())
	tv_wall_pos = v_wall_dest_pos

	switch(i_bomb_shoot_mode)
	{
		case Ci_Bomb_Shoot_Rand : 

			f_bomb_state_duration	-= TIME_GetDt()
			if ( f_bomb_state_duration < 0.0)
			{
				f_bomb_state_duration = 10.0
				i_bomb_shoot_mode = Ci_Bomb_Shoot_Wall
			}
			break

		case Ci_Bomb_Shoot_Wall :

			f_bomb_state_duration	-= TIME_GetDt()
			if ( f_bomb_state_duration < 0.0 )
			{
				f_bomb_state_duration = 10.0
				i_bomb_shoot_mode = Ci_Bomb_Shoot_Rand
			}
			break
	}	

	switch(i_bomb_shoot_mode)
	{
		case Ci_Bomb_Shoot_Rand : 
			tf_cadence = 0.1
			tf_radius = Cf_Bomb_Rand_Radius
			break

		case Ci_Bomb_Shoot_Wall :
			tf_cadence = 0.05
			tf_radius = Cf_Bomb_Wall_Radius
			break
	}	

	f_bomb_delay -= tf_dt
	if (f_bomb_delay < 0.0)
	{
		f_bomb_delay += tf_cadence
		if ( ! ti_kill_them_all )
		{
			ai_bomb_state[i_bomb_launch_index] = Ci_Bomb_Init
			i_bomb_launch_index = MATH_Modulo(i_bomb_launch_index + 1, 100)
		}
	}

	for (ti_i = 0; ti_i < 100; ti_i++)
	{
		AI_ClearStack()	
	
		switch(ai_bomb_state[ti_i])
		{
			case Ci_Bomb_Init :

				av_bomb_pos[ti_i] = OBJ_PosGet()
				av_bomb_pos[ti_i] += OBJ_SightGet() * 0.1 * OBJ_ZoomGet()
				av_bomb_pos[ti_i] += OBJ_BankingGet() * 0.3 * OBJ_ZoomGet()
				if (MATH_Modulo(ti_i, 2))
					av_bomb_pos[ti_i] += OBJ_HorizonGet() * 0.9 * OBJ_ZoomGet()
				else
					av_bomb_pos[ti_i] -= OBJ_HorizonGet() * 0.9 * OBJ_ZoomGet()

				switch(i_bomb_shoot_mode)
				{
					case Ci_Bomb_Shoot_Rand :
						ti_modulo = MATH_Modulo(ti_i, 10) 
						tv_pos = @o_main_actor OBJ_PosGet()
						tv_pos += tv_main_speed_axis
						if (ti_modulo)
						{
							tv_pos -= tv_me_to_main * 10.0
							tv_pos += tv_orth_main * MATH_RandFloat(-20.0, 20.0)
							tv_pos = MATH_VecBlend(av_bomb_pos[ti_i], tv_pos, MATH_RandFloat(0.5, 1.0))
						}
						tv_pos.z = OBJ_PosGet().z + 50.0
						break
						
					case Ci_Bomb_Shoot_Wall :
						tv_pos = tv_wall_pos
						tv_pos += tv_orth_main * (MATH_Sin(ti_i * Cf_2Pi * 0.01) * 20.0)
						tv_pos.z = OBJ_PosGet().z + 50.0
						break

				}
					
				COL_RayObject_Dist(tv_pos, cvector(0.0, 0.0, -1.0), 200.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
				tv_pos = COL_RayObject_PosGet()
				tv_normal = COL_RayObject_NormalGet()

				av_bomb_dest_pos[ti_i] = tv_pos + (tv_normal * 0.1)
				av_bomb_dest_normal[ti_i] = tv_normal
				af_bomb_radius[ti_i] = tf_radius

//				MATH_LIB_PHY_Impulsion_Get(vector tv_start_pos, vector tv_dest_pos, vector tv_gravity, float tf_wanted_speed, byref float tf_X)		
				av_bomb_speed[ti_i] = MATH_LIB_PHY_Impulsion_Get(av_bomb_pos[ti_i], av_bomb_dest_pos[ti_i], cvector(0.0, 0.0, Cf_Bomb_Gravity), Cf_Bomb_Start_Speed, tf_duration, vrai)
				if (tf_duration > 10.0)
				{
					ai_bomb_state[ti_i] = Ci_Bomb_Wait
					break
				}
				af_bomb_move_duration[ti_i] = tf_duration

				// GFX
				if ( ai_bomb_halo[ti_i] > 0)
				{
					GFX_Del(ai_bomb_halo[ti_i])
					ai_bomb_halo[ti_i] = -1
				}
				
				if ( ai_bomb_halo[ti_i] <= 0 )
				{
					ai_bomb_halo[ti_i] = GFX_Add(21)                                 	 //création du halo
					GFX_MaterialSet(ai_bomb_halo[ti_i], get_SFX_light_and_smoke,0) 	// affectation du matériau
					GFX_Setf(ai_bomb_halo[ti_i], 21000, tf_radius)             // taille du halo
					GFX_Setf(ai_bomb_halo[ti_i], 21004, 20.0)                       // taille du halo
					GFX_Seti(ai_bomb_halo[ti_i], 21101, 0xFF)          // couleur du halo
					GFX_Seti(ai_bomb_halo[ti_i], 21100, 4)
				}
				
				GFX_Setv(ai_bomb_halo[ti_i], 21200, av_bomb_pos[ti_i])
				GFX_Setv(ai_bomb_halo[ti_i], 21201, - MATH_VecNormalize(av_bomb_speed[ti_i]))

				ai_bomb_state[ti_i] = Ci_Bomb_Move

				break
				
			case Ci_Bomb_Move :
		
				af_bomb_move_duration[ti_i] -= TIME_GetDt()	
				if (af_bomb_move_duration[ti_i] > 0.0)
				{	
					// Dynamique
					av_bomb_pos[ti_i] += av_bomb_speed[ti_i] * tf_dt
					av_bomb_pos[ti_i].z += tf_grav_sqr_dt
					av_bomb_speed[ti_i].z += tf_grav_dt
					
					// GFX
					GFX_Setv(ai_bomb_halo[ti_i], 21200, av_bomb_pos[ti_i])
					GFX_Setv(ai_bomb_halo[ti_i], 21201, - MATH_VecNormalize(av_bomb_speed[ti_i]))
				}
				else
				{
					af_bomb_move_duration[ti_i]	= 4.0
				
					ai_bomb_state[ti_i] = Ci_Bomb_Impact
					GFX_Setv(ai_bomb_halo[ti_i], 21200, av_bomb_dest_pos[ti_i])
					GFX_Setv(ai_bomb_halo[ti_i], 21201, av_bomb_dest_normal[ti_i])
				}
			
				break
				
			case Ci_Bomb_Impact :

				tf_coef = af_bomb_move_duration[ti_i]
				tf_coef /= 4.0

				af_bomb_move_duration[ti_i] -= TIME_GetDt()	
				if (af_bomb_move_duration[ti_i] > 0.0)
				{
					tv_temp = @o_main_actor OBJ_PosGet() - av_bomb_dest_pos[ti_i]
					tf_temp = tv_temp.z
					tv_temp.z = 0.0
				
					if (tf_coef > 0.25)
					{
						if (tf_temp < tf_coef * 5.0)
						{
							tf_temp = af_bomb_radius[ti_i]
							tf_temp *= 0.75
							tf_temp *= tf_coef 

							DBG_RenderCylinder(av_bomb_dest_pos[ti_i], av_bomb_dest_normal[ti_i] * tf_coef * 5.0, tf_temp, color_blanc)

							tf_temp *= tf_temp
							if (MATH_VecSquareNorm(tv_temp) < tf_temp)
							{
								EVENT_AddEventPafCanal( C_EVENT_FILTER_Object,  C_PAF_RM_ComboPetit, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_main_actor, -1, 10.0, @o_main_actor OBJ_SightGet(), OBJ_PosGet())	
								af_bomb_move_duration[ti_i] = 1.0
							}
						}
					}
					else
					{
						GFX_Seti(ai_bomb_halo[ti_i], 21101, COLOR_Blend(0xFF00, 0xFF, tf_coef / 0.25))          // couleur du halo
					}
				
					GFX_Setf(ai_bomb_halo[ti_i], 21000, tf_coef * af_bomb_radius[ti_i])
					GFX_Setf(ai_bomb_halo[ti_i], 21004, tf_coef * 20.0)                       // taille du halo
					GFX_Setv(ai_bomb_halo[ti_i], 21200, av_bomb_dest_pos[ti_i])
				}
				else
				{
					if (ai_bomb_halo[ti_i] != -1)	
					{
						GFX_Del(ai_bomb_halo[ti_i])
						ai_bomb_halo[ti_i] = -1
					}
				
					ai_bomb_state[ti_i] = Ci_Bomb_Wait
				}

				break
		}
	}  
}

procedure_local void PNJ_Slalomator_Laser_Impact(vector tv_pos)
{
	int		ti_GFX_Impact	

	ti_GFX_Impact = GFX_Add(9)
	GFX_FlagSet(ti_GFX_Impact , 0, 1)
	GFX_FlagSet(ti_GFX_Impact , 2, 1)
	GFX_MaterialSet(ti_GFX_Impact , get_SFX_light_and_smoke, 5)
	GFX_Setf(ti_GFX_Impact, 9000, Cf_PiBy3)												// angle d'ouverture
	GFX_Seti(ti_GFX_Impact, 9100, 10)														// Nombre
	GFX_Seti(ti_GFX_Impact, 9101, 0xFF) //0xFFB0F8EC) 										// couleur
	GFX_Setf(ti_GFX_Impact, 9003, 0.999)														// friction
	GFX_Setf(ti_GFX_Impact, 9001, 10.0)														// vitesse initiale minimum
	GFX_Setf(ti_GFX_Impact, 9002, 60.0)														// vitesse initiale maximum
	GFX_Setf(ti_GFX_Impact, 9004, 0.1)													// épaisseur
	GFX_Setf(ti_GFX_Impact, 9005, 0.5)														// durée de vie minimum
	GFX_Setf(ti_GFX_Impact, 9006, 1.0)														// durée de vie maximum
	GFX_Setf(ti_GFX_Impact, 9007, 1.95)														// multiplicateur de longueur
	GFX_Setf(ti_GFX_Impact, 9008, 0.0)														// generation périod
	GFX_Setf(ti_GFX_Impact, 9009, 0.05)														// durée de mort minimun
	GFX_Setf(ti_GFX_Impact, 9010, 0.1)														// durée de mort maximun
	GFX_Seti(ti_GFX_Impact, 9102, 0b11000)												// Flags (1 => agrandissement centré)
	GFX_Setv(ti_GFX_Impact, 9200, tv_pos)													// Origine des étincelles
	GFX_Setv(ti_GFX_Impact, 9201, Cv_VerticalVector)											// Direction
	GFX_Setv(ti_GFX_Impact, 9202, cvector(0.0, 0.0, -10.0) )								// gravity
	GFX_Seti(ti_GFX_Impact, 9103, 3) 												// Zorder
}

procedure_local void PNJ_Slalomator_Laser()
{
	float		tf_coef
	float		tf_temp	
	float		tf_wanted_speed
	float		tf_main_speed

	vector	tv_start_pos	
	vector	tv_temp

	tv_start_pos = OBJ_PosGet()
	tv_start_pos += OBJ_SightGet() * 0.6 * OBJ_ZoomGet()
	tv_start_pos += OBJ_BankingGet() * 0.7  *OBJ_ZoomGet()

	switch(i_laser_state)
	{
		case Ci_Laser_Init :

			if ( ! @o_main_actor PROC_RM_Paf_Mode_Get() )
			{
				GFX_Line = GFX_Add(1)
				GFX_FlagSet(GFX_Line , 0, 1)
				GFX_FlagSet(GFX_Line, 2, 1)
				GFX_MaterialSet(GFX_Line, get_SFX_light_and_smoke, 3)
				GFX_Setf(GFX_Line, 1000, 0.05 * OBJ_ZoomGet())		// Epaisseur de la ligne
				GFX_Seti(GFX_Line, 1100, 0xFF)		// Couleur de la ligne
	
				v_laser_shoot_pos = OBJ_PosGet() + (OBJ_SightGet() * 1.5 * OBJ_ZoomGet())
	
				v_laser_shoot_pos.z += 20.0
				COL_RayObject_Dist(v_laser_shoot_pos, -Cv_VerticalVector, 50.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
				v_laser_shoot_pos = COL_RayObject_PosGet()

				v_GFX_Line_dest_pos = v_laser_shoot_pos

				GFX_Setv(GFX_Line, 1200, tv_start_pos)		// Coordonnée de la position 3D du début du faisceau
				GFX_Setv(GFX_Line, 1201, v_GFX_Line_dest_pos)		// Coordonnée de la position 3D de la fin du faisceau
	
				PNJ_Slalomator_Laser_Impact(v_GFX_Line_dest_pos)
	
				i_laser_state = Ci_Laser_Move
				f_laser_phase_duration = 0.0
			}

			break
			
		case Ci_Laser_Move :

			f_laser_phase_duration += TIME_GetDt()

			if (f_laser_phase_duration > 6.0 || @o_main_actor PROC_RM_Paf_Mode_Get() || ( ! OBJ_CapaTest(OBJ_Capa_0) ) )
			{
				if (GFX_Line != -1)
				{
					GFX_Del(GFX_Line)
					GFX_Line = -1
				}
			
				i_laser_state = Ci_Laser_Wait
				f_laser_phase_duration = 0.0
			}
			else
			{
				v_laser_shoot_pos += OBJ_PosGet() - v_last_pos	
			
		
				tv_temp = @o_main_actor OBJ_PosGet()
				tv_temp -= v_laser_shoot_pos
				tv_temp.z = 0.0
				tf_coef = MATH_VecNorm(tv_temp)
				tf_coef = MATH_FloatMax(tf_coef - 5.0, 0.0)
				tf_coef /= 20.0
				tf_wanted_speed = MATH_FloatBlend(2.0, 50.0, tf_coef)
				
//				tv_temp = @o_main_actor DYN_SpeedGetVector()
//				tv_temp.z = 0.0
//				tf_main_speed = MATH_VecNorm(tv_temp)
//				tf_wanted_speed += tf_main_speed
	
				tv_temp = @o_main_actor OBJ_PosGet()
				tv_temp -= v_laser_shoot_pos
				tv_temp.z = 0.0
				tf_temp = MATH_VecNorm(tv_temp)
				if (tf_temp)
				{
					tv_temp /= tf_temp
					tv_temp *= MATH_FloatMin(tf_temp, tf_wanted_speed * TIME_GetDt())
					v_laser_shoot_pos += tv_temp
				}
			
				v_laser_shoot_pos.z += 10.0
				COL_RayObject_Dist(v_laser_shoot_pos, -Cv_VerticalVector, 100.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
				v_laser_shoot_pos = COL_RayObject_PosGet()
	
//				v_laser_shoot_pos.z = @o_main_actor OBJ_PosGet().z				
				tv_temp = v_laser_shoot_pos

//				tv_temp = v_laser_shoot_pos - OBJ_PosGet()
//				tv_temp.z = tv_temp.x
//				tv_temp.x = - tv_temp.y
//				tv_temp.y = tv_temp.z
//				tv_temp.z = 0.0
//				MATH_VecSetNormalize(tv_temp)
//				tv_temp *= 10.0
//				tv_temp *= MATH_Sin(f_laser_phase_duration * 4.0)
//				tv_temp += v_laser_shoot_pos

				v_GFX_Line_dest_pos = tv_temp

				GFX_Setv(GFX_Line, 1200, tv_start_pos)		// Coordonnée de la position 3D du début du faisceau
				GFX_Setv(GFX_Line, 1201, v_GFX_Line_dest_pos)		// Coordonnée de la position 3D de la fin du faisceau
				
				PNJ_Slalomator_Laser_Impact(tv_temp)	
		
				if (MATH_VecSquareNorm(tv_temp - @o_main_actor OBJ_PosGet()) < 2.0)
				{
					EVENT_AddEventPafCanal( C_EVENT_FILTER_Object,  C_PAF_RM_Fort, OBJ_Me(), Cf_EVENT_Duree_1Trame, o_main_actor, -1, 10.0, OBJ_SightGet(), OBJ_PosGet())	

					i_laser_state = Ci_Laser_Wait
					f_laser_phase_duration = 0.0
				}
			}

			break
			
		case Ci_Laser_Wait :

			if (GFX_Line != -1)
			{
				GFX_Del(GFX_Line)
				GFX_Line = -1
			}

			if ( OBJ_CapaTest(OBJ_Capa_0) )
			{
				v_laser_shoot_pos = @o_main_actor OBJ_PosGet()
	
				f_laser_phase_duration += TIME_GetDt()
	
				if (f_laser_phase_duration > 20.0)
				{
					i_laser_state = Ci_Laser_Init
					f_laser_phase_duration = 0.0
				}
			}
			break
	}
}

procedure_local void PNJ_Slalomator_GFX_Smoke()
{
	vector	tv_pos
	vector	tv_wind

//	if (OBJ_LodVisGet()  < 0.6)
//	{
//		if (GFX_Smoke != -1)
//		{
//			GFX_Seti(GFX_Smoke, 13106, 0)												// *number of sprite to generate
//			GFX_Smoke = -1
//		}
//		return
//	}

	if (GFX_Smoke == -1)
	{
		GFX_Smoke = GFX_Add(13)																// Create the boum
		
		GFX_MaterialSet(GFX_Smoke, get_SFX_light_and_smoke, -1)						// met le materiau
		GFX_Seti(GFX_Smoke, 13101, 8)															// Materiau 0

		GFX_Seti(GFX_Smoke, 13100, 100)															// *Buffer number of sprite
		GFX_Seti(GFX_Smoke, 13106, 0xFFFFFFFF)												// *number of sprite to generate
	
		GFX_Setf(GFX_Smoke, 13003, 0.1)															// Time fase 1
		GFX_Setf(GFX_Smoke, 13004, 0.75)															// Time fase 2
	
		GFX_Seti(GFX_Smoke, 13107, 0)															// Sprites non triés
	
		GFX_FlagSet(GFX_Smoke, 0 , 1)
		GFX_FlagSet(GFX_Smoke, 2 , 1)
		
		GFX_Setf(GFX_Smoke, 13012, 0.75)														// Time random
	
		GFX_Setv(GFX_Smoke, 13203, cvector(0.01, 0.01, 0.01))					// friction speed
		GFX_Setf(GFX_Smoke, 13000, 1.0)														// Growing speed min
		GFX_Setf(GFX_Smoke, 13001, 2.0)														// Growing speed max
		GFX_Setf(GFX_Smoke, 13002, 0.0001)													// Friction Grow

		GFX_Setf(GFX_Smoke, 13007, 1.0)														// Gravity

		GFX_Setf(GFX_Smoke, 13008, 0.02)														// generation rate
	
		GFX_Setv(GFX_Smoke, 13205, Cv_NullVector)										// Mainposspeed
		GFX_Setv(GFX_Smoke, 13206, Cv_NullVector)										// Mainpossfriction

		GFX_Setv(GFX_Smoke, 13201, cvector(-1.0, -1.0, 0.0))							// Speed min
		GFX_Setv(GFX_Smoke, 13202, cvector(1.0, 1.0, 0.0))								// Speed max
		GFX_Setf(GFX_Smoke, 13009, 40.0)							// Norm speed min
		GFX_Setf(GFX_Smoke, 13010, 50.0)									// Norm speed max
		GFX_Setf(GFX_Smoke, 13005, 4.0)														// Creation size min
		GFX_Setf(GFX_Smoke, 13006, 6.0)														// Creation size max
	}

	GFX_Seti(GFX_Smoke, 13103, COLOR_Blend(0x40456779, 0x00000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 0
	GFX_Seti(GFX_Smoke, 13104, COLOR_Blend(0xEE456779, 0x80000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 1
	GFX_Seti(GFX_Smoke, 13105, COLOR_Blend(0x00456779, WOR_AmbiantColGet(0) & 0x00FFFFFF, 0.5))	// Color fase 2

	tv_wind = Cv_NullVector
	GFX_Setv(GFX_Smoke, 13204, tv_wind)												// wind

	tv_pos = OBJ_PosGet()
	tv_pos.z = @o_main_actor OBJ_PosGet().z + 4.0
	tv_pos -= tv_wind * TIME_GetDt()
	GFX_Setv(GFX_Smoke, 13200, tv_pos) 								// Creation Pos
}

procedure_local void PNJ_Slalomator_Orient()
{
	float		tf_coef
	float		tf_dist	

	vector	tv_pos
	vector	tv_last_pos
	vector	tv_dest_sight
	vector	tv_dest_banking
	
//	tv_dest_sight = @o_main_actor OBJ_PosGet()
//	tv_dest_sight += @o_main_actor DYN_SpeedGetVector() * 3.0
//	tv_dest_sight += @o_main_actor OBJ_SightGet() * 100.0
//	tv_dest_sight.z = OBJ_PosGet().z

	if (TIME_Elapsed(f_last_ray_time, 0.2))
	{
		COL_RayObject_Dist(OBJ_PosGet() + cvector(0.0, 0.0, 10.0), -Cv_VerticalVector, 50.0, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
		f_dest_Z = COL_RayObject_PosGet().z + 5.0
	}

	v_last_pos = OBJ_PosGet()

	tv_dest_sight = v_me_to_main
	tf_dist = f_me_to_main

//	tv_dest_banking.x = tv_dest_sight.y
//	tv_dest_banking.y = -tv_dest_sight.x
//	tv_dest_banking.z = 0.0
//	if (MATH_VecDotProduct(@o_main_actor OBJ_PosGet() - OBJ_PosGet(), tv_dest_banking) > 0.0)
//		tv_dest_banking *= -25.0
//	else
//		tv_dest_banking *= 25.0
	
	tf_dist -= 100.0
	tf_dist += MATH_FloatMin(MATH_VecDotProduct(@o_main_actor DYN_SpeedGetVector(), tv_dest_sight), 0.0)
	tv_dest_sight *= tf_dist
//	tv_dest_sight += tv_dest_banking
	tv_dest_sight += @o_pivot OBJ_PosGet()
	tv_dest_sight.z = OBJ_PosGet().z

	tv_pos = tv_dest_sight - @o_pivot OBJ_PosGet()
	tv_pos.z = 0.0
	tf_dist = MATH_VecSquareNorm(tv_pos) 
	if (tf_dist > dist_max * dist_max)
	{
		tf_dist = MATH_FloatSqrt(tf_dist)
		tv_pos /= tf_dist
		tv_pos *= dist_max
		tv_pos += @o_pivot OBJ_PosGet()
		tv_dest_sight = tv_pos
		tv_dest_sight.z = OBJ_PosGet().z

		tv_dest_sight = MATH_VecBlend(v_dest_pos, tv_dest_sight, 6.0 * TIME_GetDt())
		tv_dest_sight.z = MATH_FloatBlend(tv_dest_sight.z, f_dest_Z, 8.0 * TIME_GetDt())
		v_dest_pos	= tv_dest_sight
		tv_pos = v_dest_pos
	}
	else
	{
		tf_coef = f_me_to_main
		tf_coef -= dist_min
		
		if (tf_coef < 50.0)
		{
			tf_coef /= 50.0
			tf_coef = MATH_FloatMax(tf_coef, 0.0)
			
			tv_pos = OBJ_PosGet()
			tv_pos.z -= 20.0
			v_grav_pos = MATH_VecBlend(tv_pos, v_grav_pos, tf_coef)
			v_grav_speed = MATH_VecBlend(Cv_NullVector, v_grav_speed, tf_coef)

			v_dest_pos = MATH_VecBlend(@o_main_actor OBJ_PosGet() + cvector(0.0, 0.0, MATH_Sin(tf_coef * Cf_Pi) * 10.0), tv_dest_sight, tf_coef)
			tv_pos = v_dest_pos
		}
		else
		{
			tv_dest_sight = MATH_VecBlend(v_dest_pos, tv_dest_sight, 6.0 * TIME_GetDt())
			tv_dest_sight.z = MATH_FloatBlend(tv_dest_sight.z, f_dest_Z, 8.0 * TIME_GetDt())
			v_dest_pos	= tv_dest_sight
			tv_pos = v_dest_pos
		}
	}

	OBJ_PosSet(tv_pos)

	tv_dest_sight = @o_main_actor OBJ_PosGet()
	tv_dest_sight -= OBJ_PosGet()
	tv_dest_sight.z = 0.0
	if (MATH_VecSquareNorm(tv_dest_sight) > 0.001)
		tv_dest_sight = MATH_VecBlendRotate(OBJ_SightGet(), tv_dest_sight, 6.0 * TIME_GetDt())
	else
		tv_dest_sight = OBJ_SightGet()

	tv_last_pos = v_grav_pos
	v_grav_pos += v_grav_speed * 0.9 * TIME_GetDt()
	v_grav_pos.z -= 20.0 * TIME_GetDt()
	v_grav_pos -= OBJ_PosGet()
	MATH_VecSetNormalize(v_grav_pos)
	tv_dest_banking = -v_grav_pos
	v_grav_pos *= 20.0
	v_grav_pos += OBJ_PosGet()
	v_grav_speed = (v_grav_pos - tv_last_pos) / TIME_GetDt()

	tv_dest_banking = MATH_VecBlendRotate(OBJ_BankingGet(), tv_dest_banking, 6.0 * TIME_GetDt())
	OBJ_BankingGeneralSet(tv_dest_sight, tv_dest_banking)
}

