//----------------------------------------------------------------------------------------------------------------------------------------
// 					ON LIBERE LE RESEAU PASSANT PAR LE MUR DETRUIT
//----------------------------------------------------------------------------------------------------------------------------------------
procedure_local vector PROC_CALC_CENTER_BV(vector tv_V1, vector tv_V2, int ti_cpt)
{
	vector tv_temp

	tv_temp.x = (tv_V1.x + tv_V2.x) * 0.5
	tv_temp.y = (tv_V1.y + tv_V2.y) * 0.5
	tv_temp.z = (tv_V1.z + tv_V2.z) * 0.5

	return (tv_temp + @o_modules[ti_cpt] OBJ_PosGet())
}


//----------------------------------------------------------------------------------------------------------------------------------------
// 					ON LIBERE LE RESEAU PASSANT PAR LE MUR DETRUIT
//----------------------------------------------------------------------------------------------------------------------------------------
procedure_local float PROC_CALC_TAILLE_BV(int ti_val)
{
	float	tf_X, tf_Y, tf_Z

	tf_X = @o_modules[ti_val] BV_MinGet().x - @o_modules[ti_val] BV_MaxGet().x
	tf_Y = @o_modules[ti_val] BV_MinGet().y - @o_modules[ti_val] BV_MaxGet().y
	tf_Z = @o_modules[ti_val] BV_MinGet().z - @o_modules[ti_val] BV_MaxGet().z

	return ((tf_X + tf_Y + tf_Z))
}


//----------------------------------------------------------------------------------------------------------------------------------------
// 						EFFACEMENT / AFFICHAGE DES BLOCS PAFFABLES
//----------------------------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_HIDE_ALL_MODULES(int ti_etat)
{
	int ti_cpt1
	
	for (ti_cpt1=0; ti_cpt1<i_nb_modules; ti_cpt1++)
		@o_modules[ti_cpt1] OBJ_FlagInvisibleSet(ti_etat)
}


//----------------------------------------------------------------------------------------------------------------------------------------
// 											TEST DE PAF SUR UN BLOC
//----------------------------------------------------------------------------------------------------------------------------------------

procedure_local int PROC_IS_PAF_MODULE(int ti_cpt, vector tv_paf)
{
	return (@o_modules[ti_cpt] COL_BV_PointCollide(tv_paf))
}


//----------------------------------------------------------------------------------------------------------------------------------------
// 						DEPLACEMENT D'UN BLOC VENANT D'ETRE DETRUIT
//----------------------------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_DEPLACE_MODULE(int ti_cpt)
{
	vector	tv_pos, tv_rot
	float		tf_temp
	
	v_etat_modules[ti_cpt].x += v_gravite.x * TIME_GetDt()
	v_etat_modules[ti_cpt].y += v_gravite.y * TIME_GetDt()
	v_etat_modules[ti_cpt].z += v_gravite.z * TIME_GetDt()

	@o_modules[ti_cpt] OBJ_RotateLocal(v_rot_modules[ti_cpt] * TIME_GetDt())

	tv_pos = @o_modules[ti_cpt] OBJ_PosGet()
	@o_modules[ti_cpt] OBJ_PosSet(tv_pos + v_etat_modules[ti_cpt])

	if (o_ref_sol)
		tf_temp = @o_ref_sol OBJ_PosGet().z
	else
		tf_temp = OBJ_PosGet().z//@o_modules[ti_cpt] BV_MaxGet().z

	if ( (@o_modules[ti_cpt] OBJ_PosGet().z + @o_modules[ti_cpt] BV_MaxGet().z ) < tf_temp)
	{
		@o_modules[ti_cpt] OBJ_Destroy()
		i_etat_modules[ti_cpt] = 2
	}
}


//----------------------------------------------------------------------------------------------------------------------------------------
// 					DESTRUCTION D'UN BLOC VENANT DE RECEVOIR UN PAF
//----------------------------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_DESTRUCTION_MODULE(int ti_cpt, vector tv_dir_collide, float tf_vit_rot)
{
	float tf_temp, tf_val

	@o_modules[ti_cpt] COL_ColMapActivationSet(none,all)
	@o_modules[ti_cpt] OBJ_FlagInactiveSet(vrai)
	
	tf_temp = 0.025
	if (tf_vit_rot < 0.0)
	{
		v_etat_modules[ti_cpt].x += (1/tv_dir_collide.x) * tf_temp * MATH_RandFloat(0.5,1.5)
		v_etat_modules[ti_cpt].y += (1/tv_dir_collide.y) * tf_temp * MATH_RandFloat(0.5,1.5)
		v_etat_modules[ti_cpt].z = MATH_AbsFloat(1/tv_dir_collide.z) * tf_temp * MATH_RandFloat(1.0,1.5)
	}
	else
		v_etat_modules[ti_cpt] = Cv_NullVector

	
	if (tf_vit_rot < 0.0)
		v_rot_modules[ti_cpt] = cvector(MATH_RandFloat(-f_vit_rot_mod,f_vit_rot_mod), MATH_RandFloat(-f_vit_rot_mod,f_vit_rot_mod), MATH_RandFloat(-f_vit_rot_mod,f_vit_rot_mod))
	else
		v_rot_modules[ti_cpt] = cvector(MATH_RandFloat(-tf_vit_rot,tf_vit_rot), MATH_RandFloat(-tf_vit_rot,tf_vit_rot), MATH_RandFloat(-tf_vit_rot,tf_vit_rot))

	if (i_etat_modules[ti_cpt] == 1)
		PROC_DEPLACE_MODULE(ti_cpt)
}


//----------------------------------------------------------------------------------------------------------------------------------------
// 					ON LIBERE LE RESEAU PASSANT PAR LE MUR DETRUIT
//----------------------------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_FREE_NETWORK(int ti_activ)
{
	network	tn_net
	object	to_gao
	int			ti_cpt

	tn_net = WAY_NetOfObj()
	
	if (tn_net)
	{
		@get_global i_BVTerritory_LinkHasChanged = 2
	
		for (ti_cpt = 0; ti_cpt < WAY_GetNumLinks(tn_net, OBJ_Me()); ti_cpt++)
		{
			to_gao = WAY_NetNextWP(tn_net, OBJ_Me(), NetNextWP_Mode_choix_de_lindice, ti_cpt)
			if (ti_activ)
				WAY_LinkCapaSet(tn_net,OBJ_Me(),to_gao, none, OBJ_Capa_0) // On autorise le lien
			else
				WAY_LinkCapaSet(tn_net,OBJ_Me(),to_gao, OBJ_Capa_0, none) // On interdit le lien
		}
	}
}