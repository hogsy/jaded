#include "SFX_Papillons_VAR.var"

int 		ti_cpt1
vector	tv_dir, tv_old_pos, tv_old_dir, tv_dest
float 		tf_tmp_amp, tf_tmp
vector 	tv_BV_min, tv_BV_max

DBG_StartRaster(1,"Raster papillons total")
	//---------------------------------------------------------------------------------------------------------------------
	//		MODIFICATION DE LA POSITION DES WP
	//---------------------------------------------------------------------------------------------------------------------
	for (ti_cpt1 = 0; ti_cpt1<i_nb_creatures ; ti_cpt1++)
	{
		tv_BV_min = @o_BV_ref BV_MinGet() + (@o_BV_ref OBJ_PosGet() - OBJ_PosGet())
		tv_BV_max = @o_BV_ref BV_MaxGet() + (@o_BV_ref OBJ_PosGet() - OBJ_PosGet())

		// On initialise la gravité à Null
		//-------------------------------------------------------
		// 	BACKUP ANCIENNES VALEURS
		//-------------------------------------------------------
		// On mémorise l'ancienne valeur de la direction
		tv_old_dir = v_list_dir_obj[ti_cpt1]
		// Idem pour l'ancienne position
		tv_old_pos = v_list_obj[ti_cpt1]
		// idem pour l'ancienne position de destination
		tv_dest = v_list_dest_obj[ti_cpt1]

		//-------------------------------------------------------
		// 	CALCUL NOUVELLE VALEURS
		//-------------------------------------------------------
		// On détermine la nouvelle direction à suivre
		tv_dir = tv_dest - tv_old_pos

		//-----------------------------------------------------
		// Blindage vecteur nul v_attenuation
		if (f_attenuation== 0.0000)
			f_attenuation= 0.0001

		//------------------------------------------------------------
		// On test si on doit désactiver le papillon
		tf_tmp = MATH_RandInt(0,i_freq_stop_battement)

		if (tf_tmp == 0) 
			i_active[ti_cpt1] = faux

		//------------------------------------------------------------
		// On test si on doit activer le papillon
		tf_tmp = MATH_RandInt(0,i_freq_star_battement)
		
		if (tf_tmp == 0)
			i_active[ti_cpt1] = vrai

		//-------------------------------------------------------------------------------------------------------------
		// On test si le papillon est sous la BV, dans ce cas on réactive le papillon
		if (@o_list_obj[ti_cpt1] OBJ_PosGet().z < tv_BV_min.z)
			i_active[ti_cpt1] = vrai


		if (i_active[ti_cpt1])
		{
			// On le fait battre des ailes
			tf_tmp_amp = @o_list_obj[ti_cpt1] OBJ_MorphProgGet(0) -2

			if (i_sens_battement[ti_cpt1] == 0)
			{
				tf_tmp = tf_tmp_amp + ((f_vitesse_battement + MATH_RandFloat(0,f_random_vitesse_battement)) * TIME_GetDt())
				if (tf_tmp>1.0)
				{
					tf_tmp = 1.0
					i_sens_battement[ti_cpt1] = 1
				}
			}
			else
			{
				tf_tmp = tf_tmp_amp - ((f_vitesse_battement + MATH_RandFloat(0,f_random_vitesse_battement)) * TIME_GetDt())
				if (tf_tmp<0.0)
				{
					tf_tmp = 0.0
					i_sens_battement[ti_cpt1] = 0
				}
			}

			@o_list_obj[ti_cpt1] OBJ_MorphProgSet(0, 2+tf_tmp)

			// On détermine sa nouvelle position
			if (@o_BV_ref COL_BV_PointCollide(@o_list_obj[ti_cpt1] OBJ_PosGet()))
				v_list_obj[ti_cpt1] = (tv_old_pos + (f_vitesse * (tv_old_dir + (tv_dir * f_attenuation)) * TIME_GetDt()))
			else
				v_list_obj[ti_cpt1] = (tv_old_pos + (f_vitesse_hors_BV * (tv_old_dir + (tv_dir * f_attenuation)) * TIME_GetDt()))
		}
		else
		{
			//v_list_obj[ti_cpt1] = (tv_old_pos + ((f_vitesse * (tv_old_dir + (tv_old_dir * f_attenuation)) + (tv_gravite)) * TIME_GetDt()))
			if (@o_BV_ref COL_BV_PointCollide(@o_list_obj[ti_cpt1] OBJ_PosGet()))
				v_list_obj[ti_cpt1] = (tv_old_pos + (f_vitesse * (tv_old_dir + (tv_dir * f_attenuation)) * TIME_GetDt()))
			else
				v_list_obj[ti_cpt1] = (tv_old_pos + (f_vitesse_hors_BV * (tv_old_dir + (tv_dir * f_attenuation)) * TIME_GetDt()))
		}

		// On backup la direction de l'objet
		v_list_dir_obj[ti_cpt1] = MATH_VecNormalize(v_list_obj[ti_cpt1] - tv_old_pos)

		@o_list_obj[ti_cpt1] OBJ_SightSet(v_list_dir_obj[ti_cpt1])

		//---------------------------------------------------------------------------------------------------------------------
		//			TEST DE DISTANCE PAR RAPPORT A LA DESTINATION
		//---------------------------------------------------------------------------------------------------------------------
		if (MATH_VecSquareNorm(v_list_obj[ti_cpt1] - v_list_dest_obj[ti_cpt1]) < f_distance)
			v_list_dest_obj[ti_cpt1] = PROC_GEN_WP_PAPILLON(tv_BV_min, tv_BV_max, v_list_dest_obj[ti_cpt1], f_dist_gen)
			

		//---------------------------------------------------------------------------------------------------------------------
		//								RENDU DES PARTICULES
		//---------------------------------------------------------------------------------------------------------------------
		

		@o_list_obj[ti_cpt1] OBJ_PosSet(OBJ_PosGet() + v_list_obj[ti_cpt1])
}

DBG_StopRaster(1)