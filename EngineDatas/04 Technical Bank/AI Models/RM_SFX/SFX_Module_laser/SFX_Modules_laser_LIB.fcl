#include "SFX_Module_laser_VAR.var"

//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE DE TEST DES ACTIVATIONS
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_TEST_ACTIVATION()
{
	// Tests de capas :
	//		- capa 25 : ACTIVATION
	//		- capa 26 : activation du sol
	//		- capa 27 : activation du plafond
	//		- capa 28 : activation du mur gauche
	//		- capa 29 : activation du mur droit
	if(OBJ_CapaTest(33554432))		// Capa 25
		ACTIVATION = vrai
	else
		ACTIVATION = faux

	if(OBJ_CapaTest(67108864))		// Capa 26
		i_active_sol = vrai
	else
		i_active_sol = faux

	if(OBJ_CapaTest(134217728))		// Capa 27
		i_active_plafond = vrai
	else
		i_active_plafond = faux

	if(OBJ_CapaTest(268435456))		// Capa 28
		i_active_gauche = vrai
	else
		i_active_gauche = faux

	if(OBJ_CapaTest(536870912))		// Capa 28
		i_active_droite = vrai
	else
		i_active_droite = faux
}

//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE DE MISE A JOUR DE CAPAS
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_SET_ACTIVATION()
{
	// Capas :
	//		- capa 25 : ACTIVATION
	//		- capa 26 : activation du sol
	//		- capa 27 : activation du plafond
	//		- capa 28 : activation du mur gauche
	//		- capa 29 : activation du mur droit

	if(ACTIVATION)
		OBJ_CapaSet(33554432,vrai)

	if(i_active_sol)
		OBJ_CapaSet(67108864,vrai)

	if(i_active_plafond)
		OBJ_CapaSet(134217728,vrai)

	if(i_active_gauche)
		OBJ_CapaSet(268435456,vrai)

	if(i_active_droite)
		OBJ_CapaSet(536870912,vrai)
}


//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE DE REMISE A ZERO DES MATERIAUX
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_RAZ_MAT(int val)
{
	int cpt

	for (cpt = 1; cpt<5; cpt++)
	{
		MAT_MT_EnableLevel(cpt,0,val)
		MAT_MT_EnableLevel(cpt,1,val)
		MAT_MT_EnableLevel(cpt,2,val)
	}
}


//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE DE REMISE A ZERO DES FLARES
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_RAZ_FLARES(int val)
{
	int cpt
	// Remise à zéro des flares
	for (cpt=0; cpt<NB_FLARES; cpt++)
	{
		// Si le flare a déjà été créé, on le supprime
		if (i_GFX_Flares[cpt] != -1)
		{
			GFX_Del(i_GFX_Flares[cpt])
		}

		i_GFX_Activation_flares[cpt] = val
		i_GFX_Flares[cpt] = -1
	}
}


//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE DE REMISE A ZERO DES LASERS
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_RAZ_LASERS(int val)
{
	int cpt
	// Remise à zéro des lasers	
	for (cpt=0; cpt<NB_LASERS; cpt++)
	{
		// Si le laser a déjà été créé, on le supprime
		if (i_GFX_Lasers[cpt] != -1)
		{
			GFX_Del(i_GFX_Lasers[cpt])
		}

		i_GFX_Activation_lasers[cpt] = val
		i_GFX_Lasers[cpt] = -1
	}
}


//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE DE DETERMINATION DE LA COULEUR
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_TEST_COULEUR()
{
	int cpt
	int SubMat

	// On ne change quelque chose QUE si la couleur actuelle est différente de la couleur définie en param LD
	if (couleur_actuelle != couleur_lasers)
	{
		// RAZ matériaux en cas de changement de quelque chose
		for (cpt = 1; cpt<5; cpt++)
		{
			MAT_MT_EnableLevel(cpt,0,faux)
			MAT_MT_EnableLevel(cpt,1,faux)
			MAT_MT_EnableLevel(cpt,2,faux)
		}

		couleur_actuelle = couleur_lasers
		// Détermination des bons material ID des flares et des lasers
		if (couleur_lasers == 0)
		{
			id_mat_flare = 52
			id_mat_rayon = 49
			i_MatLayer = 0
		}
		else
		{
			if (couleur_lasers == 1)
			{
				id_mat_flare = 53
				id_mat_rayon = 50
				i_MatLayer = 1
			}
			else
			{
				id_mat_flare = 54
				id_mat_rayon = 51
				i_MatLayer = 2
			}
		}

		// Changement de couleur des flares et des lasers actifs
		for (cpt = 0; cpt<NB_FLARES; cpt++)
		{
			if (i_GFX_Flares[cpt] != -1)
				GFX_MaterialSet(i_GFX_Flares[cpt], get_SFX_light_and_smoke, id_mat_flare)				// affectation du matériau
		}
		
		for (cpt = 0; cpt<NB_LASERS; cpt++)
		{
			if (i_GFX_Lasers[cpt] != -1)
				GFX_MaterialSet(i_GFX_Lasers[cpt], get_SFX_light_and_smoke, id_mat_rayon )			// affectation du matériau
		}
	}

	// Activation / désactivation des plans
	if (i_active_sol)
		MAT_MT_EnableLevel(1,i_MatLayer,vrai)
	else
		MAT_MT_EnableLevel(1,i_MatLayer,faux)

	if (i_active_plafond)
		MAT_MT_EnableLevel(2,i_MatLayer,vrai)
	else
		MAT_MT_EnableLevel(2,i_MatLayer,faux)

	if (i_active_gauche)
		MAT_MT_EnableLevel(3,i_MatLayer,vrai)
	else
		MAT_MT_EnableLevel(3,i_MatLayer,faux)

	if (i_active_droite)
		MAT_MT_EnableLevel(4,i_MatLayer,vrai)
	else
		MAT_MT_EnableLevel(4,i_MatLayer,faux)
}


//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE D'AFFICHAGE DES FLARES
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_AFFICHE_FLARES(float largeur)
{
	int cpt
	// On boucle sur le nombre de flares
	for (cpt = 0; cpt<NB_FLARES; cpt++)
	{
		if ((i_GFX_Flares[cpt] == -1) && i_GFX_Activation_flares[cpt])
		{
			// Rentu des flares
			i_GFX_Flares[cpt] = GFX_Add(21)                  							 							// ajout de l’effet
			GFX_MaterialSet(i_GFX_Flares[cpt], get_SFX_light_and_smoke, id_mat_flare)			// affectation du matériau
			GFX_Seti(i_GFX_Flares[cpt], 21101, 0xFFFFFFFF)												// couleur du halo
			GFX_Setf( i_GFX_Flares[cpt], 21001, 0.5)															// taille du halo
			GFX_Seti( i_GFX_Flares[cpt], 21103, 1)															// taille du halo
		}
		GFX_Setf( i_GFX_Flares[cpt], 21000, largeur * 10 - 0.1)												// taille du halo
	}
	
	//Positionnement des flares
	for (cpt = 0; cpt < NB_FLARES; cpt++)
	{
		GFX_Setv(i_GFX_Flares[cpt], 21200, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[cpt]))		// Position

	}
}

//--------------------------------------------------------------------------------------------------------------------
//		PROCEDURE D'AFFICHAGE DES LASERS
//--------------------------------------------------------------------------------------------------------------------
procedure_local void PROC_AFFICHE_LASERS(float largeur)
{
	int cpt
	// On boucle sur le nombre de lasers
	for (cpt = 0; cpt<NB_LASERS; cpt++)
	{
		if ((i_GFX_Lasers[cpt] == -1) && i_GFX_Activation_lasers[cpt])
		{
			//-------------------
			// RENDU
			i_GFX_Lasers[cpt] = GFX_Add(1)                   								 						// ajout de l’effet
			GFX_FlagSet(i_GFX_Lasers[cpt], 0, 1)        	    														// activation de l’effet
			GFX_FlagSet(i_GFX_Lasers[cpt], 2, 1)            														// le matériau utilié sera transparent
			GFX_MaterialSet(i_GFX_Lasers[cpt], get_SFX_light_and_smoke, id_mat_rayon)		// affectation du matériau
			GFX_Seti(i_GFX_Lasers[cpt], 1100, 0xFFFFFFFF)          										// couleur du laser (blanc et opaque)
		}
		GFX_Setf(i_GFX_Lasers[cpt], 1000, largeur)        														// taille du laser
	}

	// On positionne correctement les lasers
	for (cpt = 0; cpt<NB_FLARES-1; cpt++)
	{
		GFX_Setv(i_GFX_Lasers[cpt], 1200, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[cpt]))									// Position de la source du laser
		GFX_Setv(i_GFX_Lasers[cpt], 1201, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[cpt+1]))								// Position de la destination du laser
	}
	
	// Traitement des 2 cas spéciaux
	GFX_Setv(i_GFX_Lasers[7], 1200, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[7]))											// Position de la source du laser
	GFX_Setv(i_GFX_Lasers[7], 1201, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[0]))											// Position de la destination du laser
	GFX_Setv(i_GFX_Lasers[15], 1200, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[15]))										// Position de la source du laser
	GFX_Setv(i_GFX_Lasers[15], 1201, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[8]))										// Position de la destination du laser

	// Positionnement des lasers transversaux
	for (cpt = 16; cpt<NB_LASERS; cpt++)
	{
		GFX_Setv(i_GFX_Lasers[cpt], 1200, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[cpt-16]))							// Position de la source du laser
		GFX_Setv(i_GFX_Lasers[cpt], 1201, OBJ_PosGet() + MATH_VecLocalToGlobal(v_pos[cpt-8]))								// Position de la destination du laser

	}
}


procedure_local void PROC_SUPPR_FLARE(int ti_num)
{
	if (i_GFX_Flares[ti_num] != -1)
	{
		GFX_Del(i_GFX_Flares[ti_num])
	}

	i_GFX_Activation_flares[ti_num] = faux
	i_GFX_Flares[ti_num] = -1
}


procedure_local void PROC_SUPPR_LASER(int ti_num)
{
	if (i_GFX_Lasers[ti_num] != -1)
	{
		GFX_Del(i_GFX_Lasers[ti_num])
	}

	i_GFX_Activation_lasers[ti_num] = faux
	i_GFX_Lasers[ti_num] = -1
}


procedure_local void PROC_TEST_ACTIVE_FLARES()
{
	// Activation mur plafond
	if (i_active_plafond)
	{
		i_GFX_Activation_flares[0] = vrai
		i_GFX_Activation_flares[8] = vrai
		i_GFX_Activation_flares[7] = vrai
		i_GFX_Activation_flares[15] = vrai
		i_GFX_Activation_flares[6] = vrai
		i_GFX_Activation_flares[14] = vrai
	}
	else
	{
		PROC_SUPPR_FLARE(7)
		PROC_SUPPR_FLARE(15)
	}

	// Activation mur gauche
	if (i_active_gauche)
	{
		i_GFX_Activation_flares[0] = vrai
		i_GFX_Activation_flares[8] = vrai
		i_GFX_Activation_flares[1] = vrai
		i_GFX_Activation_flares[9] = vrai
		i_GFX_Activation_flares[2] = vrai
		i_GFX_Activation_flares[10] = vrai
	}
	else
	{
		PROC_SUPPR_FLARE(1)
		PROC_SUPPR_FLARE(9)
	}

	// Activation mur sol
	if (i_active_sol)
	{
		i_GFX_Activation_flares[2] = vrai
		i_GFX_Activation_flares[10] = vrai
		i_GFX_Activation_flares[3] = vrai
		i_GFX_Activation_flares[11] = vrai
		i_GFX_Activation_flares[4] = vrai
		i_GFX_Activation_flares[12] = vrai
	}
	else
	{
		PROC_SUPPR_FLARE(3)
		PROC_SUPPR_FLARE(11)
	}

	// Activation mur droite
	if (i_active_droite)
	{
		i_GFX_Activation_flares[4] = vrai
		i_GFX_Activation_flares[12] = vrai
		i_GFX_Activation_flares[5] = vrai
		i_GFX_Activation_flares[13] = vrai
		i_GFX_Activation_flares[6] = vrai
		i_GFX_Activation_flares[14] = vrai
	}
	else
	{
		PROC_SUPPR_FLARE(5)
		PROC_SUPPR_FLARE(13)
	}
	
	if ((i_active_plafond == faux) && (i_active_gauche == faux))
	{
		PROC_SUPPR_FLARE(0)
		PROC_SUPPR_FLARE(8)
	}

	if ((i_active_gauche == faux) && (i_active_sol == faux))
	{
		PROC_SUPPR_FLARE(2)
		PROC_SUPPR_FLARE(10)
	}

	if ((i_active_sol == faux) && (i_active_droite == faux))
	{
		PROC_SUPPR_FLARE(4)
		PROC_SUPPR_FLARE(12)
	}

	if ((i_active_droite == faux) && (i_active_plafond == faux))
	{
		PROC_SUPPR_FLARE(6)
		PROC_SUPPR_FLARE(14)
	}
}


procedure_local void PROC_TEST_ACTIVE_LASERS()
{
	int cpt

	// Test première barrière de lasers
	for (cpt = 0; cpt<((NB_FLARES/2)-1); cpt++)
	{
		if ((i_GFX_Activation_flares[cpt]) && (i_GFX_Activation_flares[cpt+1]))
		{
			i_GFX_Activation_lasers[cpt] = vrai
		}
		else
		{
			PROC_SUPPR_LASER(cpt)
		}
	}

	// Test seconde barrière de lasers
	for (cpt = (NB_FLARES/2); cpt<NB_FLARES-1; cpt++)
	{
		if ((i_GFX_Activation_flares[cpt]) && (i_GFX_Activation_flares[cpt+1]))
		{
			i_GFX_Activation_lasers[cpt] = vrai
		}
		else
		{
			PROC_SUPPR_LASER(cpt)
		}
	}

	// Cas parriculiers
	if ((i_GFX_Activation_flares[(NB_FLARES/2)-1]) && (i_GFX_Activation_flares[0]))
	{
		i_GFX_Activation_lasers[(NB_FLARES/2)-1] = vrai
	}
	else
	{
		PROC_SUPPR_LASER((NB_FLARES/2)-1)
	}


	if ((i_GFX_Activation_flares[NB_FLARES-1]) && (i_GFX_Activation_flares[NB_FLARES/2]))
	{
		i_GFX_Activation_lasers[NB_FLARES-1] = vrai
	}
	else
	{
		PROC_SUPPR_LASER(NB_FLARES-1)
	}
	
	// Test lasers transversaux
	for (cpt = 0; cpt<((NB_FLARES/2)); cpt++)
	{
		if ( (i_GFX_Activation_flares[cpt]) && (i_GFX_Activation_flares[cpt+ (NB_FLARES/2) ] ) )
		{
			i_GFX_Activation_lasers[cpt + NB_FLARES] = vrai
		}
		else
		{
			PROC_SUPPR_LASER(cpt + NB_FLARES)
		}
	}
}
