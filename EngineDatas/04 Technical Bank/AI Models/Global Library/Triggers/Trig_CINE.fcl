///TrigCINE_LockMenu
//============================================================
// Param IN : le temps pendant lequel le menu sera inaccessible doit etre mis dans la 
//				composante x du vecteur vec1
// Param OUT : None
// lock le menu pendant un certain temps
//============================================================
procedure_trigger int TrigCINE_LockMenu( byref message m_msg ) // vec1 time_lock_in_x
{
	vector v
	v = m_msg.msg_vec1
	@"univ" MENU_f_LockedDuring = v.x
	return vrai
}

////TrigCINE_SndSfx
////============================================================
//// Param IN: 
////					texte		-	numéro du texte dans le tableau du PRG_ScriptSimple
////					arret		-	0 -> pas de synchro, 1 -> attente fin 2
////					timeout  -   valeur du time-out en sec (si 0 => valeur par defaut)
////
////	NE PAS UTILISER VEC4 !!!!!!!!!!!!!!!!!!!!!!!!!!!!
////
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_SndSfx(byref message m_msg) //  int1 numero int2 arret vec1 timeout_inX
//{
// 	object  		o
// 	text			txt
// 	message 	tm_msg
// 	int				ti_track 
// 	vector		tv, tv_temp
// 	float 			tf
//
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_SndSfx\n")
//#endif
//
//	if( m_msg.msg_int5 == 0 )
//	{
//		// first call => send the request
//		//-----------------------------------------
//		
//		// get the text
//		o = m_msg.msg_sender
//		txt = @"Progression/PRG_ScriptSimple" o texts[m_msg.msg_int1]
//			
//		// set the message
//		MSG_SetNull(tm_msg)
//		tm_msg.msg_gao1 = nobody 		
//		tf = SPEECH_Cte_TimeOutDefault
//		tv = 	m_msg.msg_vec1
//		if( tv.x )
//			tf = tv.x
//		tm_msg.msg_vec1 = cvector(0, SPEECH_Cte_PriorityDefault, tf)		 
//		tm_msg.msg_int1 = TEXT_FileGet(txt)
//		tm_msg.msg_int2 = TEXT_EntryGet(txt)
//		tm_msg.msg_int3 = 0
//		tm_msg.msg_int4 = 0
//		tm_msg.msg_int5 = 0		
//		
//		// send the rq
//		MSG_GlobalSend( C_EVENT_TYPE_Speech, Cf_EVENT_Duree_1Trame, tm_msg, C_EVENT_EOFADD)
//		m_msg.msg_gao1 = TEXT_ObjectGet(txt)
//	}
//
//	if(m_msg.msg_int2) 
//	{
//		// synchro is requested
//		//-------------------------------
//		if(	m_msg.msg_int5 == 0)
//		{
//			// register the rq is just sended
//			m_msg.msg_int5 = 1
//			m_msg.msg_vec4 = Cv_NullVector
//			return faux //wait
//		}
//		else if(	m_msg.msg_int5 == 1)
//		{
//			tv_temp = m_msg.msg_vec4
//			tv_temp.x += TIME_GetDt()
//			m_msg.msg_vec4 = tv_temp
//			if(tv_temp.x > 3)
//			{
//				m_msg.msg_int5 = 3
//				return vrai // speech ended => nowait
//			}
//			
//			// the rq was sended, but not played
//			for( ti_track = 0; ti_track<2; ti_track++)
//			{
//				if( !@get_speech ao_current_target[ti_track] ) continue
//				if( @get_speech ao_current_target[ti_track] == m_msg.msg_gao1) 
//				{
//					// gao start talking
//					m_msg.msg_int5 = 2
//					return faux // wait
//				}
//			}
//			
//			return faux // not yet started => wait
//		}
//		else if( m_msg.msg_int5 == 2 )
//		{
//			// the rq was sended, and started
//			for( ti_track = 0; ti_track<2; ti_track++)
//			{
//				if( !@get_speech ao_current_target[ti_track] ) continue
//				if( @get_speech ao_current_target[ti_track] == m_msg.msg_gao1) 
//				{
//					// gao is talking
//					return faux // wait
//				}
//			}
//			
//			m_msg.msg_int5 = 3
//			return vrai // speech ended => nowait
//		}
//	}
// 	return vrai //nowait
//}
//
/////TrigCINE_Wait
////============================================================
//// Param IN: 	who   			-  Destinataire
//// ------------------ HUMAIN --------------------------------------------------------------------------------------
////     				orientation 		-   orientation vers ce gao (nobody possible)
////					orient_toler	(.x)	-	orientation vers le gao avec tolerance (<> 0)
////     				regarde  			- gao a regarder
////     				arret   			- type d'arret 
////										0 -> durée (vec1.x) 
////										1 -> attente waitgoal (ou equivalent) 
////										2 -> attente fin action
////     				time   			- x -> temps en secondes
////					intention			- 0 -> rien 1 -> attente normale 2 -> attente stress 
////										  3 -> accroupi 4->denham film 5 assis blessé 6 ramasse
////										  7 -> mécanisme denham
////										 8 -> plaque contre 9 -> surveille
////										  > 1000 anim dédiée à partir de 255 (1000 = 255, 1001 = 256 etc...)
//// ------------------ BATS ------------------------------------------------------------------------------------------
////     				orientation       - orientation vers ce gao (nobody possible)
////     				regarde           - gao a regarder (nobody possible)
////     				arret               - type d'arret 
////                                            0 -> durée (vec1.x) 
////                                            1 -> attente waitgoal (ou equivalent) 
////     				time               - x -> temps en secondes
////					intention	        - 0 -> rien 1 -> lâche sa proie
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_Wait(byref message m_msg) // object1 who object2 orientation object3 regarde vec1 time int1 arret int2 intention vec3 orient_toler
//{
//	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_Wait\n")
//#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_Wait
// 	@o MSG_Send(m_msg)
// 	@o OBJ_CapaSet(0, OBJ_Capa_13)
// 	return vrai
//}
//
////TrigCINE_WaitDefault
////============================================================
//// Param IN: 	who   			- Destinataire
//// ------------------ HUMAIN --------------------------------------------------------------------------------------
////     				orientation 		- orientation vers ce gao (nobody possible)
////					orient_toler	(.x)	-	orientation vers le gao avec tolerance (<> 0)
////     				regarde  			- gao a regarder
////					intention			- (voir le wait)
//// ------------------ BATS ------------------------------------------------------------------------------------------
////     				orientation 		-   orientation vers ce gao (nobody possible)
////     				regarde  			- gao a regarder (nobody possible)
////     				arret   			- type d'arret 
////										0 -> durée (vec1.x) 
////										1 -> attente waitgoal (ou equivalent) 
////     				time   			- x -> temps en secondes
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_WaitDefault(byref message m_msg) // object1 who object2 orientation object3 regarde int1 intention vec3 orient_toler
//{
//	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_WaitDefault\n")
//#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_WaitDefault
// 	@o MSG_Send(m_msg)
// 	return vrai
//}
// 
////TrigCINE_ResetWaitDefault
////============================================================
//// Param IN: 	who   			- Destinataire
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_ResetWaitDefault(byref message m_msg) // object1 who object2 who object3 who object4 who object5 who
//{
//	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_ResetWaitDefault\n")
//#endif
// 	m_msg.msg_id = CINE_ResetWaitDefault
// 	o = m_msg.msg_gao1
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao2
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao3
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao4
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao5
// 	if(o) @o MSG_Send(m_msg)
// 	return vrai
//}
//
////TrigCINE_ResetWaitDefaultG
////============================================================
//// Param IN: 
//// Param OUT (none)
////============================================================
//procedure void TrigCINE_ResetWaitDefaultG_(byref message m_msg) 
//{
//	object	o, ot
//	int			i
//	
// 	m_msg.msg_id = CINE_ResetWaitDefault
//	ot = m_msg.msg_sender
//	for(i = 0; i < 20; i++)
//	{
//		o = @"Progression/PRG_ScriptSimple" ot who[i]
//		if(!o) break
//	 	@o MSG_Send(m_msg)
//	}
//}
//
//procedure_trigger int TrigCINE_ResetWaitDefaultG(byref message m_msg) 
//{
//	TrigCINE_ResetWaitDefaultG_(m_msg)
//	return vrai
//}
//
////TrigCINE_Vala
////============================================================
//// Param IN: 	who			-  Destinataire
//// ------------------ HUMAIN --------------------------------------------------------------------------------------
////     				position 		- gao ou se rendre
////     				regarde 		- gao a regarder
////     				intention  	-  	0 auto, 1 marche, 2 trot, 3 marche stress, 4 trot stress
////										5 marche stress rapide, 6 trot stealth, 7 recul normal
////										8 recul panique 9 course 10 marche accroupi 11 trot accroupi
////									    > 1000 anim dédiée à partir de 255 (1000 = 255, 1001 = 256 etc...)
////					mode			- 0 normal, 1 carotte, 2 lignedroite, 3 ejection, 4 notestgrid et reseau
//// ------------------ BATS ------------------------------------------------------------------------------------------
////     				orientation 	- gao ou se rendre
////     				regarde  		- gao a regarder (nobody possible)
////     				intention  	- 0 vitesse normale, 1 rapide
////					mode         - 0 conservation des vitesses au départ et à l'arrivée
////                                     - 1 départ à l'arrêt
////                                     - 2 arrivée à l'arrêt
////                                     - 3 départ et arrivée à l'arrêt
////					speed		- vitesse de deplacement (en x)
//// ------------------ RAPTOR --------------------------------------------------------------------------------------
////     				position 		- gao ou se rendre
////     				regarde 		- gao a regarder
////					speed		- vitesse de deplacement (en x)
////					alignement	- 0 ne prend pas en compte le sight du wp dest
////										- 1 s'oriente comme le wp
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_Vala(byref message m_msg) // object1 who object2 position object3 regarde int1 intention int2 mode vec1 speed int3 alignement
//{
// 	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) 
//	{
//		DBG_TraceString("TrigCINE_Vala  ")
//		DBG_TraceObject(m_msg.msg_gao2)
//		DBG_TraceEOL()
//	}
//#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_Vala
// 	@o MSG_Send(m_msg)
// 	@o OBJ_CapaSet(0, OBJ_Capa_13)
// 	return vrai
//}
//
////TrigCINES_ResetCineMode
////============================================================
//// Param IN: 	obj1-gao5  	-  	tous les gao
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINES_ResetCineMode(byref message m_msg) // object1 who object2 who object3 who object4 who object5 who
//{
// 	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINES_ResetCineMode\n")
//#endif
// 	m_msg.msg_id = CINE_Reset
// 	o = m_msg.msg_gao1
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao2
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao3
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao4
// 	if(o) @o MSG_Send(m_msg)
// 	o = m_msg.msg_gao5
// 	if(o) @o MSG_Send(m_msg)
// 	return vrai
//}
// 
////============================================================
//procedure int TrigCINES_WaitGoalCom(int num, byrefarr object arr, int ack)
//{
//	int				i, ti_res
//	object		o
//	
//	ti_res = 0
//	for(i = 0; i < num; i++)
//	{
//		o = arr[i]
//	 	if(!o || @o OBJ_CapaTest(OBJ_Capa_13)) ti_res++
//	}
//	
//	if(ti_res == num) 
//	{
//		if(ack)	// Acknowledge
//		{
//			for(i = 0; i < num; i++)
//			{
//				o = arr[i]
//			 	if(o) @o OBJ_CapaSet(OBJ_Capa_12, 0)
//			 	if(o) @o OBJ_CapaSet(0, OBJ_Capa_13)
//			}
//		}
//		
//		return vrai
//	}
//	
//	return faux
//}
//
////TrigCINES_WaitGoal
////============================================================
//// Param IN: 	obj1-gao5  	-  	tous les gao a attendre
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINES_WaitGoal(byref message m_msg) // object1 who object2 who object3 who object4 who object5 who
//{
//	object  	o
// 	int    		ti_res
//  	object	tta[20]
//
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINES_WaitGoal\n")
//#endif
//	tta[0] = m_msg.msg_gao1
//	tta[1] = m_msg.msg_gao2
//	tta[2] = m_msg.msg_gao3
//	tta[3] = m_msg.msg_gao4
//	tta[4] = m_msg.msg_gao5
//	return TrigCINES_WaitGoalCom(5, &tta[0], 1)
//}
//
////============================================================
//procedure int TrigCINES_WaitGoalG_(byref message m_msg) 
//{
//	object  	o, ot
// 	int    		ti_res
// 	int			i
// 	object	tta[20]
// 
//	ot = m_msg.msg_sender
// 	ti_res = 0
//	for(i = 0; i < 20; i++)
//	{
//		o = @"Progression/PRG_ScriptSimple" ot who[i]
//		if(!o) break
//		tta[ti_res] = o
//		ti_res++
//	}
//	
// 	// Succes
// 	return TrigCINES_WaitGoalCom(ti_res, &tta[0], 1)
//}
//
////TrigCINES_WaitGoalG
////============================================================
//// Param IN: 	
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINES_WaitGoalG(byref message m_msg) 
//{
//	return TrigCINES_WaitGoalG_(m_msg)
//}
// 
////TrigCINE_Speech
////============================================================
//// Param IN: 	who		-  	Destinataire
////					regarde	-	qui regarder
////					texte		-	numéro du texte dans le tableau du PRG_ScriptSimple
////					arret		-	0 -> instantané, 1 -> texte finit 2 -> bloquage texte finit 3 -> bloc script //
////					intention	- (voir le wait)
////					near/far	- 	1 si vous voulez que le texte soit en near/far (prendra "texte" pour near, "texte + 1" pour far)
////					orientation - vers qui je me tourne
////					orient_toler	(.x)	-	orientation vers le gao avec tolerance (<> 0)
////
////
//// NE PAS UTILISER VECTOR 4 <======== !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
////
////
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_Speech(byref message m_msg) // object1 who object2 orientation object3 regarde int1 numero int2 arret int3 intention int4 nearfar vec3 orient_toler
//{
// 	object  		o
// 	text			txt
// 	message 	mm_msg
//	int 			ti_track
//	vector		tv_temp
//
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_Speech\n")
//#endif
//
//	if(!m_msg.msg_int5)
//	{
//		if(m_msg.msg_gao1 == AI_MainActorGet(C_ID_Joueur) || m_msg.msg_int2 == 3)
//		{
//			o = m_msg.msg_sender
//			txt = @"Progression/PRG_ScriptSimple" o texts[m_msg.msg_int1]
//			
//			MSG_SetNull(mm_msg)
//			mm_msg.msg_vec1 = cvector(0, SPEECH_Cte_PriorityDefault, SPEECH_Cte_TimeOutDefault)
//			mm_msg.msg_int1 = TEXT_FileGet(txt)
//			mm_msg.msg_int2 = TEXT_EntryGet(txt)
//			mm_msg.msg_int3 = 0
//			mm_msg.msg_int4 = 0
//			mm_msg.msg_int5 = 0		
//			MSG_GlobalSend( C_EVENT_TYPE_Speech, Cf_EVENT_Duree_1Trame, mm_msg, C_EVENT_EOFADD)
//			
//			m_msg.msg_int5 = 1
//			m_msg.msg_vec4 = Cv_NullVector	// Pour timer de blocage		
//			
//			return faux
//		}
//		else
//		{
//			o = m_msg.msg_sender
//			if(m_msg.msg_int4 && @o OBJ_SqrDist(AI_MainActorGet(C_ID_Joueur)) > 8 * 8)
//				txt = @"Progression/PRG_ScriptSimple" o texts[m_msg.msg_int1 + 1]
//			else
//				txt = @"Progression/PRG_ScriptSimple" o texts[m_msg.msg_int1]
//			m_msg.msg_int4 = TEXT_FileGet(txt)
//			m_msg.msg_int5 = TEXT_EntryGet(txt)
//		 	o = m_msg.msg_gao1
//		 	m_msg.msg_id = CINE_Speech
//		 	@o MSG_Send(m_msg) 
//		 	m_msg.msg_int5 = vrai
//		 	if(m_msg.msg_int2 == 2) return faux
//		 }
//	}
//	else
//	{
//		if(m_msg.msg_gao1 == AI_MainActorGet(C_ID_Joueur) || m_msg.msg_int2 == 3)
//		{			
//			for( ti_track = 0; ti_track<2; ti_track++)
//			{
//				if( !@get_speech ao_current_target[ti_track] ) continue
//				if( @get_speech ao_current_target[ti_track] == m_msg.msg_gao1) 
//				{
//					m_msg.msg_int5 = 2
//					return faux
//				}
//			}
//			
//			if(m_msg.msg_int5 == 1) 
//			{
//				// Blindage : si on ne peut pas parler pendant plus de 2s, on sort
//				tv_temp = m_msg.msg_vec4
//				tv_temp.x += TIME_GetDt()
//				m_msg.msg_vec4 = tv_temp
//				if(tv_temp.x > 3) 
//					return vrai
//				return faux
//			}
//		}
//		else
//		{
//			o = m_msg.msg_gao1
//			if(m_msg.msg_int2 == 2 && !@o OBJ_CapaTest(OBJ_Capa_13)) return faux
//		}
//	}
//	
// 	return vrai
//}
// 
////TrigCINES_WaitCapa
////============================================================
//// Param IN: 	capa			-  	capa a tester (numéro)
////					reference	-	objet reference
////					who			-	perso waitgoal
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINES_WaitCapa(byref message m_msg) // int1 capa object1 reference object2 who object3 who object4 who object5 who
//{
//	object	to_ref
//	object	tta[5]
//	
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINES_WaitCapa\n")
//#endif
//	// Wait goal auto
//	tta[0] = m_msg.msg_gao2
//	tta[1] = m_msg.msg_gao3
//	tta[2] = m_msg.msg_gao4
//	tta[3] = m_msg.msg_gao5
//	if(!TrigCINES_WaitGoalCom(4, &tta[0], 0)) return faux
//	
//	// Test capa
//	to_ref = m_msg.msg_gao1
//	if(!@to_ref OBJ_CapaTest(m_msg.msg_int1)) return faux
//	
//	TrigCINES_WaitGoalCom(4, &tta[0], 1)
//	return vrai
//}
//
////TrigCINES_WaitScript
////============================================================
//// Param IN: 	type 			-  	type d'attente
////											+1		test distance
////											+2		test pivot in screen
////											+4		test timeout
////					vec1.x		-	distance
////					vec1.y		-	timeout
////					vec1.z		-	frequence répétition de la phrase
////					text_echec	-	texte a dire si l'attente se déclenche (une fois)   
////										=> -1 pour rien
////					reference	-	objet reference pour la vision/distance
////					who			-	perso waitgoal
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINES_WaitScript(byref message m_msg) // int1 type object1 reference vec1 distance int2 text_echec object2 who object3 who object4 who object5 who
//{
//	object		to_main
//	object		to_ref
//	float			tf_dist, tf_timeout
//	int				ti_attente, ti_rep
//	vector		tv_dist, tv_time
// 	object		o
// 	text			txt
// 	message	mm_msg
//	object		tta[5]
//	vector		v
//	
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINES_WaitScript\n")
//#endif
//
//	to_main = AI_MainActorGet(C_ID_Joueur)
//	to_ref = m_msg.msg_gao1
//	tv_dist = m_msg.msg_vec1
//	tv_time = m_msg.msg_vec2
//	tf_dist = tv_dist.x
//	tf_timeout = tv_dist.y
//	ti_attente = faux
//	
//	// Wait goal
//	tta[0] = m_msg.msg_gao2
//	tta[1] = m_msg.msg_gao3
//	tta[2] = m_msg.msg_gao4
//	tta[3] = m_msg.msg_gao5
//	if(!TrigCINES_WaitGoalCom(4, &tta[0], 0)) return faux
//
//	// Premier appel ?
//	if(!m_msg.msg_int5)
//	{
//		tv_time.x = 0	// Pour timeout
//		tv_time.y = 0	// Pour répétition
//		m_msg.msg_vec2 = tv_time
//	}	
//	else
//	{
//		tv_time.x += TIME_GetDt()
//		tv_time.y += TIME_GetDt()
//		m_msg.msg_vec2 = tv_time
//	}
//	
//	// Attente jack suffisement proche (vec1.x) de gao1
//	if(m_msg.msg_int1 & 1)
//	{
//		if(@to_ref OBJ_SqrDist(to_main) > tf_dist * tf_dist)
//			ti_attente = vrai
//	}
//
//	// Pivot in screen
//	if(m_msg.msg_int1 & 2)
//	{
//		v = VIEW_3dWorldTo2d( 0, @to_ref OBJ_PosGet() )
//		if ( (v.z < 0) || ( (v.x <= 0 || v.x >= 1) || (v.y <= 0 || v.y >= 1 ) ) )
//		{
//			ti_attente = vrai
//		}
//	}
//
//	// Timeout
//	if(ti_attente && m_msg.msg_int1 & 4)
//	{
//		if(tv_time.x > tv_dist.y)
//		{
//			ti_attente = faux
//		}
//	}
//	
//	// Si echec, dit un texte
//	if(ti_attente && (!m_msg.msg_int5 || tv_time.y > tv_dist.z))
//	{
//		tv_time.y = 0
//		m_msg.msg_vec2 = tv_time
//		
//		if(m_msg.msg_int2 != -1)
//		{
//			o = m_msg.msg_sender
//			txt = @"Progression/PRG_ScriptSimple" o texts[m_msg.msg_int2]
//			
//			MSG_SetNull(mm_msg)
//			mm_msg.msg_gao1 = OBJ_Me()		
//			mm_msg.msg_vec1 = cvector(0, SPEECH_Cte_PriorityDefault, SPEECH_Cte_TimeOutDefault)
//			mm_msg.msg_int1 = TEXT_FileGet(txt)
//			mm_msg.msg_int2 = TEXT_EntryGet(txt)
//			mm_msg.msg_int3 = 0
//			mm_msg.msg_int4 = 0
//			mm_msg.msg_int5 = 0		
//			MSG_GlobalSend( C_EVENT_TYPE_Speech, Cf_EVENT_Duree_1Trame, mm_msg, C_EVENT_EOFADD)
//		}
//	}
//	
//	// Si tout est ok, on doit renseigner les persos (waitgoal)
//	if(!ti_attente)
//	{
//		TrigCINES_WaitGoalCom(4, &tta[0], 1)
//	}
//	
//	m_msg.msg_int5 = 1
//	if(ti_attente) return faux
//	return vrai
//}
//
////TrigCINE_GlobalEvt
////============================================================
//// Param IN: 	who			- je regarde qui ?
////					type			-  	0 rien, 
////											1 regarde moi
////											2 stop + tourne vers moi + regard vers moi
////											3 comme 2, mais denham film
////					vec1.x		-	durée
////					filter			- filtre persos (5 = ann + hayes par exemple)
////										0		- tous
////										+1		- ann
////										+2		- denham
////										+4		- hayes
////										+8		- jimmy
////					speech		-	interdit les speech generique
////============================================================
//procedure_trigger int TrigCINE_GlobalEvt(byref message m_msg) // object1 who int1 type vec1 time int2 filter int3 speech
//{
//	vector		vec
//	
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_GlobalEvt\n")
//#endif
//	vec = m_msg.msg_vec1
//	if(m_msg.msg_gao1) m_msg.msg_sender = m_msg.msg_gao1
//	MSG_GlobalSend(C_EVENT_TYPE_HumainsEvt, vec.x, m_msg, C_EVENT_EOFADD)	
//	return vrai
//}
//
////TrigCINE_ForceEtat
////============================================================
//// Param IN: 	who   		-  Destinataire
////------------------ HUMAIN ---------------------------------------------------------------------------------------
////					type			-  	0 jack_meurt_si_je_meurt 		0 -> faux 1 -> vrai
////									-  	1 plus de  vision (fantome) 		0 -> faux 1 -> vrai
////									-   2 autorise chute (hauteur sol = valueo)
////									-   3 interdit soin 
////									-   4 mode chute
////									-   5 force arme en main
////												Ci_weapon_ID_colt								1
////												Ci_weapon_ID_tommy_gun					2
////												Ci_weapon_ID_shotgun							3
////												Ci_weapon_ID_sniper_rifle						4
////												Ci_weapon_ID_dynamite						5
////												Ci_weapon_ID_bambou							6
////												Ci_weapon_ID_bambou_moy					7
////												Ci_weapon_ID_bambou_petit					8
////												Ci_weapon_ID_crane							9
////												Ci_weapon_ID_levier								10
////												Ci_weapon_ID_bambou							600 (allumée)
////												Ci_weapon_ID_bambou_moy					700 (allumée)
////												Ci_weapon_ID_bambou_petit					800 (allumée)
////									- 	6 force suivi	0 -> faux 1 -> vrai
////									- 	7 force hide		0 -> faux 1 -> vrai
////									- 	8 ramasse en suivi	0 -> faux 1 -> vrai
////									-   9 pourcentage de raté au tir
////									- 	10 invincible (pas de paf, pas de grab)
////									-	11 interdit tir
////									-	12 force mort
////									-	13 interdit ramassage lances
////									-	14 pas de mort en chute
////									-	15 morph cine
////									-	16 interdit psss
////									-	17 jack se barre (APPLIQUEZ LE A UN SEUL COMPAGNON)
////									-	18 plus de variante d'attente
////									-	19 pas d'echange d'arme
////									-	20 pas d'anim stunned
////									-	21 plus AUCUN texte générique
////									-   22 interdit à un perso d'en aider un autre
////									-	23 force crouch jack
////									-	24 script jack
////									-	25 hysteresis fight
////									-	26 force expression (value = 2 -> joie       value2 = temps)
////					value			-	Depend du type
////					valueo		-	Depend du type
////------------------ BATS -------------------------------------------------------------------------------------------
////                   type           -   0 : la bat devient insensible aux pafs         0 -> faux 1 -> vrai      (défaut : faux)
////                                    -   1 : un paf coupe le script de la bat             0 -> faux 1 -> vrai      (défaut : vrai)
////                                    -   2 : fixe un nombre d'attaques fakes
////					value			-   Dépend du type
////------------------ RAPTOR ---------------------------------------------------------------------------------------
////					type			-  	0 ennemi fake			 		0 -> faux 1 -> vrai
////					value			-	Depend du type
////					valueo		-	Depend du type
////============================================================
//procedure_trigger int TrigCINE_ForceEtat(byref message m_msg) // object1 who int1 type int2 value object2 valueo int3 value2
//{
//	object  o
// 
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE) 
//		{
//			DBG_TraceString("TrigCINE_ForceEtat, type ")
//			DBG_TraceInt(m_msg.msg_int1)
//			DBG_TraceString(" , value ")
//			DBG_TraceInt(m_msg.msg_int2)
//			DBG_TraceString(" , valueo ")
//			DBG_TraceObject(m_msg.msg_gao2)
//			DBG_TraceEOL()
//		}
//	#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_ForceEtat
// 	@o MSG_Send(m_msg)
// 	return vrai
//}
//
////TrigCINE_Fight
////============================================================
//// Param IN: 	who			- Destinataire
////------------------ HUMAIN ---------------------------------------------------------------------------------------
////     				target			- gao à attaquer (nobody => calcul tout seul)
////     				mode			- type d'arret 
////										0 -> durée (vec1.x) 
////										1 -> attente waitgoal (ou equivalent) 
////     				time   			- x -> temps en secondes
////					mode2			si avec lance, 1 pour forcer la defense (sinon tir direct)
////------------------ RAPTOR --------------------------------------------------------------------------------------
////     				target			- gao à attaquer
////------------------ BATS -------------------------------------------------------------------------------------------
////					target			- gao à attaquer
////					mode			- 0 paffe, 1 grab lent, 2 grab rapide
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_Fight(byref message m_msg) // object1 who object2 target int1 mode vec1 time int2 mode2
//{
// 	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_Fight\n")
//#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_Fight
// 	@o MSG_Send(m_msg)
// 	@o OBJ_CapaSet(0, OBJ_Capa_13)
// 	return vrai
//}
//
//
////TrigCINE_Bite
////============================================================
//// Param IN: 	who			- Destinataire
////------------------ RAPTOR --------------------------------------------------------------------------------------
////     				target			- gao à mordre
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_Bite(byref message m_msg) // object1 who object2 target
//{
// 	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigCINE_Fight\n")
//#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_Bite
// 	@o MSG_Send(m_msg)
// 	@o OBJ_CapaSet(0, OBJ_Capa_13)
// 	return vrai
//}
//
//
////TrigCINE_NATIVE_Move
////============================================================
//// Param IN: 	where		-  WP Destination
//// 					NbrTir		-  Nbr de Tir a effectuer a un endroit au milieux du parcours
//// 					flag			-  Flag de controle (+1 = pas de detection des pafs)
////					wait			-  (Vec1.x) Attente avant de passer a l'ordre suivant
////					target			-  Perso specifique a attaquer
////============================================================
//procedure_trigger int TrigCINE_NATIVE_Move(byref message m_msg) // object1 where int1 NbrTir int3 flag vec1 wait object2 target
//{
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_NATIVE_Move (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(") vers WP = ")
//			DBG_TraceObject(m_msg.msg_gao1)
//			if (m_msg.msg_int1)
//			{	DBG_TraceString(" + ")
//				DBG_TraceInt(m_msg.msg_int1)
//				DBG_TraceString(" Tirs") }
//			DBG_TraceEOL()		}
//	#endif
//	m_msg.msg_id = CINE_NATIVE_Move
//	return	 vrai
//}
//
////TrigCINE_NATIVE_Launch
////============================================================
//// Param IN: 	NbrTir		-  Nbr de Tir a effectuer
//// 					Dec			-  Declage ( none(0) , Droite(1), Gauche(2) ou Droite|Gauche(3)
//// 					flag			-  Flag de controle (+1 = pas de detection des pafs)
////					wait			-  (Vec1.x) Attente avant de passer a l'ordre suivant
////					target			-  Perso specifique a attaquer
////============================================================
//procedure_trigger int TrigCINE_NATIVE_Launch(byref message m_msg) // int1 NbrTir int2 Dec int3 flag vec1 wait object2 target
//{
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_NATIVE_Launch (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(") Nbr Tir = ")
//			DBG_TraceInt(m_msg.msg_int1)
//			DBG_TraceEOL()		}
//	#endif
//	m_msg.msg_id = CINE_NATIVE_Launch
//	return	 vrai
//}
//
////TrigCINE_NATIVE_LoopTo
////============================================================
//// Param IN: 	loop			-  Indice de boucle
////============================================================
//procedure_trigger int TrigCINE_NATIVE_LoopTo(byref message m_msg) // int1 loop
//{
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_NATIVE_LoopTo (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(") Indice = ")
//			DBG_TraceInt(m_msg.msg_int1)
//			DBG_TraceEOL()		}
//	#endif
//	m_msg.msg_id = CINE_NATIVE_Loop
//	return	 vrai
//}
//
////TrigCINE_Roar
////============================================================
//// Param IN: 	who			-  Destinataire
//// ------------------ TREX --------------------------------------------------------------------------------------
////     				regarde 		- gao a regarder
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_Roar(byref message m_msg) // object1 who object3 regarde
//{
// 	object  o
// 
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) 
//	{
//		DBG_TraceString("TrigCINE_Roar  ")
//		DBG_TraceObject(m_msg.msg_gao2)
//		DBG_TraceEOL()
//	}
//#endif
// 	o = m_msg.msg_gao1
// 	m_msg.msg_id = CINE_Roar
// 	@o MSG_Send(m_msg)
// 	@o OBJ_CapaSet(0, OBJ_Capa_13)
// 	return vrai
//}
//
//
////TrigCINE_MONSTREMARIN_MoveTo
////============================================================
//// Param IN:   Where                 - WP Cible / Destination
////                   MoveAfterAttack  - WP destination après l'attaque
////                   AttackMarinWP   - WP pour aller attaquer les marins tombés à l'eau
////                   Speed_Move       - Vitesse pour le déplacement : 
////                                                 x = vitesse
////                                                 y = coef accel
////                                                 z = délai entre la fin du plongeon et le wp d'attaque des marins (si LE JOUEUR est tombé à l'eau)
////                   Intention             - Type de déplacement : 
////                                                 0/1 = déplacement sans attaque
////                                                 2 = attaque (paf) : mode "au Ras de l'eau"
////                                                 3 = attaque grab : pour la bat
////                                                 4 = attaque (paf) mode "Renverse"
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_MONSTREMARIN_MoveTo(byref message m_msg) // object1 Where object2 MoveAfterAttack object3 AttackMarinWP int1 Intention vec1 Speed_Move
//{
//	vector		tv_temp
//	object		to_monstre_marin
//	to_monstre_marin = @get_global o_monstre_marin
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_MONSTREMARIN_MoveTo (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(") / intention = ")
//			if( m_msg.msg_int1 == 0 || m_msg.msg_int1 == 1 )
//				DBG_TraceString("Déplacement (sans attaque)")
//			else if( m_msg.msg_int1 == 2 )
//				DBG_TraceString("Attaque Paf (Ras de l'eau)")
//			else if( m_msg.msg_int1 == 3 )
//				DBG_TraceString("Attaque Grab")
//			else if( m_msg.msg_int1 == 4 )
//				DBG_TraceString("Attaque Paf (Renverse)")
//			else
//				DBG_TraceString("m_msg.msg_int1 inconnu ???")
////			DBG_TraceString(" / Snake ")
////			if( m_msg.msg_int2 == 1 )
////				DBG_TraceString(" ON")
////			else
////				DBG_TraceString(" OFF")
//			DBG_TraceString(" / Cible = ")
//			DBG_TraceObject(m_msg.msg_gao1)
//			DBG_TraceString(" / Wp apres attaque = ")
//			DBG_TraceObject(m_msg.msg_gao2)
//			DBG_TraceString(" / WP attaque marins = ")
//			DBG_TraceObject(m_msg.msg_gao3)
//			tv_temp = m_msg.msg_vec1
//			DBG_TraceString(" / Vitesse Depl ")
//			DBG_TraceFloat(tv_temp.x)
//			DBG_TraceString(", accel ")
//			DBG_TraceFloat(tv_temp.y)
//			DBG_TraceString(", délai entre la fin du plongeon et le wp d'attaque des marins (si LE JOUEUR est tombé à l'eau) ")
//			DBG_TraceFloat(tv_temp.z)
//			DBG_TraceEOL()	
//		}
//	#endif
//	m_msg.msg_id = CINE_MONSTREMARIN_MoveTo
//	@to_monstre_marin MSG_Send(m_msg)
//	return	 vrai
//}
//
//
////TrigCINE_MONSTREMARIN_Reset
////============================================================
//// Param IN (none)
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_MONSTREMARIN_Reset(byref message m_msg) // 
//{
//	vector		tv_temp
//	object		to_monstre_marin
//	to_monstre_marin = @get_global o_monstre_marin
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_MONSTREMARIN_Reset (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(")")
//			DBG_TraceEOL()
//		}
//	#endif
//	m_msg.msg_id = CINE_MONSTREMARIN_Reset
//	@to_monstre_marin MSG_Send(m_msg)
//	return vrai
//}
//
//
////TrigCINE_MONSTREMARIN_Teleport
////============================================================
//// Param IN          Where            - WP Destination
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_MONSTREMARIN_Teleport(byref message m_msg) // object1 Where
//{
//	vector		tv_temp
//	object		to_monstre_marin
//	to_monstre_marin = @get_global o_monstre_marin
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_MONSTREMARIN_Teleport (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(")")
//			DBG_TraceString(" / Where = ")
//			DBG_TraceObject(m_msg.msg_gao1)
//			DBG_TraceEOL()
//		}
//	#endif
//	m_msg.msg_id = CINE_MONSTREMARIN_Teleport
//	@to_monstre_marin MSG_Send(m_msg)
//	return vrai
//}
//
//
////TrigCINE_MONSTREMARIN_MoveInTime
////============================================================
//// Param IN          Where            - WP Destination
////                         Time              - x = Durée en secondes pour me rendre au wp spécifié
////                         Intention         - Type de déplacement : 
////                                                 0 = depl direct
////                                                 1 = depl avec positionnement pour attaquer (derrière, en fonction du sight)
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_MONSTREMARIN_MoveInTime(byref message m_msg) // object1 Where int1 Intention vec1 Time
//{
//	vector		tv_temp
//	object		to_monstre_marin
//	to_monstre_marin = @get_global o_monstre_marin
//	#ifndef _FINAL_
//		if(@get_global DEBUG_TCINE)
//		{	DBG_TraceString("TrigCINE_MONSTREMARIN_MoveInTime (")
//			DBG_TraceObject(OBJ_Me())
//			DBG_TraceString(")")
//			DBG_TraceString(" / Where = ")
//			DBG_TraceObject(m_msg.msg_gao1)
//			tv_temp = m_msg.msg_vec1
//			DBG_TraceString(" / Time = ")
//			DBG_TraceFloat(tv_temp.x)
//			DBG_TraceString(" sec / Intention = ")
//			if( m_msg.msg_int1 == 1 )
//				DBG_TraceString("Positionnement avant Attaque")
//			else
//				DBG_TraceString("Deplacement standard")
////			DBG_TraceString(" / Snake ")
////			if( m_msg.msg_int2 == 1 )
////				DBG_TraceString(" ON")
////			else
////				DBG_TraceString(" OFF")
//			DBG_TraceEOL()
//		}
//	#endif
//	m_msg.msg_id = CINE_MONSTREMARIN_MoveInTime
//	@to_monstre_marin MSG_Send(m_msg)
//	return vrai
//}
//
//
////TrigCINE_WaitDisponibility
////============================================================
//// Param IN         
//// Attend la disponibilite des humains pour partir en script
//// Param OUT (none)
////============================================================
//procedure_trigger int TrigCINE_WaitDisponibility(byref message m_msg) // object1 who1 object2 who2 object3 who3 object4 who4 object5 who5)
//{
//	object	to_obj 
//	
//	to_obj = m_msg.msg_gao1
//	if(to_obj && !@to_obj OBJ_CapaTest(OBJ_Capa_11)) return faux
//	to_obj = m_msg.msg_gao2
//	if(to_obj && !@to_obj OBJ_CapaTest(OBJ_Capa_11)) return faux
//	to_obj = m_msg.msg_gao3
//	if(to_obj && !@to_obj OBJ_CapaTest(OBJ_Capa_11)) return faux
//	to_obj = m_msg.msg_gao4
//	if(to_obj && !@to_obj OBJ_CapaTest(OBJ_Capa_11)) return faux
//	to_obj = m_msg.msg_gao5
//	if(to_obj && !@to_obj OBJ_CapaTest(OBJ_Capa_11)) return faux
//	return vrai
//}
//
/////TrigCINE_ResetMunitionHayes
////============================================================
//// Param IN:
//// Param OUT
////============================================================
////procedure_trigger int TrigCINE_ResetMunitionHayes(byref message m_msg)
////{
////	@"univ" i_weapon_ammunition[ Ci_weapon_ID_sniper_rifle ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition_reserve[ Ci_weapon_ID_sniper_rifle ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition[ Ci_weapon_ID_colt ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition_reserve[ Ci_weapon_ID_colt ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition[ Ci_weapon_ID_shotgun ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition_reserve[ Ci_weapon_ID_shotgun ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition[ Ci_weapon_ID_tommy_gun ][ C_ID_Hayes ] = 0
////	@"univ" i_weapon_ammunition_reserve[ Ci_weapon_ID_tommy_gun ][ C_ID_Hayes ] = 0
////	return vrai
////}
//