Include_UltraProcedure_Header


///TrigExec_SendPafAllZDE
//============================================================
// Param IN:
//       type (int1)               => 0 = paf moyen, 1 = paf fort, 2 = tuant
//		puissance (int2)	    => points de vie enleves
//		dirSightObj (obj1)		=> sens du paf dans l axe du sight
//										 si nobody Paf direction = centre de la ZDE vers lacteur paffé
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SendPafAllZDE(byref message m_msg) // int1 type int2 puissance object1 dirSightObj
{
	object	to_target
	int			ti_type
	vector	tv_dir
	float		tf_dmg
	vector	tv_pos
	int			ti_nb_col
	object	tao_col[20]
	message		EVT_msg
	object	to_sender
	
	// TARGET ?
	ti_nb_col = COL_ZDE_ZDEListGet(&tao_col[0], C_zde_fight, C_zde_corps, all, none, Ci_Filter_IdentityFlag)

	while ( ti_nb_col)
	{
		to_target = tao_col[ti_nb_col - 1]

		// TYPE ?
		switch(m_msg.msg_int1)
		{
			case 1 :
				ti_type = C_PAF_RM_Fort
				break
			case 2 : 
				ti_type = C_PAF_RM_KiTue
				break
			default:
				ti_type = C_PAF_RM_Moyen
				break
		}
	
		// DMG
		tf_dmg = m_msg.msg_int2
			
		// POS
		tv_pos = COL_ZonePosGet(C_zde_fight)
		
		// DIR
		if ( m_msg.msg_gao1)
		{
			to_sender = m_msg.msg_gao1
			tv_dir = @to_sender OBJ_SightGet()
		}
		else
			tv_dir = @to_target OBJ_PosGet() - tv_pos

		if( MATH_VecNullToler(tv_dir, 0.01) )
			tv_dir = - @to_target OBJ_SightGet()
		

	
		to_sender = OBJ_Me()
		//	EVENT_AddEventPafCanal(C_EVENT_FILTER_All, ti_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_target, ti_canal, tf_dmg, tv_dir, tv_pos)
		
		MSG_SetNull( EVT_msg)
		EVT_msg.msg_int1 = C_EVENT_FILTER_All
		EVT_msg.msg_int2 = ti_type
		EVT_msg.msg_gao1 = to_target
		EVT_msg.msg_vec1 = tv_dir
		EVT_msg.msg_vec2 = cvector(0, tf_dmg, 0)
		EVT_msg.msg_vec3 = tv_pos
	
		@to_sender MSG_GlobalSend(C_EVENT_TYPE_Paf, Cf_EVENT_Duree_1Trame, EVT_msg, C_EVENT_EOFADD)
	
		ti_nb_col--
	}

	return vrai
}




///TrigExec_SendPaf
//============================================================
// Param IN:
//		gao_target (gao1) 	=> Cible du paf (si none == RAYMAN)
//       type (int1)               => 0 = paf moyen, 1 = paf fort, 2 = tuant 3 = Paf Fort+Grenade (expulse)
//		puissance (int2)	    => points de vie enleves
//		canal	(int3)				=> numero du bone
//		dir (vec1)				=> sens du paf
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SendPaf(byref message m_msg) // int1 type int2 puissance int3 canal vec1 dir object1 gao_target
{
	object	to_target
	int			ti_type
	vector	tv_dir
	float		tf_dmg
	vector	tv_pos
	int			ti_canal
	object	to_bone
	message		EVT_msg
	object	to_sender
	
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SendPaf\n")
#endif
	
	// TARGET ?
	to_target = m_msg.msg_gao1
	if( ! to_target )
		to_target = AI_MainActorGet(C_ID_Rayman)
	if( ! to_target )
		return vrai			// rayman ne s'est pas encore enregistré on arrête
	
	// TYPE ?
	switch(m_msg.msg_int1)
	{
		case 1 :
			ti_type = C_PAF_RM_Fort
			break
		case 2 : 
			ti_type = C_PAF_RM_KiTue
			break
		case 3 : 
			ti_type = C_PAF_RM_Fort | C_PAF_RM_Grenade
			break
		default:
			ti_type = C_PAF_RM_Moyen
			break
	}
	
	// DMG ?
	tf_dmg = m_msg.msg_int2
		
	// DIR ?
	tv_dir = m_msg.msg_vec1
	if( MATH_VecNullToler(tv_dir, 0.01) )
		tv_dir = - @to_target OBJ_SightGet()
		
	// CANAL & POS ?
	ti_canal = m_msg.msg_int3
	if( ti_canal != -1 )
	{
		to_bone = @to_target ANI_CanalObjectGet(ti_canal)
		if( ! to_bone )
			to_bone = to_target
	}
	else
		to_bone = to_target
	tv_pos = @to_bone OBJ_PosGet()
	
	to_sender = AI_MainActorGet(0)
//	EVENT_AddEventPafCanal(C_EVENT_FILTER_All, ti_type, OBJ_Me(), Cf_EVENT_Duree_1Trame, to_target, ti_canal, tf_dmg, tv_dir, tv_pos)
	
	MSG_SetNull( EVT_msg)
	EVT_msg.msg_int1 = C_EVENT_FILTER_All
	EVT_msg.msg_int2 = ti_type
	EVT_msg.msg_int4 = ti_canal
	EVT_msg.msg_gao1 = to_target
	EVT_msg.msg_vec1 = tv_dir
	EVT_msg.msg_vec2 = cvector(0, tf_dmg, 0)
	EVT_msg.msg_vec3 = tv_pos

	@to_sender MSG_GlobalSend(C_EVENT_TYPE_Paf, Cf_EVENT_Duree_1Trame, EVT_msg, C_EVENT_EOFADD)

	return vrai
}


///TrigExec_DoNothing
//============================================================
// Param IN : None
// Param OUT : None
// ne fait rien du tout du tout troulalaitou
//============================================================
procedure_trigger int TrigExec_DoNothing( byref message m_msg)
{
	return vrai
}

///TrigExec_GotoES
//============================================================
// Param IN : 
//		gao (object1)	=> ES ou on doit respawner
//		buttonX (int1)  => 0 pas de test de bouton, 1 = goto only si button X
// Param OUT : 
// 	retourne vrai si Goto effectué (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_GotoES( byref message m_msg) // object1 gao_es int1 buttonX
{
	object	to_es
	int			button1
	
	to_es = m_msg.msg_gao1
	if (!to_es) return vrai
	if ( !@to_es AI_IsModel("Global/ES_Map") ) return vrai
	
	if (@"univ" world_entrance_ID == @"Global/ES_Map" to_es des_numero_de_l_entree)
		return vrai
		
	button1 = m_msg.msg_int1
	if ( (button1 == 0) || IO_ButtonJustPressed(0) )
	{
		SAVE_Validate()
		@"univ" world_entrance_ID = @"Global/ES_Map" to_es des_numero_de_l_entree
		WOR_Reinit()
		return vrai
	}
	return faux
}

///TrigExec_SNDGroup_SmoothVolSet
//============================================================
// Param IN:
//      group (int1)     => identificateur de groupe
//			SND_Cte_GrpSpecialFX			0
//			SND_Cte_GrpMusic					1
//			SND_Cte_GrpAmbience			2
//			SND_Cte_GrpDialog					3
//			SND_Cte_GrpCutScene			4
//			SND_Cte_GrpInterface				5
//			SND_Cte_GrpA						6
//			SND_Cte_GrpB					 	7
//			SND_Cte_MasterGrp			 	8
//
//		time (vec1.x)	=> duree du fade
//		vol (vec1.y)		=> volume à la fin du fade
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SNDGroup_SmoothVolSet(byref message m_msg) // int1 group vec1 time_vol
{
	int 		ti_grp
	float 		tf_time, tf_vol
	vector	tv

#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SNDGroup_SmoothVolSet\n")
#endif
	
	if( ! m_msg.msg_int5 )
	{
		m_msg.msg_int5 = 1
		
		tv = m_msg.msg_vec1
		ti_grp = m_msg.msg_int1
		tf_time = tv.x
		tf_vol = tv.y
		
		SND_M_FadeGroup(ti_grp, tf_vol, tf_time)
	}
	return vrai
}

///TrigExec_SNDPlayMdF
//============================================================
// Param IN:
//		gao (object1)	=> gao contenant les MdF à jouer
//		once (int1)		=> 0 play a chaque appel, 1 play au premier appel dans la map
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SNDPlayMdF(byref message m_msg) // object1 gao int1 once
{
	object obj
	
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SNDPlayMdF\n")
#endif

	obj = m_msg.msg_gao1 
	
	if(m_msg.msg_int1)
		m_msg.msg_int5 = 1

	@obj SND_MdFPlay(0)
		
	return vrai
}

///TrigExec_SIGSend
//============================================================
// Param IN:
//		SIG (int1)			=> signal à envoyer :
//								normal		force
//			STRESS		0			100
//			FIGHT			1			101
//			PAF				2			102
//			COOL			3			103
//			MORT			4			104
//			INJURE			5			105
//			STALK			6			106
//			JINGLE_1		7			107
//			JINGLE_2		8			108
//			JINGLE_3		9			109
//			JINGLE_4		10			110
//			JINGLE_5		11			111
//			JINGLE_6		12			112
//			JINGLE_7		13			113
//			JINGLE_8		14			114
//			JINGLE_9		15			115
//			BIGFIGHT		16			116
//			SILENCE 		17			117
// SIG_C_MUS_KIT_0				1000
// SIG_C_MUS_KIT_1				1001
// SIG_C_MUS_KIT_2				1002
// SIG_C_MUS_KIT_3				1003
// SIG_C_MUS_KIT_4				1004
// SIG_C_MUS_KIT_5				1005
// SIG_C_MUS_KIT_6				1006
// SIG_C_MUS_KIT_7				1007
// SIG_C_MUS_KIT_8				1008
// SIG_C_MUS_KIT_9				1009
//
//		lock (int2)			=> 0 = unlock, 1 = lock, -1 = rien
//
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SIGSend(byref message m_msg) // int1 SIG int2 lock
{
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SIGSend\n")
#endif

	m_msg.msg_int1  &= ~(SIG_C_TYPE_LOCKMASK | SIG_C_TYPE_UNLOCKMASK)
	
	switch(m_msg.msg_int1)
	{
		case SIG_C_MUS_KIT_0 :
		case SIG_C_MUS_KIT_1 :
		case SIG_C_MUS_KIT_2 :
		case SIG_C_MUS_KIT_3 :
		case SIG_C_MUS_KIT_4 :
		case SIG_C_MUS_KIT_5 :
		case SIG_C_MUS_KIT_6 :
		case SIG_C_MUS_KIT_7 :
		case SIG_C_MUS_KIT_8 :
			break
			
		default:
			if( m_msg.msg_int2 == 0 )
				m_msg.msg_int1  |= SIG_C_TYPE_UNLOCKMASK
			else if( m_msg.msg_int2== 1 )
				m_msg.msg_int1  |= SIG_C_TYPE_LOCKMASK
			break
	}
		
	MSG_GlobalSend( C_EVENT_TYPE_Signal, Cf_EVENT_Duree_1Trame, m_msg, C_EVENT_EOFADD)

	return vrai
}

///TrigExec_CapaSet
//============================================================
// Param IN:
//		gao_capa1 (gao1)
//		gao_capa2 (gao2)
//		gao_capa3 (gao3)
//		gao_capa4 (gao4)
//		gao_capa5 (gao5)	=> gao dont on modifie les capa 
//		capa (int1)			=> capa à passer à vrai
//		capa (int2)			=> capa à passer à faux
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_CapaSet(byref message m_msg) // object1 gao_capa1 object2 gao_capa2 object3 gao_capa3 object4 gao_capa4 object5 gao_capa5 int1 capa_vrai int2 capa_faux
{
	object	o
	
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_CapaSet\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) o = AI_MainActorGet( 0 )
	@o OBJ_CapaSet( m_msg.msg_int1, m_msg.msg_int2 )
	o = m_msg.msg_gao2
	if (o != nobody)
		@o OBJ_CapaSet( m_msg.msg_int1, m_msg.msg_int2 )
	o = m_msg.msg_gao3
	if (o != nobody)
		@o OBJ_CapaSet( m_msg.msg_int1, m_msg.msg_int2 )
	o = m_msg.msg_gao4
	if (o != nobody)
		@o OBJ_CapaSet( m_msg.msg_int1, m_msg.msg_int2 )
	o = m_msg.msg_gao5
	if (o != nobody)
		@o OBJ_CapaSet( m_msg.msg_int1, m_msg.msg_int2 )
	return vrai
}

///TrigExec_CapaBitOn
//============================================================
// Param IN:
//		gao_capa (gao1) 	=> gao qui contient les capa 
//		capa (int1)			=> capa (bit) à passer à vrai
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_CapaBitOn( byref message m_msg ) // object1 gao_capa int1 capa_bit
{
	object o
	
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_CapaBitOn\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) o = AI_MainActorGet( 0 )
	@o OBJ_CapaSet( 1 << m_msg.msg_int1,  0)
	return vrai
}

///TrigExec_CapaBitOff
//============================================================
// Param IN:
//		gao_capa (gao1) 	=> gao qui contient les capa 
//		capa (int1)			=> capa (bit) à passer à faux
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_CapaBitOff( byref message m_msg ) // object1 gao_capa int1 capa_bit
{
	object o
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_CapaBitOff\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) o = AI_MainActorGet( 0 )
	@o OBJ_CapaSet( 0, 1 << m_msg.msg_int1)
	return vrai
}

///TrigExec_Destroy
//============================================================
// Param IN:
//		gao (gao1) 		=> gao à détruire
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Destroy( byref message m_msg ) // object1 gao2destroy
{
	object o
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_Destroy\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) 
	{
		DBG_Error( "TrigExec_Destroy : bad param (gao1)" )
		return faux
	}
	@o OBJ_Destroy()
	return vrai
}

///TrigExec_SetVisibility
//============================================================
// Param IN:
//		gao (gao1) 		=> gao à modifier
//		visibility (int1)	=> 0 = invisible, 1 = visible
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SetVisibility( byref message m_msg ) // object1 gao int1 visible
{
	object o
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SetVisibility\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) 
	{
		DBG_Error( "TrigExec_SetVisibility : bad param (gao1)" )
		return faux
	}
	@o OBJ_FlagInvisibleSet( 1 - m_msg.msg_int1 )
	return vrai
}

///TrigExec_SetActivity
//============================================================
// Param IN:
//		gao (gao1) 		=> gao à modifier
//		activity (int1)	=> 0 = inactif, 1 = actif
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SetActivity( byref message m_msg ) // object1 gao int1 active
{
	object o
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SetActivity\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) 
	{
		DBG_Error( "TrigExec_SetActivity : bad param (gao1)" )
		return faux
	}
	@o OBJ_FlagInactiveSet( 1 - m_msg.msg_int1 )
	return vrai
}

///TrigExec_SetActiveAndVisible
//============================================================
// Param IN:
//		gao (gao1) 					=> gao à modifier
//		visibility/activity (int1)	=> 0 = inactif et invisible, 1 = actif et visible
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SetActiveAndVisible( byref message m_msg ) // object1 gao int1 active_visible
{
	object o
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SetActiveAndVisible\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) 
	{
		DBG_Error( "TrigExec_SetActiveAndVisible : bad param (gao1)" )
		return faux
	}
	@o OBJ_FlagInvisibleSet( 1 - m_msg.msg_int1 )
	@o OBJ_FlagInactiveSet( 1 - m_msg.msg_int1 )
	return vrai
}

///TrigExec_SetCapaLinks
//============================================================
// Param IN:
//		gao (gao1) 		=> gao sur le reseau
//		capaoff (int1)	=> capa a mettre a 0
//		capaon (int2)	=> capa a mettre a 1
//============================================================
procedure_trigger int TrigExec_SetCapaLinks(byref message m_msg ) // object1 wp int1 capaoff int2 capaon
{
	int			i, max
	object 	o, next
	network	net
	int			link
	
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SetCapaLinks\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) o = OBJ_Me()
	
	net = @o WAY_NetOfObj()
	if(!net) 
	{
		DBG_Error( "TrigExec_SetCapaLinks : gao1 have no network" )
		return faux
	}
	
	max = WAY_GetNumLinks(net, o)
	for(i = 0; i < max; i++)
	{
		next = WAY_NetNextWP(net, o, NetNextWP_Mode_choix_de_lindice, i)	
		WAY_LinkCapaSet(net, o, next, m_msg.msg_int2, m_msg.msg_int1)
	}
	return vrai
}

///TrigExec_SetCapaOneLink
//============================================================
// Param IN:
//		gao (gao1) 		=> gao sur le reseau
//		next (gao2) 	=> gao suivant sur le réseau
//		capaoff (int1)	=> capa a mettre a 0
//		capaon (int2)	=> capa a mettre a 1
//============================================================
procedure_trigger int TrigExec_SetCapaOneLink(byref message m_msg ) // object1 wp object2 next int1 capaoff int2 capaon
{
	object 	o, next
	network	net
	
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_SetCapaOneLink\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) o = OBJ_Me()
	
	next = m_msg.msg_gao2
	if (next == nobody)
	{
		DBG_Error( "TrigExec_SetCapaOneLink : no gao2" )
		return vrai
	}
	
	net = @o WAY_NetOfObj()
	if(!net) 
	{
		DBG_Error( "TrigExec_SetCapaOneLink : gao1 have no network" )
		return vrai
	}
	
	WAY_LinkCapaSet(net, o, next, m_msg.msg_int2, m_msg.msg_int1)
	return vrai
}



///TrigExec_ForceTarget
//============================================================
// Param IN:
//		gao_father (gao1) 	=> attaquant
//                                    ( si nul on récupère le main actor )
//		gao_target (gao2) 	=> cible
//		int_type (int2)			=> 0 Normal 1 Blessant 2 Agonisant
//		int_attack (int3)		=> 0 Normal 1 Instantannée
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
////============================================================
//procedure_trigger int TrigExec_ForceTarget(byref message m_msg) // int2 int_type int3 int_attack object1 gao_father object2 gao_target
//{
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_ForceTarget\n")
//#endif
//	m_msg.msg_int1 = C_EVENT_INFOTYPE_FORCE_TARGET
//	MSG_GlobalSend( C_EVENT_TYPE_Info, 0.0, m_msg, C_EVENT_Infini | C_EVENT_ADD)
//	return vrai
//}


///TrigExec_Vala
//============================================================
// Param IN:
//		gao_father (gao1) 	=> qui ?
//		gao_target (gao2) 	=> WP
//		life_time (vec1.x)		=> durée de vie du vala (-1.0 infini)
//		wait_delay (vec1.y)	=> Durée attente (-1.0 infini)
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_Vala(byref message m_msg) // vec1 life_time_wait_delay object1 gao_father object2 gao_target
//{
//	float		tf_life_time
//	vector	tv_vec
//	tv_vec = m_msg.msg_vec1
//	tf_life_time = tv_vec.x
//
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_Vala\n")
//#endif
//
//	if (tf_life_time == -1.0)
//		MSG_GlobalSend(C_EVENT_TYPE_Vala, 0.0, m_msg, C_EVENT_EOFADD | C_EVENT_Infini)	
//	else
//		MSG_GlobalSend(C_EVENT_TYPE_Vala, tf_life_time, m_msg, C_EVENT_EOFADD)	
//
//	return vrai
//}

///TrigExec_ShakeSPG2
//============================================================
// Param IN:
//		gao_father (gao1) 	=> qui ?
//		timer (vec1.x)		    => temps restant de shake
//		amplitude (vec1.y)	=> amplitude du shake (pos perturbation)
//		amplitude (vec1.z)	=> amplitude du shake (speed perturbation)
//		nb SPG2 (int1)		=> nombre de sprite gen
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_ShakeSPG2(byref message m_msg) // object1 who vec1 X_timer_Y_amplitude int1 nb_SPG2
{
	vector	tv_data
	float		e,d,f
	object	o
	int			i,j,k, spg2, nbspg2

#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_ShakeSPG2\n")
#endif

	o = m_msg.msg_gao1
	if (o == nobody)  
	{
		o =m_msg.msg_sender
		if (o == nobody) 
		{
			DBG_Error( "TrigExec_ShakeSPG2 : bad param (gao1 or sender)" )
			return faux
		}
	}

	tv_data = m_msg.msg_vec1
	if (tv_data.y == 0) tv_data.y = 10
	d = TIME_GetDt() * tv_data.y
	e = TIME_GetDt() * tv_data.z
	nbspg2 = m_msg.msg_int1
	if (nbspg2 < 1) nbspg2 = 1
	
	if (d > 0)
	{
		for (j = 0; j < 8; j++)
		{
			for (i = 0; i < 3; i++)
			{
				k = 100 + (j*10) + i
				for (spg2 = 0; spg2 < nbspg2; spg2++)
				{
					f = @o SPG2_FloatGet(spg2, k)
					f += MATH_RandFloat(-d, d)
					@o SPG2_FloatSet(spg2,k,f)
				}
			}
		}
	}
	if (e > 0)
	{
		for (j = 0; j < 8; j++)
		{
			for (i = 0; i < 3; i++)
			{
				k = 200 + (j*10) + i
				for (spg2 = 0; spg2 < nbspg2; spg2++)
				{
					f = @o SPG2_FloatGet(spg2, k)
					f += MATH_RandFloat(-e, e)
					@o SPG2_FloatSet(spg2,k,f)
				}
			}
		}
	}
	return vrai
}


///TrigExec_FreezeModifier
//============================================================
// Param IN:
//		gao (gao1) 		=> goa possédant le modifier
//		modifier	(int1)	=> type du modifier à désactivier
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_FreezeModifier( byref message m_msg ) // object1 gao int1 modifier
{
	object o
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_FreezeModifier\n")
#endif
	o = m_msg.msg_gao1
	if (o == nobody) 
	{
		DBG_Error( "TrigExec_FreezeModifier : bad param (gao1)" )
		return faux
	}
	@o OBJ_FreezeModifier(m_msg.msg_int1, 1)	 
	return vrai
}


///TrigExec_BurnCapa0
//============================================================
// Param IN:
//		gao (gao1) 		=> Gao dont on veut mettre la capa 0 si un feu se declenche dedans
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_BurnCapa0( byref message m_msg ) // object1 gao
{
	int			i
	object	to_obj
	
	for(i = 0; i < 10; i++)
	{
		if( ! @get_SFX_GridFire o_set_capa0[i]) break
	}
	
	if(i == 10) return vrai
	
	to_obj = m_msg.msg_gao1
	@get_SFX_GridFire o_set_capa0[i] = to_obj
	return vrai
}

///TrigExec_BurnParams
//============================================================
// Param IN:
//		params(.x)		=> duree des flammes (0 = defaut)
//		params(.y)		=> temps de propagation (0 = defaut)
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_BurnParams( byref message m_msg ) // vec1 params
{
	vector	tv_temp
	
	tv_temp = m_msg.msg_vec1
	@get_global f_fire_duration = tv_temp.x
	@get_global f_fire_propag = tv_temp.y
	return vrai
}

///TrigExec_Burn
//============================================================
// Param IN:
//		gao (gao1) 		=> Objet position de la case a bruler (Si vide alors position gao courant)
//		duree (.x)		=> duree des flammes (0 = infini)
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Burn( byref message m_msg ) // object1 gao vec1 duree
{
	int			ti_capa
	object	to_obj, to_gao
	int			x, y
	vector	tv_temp
	vector	pos
	int			ti_ok
	
	if(!GRID_Has(1))
		return vrai
	GRID_CurrentSet(1)
	
	// -- Position a griller --
	to_gao = m_msg.msg_gao1
	if (	!to_gao ) to_gao = OBJ_Me()
	pos = @to_gao OBJ_PosGet()
	
	ti_ok = faux
	ti_capa = GRID_CapaGet(pos) 
	if(((ti_capa & tag_grid_terrain) == Ci_Grid2_Inflammable) && !(ti_capa & 64) && !(ti_capa & 128)) ti_ok = vrai
	
	if(!ti_ok)
	{
		for(x = -1; x <= 1; x++)
		{
			for(y = -1; y <= 1; y++)
			{
				if(x == 0 && y == 0) continue
				tv_temp = pos
				tv_temp.x += x
				tv_temp.y += y
				ti_capa = GRID_CapaGet(tv_temp) 
				if(((ti_capa & tag_grid_terrain) == Ci_Grid2_Inflammable) && !(ti_capa & 64) && !(ti_capa & 128)) 
				{
					pos = tv_temp
					ti_ok = vrai
					break
				}
			}
			
			if(ti_ok) break
		}
	}

	if(ti_ok) 
	{
		tv_temp = m_msg.msg_vec1
		to_obj = @get_SFX_GridFire OBJ_Duplicate(pos)
		@get_SFX_GridFire_path to_obj f_max_delay = tv_temp.x
		@get_SFX_GridFire_path to_obj i_original = faux
	}
	
	GRID_CurrentSet(0)

	return vrai
}

///TrigExec_SimulateEnnemy
//============================================================
// Param IN:
//		gao (gao1) 		=> Objet position 
//		type				=> Type de l'ennemy
//									raptor 14 swamp 23 oiseaucrouch 28
//		etat				=> attente 3 fight 4
//		time (.x)			=> duree (0 == une trame)
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_SimulateEnnemy( byref message m_msg ) // object1 who int1 type int2 etat vec1 time
//{
//	int				ti_i
//	object		to_obj
//	messageid	EVT_InfoSeen_ID
//	message	EVT_msg
//	object		to_who
//	vector		tv_temp
//	float			tf_time
//	
//	tv_temp = m_msg.msg_vec1
//	tf_time = tv_temp.x	
//	if(!tf_time) tf_time = Cf_EVENT_Duree_1Trame
//
////	EVENT_AddEventEnemy( C_ID_Raptor, OBJ_Me(), C_EVENT_EnemyState_Fight)
//	to_who = m_msg.msg_gao1
//	if(!to_who) to_who = OBJ_Me()
//	MSG_SetNull( EVT_msg)
//	EVT_msg.msg_int1 = m_msg.msg_int1 		// type 
//	EVT_msg.msg_int2 = m_msg.msg_int2		// etat
//	to_obj = @to_who ANI_CanalObjectGet(Anim_Canal_Torse)
//	if(!to_obj) to_obj = @to_who ANI_CanalObjectGet(Anim_Canal_Tete)
//	if(to_obj) 
//		EVT_msg.msg_vec1 = @to_obj OBJ_PosGet()
//	else
//		EVT_msg.msg_vec1 = @to_who OBJ_PosGet()
//	@to_who MSG_GlobalSend( C_EVENT_TYPE_Enemy, tf_time, EVT_msg, C_EVENT_EOFADD)
//	
//	for(ti_i = 0; ti_i < C_ID_Last_Compagnon; ti_i++)
//	{
//		to_obj = @"univ" ao_AllHumains[ti_i]
//		if(!to_obj) continue
//		
////		EVT_InfoSeen_ID = EVENT_AddEventInfo(OBJ_Me(), to_obj, C_EVENT_INFOTYPE_SEEN)
//		MSG_SetNull( EVT_msg)
//		EVT_msg.msg_int1 = C_EVENT_INFOTYPE_SEEN
//		EVT_msg.msg_gao1 = to_obj
//		EVT_InfoSeen_ID = @to_who MSG_GlobalSend( C_EVENT_TYPE_Info, tf_time, EVT_msg, C_EVENT_EOFADD)
//		
////		EVENT_Info_OutsideGridSet(EVT_InfoSeen_ID, faux)
//		MSG_GlobalSetInt( EVT_InfoSeen_ID, faux, INT3)
//		
////		EVT_InfoSeen_ID = EVENT_AddEventInteret(OBJ_Me(), 0.1, 10.0, @to_obj OBJ_PosGet(), to_obj)
////		EVENT_InteretStatusSet(EVT_InfoSeen_ID, C_EVENT_InteretStatusAttack)
//	}
//	MSG_SetNull( EVT_msg)
//	EVT_msg.msg_id = 10
//	EVT_msg.msg_int1 = C_EVENT_LockCamStatus_Fight
//	EVT_msg.msg_vec1 = Cv_NullVector
//	@to_who MSG_GlobalSend( C_EVENT_TYPE_LockCam,Cf_EVENT_Duree_1Trame, EVT_msg, C_EVENT_EOFADD)
//	return  vrai
//}

///TrigExec_EtatHumain
//============================================================
// Param IN:
//		qui 				
//				#define	C_ID_Jack								1		// Indice de Jack
//				#define	C_ID_Ann								2		// Indice de Ann
//				#define	C_ID_Hayes							3
//				#define	C_ID_Denham							5
//				#define	C_ID_Jimmy							6
//		etat				
//				#define Life_ETAT_Normal			0			// En pleine forme
//				#define Life_ETAT_Agonisant		1			// Blessé
//				#define Life_ETAT_Conval			2			// Soigné
//				#define Life_ETAT_Mort			3			// Mort
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_EtatHumain( byref message m_msg ) // int1 qui int2 etat
{
	@"univ" LIFE_HumainEtat[m_msg.msg_int1] = m_msg.msg_int2
	return  vrai
}

///TrigExec_SetGenericSpeechState
//============================================================
// Param IN:
//		state (int 1) 	=> 0 : hide generic texte
//								1 : show generic texte
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SetGenericSpeechState( byref message m_msg ) // int1 state
{
	@get_global GLOBAL_i_PlayGenericSpeech = m_msg.msg_int1
	return  vrai
}


// TrigExec_ParticuleGenerator_Go
//============================================================
// Param IN:
// 		Freq	   (Vec1.x)	=> Frequence (Nbr de particule/seconde)
//		Duree1 (Vec1.y) 	=> Durée de la generation
//		Duree2 (Vec1.z)  => Durée de la disparition (Temps necessaire avant disparition)
//		GaoParticuleG	=> Gao qui possede le generateur de particule (None = Moi)
//
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_ParticuleGenerator_Go( byref message m_msg ) // vec1 Freq object1 GaoParticuleG
{
	vector		tv_vec
	object		to_g
	
	tv_vec = m_msg.msg_vec1

	if (m_msg.msg_gao1) 
		to_g = m_msg.msg_gao1
	else
		to_g = OBJ_Me()
	
	tv_vec.y -= MATH_FloatMin(tv_vec.y, TIME_GetDt())
	if (tv_vec.y)
	{	
		// Delai1 non encore ecoulé
		@to_g OBJ_PagGeneratorFreqSet(1, tv_vec.x)
		m_msg.msg_vec1 = tv_vec
	}
	else
	{
		// Delai1 ecoulé
		@to_g OBJ_PagGeneratorFreqSet(1, 0.0)
		tv_vec.z -= MATH_FloatMin(tv_vec.z, TIME_GetDt())
		if (tv_vec.z)
			m_msg.msg_vec1 = tv_vec
		else
			return vrai	// TERMINE
	}
	return faux // TO BE CONTINUED
}


// TrigExec_ShakeCamAndRumble
//============================================================
// Param IN: 
//
//		SHAKE KAM -----------------------------------------------------------------------------------
// 		Amplitude 							(Vec1.x)		Ex: 0.02
//
//		Si 	VEC1 Null alors pas de SHAKE KAM (eventuellement du Rumble)
//
//		RUMBLE Vibration JOY --------------------------------------------------------------------
//		RumbleJoyGraveDuree			(Vec2.x)		Ex: 10     // 0 = Pas de Rumble Grave (Low Frequency)
//		RumbleJoyGravePuissance	(Vec2.y)		Ex: 150   // Valeur de De 0 a 255 max
//		RumbleJoyAigueDuree			(Vec2.z)		Ex: 10     // 0 = Pas de Rumble Aigue (Hi Frequency)
//
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_ShakeCamAndRumble( byref message m_msg ) // vec1 ShakeAmplitude vec2 RumbleJoy
{
	vector		tv_vec
	object		to_camera 

	tv_vec = m_msg.msg_vec1
	if (!MATH_VecNull(tv_vec))
	{
		// Vec 3 Non Null
		tv_vec.y = 0
		tv_vec.z = 0
		m_msg.msg_vec1 = tv_vec
	
		m_msg.msg_id = 3

		to_camera = @get_global o_camera
		@to_camera MSG_Send(m_msg)
	}

	// Rumble  !
	tv_vec = m_msg.msg_vec2
	if (tv_vec.x)
		IO_PafSet(tv_vec.y, tv_vec.x)
	if (tv_vec.z)
		IO_PifSet(tv_vec.z)

	return		vrai
}

///TrigExec_Teleport
//============================================================
// Param IN:
//		who	 	(object1)		gao to teleport
//		where	(obejct2)		gao where to teleport who
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Teleport( byref message m_msg ) // object1 who object2 where
{
	object		who, where

	who = m_msg.msg_gao1
	where = m_msg.msg_gao2
	if ( ( who != nobody ) && (where != nobody )) 
	{
//		if (@who AI_IsModel("PNJ_Predators/PNJ_Raptor"))
//		{
//			@who OBJ_Destroy()
//			@who OBJ_Reinit(vrai)
//		}
		if( who == AI_MainActorGet(0))
			@who PROC_RM_Grappin_Destroy()
		@who OBJ_PosSet( @where OBJ_PosGet() )
		@who OBJ_SightSet( @where OBJ_SightGet() )
		@who COL_StartMatrixSet(@who OBJ_PosGet())
	}
	return vrai
}

///TrigExec_GameSpeedSet
//============================================================
// Param IN:
//		Vec1.x   = Vitesse du moteur a atteindre ( 1 = vitesse normal. 0.5 = ralenti deux fois...)
//		Vec1.y   = Vitesse de blend pour le changement de vitesse ( 1 lent, 5 moyen, 10 rapide, 100000 = CUT)
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_GameSpeedSet( byref message m_msg ) // vec1 vitesse
{
	vector		tv_vec
	
	tv_vec = m_msg.msg_vec1
	@get_global f_game_speed = MATH_FloatBlend(@get_global f_old_game_speed, tv_vec.x, tv_vec.y * TIME_GetDt())
	return vrai
}

///TrigExec_DesignStruct
//============================================================
// Param IN:
// 	who   	- quel objet
//	what		- quel champ ? (0 float1 => value_vector.x)
//									 (1 int2 => value_int)
// 	vvalue	- depend de what
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_DesignStruct( byref message m_msg ) // object1 who int1 what vec1 value_vector int2 value_int
{
	object	to_obj
	vector	tv_vec1
	
	to_obj = m_msg.msg_gao1
	tv_vec1 = m_msg.msg_vec1
	switch(m_msg.msg_int1)
	{
		case 0:	to_obj.des_float1 = tv_vec1.x break
		case 1:	to_obj.des_int2 = m_msg.msg_int2 break
	}
	
	return vrai
}

///TrigExec_RexChaseRange
//============================================================
// Param IN:
// 	who   			- quel Rex ?
//	dist_min			- en deca de cette distance, je m'arrete
//	dist_max		- au dela de cette distance, je vais à ma vitesse max
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
// FRED
//procedure_trigger int TrigExec_RexChaseRange( byref message m_msg ) // object1 who vec1 dist_min vec2 dist_max
//{
//	object	to_rex
//	vector	tv_temp
//	float		tf_dist_min
//	float		tf_dist_max
//
//	to_rex = m_msg.msg_gao1
//
//	tv_temp = m_msg.msg_vec1
//	tf_dist_min = tv_temp.x
//
//	tv_temp = m_msg.msg_vec2
//	tf_dist_max = tv_temp.x
//
//	@"PNJ_Predators/PNJ_Raptor" to_rex i_flag_chase_target = vrai
//	@"PNJ_Predators/PNJ_Raptor" to_rex f_chase_dist_min = tf_dist_min
//	@"PNJ_Predators/PNJ_Raptor" to_rex f_chase_dist_max = tf_dist_max
//	
//	return faux
//}


// TrigExec_Kong_FilmAnn
//============================================================
// Param IN: (none)
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_Kong_FilmAnn( byref message m_msg )
//{
//	object	to_gao
//	to_gao = @"univ" ao_AllHumains[C_ID_Kong]
//	if (to_gao)
//		@get_Kong_Path to_gao i_Kamera_cut_ANN_flag_external = vrai
//	return vrai
//}


// TrigExec_SendMessage
//============================================================
// Param IN:
//      receiver (object5)	=> gao receiving the message
//		the receiver receives a message of type msg_id_SendMessageTrigger
//		all the other members need to be setup according to the agreed protocol
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SendMessage( byref message m_msg )	// object5 receiver  object1 object1 object2 object2 object3 object3 object4 object4 vec1 vec1 vec2 vec2 vec3 vec3 vec4 vec4 vec5 vec5 int1 int1 int2 int2 int3 int3 int4 int4 int5 int5
{
	object to_receiver

	m_msg.msg_id = msg_id_SendMessageTrigger
	to_receiver = m_msg.msg_gao5
	if (to_receiver)
	{
		@to_receiver MSG_Send(m_msg)
	}
	return vrai
}

///TrigExec_SendMessageGao5Int5
//============================================================
// Param IN : 
//		- gao 5 : objet  a qui sera envoyé le message
//		- int 5 : msg_id
//		- tous les autres paramètes dépend du messaeg à envoyer
// Param OUT : None
// ne fait rien du tout du tout troulalaitou
//============================================================
procedure_trigger int TrigExec_SendMessageGao5Int5( byref message m_msg) //object1 object1 object2 object2 object3 object3 object4 object4 object5 towho vec1 vec1 vec2 vec2 vec3 vec3 vec4 vec4 vec5 vec5 int1 int1 int2 int2 int3 int3 int4 int4 int5 message_type
{
	object to_who
	
	to_who = m_msg.msg_gao5
	if (!to_who)
		to_who = OBJ_Me()
	m_msg.msg_gao5 = nobody
	m_msg.msg_id = m_msg.msg_int5
	m_msg.msg_int5 = 0
	@to_who MSG_Send( m_msg )
	return vrai
}



// TrigExec_Kong_CameraCine
//============================================================
// Param IN: 
//					Gao       = Objet camera pour la Position et l'Oriention (Nobody = Moi Meme)
//					vector.x  = Blend In (0 = cut, 2 = Slow, 5 = Medium, 10 = Fast)
//					vector.y  = Bend Out (-1 = Rien n'est forcé, 0 = Cut, 5 = Medium, 10 = Fast)
//					vector.z  = Focale (Ex: 0.8 / 1.2)
//					vector2.x = Durée du plan ( 0 = une trame )
//
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Kong_CameraCine( byref message m_msg ) // object1 Gao vec1 Vector vec2 Vector2
{
	object	to_gao
	object	to_gao2
	vector	tv_vec
	to_gao = @get_global o_camera

	to_gao2 = m_msg.msg_gao1
	if (!to_gao2)
		to_gao2 = OBJ_Me()

	@get_Kamera_Path to_gao o_cine_gao = to_gao2

	tv_vec = m_msg.msg_vec1

	if (!tv_vec.x)
		tv_vec.x = Cf_Infinit

	if (!tv_vec.y)
		tv_vec.y = Cf_Infinit

	@get_Kamera_Path to_gao f_cine_blendIn = tv_vec.x
	@get_Kamera_Path to_gao f_cine_blendOut = tv_vec.y
	@get_Kamera_Path to_gao f_cine_focale = tv_vec.z


	tv_vec = m_msg.msg_vec2

	@get_Kamera_Path to_gao f_cine_duration = tv_vec.x

	return vrai
}

// TrigExec_DisablePlayerControl
//============================================================
// Param IN:	(none)
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_DisablePlayerControl( byref message m_msg )
{
	object to_gao
//	to_gao = @"univ" ao_AllHumains[C_ID_Kong]
//	if (to_gao)
//		@get_Kong_Path to_gao i_joy_disable_control = vrai		// Freeze bouton du Joy.

	@get_global OBJ_CustomBitsSet(OBJ_CBits_7,none)		// Freeze le JOY analog du Global

	return vrai
}


// TrigExec_AnnSetTarget
//============================================================
// Param IN:
//      target (object1)	=> target ann will attack
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_AnnSetTarget( byref message m_msg )	// object1 target
//{
//	object to_receiver
//
//	m_msg.msg_id = msg_id_Ann_SetTarget
//	to_receiver = @"univ" ao_AllHumains[C_ID_Ann]
//	
//	@to_receiver MSG_Send(m_msg)
//	
//	return vrai
//}


// TrigExec_SectoCamSet
//============================================================
// Param IN:
//      secteur => N° du secteur
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_SectoCamSet( byref message m_msg ) // int1 secteur
//{
//	SCT_SetCurrent(m_msg.msg_int1)	
//	return vrai
//}


// TrigExec_KongCine_ControlLookAxis
//============================================================
// Param IN:
//      target (object1)	=> Look this !
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_KongCine_ControlLookAxis( byref message m_msg )	// object1 target
//{
//	object to_kong
//
//	to_kong = @"univ" ao_AllHumains[C_ID_Kong]
//	@get_Kong_Path to_kong o_look_cine = m_msg.msg_gao1
//
//	return vrai
//}


// TrigExec_KBigBat_Attack
//============================================================
// Param IN:
//                                 big_bat (object1)
//                                 target (object2)
//                                 attack_wp (object3) = Attack From Here
//                                 retreat_wp (object4) = Attack To There
//                                 decolle (int1) => décolle verticalement d'abord
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_KBigBat_Attack( byref message m_msg )	// object1 big_bat object2 target object3 attack_wp object4 retreat_wp int1 decolle
{
	object to_receiver
	to_receiver = m_msg.msg_gao1
	m_msg.msg_id = msg_id_KBigBat_Attack
	@to_receiver MSG_Send(m_msg)
	return vrai
}

// TrigExec_KBat_Network_Set
//============================================================
// Param IN:
//                                 bat (object1) =				the bat to be modified
//                                 n_net_wp (object2) =		any wp of the network that must be set as 'n_net' in the bat
//                                 n_attaque_wp (object3) =	any wp of the network that must be set as 'n_attaque' in the bat
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_KBat_Network_Set( byref message m_msg )	// object1 bat object2 n_net_wp object3 n_attaque_wp
{
	object to_receiver
	to_receiver = m_msg.msg_gao1
	m_msg.msg_id = msg_id_KBat_Network_Set
	@to_receiver MSG_Send(m_msg)
	return vrai
}


// TrigExec_ReInit_Object
//============================================================
// Param IN:
//                                 object to reinit(object1)
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_ReInit_Object( byref message m_msg )	// object1 to_reint
{
	object to_reint
	to_reint= m_msg.msg_gao1
	@to_reint OBJ_Reinit(0)
	return vrai
}


// TrigExec_KTREX_Charge
//============================================================
// Param IN:
//                                 KTREX (object1) =	The TREX
//                                 target (object2) 	=	The target for the charge
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_KTREX_Charge( byref message m_msg )	// object1 KTREX object2 target
{
	object to_receiver
	to_receiver = m_msg.msg_gao1
	m_msg.msg_id = msg_id_KTREX_Charge
	@to_receiver MSG_Send(m_msg)
	return vrai
}


// TrigExec_KAnn_Fear_Set
//============================================================
// Param IN:
//                                 Fear (int1) =	1 : Ann Fear Kong 0 else
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_KAnn_Fear_Set( byref message m_msg )	// int1 Fear
{
	 @get_global i_KK_ANN_Fear_Mode = m_msg.msg_int1
	return vrai
}


// TrigExec_KAnn_On_Shoulder_Set
//============================================================
// Param IN:
//                                 Shoulder (int1) =	1 Ann On shoulder 0 Ann in Kong's Hand
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_KAnn_On_Shoulder_Set( byref message m_msg )	// int1 Shoulder
{
	 @get_global i_KK_ANN_On_Shoulder = m_msg.msg_int1
	return vrai
}


///TrigExec_CRAB_SetVagueNb
//============================================================
// Param IN:
//		int_nb (int1)			=> nombre de crabes pour la vague (min 2)
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_CRAB_SetVagueNb(byref message m_msg) // int1 int_nb 
{
	int		ti_nb
	ti_nb = m_msg.msg_int1
	if( ti_nb < 2 )
		ti_nb = 2
#ifndef _FINAL_
	if(@get_global DEBUG_TCINE)
	{
		DBG_TraceString("TrigExec_CRAB_SetVagueNb : ")
		DBG_TraceInt(ti_nb)
		DBG_TraceEOL()
	}
#endif
	@get_global i_CRAB_humain_attack_max_nb = ti_nb
	return vrai
}



///TrigExec_SendPafKong
//============================================================
// Param IN:
//		paf_type (int1)			=> 0 Leger 1 Moyen 2 Fort 3 Tuant
//		dir (vec1)				=> sens du paf
//		recul ( vec2.x)			=> recul ajouté a Kong pour le faire tomber( unité inconue mais valeur++  -> recul++
//		actor	(gao1)			=> acteur quie nvoye le paf
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_SendPafKong(byref message m_msg) // int1 paf_type vec1 dir vec2 recul object1 actor
//{
//	vector	pv_pos, pv_puissance
//	object	po_obj
//	message	EVT_msg
//	MSG_SetNull( EVT_msg)
//	switch(m_msg.msg_int1)
//	{
//		case 0 :
//			m_msg.msg_int1 = C_PAF_KK_Faible
//			break
//		case 1 :
//			m_msg.msg_int1 = C_PAF_KK_Moyen
//			break
//		case 2 :
//			m_msg.msg_int1 = C_PAF_KK_Fort
//			break
//		case 3 :
//			m_msg.msg_int1 = C_PAF_KK_KiTue
//			break
//	}	
//
//	if ( ! m_msg.msg_gao1)
//		m_msg.msg_gao1 = OBJ_Me()
//	po_obj = m_msg.msg_gao1
//	pv_pos = m_msg.msg_vec2
//	pv_puissance = cvector( 0.0, 0.0, pv_pos.x)
//	pv_pos = @po_obj OBJ_PosGet()
//	
//	
////	EVT_msg.msg_int1 = C_EVENT_PAF_Kong
//	EVT_msg.msg_int1 = C_PAF_KK_Fort
//	EVT_msg.msg_int2 = m_msg.msg_int1
//	EVT_msg.msg_int3 = 0
//	EVT_msg.msg_int4 = -1
//	EVT_msg.msg_gao1 = @"univ" ao_AllHumains[C_ID_Kong]
//	EVT_msg.msg_vec1 = m_msg.msg_vec1
//	EVT_msg.msg_vec2 = pv_puissance 
//	EVT_msg.msg_vec3 = pv_pos
//
//	@po_obj MSG_GlobalSend( C_EVENT_TYPE_Paf, Cf_EVENT_Duree_1Trame, EVT_msg, C_EVENT_EOFADD)
//	return vrai
//}


//TrigExec_ActifVisible_Multiple
//============================================================
// Param IN:
//
//		Gao1 a 5		=> gao à modifier
//		Param1 a 5		=> Type d'operation affecté au GAO.
//                                   - 0 = Inactif   +   Invisible
//                                   - 1 = Actif     +   Invisible
//                                   - 2 = Inactif   +   Visible
//                                   - 3 = Actif     +   Visible
//
// Param OUT (none)
// Retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_ActifVisible_Multiple( byref message m_msg ) // object1 gao1 object2 gao2 object3 gao3 object4 gao4 object5 gao5 int1 param1 int2 param2 int3 param3 int4 param4 int5 param5
{
	object	gao
	int			int1 
	gao = m_msg.msg_gao1
	if (gao)
	{
		int1 = m_msg.msg_int1
		@gao OBJ_FlagInactiveSet( ~int1 & 1 )
		@gao OBJ_FlagInvisibleSet( ~int1 & 2 )
	}
	gao = m_msg.msg_gao2
	if (gao)
	{
		int1 = m_msg.msg_int2
		@gao OBJ_FlagInactiveSet( ~int1 & 1 )
		@gao OBJ_FlagInvisibleSet( ~int1 & 2 )
	}
	gao = m_msg.msg_gao3
	if (gao)
	{
		int1 = m_msg.msg_int3
		@gao OBJ_FlagInactiveSet( ~int1 & 1 )
		@gao OBJ_FlagInvisibleSet( ~int1 & 2 )
	}
	gao = m_msg.msg_gao4
	if (gao)
	{
		int1 = m_msg.msg_int4
		@gao OBJ_FlagInactiveSet( ~int1 & 1 )
		@gao OBJ_FlagInvisibleSet( ~int1 & 2 )
	}
	gao = m_msg.msg_gao5
	if (gao)
	{
		int1 = m_msg.msg_int5
		@gao OBJ_FlagInactiveSet( ~int1 & 1 )
		@gao OBJ_FlagInvisibleSet( ~int1 & 2 )
	}

	return vrai
}

//TrigExec_WaterEnable
//============================================================
// Param IN:
//	on_off	-	water on/off
// Param OUT (none)
// Retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_WaterEnable( byref message m_msg ) // int1 on_off
{
	WTR_Enable(m_msg.msg_int1)
	return vrai
}


///TrigExec_LittleScoloRetreat
//============================================================
// Param IN:
// Param OUT (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_LittleScoloRetreat(byref message m_msg) // int2 int_type int3 int_attack object1 gao_father object2 gao_target
//{
//#ifndef _FINAL_
//	if(@get_global DEBUG_TCINE) DBG_TraceString("TrigExec_LittleScoloRetreat\n")
//#endif
//	m_msg.msg_int1 = C_EVENT_INFOTYPE_LITTLESCOLORETREAT
//	MSG_GlobalSend( C_EVENT_TYPE_Info, 0.0, m_msg, C_EVENT_ADD)
//	return vrai
//}


// TrigExec_Kong_Small_KNMI_Must_Die
//============================================================
// Param IN: (none)
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Kong_Small_KNMI_Must_Die( byref message m_msg )
{
	@get_global i_Small_KNMI_must_die = vrai
	return vrai
}


// TrigExec_Kong_Finish_Arena_Center_Set
//============================================================
// Param IN:                                 object1 : wp centre de l'arène
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Kong_Finish_Arena_Center_Set( byref message m_msg ) // object1 arena_center
{
	@get_global o_KK_finish_arena_center = m_msg.msg_gao1
	return vrai
}


// TrigExec_KAnn_Check_Paf_on_Network
//============================================================
// Param IN:    (none)
// Param OUT: (none)
//						ATTENTION, la priorité du trigger doit etre < 111 !!! (prio de KAnn)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_KAnn_Check_Paf_on_Network( byref message m_msg )
{
	@get_global i_KAnn_check_paf_on_network = vrai
	return vrai
}

// TrigExec_SectorisationSet
//============================================================
// Param IN:     Sect = N° de secteur
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SectorisationSet( byref message m_msg ) // int1 Sect
{
	object to_gao
	SCT_SetCurrent(m_msg.msg_int1)

	to_gao = @get_global o_AI_secto_gao
	if (to_gao)
		@to_gao Proc_Sec_AISecto_ADD()

	return vrai
}

// TrigExec_SectorisationSet
//============================================================
// Param IN:     Sect1 = N° de secteur 1
//                    Sect2 = N° de secteur 2
//                    Sect3 = N° de secteur 3
//                    Sect4 = N° de secteur 4
//                    Gao   = Objet a Sectoriser
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SectoriseCeGao( byref message m_msg ) // int1 Sect1 int2 Sect2 int3 Sect3 int4 Sect4 object1 Gao
{
	object	to_gao
	to_gao = m_msg.msg_gao1
	@to_gao SCT_SetOf(m_msg.msg_int1,m_msg.msg_int2,m_msg.msg_int3,m_msg.msg_int4)
	return vrai
}


// TrigExec_Kong_Ignore_Pafs
//============================================================
// Param IN:    (none)
// Param OUT: (none)
//						ATTENTION, la priorité du trigger doit etre < 11 !!! (prio de Kong)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_Kong_Ignore_Pafs( byref message m_msg )
//{
//	@get_global i_Kong_ignore_paf = vrai
//	return vrai
//}


// TrigExec_KBigBat_Grab_Ann
//============================================================
// Param IN:    - big_bat : the big bat whom you want to grab Ann
//                    - reset : si vrai, la big bat resete son action courante quand elle a grabbé Ann
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_KBigBat_Grab_Ann( byref message m_msg ) // object1 big_bat int1 reset
//{
//	@get_global o_KBigBat_instant_grab_Ann = m_msg.msg_gao1
//	if( m_msg.msg_int1 )
//		@get_global i_KBigBat_instant_grab_Ann_reset = vrai
//	return vrai
//}


// TrigExec_BatsKillZoneSet
//============================================================
// Param IN:    - BV : gao dont la BV détermine la zone dans laquelle les bats meurent
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_BatsKillZoneSet(byref message m_msg ) // object1 BV
//{
//	@get_global o_BatsKillZone = m_msg.msg_gao1
//	return vrai
//}


// TrigExec_KAnn_Drop_Javelin
//============================================================
// Param IN:    (none)
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_KAnn_Drop_Javelin( byref message m_msg ) // 
//{
//	@get_global i_KAnn_Drop_Javelin = vrai
//	return vrai
//}

// TrigExec_KTREX_Change_Territory
//============================================================
// Param IN:    TREX  : le TREX cible
//					Territory : son nouveau territoire
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_KTREX_Change_Territory( byref message m_msg ) // object1 TREX object2 Territoire
//{
//	object	to_trex
//	to_trex = m_msg.msg_gao1
//	@to_trex KT_Proc_ChangeTerritory( m_msg.msg_gao2)
//	return vrai
//}

// TrigExec_KTREX_Charge_Gao
//============================================================
// Param IN:    TREX  : le TREX cible
//					Target : la cible
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_KTREX_Charge_Gao( byref message m_msg ) // object1 TREX object2 Target
//{
//	object	to_trex
//	to_trex = m_msg.msg_gao1
//	@to_trex KT_Proc_Charge( m_msg.msg_gao2)
//	return vrai
//}

// TrigExec_KBigBatAttackSequenceReady
//============================================================
// Param IN:    BigBat : la BigBat qui doit passer en séquence d'attaque
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
//procedure_trigger int TrigExec_KBigBatAttackSequenceReady( byref message m_msg ) // object1 BigBat
//{
//	object	to_bigbat
//	to_bigbat = m_msg.msg_gao1
//	@to_bigbat KBC_Set_Ready_For_Attack_Sequence()
//	return vrai
//}

// TrigExec_SFX_Plouf
//============================================================
// Param IN:    Position: Gao de Position du SFX
//					Param.x  Amplification (1 = Taille normale, 2 = 2 fois plus gros...)
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SFX_Plouf( byref message m_msg ) // object1 Position Param vec1
{
	int			mi_GFX_Key
	vector	tv_pos
	object	to_gao
	float		tf_ampli 
	vector	tv_vec

	to_gao = m_msg.msg_gao1
	tv_pos = @to_gao OBJ_PosGet()
	tv_vec = m_msg.msg_vec1
	tf_ampli = tv_vec.x
	if ( MATH_FloatNullEpsilon(tf_ampli) )
		tf_ampli = 1.0
	
	mi_GFX_Key = GFX_Add(13)
	GFX_MaterialSet( mi_GFX_Key, get_SFX_light_and_smoke, -1 )
	GFX_FlagSet( mi_GFX_Key, 0 , 1)
	GFX_FlagSet( mi_GFX_Key, 2 , 1)
	GFX_Seti( mi_GFX_Key, 13101,37)
	GFX_Seti( mi_GFX_Key, 13102,38)
	GFX_Seti( mi_GFX_Key, 13100,30* tf_ampli )
	GFX_Seti( mi_GFX_Key, 13106,30* tf_ampli )
	GFX_Setf( mi_GFX_Key, 13003,0.200000 * tf_ampli )
	GFX_Setf( mi_GFX_Key, 13004,0.400000 * tf_ampli )
	GFX_Seti( mi_GFX_Key, 13012,0.500000 * tf_ampli )
	GFX_Seti( mi_GFX_Key, 13107,0)
	GFX_Setf( mi_GFX_Key, 13000,0.250000 * tf_ampli )
	GFX_Setf( mi_GFX_Key, 13001,0.4900000 * tf_ampli )
	GFX_Setf( mi_GFX_Key, 13002,0.010000)
	GFX_Setf( mi_GFX_Key, 13005,0.100000 * tf_ampli )
	GFX_Setf( mi_GFX_Key, 13006,0.300000 * tf_ampli )
	GFX_Setf( mi_GFX_Key, 13007,-5.000000)
	GFX_Setv( mi_GFX_Key, 13203,cvector(0.01500, 0.01500, 0.02500))
	GFX_Seti( mi_GFX_Key, 13103,-3551556)
	GFX_Seti( mi_GFX_Key, 13104,-1178087748)
	GFX_Seti( mi_GFX_Key, 13105,12306608)
	GFX_Setf( mi_GFX_Key, 13009,-1.000000 * tf_ampli)
	GFX_Setf( mi_GFX_Key, 13010,-4.000000 * tf_ampli)
	GFX_Setf( mi_GFX_Key, 13011,-1000)
	GFX_Setv( mi_GFX_Key, 13200, tv_pos)
	GFX_Setv( mi_GFX_Key, 13201,cvector(0.00000, 0.00000, -0.15000))
	GFX_Setv( mi_GFX_Key, 13202,cvector(0.00000, 0.00000, -0.35000))
	GFX_Setv( mi_GFX_Key, 13204,cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13205,cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13206,cvector(0.00000, 0.00000, 0.00000))
	GFX_Setv( mi_GFX_Key, 13207,0.150000 * @to_gao OBJ_HorizonGet() * tf_ampli  )
	GFX_Setv( mi_GFX_Key, 13208,0.150000 * @to_gao OBJ_SightGet() * tf_ampli  )
	GFX_Setv( mi_GFX_Key, 13209,0.100000  * @to_gao OBJ_BankingGet() * tf_ampli )
	GFX_Seti( mi_GFX_Key, 13114,1)
	GFX_Setf( mi_GFX_Key, 13013,-1.000000)
	GFX_Setf( mi_GFX_Key, 13014,1.000000)
	GFX_Setf( mi_GFX_Key, 13015,-0.050000)
	GFX_Setf( mi_GFX_Key, 13016,0.050000)
	GFX_Setf( mi_GFX_Key, 13008,0.000000)
	return vrai
}


// TrigExec_SFX_Poils
//============================================================
// Param IN:    Position: Gao de Position du SFX
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_SFX_Poils( byref message m_msg ) // object1 Position
{
	int			pi_GFX_Blood
	int			materiau_color
	object	to_light_n_smoke

	vector	tv_pos
	object	to_gao
	vector	tv_wind

	to_gao = m_msg.msg_gao1
	tv_pos = @to_gao OBJ_PosGet()
	tv_wind = Cv_NullVector
	
	to_light_n_smoke = @get_global o_global_light_and_smoke_kanada
	if( ! to_light_n_smoke )
		return vrai
	tv_wind *= -1.0		

	materiau_color = 0x00000000
	pi_GFX_Blood = GFX_Add(13)																// Create the boum	
	GFX_MaterialSet(pi_GFX_Blood, to_light_n_smoke, -1)
	GFX_FlagSet(pi_GFX_Blood, 0 , 1)
	GFX_FlagSet(pi_GFX_Blood, 2 , 1)
	GFX_Seti(pi_GFX_Blood, 13101, 23)														// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13110, 22)														// Materiau N°
	GFX_Seti(pi_GFX_Blood, 13100, 40)														// *Buffer number of sprite
	GFX_Seti(pi_GFX_Blood, 13106, 40)														// *number of sprite to generate
	GFX_Setf(pi_GFX_Blood, 13003, 0.5)														// Time fase 1
	GFX_Setf(pi_GFX_Blood, 13004, 0.8)														// Time fase 2
	GFX_Seti(pi_GFX_Blood, 13107, 0)															// Sprites non triés
	GFX_Setf(pi_GFX_Blood, 13012, 0.75)														// Time random
	GFX_Setf(pi_GFX_Blood, 13000, 0.0)														// Growing speed min
	GFX_Setf(pi_GFX_Blood, 13001, 0.0)														// Growing speed max
	GFX_Setf(pi_GFX_Blood, 13002, 1.0)														// Friction Grow
	GFX_Setf(pi_GFX_Blood, 13005, 0.25)														// Creation size min
	GFX_Setf(pi_GFX_Blood, 13006, 0.5)														// Creation size max
	GFX_Setv(pi_GFX_Blood, 13203, cvector(0.02, 0.02, 0.0))							// friction speed
	GFX_Seti(pi_GFX_Blood, 13103, 0xFF000000 + materiau_color)					// Color fase 0
	GFX_Seti(pi_GFX_Blood, 13104, 0xFF000000 + materiau_color)					// Color fase 1
	GFX_Seti(pi_GFX_Blood, 13105, 0x00000000 + materiau_color)					// Color fase 2
	GFX_Setf(pi_GFX_Blood, 13009, -1.0)														// Norm speed min
	GFX_Setf(pi_GFX_Blood, 13010, -5.0)														// Norm speed max
	GFX_Setf(pi_GFX_Blood, 13007, -5.0)														// Gravity
	GFX_Setf(pi_GFX_Blood, 13008, 0.001)													// generation rate
	GFX_Setv(pi_GFX_Blood, 13204, Cv_NullVector)										// wind
	GFX_Setv(pi_GFX_Blood, 13205, Cv_NullVector)										// Mainposspeed
	GFX_Setv(pi_GFX_Blood, 13206, Cv_NullVector)										// Mainpossfriction
	GFX_Setv(pi_GFX_Blood, 13200, tv_pos) 												// Creation Pos
	GFX_Setv(pi_GFX_Blood, 13207, 0.5 * @to_gao OBJ_HorizonGet())				// Volume edge 1
	GFX_Setv(pi_GFX_Blood, 13208, 0.5 * @to_gao OBJ_SightGet())				// Volume edge 2
	GFX_Setv(pi_GFX_Blood, 13209, 0.5  * @to_gao OBJ_BankingGet())			// Volume edge 3
	GFX_Setv(pi_GFX_Blood, 13201, tv_wind + cvector(-1.0, -1.0, -0.4))				// Speed min
	GFX_Setv(pi_GFX_Blood, 13202, tv_wind + cvector(1.0, 1.0, 1.0))					// Speed max
	// Rotation Aléatoire -----------------------------------------------------------------------------------------------------------------------------------------
	GFX_Seti(pi_GFX_Blood, 13114, 1)															// Rotation ON / OFF
	GFX_Setf(pi_GFX_Blood, 13013,-1.000000) 												// Rotation Aléatoire a la naissance Min
	GFX_Setf(pi_GFX_Blood, 13014,1.000000) 												// Rotation Aléatoire a la naissance Max
	GFX_Setf(pi_GFX_Blood, 13015,-0.350000) 												// Speed rotation Min
	GFX_Setf(pi_GFX_Blood, 13016,0.350000) 												// Speed rotation Maw

	return vrai
}



// TrigExec_Occluder_Add ======================================================
// Param IN:    Occluder1  : les occluders( 1 - 5 )

// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Occluder_Add( byref message m_msg ) // object1 Occluder1  object2 Occluder2  object3 Occluder3 object4 Occluder4  object5 Occluder5 
{
	object	to_GST
	to_GST = get_list_manager
	if ( m_msg.msg_gao1)
		@to_GST WAY_LIB_Add_Occluder( m_msg.msg_gao1)
	if ( m_msg.msg_gao2)
		@to_GST WAY_LIB_Add_Occluder( m_msg.msg_gao2)
	if ( m_msg.msg_gao3)
		@to_GST WAY_LIB_Add_Occluder( m_msg.msg_gao3)
	if ( m_msg.msg_gao4)
		@to_GST WAY_LIB_Add_Occluder( m_msg.msg_gao4)
	if ( m_msg.msg_gao5)
		@to_GST WAY_LIB_Add_Occluder( m_msg.msg_gao5)
	return vrai
}

// TrigExec_Occluder_Del ======================================================
// Param IN:    Occluder1  : les occluders( 1 - 5 )

// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Occluder_Del( byref message m_msg ) // object1 Occluder1  object2 Occluder2  object3 Occluder3 object4 Occluder4  object5 Occluder5 
{
	object	to_GST
	to_GST = get_list_manager
	if ( m_msg.msg_gao1)
		@to_GST WAY_LIB_Del_Occluder( m_msg.msg_gao1)
	if ( m_msg.msg_gao2)
		@to_GST WAY_LIB_Del_Occluder( m_msg.msg_gao2)
	if ( m_msg.msg_gao3)
		@to_GST WAY_LIB_Del_Occluder( m_msg.msg_gao3)
	if ( m_msg.msg_gao4)
		@to_GST WAY_LIB_Del_Occluder( m_msg.msg_gao4)
	if ( m_msg.msg_gao5)
		@to_GST WAY_LIB_Del_Occluder( m_msg.msg_gao5)
	return vrai
}

// TrigExec_Territory_Change ======================================================
// Param IN:    TerritoryX  : territories( 1 - 5 )
//					ON_OFFX  : vrai :active territorry / faux inactive
// Param OUT: (none)
// retourne vrai (pour les exec, vrai indique que le trigger est terminé)
//============================================================
procedure_trigger int TrigExec_Territory_Change( byref message m_msg ) // object1 Territory1 object2 Territory2  object3 Territory3 object4 Territory4  object5 Territory5 // int1 ON_OFF1 int2 ON_OFF2 int3 ON_OFF3 int4 ON_OFF4 int5 ON_OFF5
{
	int			ti_i, ti_int
	object	to_o
	
	for ( ti_i =0; ti_i<5; ti_i++)
	{
		switch( ti_i)
		{
			case 0 :
				to_o = m_msg.msg_gao1
				ti_int = m_msg.msg_int1
				break
			case 1 :
				to_o = m_msg.msg_gao2
				ti_int = m_msg.msg_int2
				break
			case 2 :
				to_o = m_msg.msg_gao3
				ti_int = m_msg.msg_int3
				break
			case 3 :
				to_o = m_msg.msg_gao4
				ti_int = m_msg.msg_int4
				break
			case 4 :
				to_o = m_msg.msg_gao5
				ti_int = m_msg.msg_int5
				break
		}
		if ( to_o)
		{
			if ( ti_int)
				@to_o OBJ_CapaSet( none, OBJ_Capa_13)
			else
				@to_o OBJ_CapaSet( OBJ_Capa_13, none)
		}
	}
	return vrai
}

///TrigExec_DisableKongAutoMove
//============================================================
// Param IN : None
// Param OUT : None
// Empêche Kong en mode auto de faire toute action.
// Important : doit avoir une priorité < 11 !!!!!
//============================================================
procedure_trigger int TrigExec_DisableKongAutoMove(byref message m_msg)
{
	object to_kong
//	to_kong = AI_MainActorGet(C_ID_Kong)
//	if( to_kong )
//	{
//		@get_Kong_Path to_kong i_LD_disable_Kong_move = vrai
//	}
	return vrai
}


///TrigExec_DoorReinit
//============================================================
// Param IN :    - door : la door à réinitialiser
//                     - pilier : le pilier pour ouvrir la door
//                     - levier : le levier pour ouvrir la door
//                     - opening_wp : le wp à atteindre
//                     - move
//                     - rotate
// Param OUT : None
//============================================================
//procedure_trigger int TrigExec_DoorReinit(byref message m_msg)	// object1 door object2 pilier object3 levier object4 opening_wp int1 move int2 rotate
//{
//	object	to_door
//	object 	to_pilier
//	object	to_levier
//	object	to_opening_wp
//	int			ti_move
//	int			ti_rotate
//	vector	tv_pos
//	to_door = m_msg.msg_gao1
//	to_pilier = m_msg.msg_gao2
//	to_levier = m_msg.msg_gao3
//	to_opening_wp = m_msg.msg_gao4
//	ti_move = m_msg.msg_int1
//	ti_rotate = m_msg.msg_int2
//	if( @to_door AI_IsModel(get_Interactive_Door_path) )
//	{
//		tv_pos = @to_door OBJ_PosGet()
//		@to_door OBJ_Reinit(0)
//		@to_door OBJ_PosSet(tv_pos)
//		@get_Interactive_Door_path to_door i_trigger_reinit_flag = vrai
//		@get_Interactive_Door_path to_door v_pos_init = tv_pos
//		@get_Interactive_Door_path to_door mi_PD_NbPilar = 1
//		@get_Interactive_Door_path to_door mao_PD_Pilar[0] = to_pilier
//		@get_Interactive_Door_path to_door mao_PD_PilarLevier[0] = to_levier
//		@get_Interactive_Door_path to_door mo_OpeningWP = to_opening_wp
//		@get_Interactive_Door_path to_door mi_Move = ti_move
//		@get_Interactive_Door_path to_door mi_Rotate = ti_rotate
//	}
//	return vrai
//}


///TrigExec_RM_Stop_World
//============================================================
// Param IN : 					i_OFF_ON: 
//										vrai : STOP le WORLD ENV
//										faux : REACTIVE le WORLD ENV
// Param OUT : None
//============================================================
procedure_trigger int TrigExec_RM_Stop_World( byref message m_msg)	// int1 i_OFF_ON
{
	if ( m_msg.msg_int1)
		@get_global i_world_stopped = vrai
	else
		@get_global i_world_stopped = faux
	return vrai
}


///TrigExec_RM_KAM_DisableFight
//============================================================
// Param IN : 			i_OFF_ON: 
//										0 : Vire l'interdiction permanance
//										1 : Interdit pour juste cette trame (a envoyer le nbr de trame necessaire)
//										2 : Interdit Permanante activé
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_RM_KAM_DisableFight( byref message m_msg)	// int1 i_OFF_ON
{
	switch (m_msg.msg_int1)
	{
		case 0 :
			@get_Kamera i_kam_enable_fight_toggle = vrai
			break
		case 1 : 
			@get_Kamera i_kam_enable_fight_trame = faux
			break
		default:
			@get_Kamera i_kam_enable_fight_toggle = faux
	}
	return vrai
}


///TrigExec_RM_Stream_Change
//============================================================
// Param IN : 			Factory = gao avec l IA stream factory
//							force: coordonnée x = nouvelle force du vent( avec signe)
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_RM_Stream_Change( byref message m_msg)	// object1 Factory vec1 force
{
	float	pf_force
	vector	pv_temp
	object	po_stream
	pv_temp = m_msg.msg_vec1
	pf_force = pv_temp.x
	po_stream = m_msg.msg_gao1
	@po_stream PROC_StreamSet( pf_force)
	return vrai
}


///TrigExec_Lapin_ModeCompagnon_Set
//============================================================
// Param IN : 			Lapin = gao avec l' IA PNJ_Lapin
//							compagnon : focer le mode compagnon : VRAI / FAUX
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_Lapin_ModeCompagnon_Set(byref message m_msg)	// object1 Lapin int1 compagnon
{
	float	pf_force
	vector	pv_temp
	object	po_gao
	po_gao = m_msg.msg_gao1
	if( po_gao && @po_gao AI_IsModel(get_PNJ_Lapin_path) )
		@po_gao Proc_Lapin_ModeCompagnon_Set(m_msg.msg_int1)
	return vrai
}



///TrigExec_RM_Cut_Grappin
//============================================================
// Param IN : 			None
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_RM_Cut_Grappin(byref message m_msg)	// 
{
	@get_global i_grappin_hotspot_nmi_died = vrai
	return vrai
}


///TrigExec_RM_OBJECTIF_Activation
//============================================================
// Param IN : 			num = numéro de l'objectif
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_RM_OBJECTIF_Activation(byref message m_msg)	// int1 num
{
	color 		tc_color
	object	to_manager
	int			ti_num
	ti_num = m_msg.msg_int1
	SpecialFlag_set(5000 + ( 2 * ti_num ) )		// doit être affiché
//	DBG_TraceString("Activation de l'objectif n° ")
//	DBG_TraceInt(ti_num)
//	DBG_TraceEOL()
	return vrai
}

///TrigExec_RM_OBJECTIF_Validation
//============================================================
// Param IN : 			num = numéro de l'objectif
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_RM_OBJECTIF_Validation(byref message m_msg)	// int1 num
{
	object	to_manager
	int			ti_num
	ti_num = m_msg.msg_int1
	SpecialFlag_set(5000 + ( 2 * ti_num + 1 ) )		// a été validé
	SpecialFlag_reset(5000 + ( 2 * ti_num ) )			// ne doit plus être affiché
//	DBG_TraceString("Validation de l'objectif n° ")
//	DBG_TraceInt(ti_num)
//	DBG_TraceEOL()
	return vrai
}

///TrigExec_RM_Speed_Limit
//============================================================
// Param IN : 			limit = vitesse limite( coord X)
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_RM_Speed_Limit( byref message m_msg)	// vec1 limit
{
	vector tv_vec
	tv_vec =m_msg.msg_vec1
	@get_global f_vitesse_limit = tv_vec.x 
	return vrai
}

///TrigExec_GLOWChangeDefault
//============================================================
// Param IN : 			- Vec1.x = Nouvelle valeur du Glow
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_GLOWChangeDefault( byref message m_msg)	// vec1 GLOW
{
	vector tv_vec
	tv_vec = m_msg.msg_vec1
	@get_global AFE_DefaultValue[Param_AE_Glow] = tv_vec.x
	return vrai
}

///TrigExec_PF_GotoWP
//============================================================
// Param IN : 			- GAO de la plateforme
//							- GAO du WP a atteindre
// Param OUT : 		None
//============================================================
procedure_trigger int TrigExec_PF_GotoWP( byref message m_msg)	// object1 Plateforme object2 Waypoint
{
	object to_pf
	object to_wp

	to_pf=m_msg.msg_gao1
	to_wp=m_msg.msg_gao2

	@to_pf  PROC_PF_Goto(to_wp)

	return vrai
}