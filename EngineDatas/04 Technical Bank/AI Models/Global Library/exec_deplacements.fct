// PARAMETRES D'ENTREE:
//    La position courante: v_way_currentpos
//    La position finale (destination): v_way_destpos
//    La vitesse du blend lors de la rotation: f_way_blendrotate (Valeur par defaut: 0.2)
//    La distance limite de l'alogo a partir de laquel il s'arrete i_way_algo_limitdestpos    (Laisser si possible la valeur par defaut: 6)
//    L'information de hauteur courante: (Le CBits_Hauteur_Grille_Courante du perso) il est mis a jour automatiquement dans les fonctions de TAG sur la grille (information recupéré dans le GMAT du sol)
//    L'information de hauteur de destination: i_way_etage_dest ( 0 = etage 0 ou != 0 pour l'etage 1)
//    Eventuellement i_way_force_recompute lorsque l'on passe de l'etat j'etais arreté et je veux me deplacer (Ne pas mettre a vrai en permanance !!!!)
//
// PARAMETRES DE SORTIE:
//    L'indication que le perso peut se deplacer : i_way_moving
//    La visée pour le perso: v_way_sight (elle s'oriente progressivement de la visée courante vers la case dest)
//    La prochaine case vers laquel le perso se dirige: v_way_case_dest    Attention ce n'est pas forcement une case a proximité car la fonction de recherche de chemin smooth les deplacements  pour que l'on ne voit pas les escaliers... Donc il est possible si rien ne l'en empeche que l'on se dirige vers une case qui est a 5 ou 6 cases de la case courante...


vector		tv_way_temp 					// Vecteur Temporaire.
int				ti_way_case_nbr_smooth	// Nbr de case dans la grille
vector		tv_way_normal					// normal de collision
int				ti_way_case_next_value 	// Valeur de la case next
int				ti_way_dif_level 				// Indique si on va sur le meme level que le courant ou pas...
vector		tv_dest_pos_temp			// Vecteur temporraire pour l'erreur grille
float			tf_lenbig
float			tf_born
int				ti_etage
int				ti_isin
int				ti_exit
int				ti_i, ti_capa, ti_cpt
int				ti_flag_next_case_reached

// Taille carré de recherche
if(!f_way_len_big) tf_lenbig = 20
else tf_lenbig = f_way_len_big
f_way_len_big = 0

if(!f_way_test_born) tf_born = 4
else tf_born = f_way_test_born
f_way_test_born = 0

// Permet de travailler sur le meme Z (cause distance)
v_way_destpos.z = v_way_currentpos.z

// Test des isin sur les etages respectifs
ti_isin = vrai
ti_exit = faux
if(!GRID_IsIn(v_way_destpos)) ti_isin = faux
if(!GRID_IsIn(v_way_currentpos)) ti_isin = faux

if (ti_isin)		// Test Source & Destination
{
	// ############
	// AVEC GRILLE
	// ############

	// Rien stocké
	if(i_way_case_nbr < 2) i_way_force_recompute = vrai
	
	// Si on a changé de case, on vérifie le chemin stocké
	if(!i_way_force_recompute)
	{
		// Case suivante occupée
		ti_capa = GRID_CapaGet(v_way_case_dest)
		if(ti_capa & tag_grid_occupe_msk) i_way_force_recompute = vrai
		
		ti_cpt = 0

		ti_flag_next_case_reached = faux

		tv_way_temp = GRID_PosGet(v_way_case_dest) 

		if (tv_way_temp == GRID_PosGet(v_way_currentpos))
		{
			// On est sur la case désirée
			ti_flag_next_case_reached = vrai
		}
		else if (f_way_tolerance_sqr_dist)
		{
			// Si on a une tolerance, on teste la distance à la prochaine case	
			tv_way_temp -= v_way_currentpos
			tv_way_temp.z = 0.0
			
			if (MATH_VecDotProduct(tv_way_temp, tv_way_temp) < f_way_tolerance_sqr_dist)
				ti_flag_next_case_reached = vrai
		}

		if (ti_flag_next_case_reached)
		{
			for(ti_i = i_way_case_nbr - 2; ti_i >= 0; ti_i--)
			{
				ti_cpt++
				if(ti_cpt == 4) break	// Pas la peine de tester tout le chemin, juste le debut
				ti_capa = GRID_CapaGet(v_way_case[ti_i])
				if(ti_capa & tag_grid_occupe_msk) i_way_force_recompute = vrai
				if(GRID_GetPond(ti_capa & tag_grid_terrain) == 0) i_way_force_recompute = vrai
			}
			
			if(!i_way_force_recompute) 
			{
				i_way_case_nbr--
				v_way_case_dest = v_way_case[i_way_case_nbr - 1]
			}
		}
	}
	
	if(i_way_force_recompute)
	{
		// RECHERCHE AUTOUR DE LA DEST_POS -----------------------------------------------------------------------------------------------------------
		if (i_way_search_around_destpos)
		{
			// Gestion d'erreur sur le point de dest (il doit etre libre d'acces)
			tv_dest_pos_temp = GRID_ComputeDest(v_way_destpos, i_way_algo_limitdestpos)
			if (MATH_VecNull(tv_dest_pos_temp))
			{
				i_way_destpos_error = vrai															// Pas de solutions (je peux pas m'en sortir)
				i_way_moving = faux																	// Donc je m'arrete
				ti_exit = vrai																				// J'arrete l'exec de cette fonction
			}
			else
				i_way_destpos_error = faux															// Cool j'ai une solution j'y go !
		}
		else
			tv_dest_pos_temp = v_way_destpos
		// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------

		if (!ti_exit)
		{
			// ### SHORT WAY########################################################
			// Tableau des cases
			// Pos depart
			// Pos arrivé
			// ??? Nib !
			// Distance a partir de laquelle le destpos est testé occupé
			// Nbr de case max a partir dequelle la fonction de recherche de chemin abort
			// Taille de la demi longueur de la zone a ne jamais depassé (carré)
			// Nbr d'éléments max a retourner
			i_way_case_nbr = GRID_ShortWay(v_way_case[0],v_way_currentpos, tv_dest_pos_temp, tf_born, i_way_algo_limitdestpos, tf_lenbig, 99)	// Chemin
#ifndef _FINAL
			if(i_way_show)
			{
				int i
				for(i = 0; i < i_way_case_nbr; i++) DBG_RenderVector(v_way_case[i], Cv_VerticalVector, 255)
			}
#endif
			
			// ######################################################################
	
			if (i_way_case_nbr >= 2)
			{
				//Optimisation ligne droite !
				ti_way_case_nbr_smooth = GRID_SmoothWay(v_way_case[0], i_way_case_nbr, 20)
	
				// On ne recalcul pas le chemin
				i_way_force_recompute = faux
				
				// Calcule de la case dest.
				if (ti_way_case_nbr_smooth < i_way_case_nbr -2)
				{
					v_way_case_dest = v_way_case[ti_way_case_nbr_smooth]
					i_way_case_nbr = ti_way_case_nbr_smooth + 2
				}
				else
					v_way_case_dest = v_way_case[i_way_case_nbr -2]
	
				// Ok on se deplace sur le chemin grille
				tv_way_temp = v_way_case_dest - v_way_currentpos
				tv_way_temp.z = 0
				v_way_sight = MATH_VecBlendRotate(OBJ_SightGet(), MATH_VecNormalize(tv_way_temp), f_way_blendrotate* DT_30 )
			}
			else
			{
				// ERREUR: Pas de deplacements possibles (pas assez de case pour le déplacement)
				i_way_case_nbr = 0
	
				// On n'altere pas la visée car on n'a pas mieux.
				v_way_sight = OBJ_SightGet()
	
				// Il faut recalculer un chemin...
				i_way_force_recompute = vrai
	
				// On arrete le deplacement si on est arrivé
				i_way_moving = faux
			}
		}
	}
	else
	{
		// Orientation
		tv_way_temp = v_way_case_dest - v_way_currentpos
		tv_way_temp.z = 0
		v_way_sight = MATH_VecBlendRotate( OBJ_SightGet(), MATH_VecNormalize(tv_way_temp), f_way_blendrotate * DT_30)
	}
}
else
{
	// ############
	// SANS GRILLE
	// ############

	tv_way_temp = v_way_destpos - v_way_currentpos
	tv_way_temp.z = 0
	if (!MATH_VecNullToler(tv_way_temp, 0.5))
	{
		// Je me deplace...
		v_way_sight = MATH_VecBlendRotate(OBJ_SightGet(), MATH_VecNormalize(tv_way_temp) , f_way_blendrotate * DT_30)
	}
	else
	{
		// Je suis a moins de 0.5m de ma destination... donc je m'arrete !
		i_way_force_recompute = vrai
		i_way_moving = faux
	}
}