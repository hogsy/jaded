//procedure int MATH_LIB_Intersection_Sphere_Sphere(vector tv_pos_A, float tf_rayon_A, vector tv_pos_B, float tf_rayon_B, int ti_flag_display_info);
//procedure int MATH_LIB_Intersection_Cylindre_Sphere(vector tv_cylinder_center, vector tv_cylinder_axis, float tf_cylinder_rayon, float tf_cylinder_length, vector tv_sphere_center, float tf_sphere_size, int ti_flag_display_info);

procedure void DBG_RenderBox(object to_gao, vector tv_min, vector tv_max, int ti_color)
{
	vector	tv_temp

	tv_temp = @to_gao OBJ_PosGet()
	tv_temp += @to_gao MATH_VecLocalToGlobal(tv_min)
	DBG_RenderVector(tv_temp, (tv_max.x - tv_min.x) * @to_gao OBJ_HorizonGet(), ti_color)
	DBG_RenderVector(tv_temp, (tv_max.y - tv_min.y) * - @to_gao OBJ_SightGet(), ti_color)
	DBG_RenderVector(tv_temp, (tv_max.z - tv_min.z) * @to_gao OBJ_BankingGet(), ti_color)

	tv_temp += @to_gao OBJ_BankingGet() * (tv_max.z - tv_min.z)
	DBG_RenderVector(tv_temp, (tv_max.x - tv_min.x) * @to_gao OBJ_HorizonGet(), ti_color)
	DBG_RenderVector(tv_temp, (tv_max.y - tv_min.y) * - @to_gao OBJ_SightGet(), ti_color)

	tv_temp += (tv_max.x - tv_min.x) * @to_gao OBJ_HorizonGet()
	DBG_RenderVector(tv_temp, (tv_min.z - tv_max.z) * @to_gao OBJ_BankingGet(), ti_color)

	tv_temp = @to_gao OBJ_PosGet()
	tv_temp += @to_gao MATH_VecLocalToGlobal(tv_max)
	DBG_RenderVector(tv_temp, (tv_min.x - tv_max.x) * @to_gao OBJ_HorizonGet(), ti_color)
	DBG_RenderVector(tv_temp, (tv_min.y - tv_max.y) * - @to_gao OBJ_SightGet(), ti_color)
	DBG_RenderVector(tv_temp, (tv_min.z - tv_max.z) * @to_gao OBJ_BankingGet(), ti_color)

	tv_temp += @to_gao OBJ_BankingGet() * (tv_min.z - tv_max.z)
	DBG_RenderVector(tv_temp, (tv_min.x - tv_max.x) * @to_gao OBJ_HorizonGet(), ti_color)
	DBG_RenderVector(tv_temp, (tv_min.y - tv_max.y) * - @to_gao OBJ_SightGet(), ti_color)
	
	tv_temp += (tv_min.x - tv_max.x) * @to_gao OBJ_HorizonGet()
	DBG_RenderVector(tv_temp, (tv_max.z - tv_min.z) * @to_gao OBJ_BankingGet(), ti_color)

//	DBG_RenderVector(tv_max, (tv_min.x - tv_max.x) * tv_X, ti_color)
//	DBG_RenderVector(tv_max, (tv_min.y - tv_max.y) * tv_Y, ti_color)
//	DBG_RenderVector(tv_max, (tv_min.z - tv_max.z) * tv_Z, ti_color)
}

procedure float OBJ_LIB_IK(object to_gao1, object to_gao2, float tf_length_1, float tf_length_2, vector tv_dest_pos, vector tv_flexion_dir, float tf_IK_coef)
{
	int			ti_flag_human_IK	

	float		tf_length_3	
	float		tf_X
	float		tf_Y
	float		tf_sign	

	vector	tv_X
	vector	tv_Y
	vector	tv_gao2_dest_pos
	
	if (!tf_IK_coef)
		return	(-1.0)

// FRED
//	if (AI_IsModel("KingKong/Humain"))
//		ti_flag_human_IK = vrai
//	else
		ti_flag_human_IK = faux

	tv_dest_pos = MATH_VecBlend(@to_gao2 OBJ_PosGet() + (@to_gao2 OBJ_BankingGet() * tf_length_2), tv_dest_pos, tf_IK_coef)

	// CALCUL DE LA POSITION DU GAO 2
	tv_X = tv_dest_pos - @to_gao1 OBJ_PosGet()
	tf_length_3 = MATH_VecNorm(tv_X)
	if( MATH_FloatNullToler(tf_length_3, 0.01) )
	{
		tv_dest_pos += OBJ_SightGet()
		tv_X = tv_dest_pos - @to_gao1 OBJ_PosGet()
		tf_length_3 = MATH_VecNorm(tv_X)
	}
	tv_X /= tf_length_3

	if (MATH_VecNull(tv_flexion_dir))
	{
		tv_Y = MATH_VecCrossProduct(@to_gao2 OBJ_BankingGet(), @to_gao1 OBJ_BankingGet())
		tf_Y = MATH_FloatLimit(MATH_VecSquareNorm(tv_Y) * 5.0, 0.0, 1.0)

		if (ti_flag_human_IK)
			tf_sign = 1.0
		else
			tf_sign = MATH_FloatSign(MATH_VecDotProduct(@to_gao1 OBJ_HorizonGet(), tv_Y))

//		DBG_RenderVector(@to_gao2 OBJ_PosGet(), tv_Y, color_cyan)
//		DBG_RenderVector(@to_gao2 OBJ_PosGet(), tf_sign * @to_gao1 OBJ_HorizonGet(), color_rouge)

		tv_Y = MATH_VecBlendRotate(tf_sign * @to_gao1 OBJ_HorizonGet(), tv_Y, tf_Y)
		tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)

		if (ti_flag_human_IK)
			tv_Y *= MATH_FloatSign(MATH_VecDotProduct(tv_Y, @to_gao1 OBJ_SightGet()))
	}
	else
	{
		tv_Y = tv_flexion_dir
		tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)
		tv_Y = MATH_VecCrossProduct(tv_X, tv_Y)
	}

	tf_Y = MATH_VecNorm(tv_Y)
	if ( !MATH_FloatNullEpsilon( tf_Y))
		tv_Y /= tf_Y

	tf_X = tf_length_2 * tf_length_2
	tf_X -= tf_length_1 * tf_length_1
	tf_X -= tf_length_3 * tf_length_3
	tf_X /= -2.0 * tf_length_3
	
	tf_Y = tf_length_1 * tf_length_1
	tf_Y -= tf_X * tf_X
	tf_Y = MATH_FloatMax(tf_Y, 0.0)
	tf_Y = MATH_FloatSqrt(tf_Y)
	
	tv_gao2_dest_pos = @to_gao1 OBJ_PosGet()
	tv_gao2_dest_pos += tf_X * tv_X
	tv_gao2_dest_pos += tf_Y * tv_Y
	
//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_gao2_dest_pos - @to_gao1 OBJ_PosGet(), color_blanc)
//	DBG_RenderVector(tv_gao2_dest_pos, tv_dest_pos - tv_gao2_dest_pos, color_blanc)

	// ROTATION VIA QUATERNION ET EN FONCTION DU COEF D'IK
	tv_X = @to_gao1 MATH_VecGlobalToLocal(tv_gao2_dest_pos - @to_gao1 OBJ_PosGet())
	@to_gao1 OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), tv_X)

	tv_X = @to_gao2 MATH_VecGlobalToLocal(tv_dest_pos - @to_gao2 OBJ_PosGet())
	@to_gao2 OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), tv_X)	
	return(tf_Y)
}

procedure float OBJ_LIB_IK_Unaligned(object to_gao1, object to_gao2, object to_gao3, float tf_length_1, float tf_length_2, vector tv_dest_pos, vector tv_flexion_dir, float tf_IK_coef)
{
	int			ti_flag_human_IK	

	float		tf_length_3	
	float		tf_X
	float		tf_Y
	float		tf_sign	

	vector	tv_X
	vector	tv_Y
	vector	tv_gao2_dest_pos
	
	if (!tf_IK_coef)
		return	(-1.0)

// FRED
//	if (AI_IsModel("KingKong/Humain"))
//		ti_flag_human_IK = vrai
//	else
		ti_flag_human_IK = faux

	tv_dest_pos = MATH_VecBlend(@to_gao2 OBJ_PosGet() + (@to_gao2 OBJ_BankingGet() * tf_length_2), tv_dest_pos, tf_IK_coef)

	// CALCUL DE LA POSITION DU GAO 2
	tv_X = tv_dest_pos - @to_gao1 OBJ_PosGet()
	tf_length_3 = MATH_VecNorm(tv_X)
	if( MATH_FloatNullToler(tf_length_3, 0.01) )
	{
		tv_dest_pos += OBJ_SightGet()
		tv_X = tv_dest_pos - @to_gao1 OBJ_PosGet()
		tf_length_3 = MATH_VecNorm(tv_X)
	}
	tv_X /= tf_length_3

	if (MATH_VecNull(tv_flexion_dir))
	{
		tv_Y = MATH_VecCrossProduct(@to_gao2 OBJ_BankingGet(), @to_gao1 OBJ_BankingGet())
		tf_Y = MATH_FloatLimit(MATH_VecSquareNorm(tv_Y) * 5.0, 0.0, 1.0)

		if (ti_flag_human_IK)
			tf_sign = 1.0
		else
			tf_sign = MATH_FloatSign(MATH_VecDotProduct(@to_gao1 OBJ_HorizonGet(), tv_Y))

//		DBG_RenderVector(@to_gao2 OBJ_PosGet(), tv_Y, color_cyan)
//		DBG_RenderVector(@to_gao2 OBJ_PosGet(), tf_sign * @to_gao1 OBJ_HorizonGet(), color_rouge)

		tv_Y = MATH_VecBlendRotate(tf_sign * @to_gao1 OBJ_HorizonGet(), tv_Y, tf_Y)
		tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)

		if (ti_flag_human_IK)
			tv_Y *= MATH_FloatSign(MATH_VecDotProduct(tv_Y, @to_gao1 OBJ_SightGet()))
	}
	else
	{
		tv_Y = tv_flexion_dir
		tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)
		tv_Y = MATH_VecCrossProduct(tv_X, tv_Y)
	}

	tf_Y = MATH_VecNorm(tv_Y)
	if ( !MATH_FloatNullEpsilon( tf_Y))
		tv_Y /= tf_Y

	tf_X = tf_length_2 * tf_length_2
	tf_X -= tf_length_1 * tf_length_1
	tf_X -= tf_length_3 * tf_length_3
	tf_X /= -2.0 * tf_length_3
	
	tf_Y = tf_length_1 * tf_length_1
	tf_Y -= tf_X * tf_X
	tf_Y = MATH_FloatMax(tf_Y, 0.0)
	tf_Y = MATH_FloatSqrt(tf_Y)
	
	tv_gao2_dest_pos = @to_gao1 OBJ_PosGet()
	tv_gao2_dest_pos += tf_X * tv_X
	tv_gao2_dest_pos += tf_Y * tv_Y
	
//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_gao2_dest_pos - @to_gao1 OBJ_PosGet(), color_blanc)
//	DBG_RenderVector(tv_gao2_dest_pos, tv_dest_pos - tv_gao2_dest_pos, color_blanc)

	// ROTATION VIA QUATERNION ET EN FONCTION DU COEF D'IK
	tv_X = @to_gao1 MATH_VecGlobalToLocal(tv_gao2_dest_pos - @to_gao1 OBJ_PosGet())
	@to_gao1 OBJ_Rotate_FromTo(@to_gao1 MATH_VecGlobalToLocal(@to_gao2 OBJ_PosGet() - @to_gao1 OBJ_PosGet()), tv_X)

	tv_X = @to_gao2 MATH_VecGlobalToLocal(tv_dest_pos - @to_gao2 OBJ_PosGet())
	@to_gao2 OBJ_Rotate_FromTo(@to_gao2 MATH_VecGlobalToLocal(@to_gao3 OBJ_PosGet() - @to_gao2 OBJ_PosGet()), tv_X)	
	return(tf_Y)
}


procedure void OBJ_LIB_IK_3_Bones(object to_gao1, object to_gao2, object to_gao3, float tf_length_1, float tf_length_2, float tf_length_3, vector tv_dest_pos, vector tv_flexion_dir1, vector tv_flexion_dir2, float tf_tenseur_coef, float tf_IK_coef)
{
	float		tf_X
	float		tf_Y
	float		tf_length_4
	float		tf_sign

	vector	tv_X
	vector	tv_Y

	vector	tv_gao2_max_pos
	vector	tv_gao2_min_pos	

	vector	tv_gao2_dest_pos
	vector	tv_gao3_dest_pos	

	if (!tf_IK_coef)
		return

	tv_dest_pos = MATH_VecBlend(@to_gao3 OBJ_PosGet() + (@to_gao3 OBJ_BankingGet() * tf_length_3), tv_dest_pos, tf_IK_coef)

//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_flexion_dir1 * 3.0, color_bleu)
//	DBG_RenderVector(@to_gao3 OBJ_PosGet(), tv_flexion_dir2 * 3.0, color_bleu)

	// CALCUL DE L'AXE X
	tv_X = tv_dest_pos - @to_gao1 OBJ_PosGet()
	tf_length_4 = MATH_VecNorm(tv_X)
	tv_X /= tf_length_4

//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_X * 3.0, color_rouge)
		
	// CALCUL DE LA POSITION MIN DU GAO 2
	tv_Y = tv_flexion_dir2
	tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)
	tv_Y = MATH_VecCrossProduct(tv_X, tv_Y)

//	tv_Y = MATH_VecCrossProduct(tv_X, tv_flexion_dir2)
	
	tf_Y = MATH_VecNorm(tv_Y)
	if ( !MATH_FloatNullEpsilon( tf_Y))
		tv_Y /= tf_Y

//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_Y * 3.0, color_vert)
	tf_Y = tf_length_1 + tf_length_2
	tf_Y *= tf_Y

	tf_X = tf_length_3
	tf_X *= tf_X
	tf_X -= tf_Y
	tf_X -= tf_length_4 * tf_length_4
	tf_X /= -2.0 * tf_length_4
	
	tf_Y -= tf_X * tf_X
	tf_Y = MATH_FloatMax(tf_Y, 0.0)
	tf_Y = MATH_FloatSqrt(tf_Y)
		
	tv_gao2_min_pos = tf_X * tv_X
	tv_gao2_min_pos += tf_Y * tv_Y

	// On ramène le vecteur à la bonne longeur
	tv_gao2_min_pos /= tf_length_1 + tf_length_2
	tv_gao2_min_pos *= tf_length_1
//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_gao2_min_pos, color_rouge)
	tv_gao2_min_pos += @to_gao1 OBJ_PosGet()

	// CALCUL DE LA POSITION MAX DU GAO 2
	tv_Y = tv_flexion_dir1
	tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)
	tv_Y = MATH_VecCrossProduct(tv_X, tv_Y)

//	tv_Y = MATH_VecCrossProduct(tv_X, tv_flexion_dir1)

	tf_Y = MATH_VecNorm(tv_Y)
	if ( !MATH_FloatNullEpsilon( tf_Y))
		tv_Y /= tf_Y

//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_Y * 3.0, color_vert)

	tf_Y = tf_length_1
	tf_Y *= tf_Y

	tf_X = tf_length_2 + tf_length_3
	tf_X *= tf_X
	tf_X -= tf_Y
	tf_X -= tf_length_4 * tf_length_4
	tf_X /= -2.0 * tf_length_4
	
	tf_Y -= tf_X * tf_X
	tf_Y = MATH_FloatMax(tf_Y, 0.0)
	tf_Y = MATH_FloatSqrt(tf_Y)
	
	tv_gao2_max_pos = tf_X * tv_X
	tv_gao2_max_pos += tf_Y * tv_Y
//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_gao2_max_pos, color_vert)
	tv_gao2_max_pos += @to_gao1 OBJ_PosGet()

	// CALCUL DE LA POSITION DU GAO 2
//	tf_tenseur_coef = (1.0 - MATH_Sin(TIME_Get() * 4.0)) * 0.5
//	tf_tenseur_coef = 0.0

	tv_gao2_dest_pos = MATH_VecBlendRotate(tv_gao2_min_pos - @to_gao1 OBJ_PosGet(), tv_gao2_max_pos -  @to_gao1 OBJ_PosGet(), tf_tenseur_coef)
	tv_gao2_dest_pos += @to_gao1 OBJ_PosGet()

	// CALCUL DE LA POSITION DU GAO 3
	tv_X = tv_dest_pos - tv_gao2_dest_pos
	tf_length_4 = MATH_VecNorm(tv_X)
	tv_X /= tf_length_4
	
//	DBG_RenderVector(tv_gao2_dest_pos, tv_flexion_dir2 * 3.0, color_bleu)
//	DBG_RenderVector(tv_gao2_dest_pos, tv_X * 3.0, color_rouge)
	
	tv_Y = tv_flexion_dir2
	tv_Y = MATH_VecCrossProduct(tv_Y, tv_X)
	tv_Y = MATH_VecCrossProduct(tv_X, tv_Y)
	
//	tv_Y = MATH_VecCrossProduct(tv_X, tv_flexion_dir2)

	tf_Y = MATH_VecNorm(tv_Y)
	if ( !MATH_FloatNullEpsilon( tf_Y))
		tv_Y /= tf_Y

//	DBG_RenderVector(tv_gao2_dest_pos, tv_Y * 3.0, color_vert)

	tf_Y = tf_length_2 * tf_length_2
	
	tf_X = tf_length_3 * tf_length_3
	tf_X -= tf_Y
	tf_X -= tf_length_4 * tf_length_4
	tf_X /= -2.0 * tf_length_4
	
	tf_Y -= tf_X * tf_X
	tf_Y = MATH_FloatMax(tf_Y, 0.0)
	tf_Y = MATH_FloatSqrt(tf_Y)
	
	tv_gao3_dest_pos = tf_X * tv_X
	tv_gao3_dest_pos += tf_Y * tv_Y
	tf_X = MATH_VecNorm(tv_gao3_dest_pos)
	tv_gao3_dest_pos += tv_gao2_dest_pos

//	DBG_RenderVector(@to_gao1 OBJ_PosGet(), tv_gao2_dest_pos - @to_gao1 OBJ_PosGet(), color_cyan)
//	DBG_RenderVector(tv_gao2_dest_pos, tv_gao3_dest_pos - tv_gao2_dest_pos, color_cyan)
//	DBG_RenderVector(tv_gao3_dest_pos, tv_dest_pos - tv_gao3_dest_pos, color_cyan)
	
//	tv_X = MATH_VecBlend(cvector(0.0, 0.0, 1.0), @to_gao1 MATH_VecGlobalToLocal(tv_gao2_dest_pos - @to_gao1 OBJ_PosGet()), tf_IK_coef)
	tv_X = @to_gao1 MATH_VecGlobalToLocal(tv_gao2_dest_pos - @to_gao1 OBJ_PosGet())
	@to_gao1 OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), tv_X)
//	tv_X = MATH_VecBlend(cvector(0.0, 0.0, 1.0), @to_gao2 MATH_VecGlobalToLocal(tv_gao3_dest_pos - @to_gao2 OBJ_PosGet()), tf_IK_coef)
	tv_X = @to_gao2 MATH_VecGlobalToLocal(tv_gao3_dest_pos - @to_gao2 OBJ_PosGet())
	@to_gao2 OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), tv_X)
//	tv_X = MATH_VecBlend(cvector(0.0, 0.0, 1.0), @to_gao3 MATH_VecGlobalToLocal(tv_dest_pos - @to_gao3 OBJ_PosGet()), tf_IK_coef)
	tv_X = @to_gao3 MATH_VecGlobalToLocal(tv_dest_pos - @to_gao3 OBJ_PosGet())
	@to_gao3 OBJ_Rotate_FromTo(cvector(0.0, 0.0, 1.0), tv_X)
}

// ====================================================================================================
// RETOURNE LA POSITION LA PLUS PROCHE DANS LA BV DU GAO SPECIFIE
// ====================================================================================================
procedure vector OBJ_LIB_NearestBVPos(vector tv_start_pos, object to_BV)
{
	int			ti_i	

	vector	tv_diagonale
	vector	tv_bv_center
	vector	tv_start_to_bv_center
	vector	tv_nearest_pos	

	tv_diagonale = @to_BV BV_MaxGet() - @to_BV BV_MinGet()
	tv_diagonale *= 0.5

	tv_bv_center = @to_BV OBJ_PosGet()
	tv_bv_center += @to_BV BV_MinGet()

	tv_bv_center += tv_diagonale
	
	tv_nearest_pos = tv_bv_center - tv_start_pos

	if (tv_nearest_pos.x >= 0.0)
		tv_nearest_pos.x -= MATH_FloatMin(tv_nearest_pos.x, tv_diagonale.x)
	else
		tv_nearest_pos.x += MATH_FloatMin(-tv_nearest_pos.x, tv_diagonale.x)

	if (tv_nearest_pos.y >= 0.0)
		tv_nearest_pos.y -= MATH_FloatMin(tv_nearest_pos.y, tv_diagonale.y)
	else
		tv_nearest_pos.y += MATH_FloatMin(-tv_nearest_pos.y, tv_diagonale.y)

	if (tv_nearest_pos.z >= 0.0)
		tv_nearest_pos.z -= MATH_FloatMin(tv_nearest_pos.z, tv_diagonale.z)
	else
		tv_nearest_pos.z += MATH_FloatMin(-tv_nearest_pos.z, tv_diagonale.z)

	tv_nearest_pos += tv_start_pos

	return(tv_nearest_pos)
}

// ============================================================
// RETOURNE LE POINT D'INTERSECTION ENTRE UNE DIRECTION ET UNE BV
// ============================================================
procedure int OBJ_LIB_Intersection_Dir_BV(object to_BV, vector tv_start_pos, vector tv_dir, byref float tf_dist, byref vector tv_collide_pos)
{
	int		ti_i
	
	float		tf_X

	vector	tv_bv_min_pos
	vector	tv_bv_max_pos

	tv_bv_min_pos = @to_BV OBJ_PosGet()
	tv_bv_max_pos = tv_bv_min_pos
	tv_bv_min_pos += @to_BV BV_MinGet()
	tv_bv_max_pos += @to_BV BV_MaxGet()

	for (ti_i = 0; ti_i < 3; ti_i++)
	{
		// CHOIX DU COTE DE LA BV
		switch(ti_i)
		{
			// TEST X FACE
			case 0 :

				if (!tv_dir.x)
					continue
				if (tv_dir.x > 0.0)
					tf_dist = (tv_bv_min_pos.x - tv_start_pos.x) / tv_dir.x
				else
					tf_dist = (tv_bv_max_pos.x - tv_start_pos.x) / tv_dir.x

				if (tf_dist < 0.0)
					continue

				tv_collide_pos = tv_start_pos
				tv_collide_pos += tf_dist * tv_dir	
		
				if (tv_collide_pos.y < tv_bv_min_pos.y)
					continue
				if (tv_collide_pos.y > tv_bv_max_pos.y)
					continue
				if (tv_collide_pos.z < tv_bv_min_pos.z)
					continue
				if (tv_collide_pos.z > tv_bv_max_pos.z)
					continue

				return(vrai)

			// TEST Y FACE
			case 1 :

				if (!tv_dir.y)
					continue
				if (tv_dir.y > 0.0)
					tf_dist = (tv_bv_min_pos.y - tv_start_pos.y) / tv_dir.y
				else
					tf_dist = (tv_bv_max_pos.y - tv_start_pos.y) / tv_dir.y

				if (tf_dist < 0.0)
					continue
			
				tv_collide_pos = tv_start_pos
				tv_collide_pos += tf_dist * tv_dir	
		
				if (tv_collide_pos.x < tv_bv_min_pos.x)
					continue
				if (tv_collide_pos.x > tv_bv_max_pos.x)
					continue
				if (tv_collide_pos.z < tv_bv_min_pos.z)
					continue
				if (tv_collide_pos.z > tv_bv_max_pos.z)
					continue

				return(vrai)

			// TEST Z FACE
			case 2 :

				if (!tv_dir.z)
					continue
				if (tv_dir.z > 0.0)
					tf_dist = (tv_bv_min_pos.z - tv_start_pos.z) / tv_dir.z
				else
					tf_dist = (tv_bv_max_pos.z - tv_start_pos.z) / tv_dir.z

				if (tf_dist < 0.0)
					continue

				tv_collide_pos = tv_start_pos
				tv_collide_pos += tf_dist * tv_dir	
		
				if (tv_collide_pos.x < tv_bv_min_pos.x)
					continue
				if (tv_collide_pos.x > tv_bv_max_pos.x)
					continue
				if (tv_collide_pos.y < tv_bv_min_pos.y)
					continue
				if (tv_collide_pos.y > tv_bv_max_pos.y)
					continue

				return(vrai)
		}
	}	

	return(faux)
}

// ===============================================================
// RETOURNE LE POINT D'INTERSECTION ENTRE UNE DIRECTION ET UNE OBBOX
// ===============================================================
procedure int OBJ_LIB_Intersection_Dir_OBBOX(object to_BV, vector tv_start_pos, vector tv_dir, byref float tf_dist, byref vector tv_collide_pos, byref vector tv_collide_normal)
{
	int		ti_i
	
	float		tf_X

	vector	tv_bv_min_pos
	vector	tv_bv_max_pos

	tv_start_pos = @to_BV MATH_VecGlobalToLocal(tv_start_pos - @to_BV OBJ_PosGet())
	tv_dir = @to_BV MATH_VecGlobalToLocal(tv_dir)

	tv_bv_min_pos = @to_BV BV_OBBoxMinGet()
	tv_bv_max_pos = @to_BV BV_OBBoxMaxGet()

	for (ti_i = 0; ti_i < 3; ti_i++)
	{
		// CHOIX DU COTE DE LA BV
		switch(ti_i)
		{
			// TEST X FACE
			case 0 :

				if (!tv_dir.x)
					continue
				if (tv_dir.x > 0.0)
					tf_dist = (tv_bv_min_pos.x - tv_start_pos.x) / tv_dir.x
				else
					tf_dist = (tv_bv_max_pos.x - tv_start_pos.x) / tv_dir.x

				if (tf_dist < 0.0)
					continue

				tv_collide_pos = tv_start_pos
				tv_collide_pos += tf_dist * tv_dir	
		
				if (tv_collide_pos.y < tv_bv_min_pos.y)
					continue
				if (tv_collide_pos.y > tv_bv_max_pos.y)
					continue
				if (tv_collide_pos.z < tv_bv_min_pos.z)
					continue
				if (tv_collide_pos.z > tv_bv_max_pos.z)
					continue

				tv_collide_pos = @to_BV MATH_VecLocalToGlobal(tv_collide_pos)
				tv_collide_pos += @to_BV OBJ_PosGet()

				tv_collide_normal = - @to_BV OBJ_HorizonGet() * MATH_FloatSign(tv_dir.x)

				return(vrai)

			// TEST Y FACE
			case 1 :

				if (!tv_dir.y)
					continue
				if (tv_dir.y > 0.0)
					tf_dist = (tv_bv_min_pos.y - tv_start_pos.y) / tv_dir.y
				else
					tf_dist = (tv_bv_max_pos.y - tv_start_pos.y) / tv_dir.y

				if (tf_dist < 0.0)
					continue
			
				tv_collide_pos = tv_start_pos
				tv_collide_pos += tf_dist * tv_dir	
		
				if (tv_collide_pos.x < tv_bv_min_pos.x)
					continue
				if (tv_collide_pos.x > tv_bv_max_pos.x)
					continue
				if (tv_collide_pos.z < tv_bv_min_pos.z)
					continue
				if (tv_collide_pos.z > tv_bv_max_pos.z)
					continue

				tv_collide_pos = @to_BV MATH_VecLocalToGlobal(tv_collide_pos)
				tv_collide_pos += @to_BV OBJ_PosGet()

				tv_collide_normal = @to_BV OBJ_SightGet() * MATH_FloatSign(tv_dir.y)

				return(vrai)

			// TEST Z FACE
			case 2 :

				if (!tv_dir.z)
					continue
				if (tv_dir.z > 0.0)
					tf_dist = (tv_bv_min_pos.z - tv_start_pos.z) / tv_dir.z
				else
					tf_dist = (tv_bv_max_pos.z - tv_start_pos.z) / tv_dir.z

				if (tf_dist < 0.0)
					continue

				tv_collide_pos = tv_start_pos
				tv_collide_pos += tf_dist * tv_dir	
		
				if (tv_collide_pos.x < tv_bv_min_pos.x)
					continue
				if (tv_collide_pos.x > tv_bv_max_pos.x)
					continue
				if (tv_collide_pos.y < tv_bv_min_pos.y)
					continue
				if (tv_collide_pos.y > tv_bv_max_pos.y)
					continue

				tv_collide_pos = @to_BV MATH_VecLocalToGlobal(tv_collide_pos)
				tv_collide_pos += @to_BV OBJ_PosGet()

				tv_collide_normal = - @to_BV OBJ_BankingGet() * MATH_FloatSign(tv_dir.z)

				return(vrai)
		}
	}	

	return(faux)
}


//procedure int OBJ_LIB_Intersection_Dir_Actor_OBBOX(object to_actor, vector tv_start_pos, vector tv_dir, byref float tf_dist, byref vector tv_collide_pos, byref vector tv_collide_normal, byref int ti_canal_index)
//{
//	int			ti_i
//	int			ti_return	
//
//	float		tf_best_dist
//
//	vector	tv_ray_pos
//	vector	tv_ray_normal
//
//	object	to_bone
//	
//	ti_return = faux
//	tf_best_dist = Cf_Infinit
//
//	for (ti_i = 0; ti_i < 255; ti_i++)
//	{
//		to_bone = @to_actor ANI_CanalObjectGet(ti_i)
//		if (to_bone && @to_bone OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_OBBox))
//		{
//			if (OBJ_LIB_Intersection_Dir_OBBOX(to_bone, tv_start_pos, tv_dir, tf_dist, tv_ray_pos, tv_ray_normal))
//			{
//				ti_return = vrai
//				tf_dist = MATH_VecDotProduct(tv_ray_pos - tv_start_pos, tv_ray_pos - tv_start_pos)
//				if (tf_dist < tf_best_dist)
//				{
//					ti_canal_index = ti_i
//					tf_best_dist = tf_dist
//					tv_collide_pos = tv_ray_pos
//					tv_collide_normal = tv_ray_normal
//				}
//			}
//		}
//	}
//
//	if (ti_return)
//		tf_dist = MATH_FloatSqrt(tf_best_dist)
//		
//	return(ti_return)
//}

//procedure int OBJ_LIB_Collision_Dist_Actor_OBBOX(object to_actor, vector tv_start_pos, vector tv_dir, byref float tf_dist, byref vector tv_collide_pos, byref vector tv_collide_normal, byref int ti_canal_index)
//{
//	float tf_intersection_dist
//
//	if (OBJ_LIB_Intersection_Dir_Actor_OBBOX(to_actor, tv_start_pos, tv_dir, tf_intersection_dist, tv_collide_pos, tv_collide_normal, ti_canal_index))
//	{
//		if (tf_intersection_dist < tf_dist)
//		{
//			tf_dist = tf_intersection_dist
//			return(vrai)
//		}
//	}
//	
//	return(faux)
//}

procedure vector OBJ_LIB_Nearest_Volume_Pos(object to_BV, vector tv_size_min, vector tv_size_max, vector tv_start_pos)
{
	int			ti_i	

	vector	tv_diagonale
	vector	tv_bv_center
	vector	tv_start_to_bv_center
	vector	tv_nearest_pos

	tv_start_pos = @to_BV MATH_VecGlobalToLocal(tv_start_pos - @to_BV OBJ_PosGet())

	tv_diagonale = tv_size_max - tv_size_min
	tv_diagonale *= 0.5

	tv_bv_center = tv_size_min
	tv_bv_center += tv_diagonale
	
	tv_nearest_pos = tv_bv_center - tv_start_pos

	if (tv_nearest_pos.x >= 0.0)
		tv_nearest_pos.x -= MATH_FloatMin(tv_nearest_pos.x, tv_diagonale.x)
	else
		tv_nearest_pos.x += MATH_FloatMin(-tv_nearest_pos.x, tv_diagonale.x)

	if (tv_nearest_pos.y >= 0.0)
		tv_nearest_pos.y -= MATH_FloatMin(tv_nearest_pos.y, tv_diagonale.y)
	else
		tv_nearest_pos.y += MATH_FloatMin(-tv_nearest_pos.y, tv_diagonale.y)

	if (tv_nearest_pos.z >= 0.0)
		tv_nearest_pos.z -= MATH_FloatMin(tv_nearest_pos.z, tv_diagonale.z)
	else
		tv_nearest_pos.z += MATH_FloatMin(-tv_nearest_pos.z, tv_diagonale.z)

	tv_nearest_pos += tv_start_pos

	tv_nearest_pos = @to_BV MATH_VecLocalToGlobal(tv_nearest_pos)
	tv_nearest_pos += @to_BV OBJ_PosGet()

	return(tv_nearest_pos)
}

procedure int OBJ_LIB_Intersection_Volume_Sphere(object to_volume, vector tv_size_min, vector tv_size_max, vector tv_sphere_center, float tf_sphere_size, int ti_flag_display_info)
{
	vector	tv_nearest_pos

	tv_nearest_pos = OBJ_LIB_Nearest_Volume_Pos(to_volume, tv_size_min, tv_size_max, tv_sphere_center)
	tv_nearest_pos -= tv_sphere_center
	
	if (MATH_VecDotProduct(tv_nearest_pos, tv_nearest_pos) <= tf_sphere_size * tf_sphere_size)
	{
#ifndef _FINAL_
		if (ti_flag_display_info)
		{
			DBG_RenderSphere(tv_sphere_center, tf_sphere_size, 0x800000FF)
			DBG_RenderVector(tv_sphere_center, tv_nearest_pos, color_rouge)
			DBG_RenderBox(to_volume, tv_size_min, tv_size_max, color_rouge)
		}
#endif
		return(vrai)
	}
	else
	{
#ifndef _FINAL_
		if (ti_flag_display_info)
		{
			DBG_RenderSphere(tv_sphere_center, tf_sphere_size, 0x8000FF00)
			DBG_RenderVector(tv_sphere_center, tv_nearest_pos, color_vert)
			DBG_RenderBox(to_volume, tv_size_min, tv_size_max, color_vert)
		}
#endif
		return(faux)
	}
}


procedure int OBJ_LIB_Virtual_Collision(object to_gao1, object to_gao2, int ti_flag_display_info)
{
	vector	tv_pos
	float		tf_size
	if (@to_gao1 OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_ZDM) && @to_gao2 OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_ColMap))
	{
		tv_pos = @to_gao1 COL_ZonePosGet(C_zdm_pied)
		tf_size = @to_gao1 COL_ZoneSizeGet(C_zdm_pied)
		switch(@to_gao2 COL_ColMapTypeGet(0))
		{
			case COL_C_Zone_Sphere :
	
				if (MATH_LIB_Intersection_Sphere_Sphere(@to_gao2 OBJ_PosGet() + (@to_gao2 MATH_VecLocalToGlobal(@to_gao2 COL_ColMapMinGet(0))), @to_gao2 COL_ColMapMaxGet(0).x, tv_pos, tf_size, ti_flag_display_info))
					return(vrai)
					
				break
		
			case COL_C_Zone_Cylinder :
	
				if (MATH_LIB_Intersection_Cylindre_Sphere(@to_gao2 OBJ_PosGet() + (@to_gao2 MATH_VecLocalToGlobal(@to_gao2 COL_ColMapMinGet(0))), @to_gao2 OBJ_BankingGet(), @to_gao2 COL_ColMapMaxGet(0).x, @to_gao2 COL_ColMapMaxGet(0).y, tv_pos, tf_size, ti_flag_display_info))
					return(vrai)
					
				break	
				
			case COL_C_Zone_Box :
	
				if (OBJ_LIB_Intersection_Volume_Sphere(to_gao2, @to_gao2 COL_ColMapMinGet(0) * @to_gao2 OBJ_ZoomGet(), @to_gao2 COL_ColMapMaxGet(0)* @to_gao2 OBJ_ZoomGet(), tv_pos, tf_size, ti_flag_display_info))
					return(vrai)
					
				break
		}
	}

	if (@to_gao2 OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_ZDM) && @to_gao1 OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_ColMap))
	{
		tv_pos = @to_gao2 COL_ZonePosGet(C_zdm_pied)
		tf_size = @to_gao2 COL_ZoneSizeGet(C_zdm_pied)
		
		switch(@to_gao1 COL_ColMapTypeGet(0))
		{
			case COL_C_Zone_Sphere :
	
				if (MATH_LIB_Intersection_Sphere_Sphere(@to_gao1 OBJ_PosGet() + (@to_gao1 MATH_VecLocalToGlobal(@to_gao1 COL_ColMapMinGet(0))), @to_gao1 COL_ColMapMaxGet(0).x, tv_pos, tf_size, ti_flag_display_info))
					return(vrai)
					
				break
				
			case COL_C_Zone_Cylinder :
	
				if (MATH_LIB_Intersection_Cylindre_Sphere(@to_gao1 OBJ_PosGet() + (@to_gao1 MATH_VecLocalToGlobal(@to_gao1 COL_ColMapMinGet(0))), @to_gao1 OBJ_BankingGet(), @to_gao1 COL_ColMapMaxGet(0).x, @to_gao1 COL_ColMapMaxGet(0).y, tv_pos, tf_size, ti_flag_display_info))
					return(vrai)
					
				break
				
			case COL_C_Zone_Box :
	
				if (OBJ_LIB_Intersection_Volume_Sphere(to_gao1, @to_gao1 COL_ColMapMinGet(0), @to_gao1 COL_ColMapMaxGet(0), tv_pos, tf_size, ti_flag_display_info))
					return(vrai)
					
				break
		}
	}

	return(faux)
}

procedure int OBJ_LIB_Virtual_Colmap_Collision(object to_gao1, object to_gao2, int ti_flag_display_info)
{
	vector		tv_A_min	
	vector		tv_A_max
	vector		tv_B_min	
	vector		tv_B_max

	if (@to_gao1 COL_ColMapTypeGet(0) != COL_C_Zone_Box)
		return(faux)

	if (@to_gao2 COL_ColMapTypeGet(0) != COL_C_Zone_Box)
		return(faux)

	tv_A_min = @to_gao1 COL_ColMapMinGet(0) * @to_gao1 OBJ_ZoomGet()
	tv_A_max = @to_gao1 COL_ColMapMaxGet(0) * @to_gao1 OBJ_ZoomGet()
	tv_B_min = @to_gao2 COL_ColMapMinGet(0) * @to_gao2 OBJ_ZoomGet()
	tv_B_max = @to_gao2 COL_ColMapMaxGet(0) * @to_gao2 OBJ_ZoomGet()

	return(MATH_LIB_OBB_OBB_Intersection(to_gao1, tv_A_min, tv_A_max, to_gao2, tv_B_min, tv_B_max, ti_flag_display_info))

	return(vrai)
}

procedure void OBJ_LIB_Detach_Javelin(object	 to_gao)
{
	int			ti_i
	
	object	to_lance	

//	for (ti_i = 0; ti_i < Ci_bambou_maxinmap; ti_i++)
//	{
//		to_lance = 	@get_global ao_Lances[ti_i]
//	
//		if (!to_lance)
//			continue	
//	
//		if (@get_Arme_Lance_path to_lance mi_State != Ci_bambou_state_plug)
//			continue
//			
//		if (@get_Arme_Lance_path to_lance o_plug_to_master != to_gao)
//			continue
//		
//		macro_set_javelin_plug_timer(to_lance, 0.0)
//	}
}