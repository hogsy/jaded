procedure int ARR_LIB_IntSearch(byrefarr int tai_int, int ti_array_size, int ti_find_this_int)
{
	int		ti_i
	
	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
	{
		if (tai_int[ti_i] == ti_find_this_int)
			return(ti_i)
	}
	
	return(-1)
}

procedure int ARR_LIB_MessageIDSearch(byrefarr messageid tamid_msg_ID, int ti_array_size, messageid tmid_find_this_message_ID)
{
	int		ti_i
	
	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
	{
		if (MSG_GlobalGetId(tamid_msg_ID[ti_i]) == MSG_GlobalGetId(tmid_find_this_message_ID))
			return(ti_i)
	}
	
	return(-1)
}

procedure int ARR_LIB_NetworkSearch(byrefarr network tan_net, int ti_array_size, network tn_find_this_net)
{
	int		ti_i
	
	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
	{
		if (tan_net[ti_i] == tn_find_this_net)
			return(ti_i)
	}
	
	return(-1)
}

procedure int ARR_LIB_VectorSearch(byrefarr vector tav_pos, int ti_array_size, vector tv_find_this_pos, float tf_tolerance)
{
	int		ti_i
	
	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
	{
		if (MATH_VecNullToler(tav_pos[ti_i] - tv_find_this_pos, tf_tolerance))
			return(ti_i)
	}
	
	return(-1)
}

// TRI RAPIDE DES VALEURS ======================================================================
procedure int ARR_LIB_Sub_QuickSort_Pivot_Get(byrefarr float value, int ti_start_index, int ti_end_index)
{
	int		ti_i
	int		ti_pivot_index	

	float	tf_pivot_value
	float	tf_temp
	
	ti_pivot_index = ti_start_index
	tf_pivot_value = value[ti_start_index]
	
	for (ti_i = ti_start_index + 1; ti_i <= ti_end_index; ti_i++)
	{
		if (value[ti_i] < tf_pivot_value)
		{
			ti_pivot_index++

			tf_temp = value[ti_i]
			value[ti_i] = value[ti_pivot_index]
			value[ti_pivot_index] = tf_temp
		}
	}

	tf_temp = value[ti_start_index]
	value[ti_start_index] = value[ti_pivot_index]
	value[ti_pivot_index] = tf_temp
	
	return(ti_pivot_index)
}
procedure void ARR_LIB_Sub_QuickSort(byrefarr float value, int ti_start_index, int ti_end_index)
{
	int ti_pivot_index	

	if (ti_start_index < ti_end_index)
	{
		ti_pivot_index = ARR_LIB_Sub_QuickSort_Pivot_Get(&value[0], ti_start_index, ti_end_index)
		ARR_LIB_Sub_QuickSort(&value[0], ti_start_index, ti_pivot_index)
		ARR_LIB_Sub_QuickSort(&value[0], ti_pivot_index + 1, ti_end_index)
	}
}
procedure void ARR_LIB_QuickSort_Order(byrefarr float value, int ti_array_size)
{
	ARR_LIB_Sub_QuickSort(&value[0], 0, ti_array_size - 1)
}

// TRI RAPIDE DES GAO EN FONCTION DE PONDERATION VALEURS ==========================
procedure int ARR_LIB_Sub_Gao_QuickSort_Pivot_Get(byrefarr object gao, byrefarr float value, int ti_start_index, int ti_end_index)
{
	int			ti_i
	int			ti_pivot_index	

	float		tf_pivot_value
	float		tf_temp
	
	object	to_temp

	ti_pivot_index = ti_start_index
	tf_pivot_value = value[ti_start_index]
	
	for (ti_i = ti_start_index + 1; ti_i <= ti_end_index; ti_i++)
	{
		if (value[ti_i] < tf_pivot_value)
		{
			ti_pivot_index++

			tf_temp = value[ti_i]
			value[ti_i] = value[ti_pivot_index]
			value[ti_pivot_index] = tf_temp
			
			to_temp = gao[ti_i]
			gao[ti_i] = gao[ti_pivot_index]
			gao[ti_pivot_index] = to_temp
		}
	}

	tf_temp = value[ti_start_index]
	value[ti_start_index] = value[ti_pivot_index]
	value[ti_pivot_index] = tf_temp

	to_temp = gao[ti_start_index]
	gao[ti_start_index] = gao[ti_pivot_index]
	gao[ti_pivot_index] = to_temp

	return(ti_pivot_index)
}
procedure void ARR_LIB_Sub_Gao_QuickSort(byrefarr object gao, byrefarr float value, int ti_start_index, int ti_end_index)
{
	int ti_pivot_index	

	if (ti_start_index < ti_end_index)
	{
		ti_pivot_index = ARR_LIB_Sub_Gao_QuickSort_Pivot_Get(&gao[0], &value[0], ti_start_index, ti_end_index)
		ARR_LIB_Sub_Gao_QuickSort(&gao[0], &value[0], ti_start_index, ti_pivot_index)
		ARR_LIB_Sub_Gao_QuickSort(&gao[0], &value[0], ti_pivot_index + 1, ti_end_index)
	}
}
procedure void ARR_LIB_Gao_QuickSort_Order(byrefarr object gao, byrefarr float value, int ti_array_size)
{
	ARR_LIB_Sub_Gao_QuickSort(&gao[0], &value[0], 0, ti_array_size - 1)
}

// TRI RAPIDE DES INDEX ===========================================================================
procedure int ARR_LIB_Sub_QuickSort_Index_Pivot_Get(byrefarr int index, byrefarr float value, int ti_start_index, int ti_end_index)
{
	int		ti_i
	int		ti_pivot_index	
	int		ti_temp

	float	tf_pivot_value
	
	ti_pivot_index = ti_start_index
	tf_pivot_value = value[index[ti_start_index]]
	
	for (ti_i = ti_start_index + 1; ti_i <= ti_end_index; ti_i++)
	{
		if (value[index[ti_i]] < tf_pivot_value)
		{
			ti_pivot_index++

			ti_temp = index[ti_i]
			index[ti_i] = index[ti_pivot_index]
			index[ti_pivot_index] = ti_temp
		}
	}

	ti_temp = index[ti_start_index]
	index[ti_start_index] = index[ti_pivot_index]
	index[ti_pivot_index] = ti_temp
	
	return(ti_pivot_index)
}
procedure void ARR_LIB_Sub_QuickSort_Index(byrefarr int index, byrefarr float value, int ti_start_index, int ti_end_index)
{
	int ti_pivot_index	

	if (ti_start_index < ti_end_index)
	{
		ti_pivot_index = ARR_LIB_Sub_QuickSort_Index_Pivot_Get(&index[0], &value[0], ti_start_index, ti_end_index)
		ARR_LIB_Sub_QuickSort_Index(&index[0], &value[0], ti_start_index, ti_pivot_index)
		ARR_LIB_Sub_QuickSort_Index(&index[0], &value[0], ti_pivot_index + 1, ti_end_index)
	}
}
procedure void ARR_LIB_QuickSort_OrderIndex(byrefarr int index, byrefarr float value, int ti_array_size)
{
	int		ti_i	

	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
		index[ti_i] = ti_i

	ARR_LIB_Sub_QuickSort_Index(&index[0], &value[0], 0, ti_array_size - 1)
}

// TRI PAR FUSION DES VALEURS =================================================================
procedure void ARR_LIB_Sub_Fusion_Fusionne(byrefarr float af_value, int ti_index_start, int ti_middle_index, int ti_index_end)
{
	int		ti_i
	int		ti_compteur_1	
	int		ti_compteur_2
	
	float	taf_temp[200]
	
	// On recopie la première moitié du tableau
	for (ti_i = 0; ti_i <= ti_index_end - ti_index_start; ti_i++)
		taf_temp[ti_i] = af_value[ti_index_start + ti_i]

	ti_compteur_1 = ti_index_start
	ti_compteur_2 = ti_middle_index + 1

	for (ti_i = ti_index_start; ti_i <= ti_index_end; ti_i++)
	{
		if (ti_compteur_1 > ti_middle_index)
		{
			// On a parcouru tout le premier tableau
			break 
		}
		else if (ti_compteur_2 > ti_index_end)
		{
			// On a parcouru tout le deuxième tableau
			af_value[ti_i] = taf_temp[ti_compteur_1 - ti_index_start]
			ti_compteur_1++
		}
		else if (taf_temp[ti_compteur_1 - ti_index_start] < af_value[ti_compteur_2])
		{
			// L'élément du premier sous tableau est plus petit
			af_value[ti_i] = taf_temp[ti_compteur_1 - ti_index_start]
			ti_compteur_1++
		}
		else
		{
			// L'élément du second tableau est plus petit
			af_value[ti_i] = af_value[ti_compteur_2]
			ti_compteur_2++
		}
	}
}
procedure void ARR_LIB_Sub_Fusion(byrefarr float af_value, int ti_index_start, int ti_index_end)
{
	int		ti_middle_index
	
	if (ti_index_start < ti_index_end)
	{
		ti_middle_index = ti_index_start + ti_index_end
		ti_middle_index /= 2
		
		ARR_LIB_Sub_Fusion(&af_value[0], ti_index_start, ti_middle_index)
		ARR_LIB_Sub_Fusion(&af_value[0], ti_middle_index + 1, ti_index_end)
		ARR_LIB_Sub_Fusion_Fusionne(&af_value[0], ti_index_start, ti_middle_index, ti_index_end)
	}
}
procedure void ARR_LIB_Fusion_Order( byrefarr float af_value, int ti_array_size)
{
	ARR_LIB_Sub_Fusion(&af_value[0], 0, ti_array_size - 1)
}

// TRI PAR FUSION DES INDEX =======================================================================================
procedure void ARR_LIB_Sub_Fusion_FusionneIndex(byrefarr int ai_index_arr, byrefarr float af_value, int ti_index_start, int ti_middle_index, int ti_index_end)
{
	int		ti_i
	int		ti_compteur_1	
	int		ti_compteur_2
	
	int		tai_temp[200]
	
	// On recopie la première moitié du tableau
	for (ti_i = 0; ti_i <= ti_index_end - ti_index_start; ti_i++)
		tai_temp[ti_i] = ai_index_arr[ti_index_start + ti_i]

	ti_compteur_1 = ti_index_start
	ti_compteur_2 = ti_middle_index + 1

	for (ti_i = ti_index_start; ti_i <= ti_index_end; ti_i++)
	{
		if (ti_compteur_1 > ti_middle_index)
		{
			// On a parcouru tout le premier tableau
			break
		}
		else if (ti_compteur_2 > ti_index_end)
		{
			// On a parcouru tout le deuxième tableau
			ai_index_arr[ti_i] = tai_temp[ti_compteur_1 - ti_index_start]
			ti_compteur_1++
		}
		else if (af_value[tai_temp[ti_compteur_1 - ti_index_start]] < af_value[ai_index_arr[ti_compteur_2]])
		{
			// L'élément du premier tableau est plus petit
			ai_index_arr[ti_i] = tai_temp[ti_compteur_1 - ti_index_start]
			ti_compteur_1++
		}
		else
		{
			// L'élément du second tableau est plus petit
			ai_index_arr[ti_i] = ai_index_arr[ti_compteur_2]
			ti_compteur_2++
		}
	}
}
procedure void ARR_LIB_Sub_Fusion_OrderIndex(byrefarr int ai_index_arr, byrefarr float af_value, int ti_index_start, int ti_index_end)
{
	int		ti_middle_index
	
	if (ti_index_start < ti_index_end)
	{
		ti_middle_index = ti_index_start + ti_index_end
		ti_middle_index /= 2
		
		ARR_LIB_Sub_Fusion_OrderIndex(&ai_index_arr[0], &af_value[0], ti_index_start, ti_middle_index)
		ARR_LIB_Sub_Fusion_OrderIndex(&ai_index_arr[0], &af_value[0], ti_middle_index + 1, ti_index_end)
		ARR_LIB_Sub_Fusion_FusionneIndex(&ai_index_arr[0], &af_value[0], ti_index_start, ti_middle_index, ti_index_end)
	}
}
procedure void ARR_LIB_Fusion_OrderIndex(byrefarr int ai_index_arr, byrefarr float af_value, int ti_array_size)
{
	int		ti_i	

	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
		ai_index_arr[ti_i] = ti_i

	ARR_LIB_Sub_Fusion_OrderIndex(&ai_index_arr[0], &af_value[0], 0, ti_array_size - 1)
}

// NEAREST REACHEABLE ===========================================================================================
// RETOURNE LE WP LE PLUS PROCHE ACCESSIBLE EN LIGNE DROITE ET S'IL Y EN A UN DANS UN CONE
procedure object ARR_LIB_NearestSightReachableWaypoint(byrefarr object tao_wp2, int ti_start_index, int ti_array_size, vector tv_start_pos, vector tv_sight, float tf_cos_angle, int ti_capa_a_vrai, int ti_capa_a_faux, byref object to_nearest_wp, int ti_grid_width, int ti_warning)
{
	int				ti_good_wp_nb
	int				ti_i
	int				ti_wp_capa
	int				ti_index
	int				ti_index_order[100]

	float			tf_norm
	float			tf_tested_length
	float			taf_sqr_dist[100]
	float			tf_dot_product

	vector		tv_tested_pos
	vector		tv_grid_start_pos
	vector		tv_grid_dest_pos
	vector		tv_start_to_dest

	object		tao_wp[100]
	object		to_wp

//#ifndef _FINAL_
//	// ON N'EST PAS SUR LA GRILLE !!!
//	if (! GRID_IsIn(tv_start_pos))
//	{
//		DBG_RenderVector(tv_start_pos + cvector(0.0, 0.0, -100000.0), Cv_VerticalVector * 1000000.0, color_cyan)
//		DBG_BreakPoint()
//	}
//#endif 

	GRID_CurrentSet(0)

	MATH_VecSetNormalize(tv_sight)

	tv_grid_start_pos = GRID_PosGet(tv_start_pos)

	ti_good_wp_nb = 0
	for (ti_i = 0; ti_i < ti_array_size; ti_i++)
	{
		to_wp = tao_wp2[ti_start_index + ti_i]
	
		// Test capa
		ti_wp_capa = @to_wp OBJ_CapaGet()

		if (ti_wp_capa & ti_capa_a_faux)
			continue

		if (ti_capa_a_vrai != all && ! (ti_wp_capa & ti_capa_a_vrai))
			continue

		// Ce wp est bon pour le service, on calcul sa distance à la position désirée
		tv_grid_dest_pos = GRID_PosGet(@to_wp OBJ_PosGet()	)

		tv_start_to_dest = tv_grid_dest_pos - tv_grid_start_pos
		tv_start_to_dest.z = 0.0

		tf_norm = MATH_VecDotProduct(tv_start_to_dest, tv_start_to_dest)

		taf_sqr_dist[ti_good_wp_nb] = tf_norm
		tao_wp[ti_good_wp_nb] = to_wp
		
		ti_good_wp_nb++
	}

	to_wp = nobody
	to_nearest_wp = nobody

	if (!ti_good_wp_nb)
		return	(nobody)

	// On récupère les index qui déterminent l'ordre des wps du plus proche au plus éloigné...
//	ARR_Fusion_OrderIndex(&ti_index_order[0], &taf_sqr_dist[0], ti_good_wp_nb)
	ARR_LIB_QuickSort_OrderIndex(&ti_index_order[0], &taf_sqr_dist[0], ti_good_wp_nb)
	@get_global i_quick_sort_call_nb ++
	@get_global i_quick_sort_wp_nb += ti_good_wp_nb
	
	to_nearest_wp = tao_wp[ti_index_order[0]]

	// On regarde pour chaque wp, du plus proche au plus éloigné
//	for (ti_i = 0; ti_i < MATH_FloatMin(ti_good_wp_nb, 5); ti_i++)
	for (ti_i = 0; ti_i < ti_good_wp_nb; ti_i++)
	{
		ti_index	= ti_index_order[ti_i]
	
		if (taf_sqr_dist[ti_index] == 0.0)
		{
			to_wp = tao_wp[ti_index]
			to_nearest_wp = tao_wp[ti_index_order[0]]
			break
		}
		else
		{
			tf_norm = MATH_FloatSqrt(taf_sqr_dist[ti_index])
			
			tv_grid_dest_pos = GRID_PosGet(@tao_wp[ti_index] OBJ_PosGet())

			tv_start_to_dest = tv_grid_dest_pos - tv_grid_start_pos
			tv_start_to_dest.z = 0.0
			tv_start_to_dest /= tf_norm

			if (tf_cos_angle == -1.0)
				tf_dot_product = 1.0
			else
				tf_dot_product = MATH_VecDotProduct(tv_sight, tv_start_to_dest)

			if (to_wp && tf_dot_product < tf_cos_angle)
				continue
				
			if (GRID_LIB_IsReachableFrom(tv_grid_dest_pos, tv_grid_start_pos, 0, -1.0, faux, ti_grid_width))
			{
				if (tf_dot_product >= tf_cos_angle)
				{
					to_wp = tao_wp[ti_index]
					break
				}
				else if (!to_wp)
				{
					to_wp = tao_wp[ti_index]
				}
			}
		}
	}

	// Si on n'a pas trouvé de wp accessible en ligne droite
	if (to_wp == nobody && AI_GetCurSystem() == 10)
	{
#ifndef _FINAL_
		if (ti_warning && @get_global i_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos_nb < 200 && ARR_LIB_VectorSearch(& @get_global av_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos[0], @get_global i_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos_nb, tv_start_pos, 0.1) == -1)
		{
			@get_global av_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos[@get_global i_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos_nb] = tv_start_pos
			@get_global ao_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos_Nearest_Wp[@get_global i_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos_nb] = tao_wp[ti_index_order[0]]
			@get_global i_GST_Climb_NearestSightReachableWaypoint_Invalid_Pos_nb++

//			// ON RECOMMENCE =================================================================
//			// ON RECOMMENCE =================================================================
//			// ON RECOMMENCE =================================================================
//		
//			GRID_CurrentSet(0)
//		
//			MATH_VecSetNormalize(tv_sight)
//		
//			tv_grid_start_pos = GRID_PosGet(tv_start_pos)
//		
//			ti_good_wp_nb = 0
//			for (ti_i = 0; ti_i < ti_array_size; ti_i++)
//			{
//				to_wp = tao_wp2[ti_start_index + ti_i]
//			
//				// Test capa
//				ti_wp_capa = @to_wp OBJ_CapaGet()
//		
//				if (ti_wp_capa & ti_capa_a_faux)
//					continue
//		
//				if (ti_capa_a_vrai != all && ! (ti_wp_capa & ti_capa_a_vrai))
//					continue
//		
//				// Ce wp est bon pour le service, on calcul sa distance à la position désirée
//				tv_grid_dest_pos = GRID_PosGet(@to_wp OBJ_PosGet()	)
//		
//				tv_start_to_dest = tv_grid_dest_pos - tv_grid_start_pos
//				tv_start_to_dest.z = 0.0
//		
//				tf_norm = MATH_VecDotProduct(tv_start_to_dest, tv_start_to_dest)
//		
//				taf_sqr_dist[ti_good_wp_nb] = tf_norm
//				tao_wp[ti_good_wp_nb] = to_wp
//				
//				ti_good_wp_nb++
//			}
//		
//			to_wp = nobody
//			to_nearest_wp = nobody
//		
//			if (!ti_good_wp_nb)
//				return	(nobody)
//		
//			// On récupère les index qui déterminent l'ordre des wps du plus proche au plus éloigné...
//		//	ARR_Fusion_OrderIndex(&ti_index_order[0], &taf_sqr_dist[0], ti_good_wp_nb)
//			ARR_LIB_QuickSort_OrderIndex(&ti_index_order[0], &taf_sqr_dist[0], ti_good_wp_nb)
//
//			for (ti_i = 0; ti_i < ti_good_wp_nb; ti_i++)
//			{
//				ti_index	= ti_index_order[ti_i]
//				DBG_TraceObject(tao_wp[ti_index])
//				DBG_TraceString(" est à ")
//				DBG_TraceFloat(MATH_FloatSqrt(taf_sqr_dist[ti_index]))
//				DBG_TraceString(" mètres")
//				DBG_TraceEOL()
//			}
//			
//			to_nearest_wp = tao_wp[ti_index_order[0]]
//		
//			// On regarde pour chaque wp, du plus proche au plus éloigné
//		//	for (ti_i = 0; ti_i < MATH_FloatMin(ti_good_wp_nb, 5); ti_i++)
//			for (ti_i = 0; ti_i < ti_good_wp_nb; ti_i++)
//			{
//				ti_index	= ti_index_order[ti_i]
//			
//				if (taf_sqr_dist[ti_index] == 0.0)
//				{
//					to_wp = tao_wp[ti_index]
//					to_nearest_wp = tao_wp[ti_index_order[0]]
//					break
//				}
//				else
//				{
//					tf_norm = MATH_FloatSqrt(taf_sqr_dist[ti_index])
//					
//					tv_grid_dest_pos = GRID_PosGet(@tao_wp[ti_index] OBJ_PosGet())
//		
//					tv_start_to_dest = tv_grid_dest_pos - tv_grid_start_pos
//					tv_start_to_dest.z = 0.0
//					tv_start_to_dest /= tf_norm
//		
//					if (tf_cos_angle == -1.0)
//						tf_dot_product = 1.0
//					else
//						tf_dot_product = MATH_VecDotProduct(tv_sight, tv_start_to_dest)
//		
//					if (to_wp && tf_dot_product < tf_cos_angle)
//						continue
//						
//					if (GRID_LIB_IsReachableFrom(tv_grid_dest_pos, tv_grid_start_pos, 0, -1.0, vrai, ti_grid_width))
//					{
//						if (tf_dot_product >= tf_cos_angle)
//						{
//							to_wp = tao_wp[ti_index]
//							break
//						}
//						else if (!to_wp)
//						{
//							to_wp = tao_wp[ti_index]
//						}
//					}
//				}
//			}
//		
//			// ON RECOMMENCE =================================================================
//			// ON RECOMMENCE =================================================================
//			// ON RECOMMENCE =================================================================

		}
#endif
	}

	return(to_wp)
}

// ====================================================================================================
// RETOURNE LE GAO DU RESEAU DONT LA BV EST LA PLUS PROCHE DE LA POSITION SPECIFIEE
// ====================================================================================================
procedure object ARR_LIB_NearestBVWaypoint(byrefarr object tao_wp, int ti_wp_nb, vector tv_start_pos, int ti_capa_a_vrai, int ti_capa_a_faux, byref vector tv_nearest_pos)
{
	int				ti_i
	int				ti_wp_capa

	float			tf_dist
	float			tf_best_dist

	vector		tv_nearest_bv_pos
	vector		tv_start_to_nearest_bv_pos

	object	to_wp

	to_wp = nobody
	tf_best_dist = Cf_Infinit

	for (ti_i = 0; ti_i < ti_wp_nb; ti_i++)
	{
		// Test capa
		ti_wp_capa = @tao_wp[ti_i] OBJ_CapaGet()

		if (ti_wp_capa & ti_capa_a_faux)
			continue

		if (ti_capa_a_vrai != all && ! (ti_wp_capa & ti_capa_a_vrai))
			continue

		if (@tao_wp[ti_i] COL_BV_PointCollide(tv_start_pos))
			return(tao_wp[ti_i])

		tv_nearest_bv_pos = OBJ_LIB_NearestBVPos(tv_start_pos, tao_wp[ti_i])
		
		tv_start_to_nearest_bv_pos = tv_nearest_bv_pos
		tv_start_to_nearest_bv_pos -= tv_start_pos
		
		tf_dist = MATH_VecDotProduct(tv_start_to_nearest_bv_pos, tv_start_to_nearest_bv_pos)
		if (tf_dist < tf_best_dist)
		{
			tv_nearest_pos = tv_nearest_bv_pos
			tf_best_dist = tf_dist
			to_wp = tao_wp[ti_i]
			
			if (!tf_dist)
				return(to_wp)
		}
	}
	
	return(to_wp)
}

