procedure void DBG_RenderBox(object to_gao, vector tv_min, vector tv_max, int ti_color);

procedure int MATH_LIB_InTriangle(vector tv_A, vector tv_normale_A, vector tv_B, vector tv_normale_B, vector tv_C, vector tv_normale_C, vector tv_pos)
{
	float	tf_sign	

	tf_sign = MATH_FloatSign(MATH_VecDotProduct(tv_pos - tv_A, tv_normale_A))

	if (tf_sign != MATH_FloatSign(MATH_VecDotProduct(tv_pos - tv_B, tv_normale_B)))
		return(faux)

	if (tf_sign != MATH_FloatSign(MATH_VecDotProduct(tv_pos - tv_C, tv_normale_C)))
		return(faux)

	return(vrai)
}

//procedure int GST_Climb_InRectangle(vector tv_corner, vector tv_X, vector tv_Y, float tf_X, float tf_Y, vector tv_pos)
//{
//	float		tf_dot
//	vector	tv_corner_to_pos	
//
//	tv_corner_to_pos = tv_pos - tv_corner
//
//	tf_dot = MATH_VecDotProduct(tv_corner_to_pos, tv_X)
//	if (tf_dot < 0.0 || tf_dot > tf_X)
//		return(faux)
//
//	tf_dot = MATH_VecDotProduct(tv_corner_to_pos, tv_Y)
//	if (tf_dot < 0.0 || tf_dot > tf_Y)
//		return(faux)
//
//	return(vrai)
//}

procedure int MATH_LIB_PointInTriangle(vector tv_M, vector tv_A, vector tv_B, vector tv_C, vector tv_N, byref int ti_exit_value)
{
	float		tf_val	

	vector 	tv_MA
	vector	tv_MB
	vector	tv_MC

	tv_MA = tv_A - tv_M
	tv_MB = tv_B - tv_M
	tv_MC = tv_C - tv_M

	#define Cf_InvSqr3	0.577350269189

	if (MATH_AbsFloat(tv_N.z) > Cf_InvSqr3)
	{
		tf_val = (tv_MA.x * tv_MB.y) - (tv_MA.y * tv_MB.x)
		if (MATH_FloatSign(tv_N.z) != MATH_FloatSign(tf_val))
		{
			if (ti_exit_value)
				ti_exit_value = 0
			return(faux)
		}
		else
		{
			tf_val = (tv_MB.x * tv_MC.y) - (tv_MB.y * tv_MC.x)
			if (MATH_FloatSign(tv_N.z) != MATH_FloatSign(tf_val))
			{
				if (ti_exit_value)
					ti_exit_value = 1
				return(faux)
			}
			else
			{
				tf_val = (tv_MC.x * tv_MA.y) - (tv_MC.y * tv_MA.x)
				if (MATH_FloatSign(tv_N.z) == MATH_FloatSign(tf_val))
				{
					return(vrai)
				}
				else
				{
					if (ti_exit_value)
						ti_exit_value = 2
					return(faux)
				}
			}
		}
	}
	else if (MATH_AbsFloat(tv_N.y) > Cf_InvSqr3)
	{
		tf_val = (tv_MA.z * tv_MB.x) - (tv_MA.x * tv_MB.z)
		if (MATH_FloatSign(tv_N.y) != MATH_FloatSign(tf_val))
		{
			if (ti_exit_value)
				ti_exit_value = 0
			return(faux)
		}
		else
		{
			tf_val = (tv_MB.z * tv_MC.x) - (tv_MB.x * tv_MC.z)
			if (MATH_FloatSign(tv_N.y) != MATH_FloatSign(tf_val))
			{
				if (ti_exit_value)
					ti_exit_value = 1
				return(faux)
			}
			else
			{
				tf_val = (tv_MC.z * tv_MA.x) - (tv_MC.x * tv_MA.z)
				if (MATH_FloatSign(tv_N.y) == MATH_FloatSign(tf_val))
				{
					return(vrai)
				}
				else
				{
					if (ti_exit_value)
						ti_exit_value = 2
					return(faux)
				}
			}
		}
	}
	else
	
	{
		tf_val = (tv_MA.y * tv_MB.z) - (tv_MA.z * tv_MB.y)
		if(MATH_FloatSign(tv_N.x) != MATH_FloatSign(tf_val))
		{
			if (ti_exit_value)
				ti_exit_value = 0
			return(faux)
		}
		else
		{
			tf_val = (tv_MB.y * tv_MC.z) - (tv_MB.z * tv_MC.y)
			if(MATH_FloatSign(tv_N.x) != MATH_FloatSign(tf_val))
			{
				if (ti_exit_value)
					ti_exit_value = 1
				return(faux)
			}
			else
			{
				tf_val = (tv_MC.y * tv_MA.z) - (tv_MC.z * tv_MA.y)

				if(MATH_FloatSign(tv_N.x) == MATH_FloatSign(tf_val))
				{
					return(vrai)
				}
				else
				{
					if (ti_exit_value)
						ti_exit_value = 2
					return(faux)
				}
			}
		}
	}
}

procedure int MATH_LIB_InQuadrilatere(vector tv_A, vector tv_B, vector tv_C, vector tv_D, vector tv_pos, vector tv_normale, int ti_quadrilataire_type, int ti_display_info)
{
	// CA MARCHE AVEC LES QUADRILATAIRES CONVEXES, CONCAVES ET CROISES
	int			ti_i
	int			ti_flag_in_quadrilataire	
	int			ti_concave_point_index

	float		tf_sign	
	float		tf_point_sign[4]
	float		tf_dot_product

	vector	tv_point[4]
	vector	tv_cross_product[4]
	vector	tav_triangle_sommet[3]
	vector	tav_triangle_normale[3]

	tv_point[0] = tv_A
	tv_point[1] = tv_B
	tv_point[2] = tv_C
	tv_point[3] = tv_D

#ifndef _FINAL_
	if (ti_display_info)
	{
		tv_point[0] -= MATH_VecDotProduct(tv_point[0] - tv_pos, tv_normale) * tv_normale
		tv_point[1] -= MATH_VecDotProduct(tv_point[1] - tv_pos, tv_normale) * tv_normale
		tv_point[2] -= MATH_VecDotProduct(tv_point[2] - tv_pos, tv_normale) * tv_normale
		tv_point[3] -= MATH_VecDotProduct(tv_point[3] - tv_pos, tv_normale) * tv_normale
	}
#endif

	ti_flag_in_quadrilataire = vrai

	// CALCUL DES NORMALES
	for (ti_i = 0; ti_i < 4; ti_i++)
		tv_cross_product[ti_i] = MATH_VecCrossProduct(tv_point[MATH_Modulo(ti_i + 1, 4)] - tv_point[ti_i], tv_normale)

	// TYPE DU QUADRILATAIRE
	switch(ti_quadrilataire_type)
	{
		case Ci_QUADRILATAIRE_CONVEXE :
			tf_sign = 4.0
			break

		case Ci_QUADRILATAIRE_CONCAVE :
			tf_sign = 2.0
			break

		case Ci_QUADRILATAIRE_CROISE :
			tf_sign = 0.0
			break

		default:
			tf_sign = 0.0
			for (ti_i = 0; ti_i < 4; ti_i++)
			{
				tf_dot_product = MATH_VecDotProduct(tv_point[MATH_Modulo(ti_i + 2, 4)] - tv_point[ti_i], tv_cross_product[ti_i])
				if (tf_dot_product)
				{
					tf_point_sign[ti_i] = MATH_FloatSign(tf_dot_product)
					tf_sign += tf_point_sign[ti_i]
				}
				else
				{
					tf_point_sign[ti_i] = 0.0
				}
			}
	}

	if (MATH_AbsFloat(tf_sign) == 4.0)
	{
		// QUADRILATAIRE CONVEXE
		for (ti_i = 0; ti_i < 4; ti_i++)
		{
			tf_dot_product = MATH_VecDotProduct(tv_pos - tv_point[ti_i], tv_cross_product[ti_i])
			if (tf_dot_product && !ti_i)
				tf_sign = MATH_FloatSign(tf_dot_product)
			else if (tf_sign != MATH_FloatSign(tf_dot_product))
				ti_flag_in_quadrilataire = faux
		}
	}
	else if (MATH_AbsFloat(tf_sign) == 2.0)
	{
		// QUADRILATAIRE CONCAVE
		ti_flag_in_quadrilataire = faux
	
		tf_sign = MATH_FloatSign(tf_sign)
	
		// RECHERCHE DU POINT DE CONCAVITE
		for (ti_i = 0; ti_i < 4; ti_i++)
		{
			if (tf_point_sign[ti_i] != tf_sign)
			{
				ti_concave_point_index = MATH_Modulo(ti_i + 1, 4)
				break
			}
		}
		
//		DBG_RenderVector(tv_point[ti_concave_point_index], tv_normale * 5.0, color_rouge)
		
		// TEST DES DEUX TRIANGLES
		tav_triangle_sommet[0] = tv_point[ti_concave_point_index] 
		tav_triangle_normale[0] = tv_cross_product[ti_concave_point_index]
		
		tav_triangle_sommet[1] = tv_point[MATH_Modulo(ti_concave_point_index + 1, 4)] 
		tav_triangle_normale[1] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 1, 4)]

		tav_triangle_sommet[2] = tv_point[MATH_Modulo(ti_concave_point_index + 2, 4)] 
		tav_triangle_normale[2] = MATH_VecCrossProduct(tav_triangle_sommet[0] - tav_triangle_sommet[2], tv_normale)

		if (MATH_LIB_InTriangle(tav_triangle_sommet[0], tav_triangle_normale[0], tav_triangle_sommet[1], tav_triangle_normale[1], tav_triangle_sommet[2], tav_triangle_normale[2], tv_pos))
		{
			ti_flag_in_quadrilataire = vrai
		}
		else
		{
			tav_triangle_normale[0] = -tav_triangle_normale[2]
			
			tav_triangle_sommet[1] = tav_triangle_sommet[2]
			tav_triangle_normale[1] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 2, 4)]
	
			tav_triangle_sommet[2] = tv_point[MATH_Modulo(ti_concave_point_index + 3, 4)] 
			tav_triangle_normale[2] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 3, 4)]

			if (MATH_LIB_InTriangle(tav_triangle_sommet[0], tav_triangle_normale[0], tav_triangle_sommet[1], tav_triangle_normale[1], tav_triangle_sommet[2], tav_triangle_normale[2], tv_pos))
				ti_flag_in_quadrilataire = vrai
		}
	}
	else
	{
		// QUADRILATAIRE CROISE
		ti_flag_in_quadrilataire = faux

		// RECHERCHE DU POINT DE CROISEMENT
		tf_sign = tf_point_sign[0]
	
		for (ti_i = 1; ti_i < 4; ti_i++)
		{
			if (tf_point_sign[ti_i] != tf_sign)
			{
				ti_concave_point_index = MATH_Modulo(ti_i + 1, 4)
				break
			}
		}
		
		// TEST DES DEUX TRIANGLES
		tav_triangle_sommet[0] = tv_point[ti_concave_point_index] 
		tav_triangle_normale[0] = tv_cross_product[ti_concave_point_index]
		
		tav_triangle_sommet[1] = tv_point[MATH_Modulo(ti_concave_point_index + 1, 4)] 
		tav_triangle_normale[1] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 1, 4)]

		tav_triangle_sommet[2] = tav_triangle_sommet[0]
		tav_triangle_normale[2] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 3, 4)]

		if (MATH_LIB_InTriangle(tav_triangle_sommet[0], tav_triangle_normale[0], tav_triangle_sommet[1], tav_triangle_normale[1], tav_triangle_sommet[2], tav_triangle_normale[2], tv_pos))
		{
			ti_flag_in_quadrilataire = vrai
		}
		else
		{
			tav_triangle_normale[2] = tav_triangle_normale[1]

			tav_triangle_sommet[1] = tv_point[MATH_Modulo(ti_concave_point_index + 3, 4)] 
			tav_triangle_normale[1] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 3, 4)]

			tav_triangle_sommet[0] = tv_point[MATH_Modulo(ti_concave_point_index + 2, 4)]
			tav_triangle_normale[0] = tv_cross_product[MATH_Modulo(ti_concave_point_index + 2, 4)]

			tav_triangle_sommet[2] = tav_triangle_sommet[0]

			if (MATH_LIB_InTriangle(tav_triangle_sommet[0], tav_triangle_normale[0], tav_triangle_sommet[1], tav_triangle_normale[1], tav_triangle_sommet[2], tav_triangle_normale[2], tv_pos))
				ti_flag_in_quadrilataire = vrai
		}
	}

#ifndef _FINAL_
	if (AI_GetCurSystem() == 10 && ti_display_info)
	{
		for (ti_i = 0; ti_i < 4; ti_i++)
		{
			if (ti_flag_in_quadrilataire)
				DBG_RenderVector(tv_point[ti_i], tv_point[MATH_Modulo(ti_i + 1, 4)] - tv_point[ti_i], color_vert)
			else
				DBG_RenderVector(tv_point[ti_i], tv_point[MATH_Modulo(ti_i + 1, 4)] - tv_point[ti_i], color_rouge)
		}
	
		if (ti_flag_in_quadrilataire)
			DBG_RenderVector(tv_pos, tv_normale * 5.0, color_vert)
	}
#endif

	return(ti_flag_in_quadrilataire)
}

procedure vector MATH_LIB_VectorInPrisme(vector tv_vector, vector tv_cone_dir, vector tv_prisme_Z_dir, float tf_angle_limit)
{
	float		tf_angle	

	vector 	tv_hor_dir
	
	tv_hor_dir = tv_vector
	tv_hor_dir -= MATH_VecDotProduct(tv_vector, tv_prisme_Z_dir) * tv_prisme_Z_dir
	
	tf_angle = MATH_VecAngle(tv_hor_dir, tv_cone_dir, tv_prisme_Z_dir)
	
	if (MATH_AbsFloat(tf_angle) > tf_angle_limit)
	{
		tf_angle = MATH_FloatSign(tf_angle) * (MATH_AbsFloat(tf_angle) - tf_angle_limit)
		tv_vector = MATH_VecRotate(tv_vector, tv_prisme_Z_dir, tf_angle)
	}
	
	return(tv_vector)
}

procedure float MATH_LIB_ZoneInCone(vector tv_start_pos, vector tv_sight, float tf_cos_angle, float tf_dist_max, vector tv_dest_pos, float tf_zone_rayon, int ti_flag_2D, byref float tf_dot_product, int ti_color_cone, int ti_color_sphere)
{
	int			ti_i	

	float		tf_dist
	float		tf_Adj
	float		tf_Opp
	float		tf_Hyp
	float		tf_val
	float		tf_norm	
	float		tf_sqr_dist

	vector	tv_start_to_dest
	vector	tv_dir
	vector	tv_cone_limit
	vector	tv_horizon
	vector	tv_projection
	vector	tv_render_cone
	vector	tv_pos_A
	vector	tv_pos_B
	vector	tv_pos_C

	if (ti_flag_2D)
	{
		tv_dest_pos.z = tv_start_pos.z
		tv_sight.z = 0.0
		tf_norm = MATH_VecNorm(tv_sight)
		if (MATH_FloatNullToler(tf_norm, 0.001))
			return(0.0)
			
		tv_sight /= tf_norm
	}

#ifndef _FINAL_
	if (AI_GetCurSystem() == 10)
	{
		if (ti_color_sphere)
			DBG_RenderSphere(tv_dest_pos, tf_zone_rayon, ti_color_sphere)
	
		if (ti_color_cone)
		{
//			DBG_RenderCone(tv_start_pos, tv_sight * tf_dist_max, MATH_ACos(tf_cos_angle), ti_color_cone)
	
			tv_render_cone = MATH_VecCrossProduct(tv_sight, Cv_VerticalVector)
			if (MATH_VecDotProduct(tv_render_cone, tv_render_cone))
			{
				tv_render_cone = MATH_VecRotate(tv_sight, tv_render_cone, MATH_ACos(tf_cos_angle)) * tf_dist_max
			}
			else
			{
				tv_render_cone = MATH_VecCrossProduct(tv_sight, cvector(1.0, 0.0, 0.0))
				tv_render_cone = MATH_VecRotate(tv_sight, tv_render_cone, MATH_ACos(tf_cos_angle)) * tf_dist_max
			}
			
			tv_pos_C = tv_start_pos
			tv_pos_C += tv_sight * tf_dist_max
	
			tv_pos_A = tv_start_pos
			tv_pos_A += tv_render_cone
			for (ti_i = 0; ti_i < 15; ti_i++)
			{
				DBG_RenderVector(tv_pos_C, tv_pos_A - tv_pos_C, ti_color_cone)
				DBG_RenderVector(tv_start_pos, tv_render_cone, ti_color_cone)
				tv_render_cone = MATH_VecRotate(tv_render_cone, tv_sight, Cf_2Pi / 15.0)
				tv_pos_B = tv_start_pos
				tv_pos_B += tv_render_cone
				DBG_RenderVector(tv_pos_A, tv_pos_B - tv_pos_A, ti_color_cone)
				tv_pos_A = tv_pos_B
			}
		}
	}
#endif	

	tv_start_to_dest = tv_dest_pos
	tv_start_to_dest -= tv_start_pos
	
	tf_sqr_dist = MATH_VecDotProduct(tv_start_to_dest, tv_start_to_dest)
	if (tf_sqr_dist <= tf_zone_rayon * tf_zone_rayon)
	{
		// INTERSECTION DIRECTE
		tf_dist = MATH_FloatSqrt(tf_sqr_dist)
		
		if (tf_dist)
		{
			tv_dir = tv_start_to_dest / tf_dist
			tf_dot_product = MATH_VecDotProduct(tv_sight, tv_dir)
		}
		else
		{
			tf_dot_product = -1.0
		}

		return(0.00001 + tf_dist)
	}
	else if (tf_sqr_dist <= (tf_dist_max + tf_zone_rayon) * (tf_dist_max + tf_zone_rayon))
	{
		// PAS TROP LOIN
		tf_dist = MATH_FloatSqrt(tf_sqr_dist)
		tv_dir = tv_start_to_dest / tf_dist
		
		tf_dot_product = MATH_VecDotProduct(tv_sight, tv_dir)
		if (tf_dot_product >= tf_cos_angle)
		{
			// OK, C'EST DANS LE CONE*
			return(0.00001 + tf_dist)
		}
		else if (tf_zone_rayon)
		{
			// ON N'EST PAS DANS LE CONE
			if (tf_cos_angle)
			{
				// ON VA CONSTRUIRE LE VECTEUR QUI CORRESPOND A LA LIMITE DU CONE
				tv_horizon = MATH_VecCrossProduct(tv_sight, tv_dir)
				tv_horizon = MATH_VecCrossProduct(tv_sight, tv_horizon)
				MATH_VecSetNormalize(tv_horizon)
	
				tf_Adj = MATH_AbsFloat(MATH_VecDotProduct(tv_start_to_dest, tv_sight))
				
				tf_val = tf_Adj * tf_Adj
				tf_val = MATH_FloatSqrt((tf_val / (tf_cos_angle * tf_cos_angle)) - tf_val)
				
				tv_cone_limit = tv_sight * tf_Adj
				tv_cone_limit -= tf_val * tv_horizon
				MATH_VecSetNormalize(tv_cone_limit)
	
				tv_projection = tv_start_pos
				tv_projection += MATH_VecDotProduct(tv_start_to_dest, tv_cone_limit) * tv_cone_limit
				tv_projection -= tv_dest_pos
			
				// DISTANCE AU CARRE ENTRE LE CONE ET LE POINT DEST
				tf_sqr_dist = MATH_VecDotProduct(tv_projection, tv_projection)
			}
			else
			{
				// DISTANCE AU CARRE ENTRE LE CONE ET LE POINT DEST
				tf_sqr_dist = MATH_VecDotProduct(tv_start_to_dest, -tv_sight)
				tf_sqr_dist *= tf_sqr_dist
			}
			
			if (tf_sqr_dist <= tf_zone_rayon * tf_zone_rayon)
			{
				// INTERSECTION
				return(0.00001 + tf_dist)
			}
		}
	}

	return(0.0)
}


// BEZIER
procedure vector MATH_LIB_Bezier_Pos_Get(float tf_coef, vector tv_point_A, vector tv_point_B, vector tv_point_C, vector tv_point_D, byref vector tv_sight)
{
	if (tf_coef <= 0.0)
	{
		tv_sight = tv_point_B - tv_point_A
		return(tv_point_A)
	}
	
	if (tf_coef >= 1.0)
	{
		tv_sight = tv_point_D - tv_point_C
		return(tv_point_D)
	}

	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
	tv_point_C += (tv_point_D - tv_point_C) * tf_coef

	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef

	tv_sight = tv_point_B - tv_point_A

	tv_point_A += tv_sight * tf_coef

	return(tv_point_A)
}

procedure float MATH_LIB_Bezier_Find_Move_Coef(float tf_norm, int ti_iteration_nb, vector tv_point_A, vector tv_point_B, vector tv_point_C, vector tv_point_D)
{
	int			ti_i	

	float		tf_coef
	float		tf_borne_min
	float		tf_borne_max
	float		tf_sqr_norm	
	float		tf_sqr_dist

	vector	tv_move
	vector	tv_temp

	if (!tf_norm)
		return(0.0)

	tf_borne_min = 0.0
	tf_borne_max = 1.0

	tf_sqr_norm = tf_norm
	tf_sqr_norm *= tf_sqr_norm

	tv_temp = tv_point_D
	tv_temp -= tv_point_A
	if (MATH_VecDotProduct(tv_temp, tv_temp) <= tf_sqr_norm)
		return(1.0)

	ti_i = 0
	while(	ti_i < ti_iteration_nb)
	{
		ti_i++
		
		tf_coef = tf_borne_min
		tf_coef += (tf_borne_max - tf_borne_min) * 0.5
		
		tv_move = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_temp)
		tv_move -= tv_point_A
		tv_move.z = 0.0
		
		tf_sqr_dist = MATH_VecDotProduct(tv_move, tv_move) 
		if (tf_sqr_dist > tf_sqr_norm)
			tf_borne_max = tf_coef
		else
			tf_borne_min = tf_coef
	}

	return(tf_coef)
}

// A BEZIER
procedure vector MATH_LIB_A_Bezier_Pos_Get(float tf_coef, float tf_B_weight, float tf_C_weight, vector tv_point_A, vector tv_point_B, vector tv_point_C, vector tv_point_D)
{
	float	tf_WResult1
	float	tf_WResult2
	float	tf_WResult3

	if (tf_coef <= 0.0)
		return(tv_point_A)
	
	if (tf_coef >= 1.0)
		return(tv_point_D)

	tf_WResult1 = 1.0 + ((tf_B_weight - 1.0) * tf_coef)
	tf_WResult2 = tf_B_weight + ((tf_C_weight - tf_B_weight) * tf_coef)
	tf_WResult3 = tf_C_weight + ((1.0 - tf_C_weight) * tf_coef)

	tf_WResult1 += (tf_WResult2 - tf_WResult1) * tf_coef
	tf_WResult2 += (tf_WResult3 - tf_WResult2) * tf_coef

	tf_WResult1 += (tf_WResult2 - tf_WResult1) * tf_coef

	tv_point_B *= tf_B_weight
	tv_point_C *= tf_C_weight

	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef
	tv_point_C += (tv_point_D - tv_point_C) * tf_coef

	tv_point_A += (tv_point_B - tv_point_A) * tf_coef
	tv_point_B += (tv_point_C - tv_point_B) * tf_coef

	tv_point_A += (tv_point_B - tv_point_A) * tf_coef

	tv_point_A *= 1.0 / tf_WResult1
	
	return(tv_point_A)
}

procedure void MATH_LIB_Bezier_Display(int ti_nb_segment, vector tv_point_A, vector tv_point_B, vector tv_point_C, vector tv_point_D, int ti_color)
{
#ifndef _FINAL_
	int			ti_i

	float		tf_coef	
	float		tf_step
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_sight	
	vector	tv_temp

	if (AI_GetCurSystem() != 10)
		return

	tf_step = 1.0
	tf_step /= ti_nb_segment

	tv_start_pos = tv_point_A

//	DBG_RenderVector(tv_point_A, tv_point_B - tv_point_A, color_jaune)
//	DBG_RenderVector(tv_point_C, tv_point_D - tv_point_C, color_jaune)

	for (ti_i = 1; ti_i < ti_nb_segment; ti_i++)
	{
		tf_coef = ti_i * tf_step
		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_point_A, tv_point_B, tv_point_C, tv_point_D, tv_sight)
		DBG_RenderVector(tv_start_pos, tv_dest_pos - tv_start_pos, ti_color)
//		tv_temp	= MATH_VecBlend(tv_point_A, tv_point_D, tf_coef)
//		DBG_RenderVector(tv_temp, tv_dest_pos - tv_temp, color_rouge)

		tv_start_pos = tv_dest_pos
	}
	DBG_RenderVector(tv_dest_pos, tv_point_D - tv_dest_pos, ti_color)
#endif
	return
}

procedure void MATH_LIB_A_Bezier_Display(int ti_nb_segment, float tf_B_weight, float tf_C_weight, vector tv_point_A, vector tv_point_B, vector tv_point_C, vector tv_point_D)
{
	int			ti_i	

	float		tf_coef	
	float		tf_step
	
	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_sight

	if (AI_GetCurSystem() != 10)
		return
	
	tf_step = 1.0
	tf_step /= ti_nb_segment

	tv_start_pos = tv_point_A
	tv_dest_pos = tv_start_pos

	for (ti_i = 1; ti_i <= ti_nb_segment; ti_i++)
	{
		tf_coef = ti_i * tf_step
		tv_start_pos = tv_dest_pos
		tv_dest_pos = MATH_LIB_A_Bezier_Pos_Get(tf_coef, tf_B_weight, tf_C_weight, tv_point_A, tv_point_B, tv_point_C, tv_point_D)
		DBG_RenderVector(tv_start_pos, tv_dest_pos - tv_start_pos, color_rouge)
	}
}

// ============================================================
// RETOURNE LE POINT D'INTERSECTION ENTRE UNE LIGNE ET UN PLAN
// ============================================================
procedure int MATH_LIB_Intersection_Line_Plane(vector tv_start_pos, vector tv_dir, vector tv_plan_pos, vector tv_plan_normale, byref float tf_dist, byref vector tv_collide_pos)
{
	tf_dist = MATH_VecDotProduct(tv_dir, tv_plan_normale)	
	if (!tf_dist)
		return(faux)

	tf_dist = - MATH_VecDotProduct(tv_start_pos - tv_plan_pos, tv_plan_normale) / tf_dist

	tv_collide_pos = tv_start_pos
	tv_collide_pos += tf_dist * tv_dir
 
	return(vrai)
}

// ============================================================
// RETOURNE LE POINT D'INTERSECTION ENTRE UNE DIRECTION ET UN PLAN
// ============================================================
procedure int MATH_LIB_Intersection_Dir_Plane(vector tv_start_pos, vector tv_dir, vector tv_plan_pos, vector tv_plan_normale, byref float tf_dist, byref vector tv_collide_pos)
{
	if (MATH_LIB_Intersection_Line_Plane(tv_start_pos, tv_dir, tv_plan_pos, tv_plan_normale, tf_dist, tv_collide_pos))
	{
		if (tf_dist >= 0.0)
			return(vrai)
		else
			return(faux)
	}
	else
	{
		return(faux)
	}
}

// ====================================================================
// RETOURNE LE POINT D'INTERSECTION ENTRE UNE DIRECTION ET UN PLAN ORIENTE
// ====================================================================
procedure int MATH_LIB_Intersection_Dir_Oriented_Plane(vector tv_start_pos, vector tv_dir, vector tv_plan_pos, vector tv_plan_normale, byref float tf_dist, byref vector tv_collide_pos)
{
	tf_dist = MATH_VecDotProduct(tv_dir, tv_plan_normale)	
	if (tf_dist >= 0.0)
		return(faux)

	tf_dist = - MATH_VecDotProduct(tv_start_pos - tv_plan_pos, tv_plan_normale) / tf_dist

	tv_collide_pos = tv_start_pos
	tv_collide_pos += tf_dist * tv_dir
 
	if (tf_dist >= 0.0)
		return(vrai)
	else
		return(faux)
}

// =======================================================================================
// RETOURNE LE POINT D'INTERSECTION ENTRE UNE DIRECTION ET UNE FACE REALTIME RENDERING p. 305
// =======================================================================================
procedure int MATH_LIB_IntersectionDirTriangle(vector tv_O, vector tv_D, vector tv_V0, vector tv_V1, vector tv_V2, byref float tf_T, byref vector tv_collide_pos)
{
	float		tf_a	
	float		tf_f
	float		tf_U
	float		tf_V
	
	vector	tv_e1
	vector	tv_e2
	vector	tv_P	
	vector	tv_S
	vector	tv_Q

	tv_e1 = tv_V1 - tv_V0
	tv_e2 = tv_V2 - tv_V0
	
	tv_P = MATH_VecCrossProduct(tv_D, tv_e2)
	
	tf_a = MATH_VecDotProduct(tv_e1, tv_P) 
	
	if (MATH_FloatNullEpsilon(tf_a))	
		return(faux)
		
	tf_f = 1.0 / tf_a

	tv_S = tv_O - tv_V0
	
	tf_U = tf_f * MATH_VecDotProduct(tv_S, tv_P)

	if (tf_U < 0.0 || tf_U > 1.0)	
		return(faux)
		
	tv_Q = MATH_VecCrossProduct(tv_S, tv_e1)
	
	tf_V = tf_f * MATH_VecDotProduct(tv_D, tv_Q)
	
	if (tf_V < 0.0 || tf_U+ tf_V > 1.0)
		return(faux)
		
	tf_T = tf_f * MATH_VecDotProduct(tv_e2, tv_Q)
	
	tv_collide_pos = tv_O
	tv_collide_pos += tf_T * tv_D
	
	return(vrai)
}

// =======================================================================================
// COLLISION CYLINDRE POS
// =======================================================================================
procedure vector MATH_LIB_Nearest_Cylinder_Pos(vector tv_cylinder_pos, vector tv_axis, float tf_size_min, float tf_size_max, float tf_rayon, vector tv_start_pos)
{
	float	tf_dist
	float	tf_dot_product	

	vector tv_nearest_pos

	tv_nearest_pos = tv_start_pos
	tv_nearest_pos -= tv_cylinder_pos
	
	tf_dot_product = MATH_VecDotProduct(tv_nearest_pos, tv_axis)
	tv_nearest_pos -= tf_dot_product * tv_axis
	tf_dot_product = MATH_FloatLimit(tf_dot_product, tf_size_min, tf_size_max)

	tf_dist = MATH_VecDotProduct(tv_nearest_pos, tv_nearest_pos)
	if (tf_dist > tf_rayon * tf_rayon)
	{
		tf_dist = MATH_FloatSqrt(tf_dist)
		tv_nearest_pos /= tf_dist
		tv_nearest_pos *= tf_rayon
	}

	tv_nearest_pos += tf_dot_product * tv_axis
	tv_nearest_pos += tv_cylinder_pos

	return(tv_nearest_pos)
}

procedure int MATH_LIB_2D_COL_WhichSide(byrefarr vector vertices, int ti_vertex_nb, vector tv_dir, vector tv_pos)
{
	int		ti_i
	int		ti_positive
	int		ti_negative
	
	float	tf_dot_product

	ti_positive = 0
	ti_negative = 0

	for (ti_i = 0; ti_i < ti_vertex_nb; ti_i++)
	{
		tf_dot_product = MATH_VecDotProduct(tv_dir, vertices[ti_i] - tv_pos)
		if (tf_dot_product > 0.0)
			ti_positive++
		else if (tf_dot_product < 0.0)
			ti_negative++
			
		if (ti_positive && ti_negative)
			return(0)
	}
	
	if (ti_positive)	
		return(1)
	else
		return(-1)
}

procedure int MATH_LIB_2D_COL_Intersection(byrefarr vector Polygon_A, int vertex_A_nb, byrefarr vector Polygon_B, int vertex_B_nb)
{	
	int			ti_i
	int			ti_k
	
	vector	tv_normale

	ti_k = vertex_A_nb - 1
	for (ti_i = 0; ti_i < vertex_A_nb; ti_i++)
	{
		tv_normale = Polygon_A[ti_i] - Polygon_A[ti_k]
		tv_normale.z = tv_normale.x
		tv_normale.x = tv_normale.y
		tv_normale.y = -tv_normale.z
		tv_normale.z = 0.0
	
		if (MATH_LIB_2D_COL_WhichSide(&Polygon_B[0], vertex_B_nb, tv_normale, Polygon_A[ti_i]) > 0)
			return(faux)

		ti_k = ti_i
	}

	ti_k = vertex_B_nb - 1
	for (ti_i = 0; ti_i < vertex_B_nb; ti_i++)
	{
		tv_normale = Polygon_B[ti_i] - Polygon_B[ti_k]
		tv_normale.z = tv_normale.x
		tv_normale.x = tv_normale.y
		tv_normale.y = -tv_normale.z
		tv_normale.z = 0.0
	
		if (MATH_LIB_2D_COL_WhichSide(&Polygon_A[0], vertex_A_nb, tv_normale, Polygon_B[ti_i]) > 0)
			return(faux)

		ti_k = ti_i
	}

	return(vrai)
}

procedure void MATH_LIB_COL_3D_To_2D(byrefarr vector vertices, int ti_vertex_nb, vector tv_O, vector tv_X_axis, vector tv_Y_axis)
{
	int			ti_i
	
	vector	tv_3D_pos
	vector	tv_2D_pos

	tv_2D_pos.z = 0.0

	for (ti_i = 0; ti_i < ti_vertex_nb; ti_i++)
	{
		tv_3D_pos = vertices[ti_i]
		tv_2D_pos.x = MATH_VecDotProduct(tv_3D_pos - tv_O, tv_X_axis)
		tv_2D_pos.y = MATH_VecDotProduct(tv_3D_pos - tv_O, tv_Y_axis)
		vertices[ti_i] = tv_2D_pos
	}

//	for (ti_i = 0; ti_i < ti_vertex_nb; ti_i++)
//		DBG_RenderVector(tv_O + vertices[ti_i], vertices[MATH_Modulo(ti_i + 1, ti_vertex_nb)] - vertices[ti_i], color_blanc)
	
	return
}

//procedure int MATH_LIB_Intersection_Cylindre_Cylindre(vector tv_pos_A, vector tv_axis_A, float tf_min_A, float tf_max_A, float tf_rayon_A, vector tv_pos_B, vector tv_axis_B, float tf_min_B, float tf_max_B, float tf_rayon_B)
//{
//	int				ti_result	
//
//	float			tf_norm	
//	float			tf_dist
//	float			tf_sum
//	float			tf_dot_product
//	float			tf_dist_A
//	float			tf_dist_B
//	
//	vector		tv_AB
//	vector		tv_temp
//	vector		tv_cross_product
//	vector		tv_largeur_A	
//	vector		tv_largeur_B	
//	vector		tav_rect_A[4]
//	vector		tav_rect_B[4]
//	vector		tv_X_axis
//	vector		tv_Y_axis
//
//	vector		tv_projection_A_sur_B
//	vector		tv_projection_B_sur_A
//
//	tv_AB = tv_pos_B
//	tv_AB -= tv_pos_A 
//
//	tf_sum = tf_rayon_A + tf_rayon_B
//
//	tv_cross_product = MATH_VecCrossProduct(tv_axis_A, tv_axis_B)
//	tf_norm = MATH_VecDotProduct(tv_cross_product, tv_cross_product)
//
//	ti_result = vrai
//	
//	if (tf_norm)
//	{
//		// AXES NON PARALLELES	
//	
//		tf_norm = MATH_FloatSqrt(tf_norm)
//		tv_cross_product /= tf_norm
//		
//		tf_dist = MATH_VecDotProduct(tv_AB, tv_cross_product)
//		
//		DBG_RenderVector(tv_pos_A, tv_cross_product * tf_dist, color_rouge)	
//
//		if (MATH_AbsFloat(tf_dist) > tf_sum)
//		{
//			ti_result = faux
//
//			DBG_RenderCylinder(tv_pos_A + (tv_axis_A * tf_min_A), tv_axis_A * (tf_max_A - tf_min_A), tf_rayon_A, 0x8000FF00)
//			DBG_RenderCylinder(tv_pos_B + (tv_axis_B * tf_min_B), tv_axis_B * (tf_max_B - tf_min_B), tf_rayon_B, 0x8000FF00)
//		}
//		else
//		{
//			// TEST AFFICHAGE DES DEUX RECTANGLES
//			tf_dist_A = MATH_FloatSign(tf_dist) * MATH_FloatMax(MATH_AbsFloat(tf_dist) - tf_rayon_B, 0.0)
//		
//			tav_rect_A[0] = tv_pos_A	
//			tav_rect_A[0] += tf_dist_A * tv_cross_product
//			
//			tf_dist_A = MATH_FloatSqrt((tf_rayon_A * tf_rayon_A) - (tf_dist_A * tf_dist_A))
//			
//			tv_largeur_A = MATH_VecCrossProduct(tv_axis_A, tv_cross_product)
//			tv_largeur_A *= tf_dist_A
//			
//			tav_rect_A[0] += tv_axis_A * tf_min_A
//
//			tav_rect_A[3] = tav_rect_A[0]
//
//			tav_rect_A[0] += tv_largeur_A
//			tav_rect_A[3] -= tv_largeur_A
//
//			tav_rect_A[1] = tav_rect_A[0]
//			tav_rect_A[1] += tv_axis_A * (tf_max_A - tf_min_A)
//		
//			tav_rect_A[2] = tav_rect_A[3]
//			tav_rect_A[2] += tv_axis_A * (tf_max_A - tf_min_A)
//
//			DBG_RenderVector(tav_rect_A[0], tav_rect_A[1] - tav_rect_A[0], color_blanc)
//			DBG_RenderVector(tav_rect_A[1], tav_rect_A[2] - tav_rect_A[1], color_blanc)
//			DBG_RenderVector(tav_rect_A[2], tav_rect_A[3] - tav_rect_A[2], color_blanc)
//			DBG_RenderVector(tav_rect_A[3], tav_rect_A[0] - tav_rect_A[3], color_blanc)
//
//			tf_dist_B = MATH_FloatSign(tf_dist) * MATH_FloatMax(MATH_AbsFloat(tf_dist) - tf_rayon_A, 0.0)
////			tf_dist_B = tf_rayon_B
//		
//			tav_rect_B[0] = tv_pos_B
//			tav_rect_B[0] -= tf_dist_B * tv_cross_product
//			
//			tf_dist_B = MATH_FloatSqrt((tf_rayon_B * tf_rayon_B) - (tf_dist_B * tf_dist_B))
//			
//			tv_largeur_B = MATH_VecCrossProduct(tv_cross_product, tv_axis_B)
//			tv_largeur_B *= tf_dist_B
//			
//			tav_rect_B[0] += tv_axis_B * tf_min_B
//
//			tav_rect_B[3] = tav_rect_B[0]
//
//			tav_rect_B[0] -= tv_largeur_B
//			tav_rect_B[3] += tv_largeur_B
//
//			tav_rect_B[1] = tav_rect_B[0]
//			tav_rect_B[1] += tv_axis_B * (tf_max_B - tf_min_B)
//		
//			tav_rect_B[2] = tav_rect_B[3]
//			tav_rect_B[2] += tv_axis_B * (tf_max_B - tf_min_B)
//
//			DBG_RenderVector(tav_rect_B[0], tav_rect_B[1] - tav_rect_B[0], color_blanc)
//			DBG_RenderVector(tav_rect_B[1], tav_rect_B[2] - tav_rect_B[1], color_blanc)
//			DBG_RenderVector(tav_rect_B[2], tav_rect_B[3] - tav_rect_B[2], color_blanc)
//			DBG_RenderVector(tav_rect_B[3], tav_rect_B[0] - tav_rect_B[3], color_blanc)
//
//			tv_X_axis = MATH_VecCrossProduct(tv_cross_product, tv_axis_A)
//			tv_Y_axis = MATH_VecCrossProduct(tv_cross_product, tv_X_axis)
//
//			MATH_LIB_COL_3D_To_2D(&tav_rect_A[0], 4, tv_pos_A, tv_X_axis, tv_Y_axis)
//			MATH_LIB_COL_3D_To_2D(&tav_rect_B[0], 4, tv_pos_A, tv_X_axis, tv_Y_axis)
//			
//			if (MATH_LIB_2D_COL_Intersection(&tav_rect_A[0], 4, &tav_rect_B[0], 4))
//			{
//				DBG_RenderCylinder(tv_pos_A + (tv_axis_A * tf_min_A), tv_axis_A * (tf_max_A - tf_min_A), tf_rayon_A, 0x800000FF)
//				DBG_RenderCylinder(tv_pos_B + (tv_axis_B * tf_min_B), tv_axis_B * (tf_max_B - tf_min_B), tf_rayon_B, 0x800000FF)
//			}
//			else
//			{
//				DBG_RenderCylinder(tv_pos_A + (tv_axis_A * tf_min_A), tv_axis_A * (tf_max_A - tf_min_A), tf_rayon_A, 0x8000FF00)
//				DBG_RenderCylinder(tv_pos_B + (tv_axis_B * tf_min_B), tv_axis_B * (tf_max_B - tf_min_B), tf_rayon_B, 0x8000FF00)
//			}
//		}
//	}
//	else
//	{
//		// AXES PARALLELES	
//	
//		tv_temp = tv_AB
//		tv_temp -= MATH_VecDotProduct(tv_temp, tv_axis_A) * tv_axis_A
//
//		tf_dist = MATH_VecDotProduct(tv_temp, tv_temp)
//	
//		if (tf_dist > tf_sum * tf_sum)
//		{
//			ti_result = faux
//			
//			DBG_RenderCylinder(tv_pos_A + (tv_axis_A * tf_min_A), tv_axis_A * (tf_max_A - tf_min_A), tf_rayon_A, 0x8000FF00)
//			DBG_RenderCylinder(tv_pos_B + (tv_axis_B * tf_min_B), tv_axis_B * (tf_max_B - tf_min_B), tf_rayon_B, 0x8000FF00)
//		}
//	}
//	
//	return(ti_result)
//}

procedure int MATH_LIB_Intersection_Sphere_Sphere(vector tv_pos_A, float tf_rayon_A, vector tv_pos_B, float tf_rayon_B, int ti_flag_display_info)
{	
	float		tf_dist_sum_sqr

	vector	tv_temp
	
	tv_temp	= tv_pos_B
	tv_temp -= tv_pos_A
	
	tf_dist_sum_sqr = tf_rayon_A
	tf_dist_sum_sqr += tf_rayon_B
	tf_dist_sum_sqr *= tf_dist_sum_sqr

	if (MATH_VecDotProduct(tv_temp, tv_temp) > tf_dist_sum_sqr)
	{
#ifndef _FINAL_
		if (ti_flag_display_info)
		{
			DBG_RenderSphere(tv_pos_A, tf_rayon_A, 0x8000FF00)
			DBG_RenderSphere(tv_pos_B, tf_rayon_B, 0x8000FF00)
		}
#endif
		return(faux)
	}
	else
	{
#ifndef _FINAL_
		if (ti_flag_display_info)
		{
			DBG_RenderSphere(tv_pos_A, tf_rayon_A, 0x800000FF)
			DBG_RenderSphere(tv_pos_B, tf_rayon_B, 0x800000FF)
		}
#endif
		return(vrai)
	}
}

procedure vector MATH_LIB_Nearest_Cylindre_Pos(vector tv_cylinder_center, vector tv_cylinder_axis, float tf_cylinder_rayon, float tf_cylinder_length, vector tv_start_pos)
{
	float	tf_dist
	float	tf_dot_product	

	vector tv_nearest_pos

	tv_nearest_pos = tv_start_pos
	tv_nearest_pos -= tv_cylinder_center
	
	tf_dot_product = MATH_VecDotProduct(tv_nearest_pos, tv_cylinder_axis)
	tv_nearest_pos -= tf_dot_product * tv_cylinder_axis
	tf_dot_product = MATH_FloatLimit(tf_dot_product, -tf_cylinder_length, tf_cylinder_length)

	tf_dist = MATH_VecDotProduct(tv_nearest_pos, tv_nearest_pos)
	if (tf_dist > tf_cylinder_rayon * tf_cylinder_rayon)
	{
		tf_dist = MATH_FloatSqrt(tf_dist)
		tv_nearest_pos /= tf_dist
		tv_nearest_pos *= tf_cylinder_rayon
	}

	tv_nearest_pos += tf_dot_product * tv_cylinder_axis
	tv_nearest_pos += tv_cylinder_center

	return(tv_nearest_pos)
}

procedure int MATH_LIB_Intersection_Cylindre_Sphere(vector tv_cylinder_center, vector tv_cylinder_axis, float tf_cylinder_rayon, float tf_cylinder_length, vector tv_sphere_center, float tf_sphere_size, int ti_flag_display_info)
{
	vector	tv_nearest_pos

	tv_nearest_pos = MATH_LIB_Nearest_Cylindre_Pos(tv_cylinder_center, tv_cylinder_axis, tf_cylinder_rayon, tf_cylinder_length, tv_sphere_center)
	tv_nearest_pos -= tv_sphere_center
	
	if (MATH_VecDotProduct(tv_nearest_pos, tv_nearest_pos) <= tf_sphere_size * tf_sphere_size)
	{
#ifndef _FINAL_
		if (ti_flag_display_info)
		{
			tv_cylinder_center -= tf_cylinder_length * tv_cylinder_axis
			tf_cylinder_length *= 2.0
			DBG_RenderCylinder(tv_cylinder_center, tv_cylinder_axis * tf_cylinder_length, tf_cylinder_rayon, 0x800000FF)
			DBG_RenderSphere(tv_sphere_center, tf_sphere_size, 0x800000FF)
			DBG_RenderVector(tv_sphere_center, tv_nearest_pos, color_rouge)
		}
#endif
		return(vrai)
	}
	else
	{
#ifndef _FINAL_
		if (ti_flag_display_info)
		{
			tv_cylinder_center -= tf_cylinder_length * tv_cylinder_axis
			tf_cylinder_length *= 2.0
			DBG_RenderCylinder(tv_cylinder_center, tv_cylinder_axis * tf_cylinder_length, tf_cylinder_rayon, 0x8000FF00)
			DBG_RenderSphere(tv_sphere_center, tf_sphere_size, 0x8000FF00)
			DBG_RenderVector(tv_sphere_center, tv_nearest_pos, color_vert)
		}
#endif
		return(faux)
	}
}

procedure vector MATH_LIB_AllPosInCone(byrefarr vector tav_pos, int ti_pos_nb, vector tv_cone_origin, vector tv_cone_dir, float tf_cos_half_angle, int ti_flag_display_info)
{
	int			ti_i

	float		tf_sqr_dist
	float		tf_o
	float		tf_a
	float		tf_delta
	float		tf_A
	float		tf_B
	float		tf_C
	float		tf_X
	float		tf_biggest_X

	vector	tv_cone_to_pos

	tf_biggest_X = 0.0

	tf_A = 1.0
	tf_A -= 1.0 / (tf_cos_half_angle * tf_cos_half_angle)

	for (ti_i= 0; ti_i < ti_pos_nb; ti_i++)
	{
		tv_cone_to_pos = tav_pos[ti_i]
		tv_cone_to_pos -= tv_cone_origin

		tf_a = MATH_VecDotProduct(tv_cone_to_pos, tv_cone_dir)
		tv_cone_to_pos -= tf_a * tv_cone_dir
		tf_o = MATH_VecDotProduct(tv_cone_to_pos, tv_cone_to_pos)
		
		tf_B = 2.0 * tf_a * tf_A

		tf_C = tf_a * tf_a * tf_A
		tf_C += tf_o

		tf_delta = (tf_B * tf_B) - (4.0 * tf_A * tf_C)
		
		if (tf_delta >= 0.0)
		{
			tf_delta = MATH_FloatSqrt(tf_delta)
			
			tf_X = MATH_FloatMax( (-tf_B - tf_delta) / (2.0 * tf_A), (-tf_B + tf_delta) / (2.0 * tf_A))
			tf_X = MATH_FloatMax(tf_X, 0.0)
			
			if (tf_X > tf_biggest_X)
				tf_biggest_X = tf_X
		}
	}

	tv_cone_origin -= tf_biggest_X * tv_cone_dir

#ifndef _FINAL_
	if (ti_flag_display_info)
		DBG_RenderCone(tv_cone_origin, tv_cone_dir * 100.0, MATH_ACos(tf_cos_half_angle), 0x80008000)
#endif

	return(tv_cone_origin)
}

procedure vector MATH_LIB_AllSphereInCone(byrefarr vector tav_pos, byrefarr float taf_size, int ti_pos_nb, vector tv_cone_origin, vector tv_cone_dir, float tf_cos_half_angle, int	ti_flag_display_info)
{
	int			ti_i

	float		tf_sqr_cos
	float		tf_sqr_dist
	float		tf_o
	float		tf_a
	float		tf_precal
	float		tf_delta
	float		tf_A
	float		tf_B
	float		tf_C
	float		tf_X
	float		tf_biggest_X
	float		tf_sin

	vector	tv_cone_to_pos
	vector	tv_horizon
	vector	tv_cone_limit

	tf_biggest_X = 0.0

	tf_sqr_cos = tf_cos_half_angle
	tf_sqr_cos *= tf_sqr_cos

	tf_sin = MATH_FloatSqrt(1.0 - tf_sqr_cos)

	for (ti_i= 0; ti_i < ti_pos_nb; ti_i++)
	{
		tv_cone_to_pos = tav_pos[ti_i]
		tv_cone_to_pos -= tv_cone_origin

		// ON VA CONSTRUIRE LE VECTEUR QUI CORRESPOND A LA LIMITE DU CONE
		tv_horizon = MATH_VecCrossProduct(tv_cone_to_pos, tv_cone_dir)
		tv_horizon = MATH_VecCrossProduct(tv_cone_dir, tv_horizon)
		MATH_VecSetNormalize(tv_horizon)

		tv_cone_limit = tf_cos_half_angle * tv_horizon
		tv_cone_limit -= tv_cone_dir * tf_sin

#ifndef _FINAL_
		if (ti_flag_display_info)
			DBG_RenderSphere(tav_pos[ti_i], taf_size[ti_i], 0x80008000)
#endif

		tv_cone_to_pos = tav_pos[ti_i]
		tv_cone_to_pos += tv_cone_limit * taf_size[ti_i]
		tv_cone_to_pos -= tv_cone_origin

		tf_a = MATH_VecDotProduct(tv_cone_to_pos, tv_cone_dir)
		tv_cone_to_pos -= tf_a * tv_cone_dir
		tf_o = MATH_VecDotProduct(tv_cone_to_pos, tv_cone_to_pos)
		
		tf_precal = 1.0
		tf_precal -= 1.0 / tf_sqr_cos
		
		tf_A = tf_precal

		tf_B = 2.0 * tf_a * tf_precal

		tf_C = tf_a * tf_a * tf_precal
		tf_C += tf_o

		tf_delta = (tf_B * tf_B) - (4.0 * tf_A * tf_C)
		
		if (tf_delta >= 0.0)
		{
			tf_delta = MATH_FloatSqrt(tf_delta)
			
			tf_X = MATH_FloatMax( (-tf_B - tf_delta) / (2.0 * tf_A), (-tf_B + tf_delta) / (2.0 * tf_A))
			tf_X = MATH_FloatMax(tf_X, 0.0)
			
			if (tf_X > tf_biggest_X)
				tf_biggest_X = tf_X
		}
	}

	tv_cone_origin -= tf_biggest_X * tv_cone_dir

#ifndef _FINAL_
	if (ti_flag_display_info)
		DBG_RenderCone(tv_cone_origin, tv_cone_dir * 100.0, MATH_ACos(tf_cos_half_angle), 0x80008000)
#endif

	return(tv_cone_origin)
}

procedure int MATH_LIB_OBB_OBB_Intersection(object to_gaoA, vector tv_A_min, vector tv_A_max, object to_gaoB, vector tv_B_min, vector tv_B_max, int ti_display_info)
{
	int			ti_i
	int			ti_k
	
	float		tf_a[3]
	float		tf_b[3]
	float		tf_T[3]
	
	float 		tf_ra
	float 		tf_rb
	float 		tf_t
	
	vector	tv_A
	vector	tv_A_extend
	
	vector	tv_B
	vector	tv_B_extend
	
	vector	tv_AB
	vector	tv_inA_AB
	
	vector	tv_A_axis[3]
	vector	tv_B_axis[3]
	
	// A =======================================
	tv_A_axis[0] = @to_gaoA OBJ_HorizonGet()
	tv_A_axis[1] = -@to_gaoA OBJ_SightGet()
	tv_A_axis[2] = @to_gaoA OBJ_BankingGet()
	
	tv_A_extend = (tv_A_max - tv_A_min) * 0.5
	
	tv_A = @to_gaoA OBJ_PosGet()
	tv_A += @to_gaoA MATH_VecLocalToGlobal(tv_A_min)
	tv_A += @to_gaoA MATH_VecLocalToGlobal(tv_A_extend)
	
	tf_a[0] = tv_A_extend.x
	tf_a[1] = tv_A_extend.y
	tf_a[2] = tv_A_extend.z
	
	// B =======================================
	tv_B_axis[0] = @to_gaoB OBJ_HorizonGet()
	tv_B_axis[1] = -@to_gaoB OBJ_SightGet()
	tv_B_axis[2] = @to_gaoB OBJ_BankingGet()
	
	tv_B_extend = (tv_B_max - tv_B_min) * 0.5
	
	tv_B = @to_gaoB OBJ_PosGet()
	tv_B += @to_gaoB MATH_VecLocalToGlobal(tv_B_min)
	tv_B += @to_gaoB MATH_VecLocalToGlobal(tv_B_extend)
	
	tf_b[0] = tv_B_extend.x
	tf_b[1] = tv_B_extend.y
	tf_b[2] = tv_B_extend.z
	
	// AB et T ==================================
	tv_AB = tv_B - tv_A
	tf_T[0] = MATH_VecDotProduct(tv_AB, tv_A_axis[0])
	tf_T[1] = MATH_VecDotProduct(tv_AB, tv_A_axis[1])
	tf_T[2] = MATH_VecDotProduct(tv_AB, tv_A_axis[2])
	
	for (ti_i = 0; ti_i < 3; ti_i++)
		for (ti_k = 0; ti_k < 3; ti_k++)
			@get_global af_matrix_R[ti_i][ti_k] = MATH_VecDotProduct(tv_A_axis[ti_i], tv_B_axis[ti_k])
	
	for (ti_i = 0; ti_i < 3; ti_i++)
	{
		tf_ra = tf_a[ti_i]
	
		tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[ti_i][0])
		tf_rb += tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[ti_i][1])
		tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[ti_i][2])
	
		tf_t = MATH_AbsFloat(tf_T[ti_i])
	
		if (tf_t > tf_ra + tf_rb) 
		{
#ifndef _FINAL_
			if (ti_display_info)
			{
				DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
				DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
			}
#endif
			return(faux)
		}
	}
	
	for (ti_k = 0; ti_k < 3; ti_k++)
	{
		tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[0][ti_k])
		tf_ra += tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[1][ti_k])
		tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[2][ti_k])
	
		tf_rb = tf_b[ti_k]
	
		tf_t = tf_T[0] * @get_global af_matrix_R[0][ti_k]
		tf_t += tf_T[1] * @get_global af_matrix_R[1][ti_k]
		tf_t += tf_T[2] * @get_global af_matrix_R[2][ti_k]
		tf_t = MATH_AbsFloat(tf_t)
	
		if (tf_t > tf_ra + tf_rb)
		{
#ifndef _FINAL_
			if (ti_display_info)
			{
				DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
				DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
			}
#endif
			return(faux)
		}
	}
	
	//9 cross products
	
	//L = A0 x B0
	tf_ra = tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[2][0])
	tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[1][0])
	
	tf_rb = tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[0][2])
	tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[0][1])
	
	tf_t = tf_T[2] * @get_global af_matrix_R[1][0]
	tf_t -= tf_T[1] * @get_global af_matrix_R[2][0]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A0 x B1
	tf_ra = tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[2][1])
	tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[1][1])
	
	tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[0][2])
	tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[0][0])
	
	tf_t = tf_T[2] * @get_global af_matrix_R[1][1]
	tf_t -= tf_T[1] * @get_global af_matrix_R[2][1]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A0 x B2
	tf_ra = tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[2][2])
	tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[1][2])
	
	tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[0][1])
	tf_rb += tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[0][0])
	
	tf_t = tf_T[2] * @get_global af_matrix_R[1][2]
	tf_t -= tf_T[1] * @get_global af_matrix_R[2][2]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A1 x B0
	tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[2][0])
	tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[0][0])
	
	tf_rb = tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[1][2])
	tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[1][1])
	
	tf_t = tf_T[0] * @get_global af_matrix_R[2][0]
	tf_t -= tf_T[2] * @get_global af_matrix_R[0][0]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A1 x B1
	tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[2][1])
	tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[0][1])
	
	tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[1][2])
	tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[1][0])
	
	tf_t = tf_T[0] * @get_global af_matrix_R[2][1]
	tf_t -= tf_T[2] * @get_global af_matrix_R[0][1]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A1 x B2
	tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[2][2])
	tf_ra += tf_a[2] * MATH_AbsFloat(@get_global af_matrix_R[0][2])
	
	tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[1][1])
	tf_rb += tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[1][0])
	
	tf_t = tf_T[0] * @get_global af_matrix_R[2][2]
	tf_t -= tf_T[2] * @get_global af_matrix_R[0][2]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A2 x B0
	tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[1][0])
	tf_ra += tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[0][0])
	
	tf_rb = tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[2][2])
	tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[2][1])
	
	tf_t = tf_T[1] * @get_global af_matrix_R[0][0]
	tf_t -= tf_T[0] * @get_global af_matrix_R[1][0]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A2 x B1
	tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[1][1])
	tf_ra += tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[0][1])
	
	tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[2][2])
	tf_rb += tf_b[2] * MATH_AbsFloat(@get_global af_matrix_R[2][0])
	
	tf_t = tf_T[1] * @get_global af_matrix_R[0][1]
	tf_t -= tf_T[0] * @get_global af_matrix_R[1][1]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
	//L = A2 x B2
	tf_ra = tf_a[0] * MATH_AbsFloat(@get_global af_matrix_R[1][2])
	tf_ra += tf_a[1] * MATH_AbsFloat(@get_global af_matrix_R[0][2])
	
	tf_rb = tf_b[0] * MATH_AbsFloat(@get_global af_matrix_R[2][1])
	tf_rb += tf_b[1] * MATH_AbsFloat(@get_global af_matrix_R[2][0])
	
	tf_t = tf_T[1] * @get_global af_matrix_R[0][2]
	tf_t -= tf_T[0] * @get_global af_matrix_R[1][2]
	tf_t = MATH_AbsFloat(tf_t)
	
	if (tf_t > tf_ra + tf_rb)
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_vert)
			DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_vert)
		}
#endif
		return(faux)
	}
	
#ifndef _FINAL_
	if (ti_display_info)
	{
		DBG_RenderBox(to_gaoA, tv_A_min, tv_A_max, color_rouge)
		DBG_RenderBox(to_gaoB, tv_B_min, tv_B_max, color_rouge)
	}
#endif
	return(vrai)
}

procedure float MATH_LIB_Get_Intersection_Time(vector tv_pos_A, vector tv_speed_A, float tf_size_A, vector tv_pos_B, vector tv_speed_B, float tf_size_B)
{
	float		tf_X1
	float		tf_X2
	float		tf_A
	float		tf_B
	float		tf_C
	float		tf_DELTA	

	vector	tv_AB
	vector	tv_diff_speed	

	tv_diff_speed = tv_speed_B - tv_speed_A
	tv_AB = tv_pos_B - tv_pos_A

	tf_C = tf_size_A + tf_size_B
	tf_C *= tf_C
	tf_C = MATH_VecDotProduct(tv_AB, tv_AB) - tf_C
	
	if (tf_C < 0.0)
		return(0.0)

	tf_A = MATH_VecDotProduct(tv_diff_speed, tv_diff_speed)

	if (tf_A == 0.0)
		return(Cf_Infinit)

	tf_B = 2.0 * MATH_VecDotProduct(tv_AB, tv_diff_speed)

	tf_DELTA = tf_B * tf_B
	tf_DELTA -= 4.0 * tf_A * tf_C

	if (tf_DELTA < 0.0)
	{
		return(Cf_Infinit)
	}
	else if (MATH_FloatNullToler(tf_DELTA, 0.001))
	{
		tf_X1 = -tf_B / (2.0 * tf_A)
	
//		DBG_RenderVector(tv_pos_A, tv_speed_A * tf_X1, color_rouge)	
//		DBG_RenderVector(tv_pos_B, tv_speed_B * tf_X1, color_rouge)
//		DBG_RenderSphere(tv_pos_A + (tv_speed_A * tf_X1), tf_size_A, 0x800000FF)	
//		DBG_RenderSphere(tv_pos_B + (tv_speed_B * tf_X1), tf_size_B, 0x800000FF)
		return(tf_X1)
	}
	else
	{
		tf_DELTA = MATH_FloatSqrt(tf_DELTA)

		tf_X1 = -tf_B - tf_DELTA
		tf_X1 /= 2.0 * tf_A
		
		tf_X2 = -tf_B + tf_DELTA
		tf_X2 /= 2.0 * tf_A
		
		if (tf_X1 < 0.0 && tf_X1 < 0.0)
			return(Cf_Infinit)
		
		if (tf_X1 < 0.0)
			tf_X1 = tf_X2
		else
			tf_X1 = MATH_FloatMin(tf_X1, tf_X2)
			
//		DBG_RenderVector(tv_pos_A, tv_speed_A * tf_X1, color_rouge)	
//		DBG_RenderVector(tv_pos_B, tv_speed_B * tf_X1, color_rouge)
//		DBG_RenderSphere(tv_pos_A + (tv_speed_A * tf_X1), tf_size_A, 0x800000FF)	
//		DBG_RenderSphere(tv_pos_B + (tv_speed_B * tf_X1), tf_size_B, 0x800000FF)
		return(tf_X1)
	}

	return(Cf_Infinit)
}

procedure void MATH_LIB_PHY_Display_Trajectory(vector tv_start_pos, vector tv_start_speed, vector tv_gravity, float tf_time, int ti_segment_nb)
{
#ifndef _FINAL_
	int		ti_i
	
	float	tf_time_step

	vector	tv_pos

	if (AI_GetCurSystem() != 10)
		return

	tf_time_step = tf_time / ti_segment_nb
	tv_gravity *= tf_time_step

	for (ti_i = 0; ti_i < ti_segment_nb; ti_i++)
	{
		tv_start_speed	 += tv_gravity
		tv_pos = tv_start_pos
		tv_pos += tv_start_speed * tf_time_step
		DBG_RenderVector(tv_start_pos, tv_pos - tv_start_pos, color_jaune)
		tv_start_pos = tv_pos
	}
#endif
}

procedure vector MATH_LIB_PHY_Impulsion_Get(vector tv_start_pos, vector tv_dest_pos, vector tv_gravity, float tf_wanted_speed, byref float tf_X, int ti_flag_short_way)
{
	float		tf_A
	float		tf_B
	float		tf_C
	float		tf_DELTA
	float		tf_sqr_wanted_speed	

	vector	tv_wanted_move
	vector	tv_impulsion

	tv_wanted_move = tv_dest_pos
	tv_wanted_move -= tv_start_pos
	
	tf_sqr_wanted_speed = tf_wanted_speed
	tf_sqr_wanted_speed *= tf_sqr_wanted_speed

	tf_A = MATH_VecDotProduct(tv_gravity, tv_gravity) / 4.0
	tf_B = - MATH_VecDotProduct(tv_wanted_move, tv_gravity) - tf_sqr_wanted_speed
	tf_C = MATH_VecDotProduct(tv_wanted_move, tv_wanted_move)

	tf_DELTA = (tf_B * tf_B) - (4.0 * tf_A * tf_C)

	if (tf_DELTA > 0.0)
	{
		// On a une solution...	
		tf_DELTA = MATH_FloatSqrt(tf_DELTA)
		if (ti_flag_short_way)
			tf_X = MATH_FloatMin((-tf_B - tf_DELTA) / (2.0 * tf_A), (-tf_B + tf_DELTA) / (2.0 * tf_A))
		else
			tf_X = MATH_FloatMax((-tf_B - tf_DELTA) / (2.0 * tf_A), (-tf_B + tf_DELTA) / (2.0 * tf_A))
		tf_X = MATH_FloatSqrt(tf_X)
		
		tv_impulsion = tv_wanted_move / tf_X
		tv_impulsion -= 0.5 * tv_gravity * tf_X
	}
	else
	{
		// Impulsion qui me rapproche le plus de ma cible
		tf_X = Cf_Infinit
		
		tv_impulsion = MATH_VecBlendRotate(tv_wanted_move, -tv_gravity, 0.5)
		MATH_VecSetNorm(tv_impulsion, tf_wanted_speed)
	}
	
	return(tv_impulsion)
}


