//procedure void GRID_LIB_Ultra_Tag_Get(int ti_ID, byrefarr object tao_ultra_tag, byref int ti_ultra_tag_nb)
//{
//	int		ti_i
//	int		ti_k
//	int		ti_perso_ID
//	
//	object	to_ultra_tag
//
//	for (ti_i = 0; ti_i < @get_list_manager i_ultra_tag_nb; ti_i++)
//	{
//		to_ultra_tag = @get_list_manager ao_ultra_tag[ti_i]
//	
//		if (@"Interactive_Objects/Ultra_Tag" to_ultra_tag mode)
//		{
//			for (ti_k = 0; ti_k < 10; ti_k++)
//			{
//				ti_perso_ID = @"Interactive_Objects/Ultra_Tag" to_ultra_tag perso_ID[ti_k] 
//				if (ti_perso_ID == ti_ID)
//				{
//					tao_ultra_tag[ti_ultra_tag_nb] = to_ultra_tag
//					ti_ultra_tag_nb++
//					
//					break
//				}
//			}
//		}
//	}
//}
//
//procedure void GRID_LIB_Ultra_Tag_On(int ti_ultra_tag_id, byrefarr object tao_ultra_tag, int ti_ultra_tag_nb)
//{
//	int			ti_i
//	object	to_ultra_tag
//
//	if (@get_global i_ultra_tag_last_id != ti_ultra_tag_id)
//	{
//		while(@get_global i_ultra_tag_nb)
//		{
//			@get_global i_ultra_tag_nb--
//			to_ultra_tag = @get_global ao_ultra_tag[@get_global i_ultra_tag_nb] 
//			@to_ultra_tag AI_CBExecute(CallBack_TagOff, 0)
//			@get_global ao_ultra_tag[@get_global i_ultra_tag_nb] = nobody
//		}
//
//		for (ti_i = 0; ti_i < ti_ultra_tag_nb; ti_i++)
//		{
//			@get_global ao_ultra_tag[ti_i] = tao_ultra_tag[ti_i]
//			@tao_ultra_tag[ti_i] AI_CBExecute(CallBack_TagOn, 0)
//		}		
//		@get_global i_ultra_tag_last_id = ti_ultra_tag_id
//		@get_global i_ultra_tag_nb = ti_ultra_tag_nb
//	}
//}

//procedure void GRID_LIB_Ultra_Tag_Off(byrefarr object tao_ultra_tag, int ti_ultra_tag_nb)
//{
//	int		ti_i	
//
//	for (ti_i = 0; ti_i < ti_ultra_tag_nb; ti_i++)
//		@tao_ultra_tag[ti_i] AI_CBExecute(CallBack_TagOff, 0)
//}

// Determine si une case est bloquée ou non
procedure int GRID_LIB_Blocked(vector tv_pos, int ti_test_mode)
{
	int ti_grid_capa

	GRID_CurrentSet(0)

//#ifndef _FINAL_
//	// ON N'EST PAS SUR LA GRILLE !!!
//	if (! GRID_IsIn(tv_pos))
//	{
//		DBG_RenderVector(tv_pos + cvector(0.0, 0.0, -100000.0), Cv_VerticalVector * 1000000.0, color_cyan)
//		DBG_BreakPoint()
//	}
//#endif 

	ti_grid_capa = GRID_CapaGet(tv_pos)

	// CASES ROUGES ================================================
	if (ti_test_mode & 0b1 && ti_grid_capa & tag_grid_occupe_msk)
		return(vrai)

	// TERRAINS STATIQUES ============================================
	if (ti_test_mode & 0b10 && GRID_GetPond(ti_grid_capa & tag_grid_terrain) != 1.0)
		return(vrai)
	if (GRID_GetPond(ti_grid_capa & tag_grid_terrain) == 0.0)
		return(vrai)
		
	// TERRAINS DYNAMIQUES  ============================================
	ti_grid_capa = tag_grid_terraindyn_mask(ti_grid_capa)
	if (ti_test_mode & 0b10 && GRID_GetPondDyn(ti_grid_capa) != 1.0)
		return(vrai)	
	if (GRID_GetPondDyn(ti_grid_capa) == 0.0)
		return(vrai)
				
	return(faux)
}

procedure int GRID_LIB_Test_Case(vector tv_pos, int ti_test_mode, int ti_display_info)
{
	vector	tv_render_pos	

	@get_global i_reachable_from_case_nb ++

	if (GRID_LIB_Blocked(tv_pos, ti_test_mode))
	{
#ifndef _FINAL_
		if (ti_display_info)
		{
			tv_render_pos = GRID_PosGet(tv_pos)
			tv_render_pos.z = tv_pos.z
			DBG_RenderVector(tv_render_pos, cvector(0.0, 0.0, 10.0), color_rouge)
		}
#endif
		@get_global v_grid_lib_last_blocked_pos = tv_pos
		return(faux)
	}
	else
	{
#ifndef _FINAL_
 		if (ti_display_info)
 		{
	 		tv_render_pos = GRID_PosGet(tv_pos)
			tv_render_pos.z = tv_pos.z
			DBG_RenderVector(tv_render_pos, cvector(0.0, 0.0, 5.0), color_vert)
		}
#endif
		return(vrai)
	}
}

procedure int GRID_LIB_IsReachableFrom(vector tv_start_pos, vector tv_dest_pos, int ti_test_mode, float tf_max_length, int ti_display_info, int ti_side_extrusion_nb)
{
	int			ti_i	
	int			ti_k
	int			ti_case_tested
	int			ti_case_nb
	int			ti_dx
	int			ti_dy
	int			ti_step_x
	int			ti_step_y
	int			ti_sum

	float		tf_x
	float		tf_y
	float		tf_z
	float		tf_dist	
	float		tf_step_length

	vector 	tv_start_to_dest
	vector	tv_ortho_dir
	vector	tv_tested_pos
	vector	tv_pos
	vector	tv_render_pos

	object	to_main_actor

//	ti_display_info = vrai

//	to_main_actor = AI_MainActorGet(0)

	@get_global i_reachable_from_call_nb ++

	GRID_CurrentSet(0)	

	tf_z = tv_start_pos.z
//	tf_z = @to_main_actor OBJ_PosGet().z + 0.25

	tv_start_pos = GRID_PosGet(tv_start_pos)
	tv_dest_pos = GRID_PosGet(tv_dest_pos)

	tv_start_pos.z = tf_z
	tv_dest_pos.z = tf_z

 	tv_start_to_dest = tv_dest_pos - tv_start_pos

	tf_dist = MATH_VecNorm(tv_start_to_dest)
	if (!tf_dist)
		return	(vrai)

	tv_start_to_dest /= tf_dist

	tv_ortho_dir = tv_start_to_dest
	tv_ortho_dir.z = tv_ortho_dir.x
	tv_ortho_dir.x = -tv_ortho_dir.y
	tv_ortho_dir.y = tv_ortho_dir.z
	tv_ortho_dir.z = 0.0
	
	if (MATH_AbsFloat(tv_ortho_dir.x) > MATH_AbsFloat(tv_ortho_dir.y))
	{
		tv_ortho_dir.x = MATH_FloatSign(tv_ortho_dir.x)
		tv_ortho_dir.y = 0.0
	}
	else
	{
		tv_ortho_dir.x= 0.0
		tv_ortho_dir.y = MATH_FloatSign(tv_ortho_dir.y)
	}

	if (tf_max_length > 0.0)
		tf_dist = MATH_FloatMin(tf_dist, tf_max_length)
	else if (tf_max_length < 0.0)
		tf_dist = MATH_FloatMax(tf_dist + tf_max_length, 0.0)

	tv_dest_pos = tv_start_pos
	tv_dest_pos += tv_start_to_dest * tf_dist
	tv_dest_pos = GRID_PosGet(tv_dest_pos)
	tv_dest_pos.z = tf_z

	tf_x = tv_start_pos.x
	tf_y = tv_start_pos.y

	ti_dx = tv_dest_pos.x - tf_x
	ti_dy = tv_dest_pos.y - tf_y

	ti_step_x = MATH_FloatSign(ti_dx)
	ti_step_y = MATH_FloatSign(ti_dy)

	ti_dx *= ti_step_x
	ti_dy *= ti_step_y

//	DBG_RenderVector(tv_start_pos, tv_dest_pos - tv_start_pos, color_rouge)

	if (ti_dx > ti_dy)
	{
		ti_sum = ti_dx >> 1
		for (ti_i = 1; ti_i < ti_dx; ti_i++)
		{
			if (ti_i == ti_dx - 1)
				ti_side_extrusion_nb	 = 0
		
			tf_x += ti_step_x
			ti_sum += ti_dy
			if (ti_sum >= ti_dx)
			{
				ti_sum -= ti_dx
				tf_y += ti_step_y
				if (ti_sum <= ti_dy >> 1)
				{
					for (ti_k = 0; ti_k < 1 + (ti_side_extrusion_nb * 2); ti_k++)
					{
						if ( ! GRID_LIB_Test_Case(cvector(tf_x, tf_y - ti_step_y, tv_start_pos.z) + ((ti_k - ti_side_extrusion_nb) * tv_ortho_dir), ti_test_mode, ti_display_info) )
							return(faux)
					}
				}
				else
				{
					for (ti_k = 0; ti_k < 1 + (ti_side_extrusion_nb * 2); ti_k++)
					{
						if ( ! GRID_LIB_Test_Case(cvector(tf_x - ti_step_x, tf_y, tv_start_pos.z) + ((ti_k - ti_side_extrusion_nb) * tv_ortho_dir), ti_test_mode, ti_display_info) )
							return(faux)
					}
				}
			}
			
			for (ti_k = 0; ti_k < 1 + (ti_side_extrusion_nb * 2); ti_k++)
			{
				if ( ! GRID_LIB_Test_Case(cvector(tf_x, tf_y, tv_start_pos.z) + ((ti_k - ti_side_extrusion_nb) * tv_ortho_dir), ti_test_mode, ti_display_info) )
					return(faux)
			}
		}
	}
	else
	{
		ti_sum = ti_dy >> 1
		for (ti_i = 1; ti_i <= ti_dy; ti_i++)
		{
			if (ti_i == ti_dx - 1)
				ti_side_extrusion_nb	 = 0

			tf_y += ti_step_y
			ti_sum += ti_dx
			if (ti_sum >= ti_dy)
			{
				ti_sum -= ti_dy
				tf_x += ti_step_x
				if (ti_sum >= ti_dx >> 1)
				{
					for (ti_k = 0; ti_k < 1 + (ti_side_extrusion_nb * 2); ti_k++)
					{
						if ( ! GRID_LIB_Test_Case(cvector(tf_x, tf_y - ti_step_y, tv_start_pos.z) + ((ti_k - ti_side_extrusion_nb) * tv_ortho_dir), ti_test_mode, ti_display_info) )
							return(faux)
					}
				}
				else
				{
					for (ti_k = 0; ti_k < 1 + (ti_side_extrusion_nb * 2); ti_k++)
					{
						if ( ! GRID_LIB_Test_Case(cvector(tf_x - ti_step_x, tf_y, tv_start_pos.z) + ((ti_k - ti_side_extrusion_nb) * tv_ortho_dir), ti_test_mode, ti_display_info) )
							return(faux)
					}
				}
			}
			
			for (ti_k = 0; ti_k < 1 + (ti_side_extrusion_nb * 2); ti_k++)
			{
				if ( ! GRID_LIB_Test_Case(cvector(tf_x, tf_y, tv_start_pos.z) + ((ti_k - ti_side_extrusion_nb) * tv_ortho_dir), ti_test_mode, ti_display_info) )
					return(faux)
			}
		}
	}

	return(vrai)
}

procedure int GRID_LIB_NoFireFromTo(vector tv_start_pos, vector tv_dest_pos, int ti_test_mode, float tf_max_length, int ti_display_info, int ti_side_extrusion_nb)
{
	int			ti_i	
	int			ti_case_tested
	int			ti_case_nb

	float		tf_dist	
	float		tf_step_length

	vector 	tv_start_to_dest
	vector	tv_ortho_dir
	vector	tv_tested_pos
	vector	tv_pos
	vector	tv_render_pos

	object	to_main_actor

	GRID_CurrentSet(1)	

	tf_dist = tv_start_pos.z

	tv_start_pos = GRID_PosGet(tv_start_pos)
	tv_dest_pos = GRID_PosGet(tv_dest_pos)

	tv_start_pos.z = tf_dist
	tv_dest_pos.z = tf_dist

 	tv_start_to_dest = tv_dest_pos - tv_start_pos

	tf_dist = MATH_VecNorm(tv_start_to_dest)
	if (!tf_dist)
	{
		GRID_CurrentSet(0)	
		return	(vrai)
	}

	tv_ortho_dir = tv_start_to_dest / tf_dist
	tv_ortho_dir.z = tv_ortho_dir.x
	tv_ortho_dir.x = tv_ortho_dir.y
	tv_ortho_dir.y = tv_ortho_dir.z
	tv_ortho_dir.z = 0.0

	tf_step_length = MATH_FloatMax(MATH_AbsFloat(tv_start_to_dest.x), MATH_AbsFloat(tv_start_to_dest.y))
	tv_start_to_dest /= tf_step_length
	tf_step_length = MATH_VecNorm(tv_start_to_dest)

	if (tf_max_length > 0.0)
		tf_dist = MATH_FloatMin(tf_dist, tf_max_length)
	else if (tf_max_length < 0.0)
		tf_dist = MATH_FloatMax(tf_dist + tf_max_length, 0.0)

	ti_case_nb = tf_dist / tf_step_length
	if (ti_case_nb <= 1)
	{
		GRID_CurrentSet(0)	
		return	(vrai)
	}
		
	tv_tested_pos = tv_start_pos
	for (ti_case_tested = 1; ti_case_tested <= ti_case_nb; ti_case_tested++)
	{
		tv_pos = tv_tested_pos
		tv_pos -= ti_side_extrusion_nb * tv_ortho_dir

		for (ti_i = 0; ti_i < 1 + (ti_side_extrusion_nb * 2); ti_i++)
		{
			if (GRID_CapaGet(tv_pos) & Ci_Grid2_EnFeu)
			{
#ifndef _FINAL_
				if (ti_display_info)
				{
					tv_render_pos = GRID_PosGet(tv_pos)
					tv_render_pos.z = tv_pos.z
					DBG_RenderVector(tv_render_pos, cvector(0.0, 0.0, 5.0), color_rouge)
				}
#endif
				@get_global v_grid_lib_last_blocked_pos = tv_pos
				GRID_CurrentSet(0)
				return(faux)
			}
#ifndef _FINAL_
			else if (ti_display_info)
			{
				tv_render_pos = GRID_PosGet(tv_pos)
				tv_render_pos.z = tv_pos.z
				DBG_RenderVector(tv_render_pos, cvector(0.0, 0.0, 5.0), color_vert)
			}
#endif
		
			tv_pos += tv_ortho_dir
		}

		tv_tested_pos += tv_start_to_dest
	}

	GRID_CurrentSet(0)
	return(vrai)
}


procedure int GRID_LIB_Pos_In_Ultra_Tag(object to_ultra_tag, vector tv_pos)
{	
	int			ti_flag_tag_enable

	float		tf_X_min
	float		tf_X_max
	float		tf_Y_min
	float		tf_Y_max

	ti_flag_tag_enable = @"Interactive_Objects/Ultra_Tag" to_ultra_tag i_flag_tag_enable
	if (! ti_flag_tag_enable )
		return(faux)

	tf_X_min = @"Interactive_Objects/Ultra_Tag" to_ultra_tag f_X_min
	tf_X_max = @"Interactive_Objects/Ultra_Tag" to_ultra_tag f_X_max
	tf_Y_min = @"Interactive_Objects/Ultra_Tag" to_ultra_tag f_Y_min
	tf_Y_max = @"Interactive_Objects/Ultra_Tag" to_ultra_tag f_Y_max
	
	tv_pos = GRID_PosGet(tv_pos)

	if (tv_pos.x >= tf_X_min && tv_pos.x <= tf_X_max && tv_pos.y >= tf_Y_min && tv_pos.y <= tf_Y_max)
		return(vrai)
		
	return(faux)
}

//=============================================================
//=============================================================
procedure int GRID_LIB_CaseEnFeu(vector pos)
{
	int	capa, oui
	
	oui = faux
	if(!GRID_Has(1)) return 0
	GRID_CurrentSet(1)
	capa = GRID_CapaGet(pos)
	if(capa & Ci_Grid2_EnFeu) oui = vrai
	GRID_CurrentSet(0)
	return oui
}