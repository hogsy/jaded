#include "TROW_defines.var"

Include_UltraProcedure_Header

int				ti_i
int				ti_zde_corps_nb
int				ti_index
int				ti_flag_main
int				ti_flag_boost

float			tf_hor_speed
float			tf_speed_coef
float			tf_wanted_traction
float			tf_next_wanted_traction

object		to_head
object		tao_zde_corps_gao[20]

vector		tv_pos
vector		tv_joy_dir
vector		tv_speed
vector		tv_traction


if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux
	return
}


if (i_etat_courant != ETAT_Basic)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Basic
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = AI_TrackCurGet()
	
	COL_ColSetActivationSet(C_bit_zdm_pied, none)

	COL_SwapToSpecific(C_zde_corps)
	COL_ZonePosSet(C_zde_corps, Cv_NullVector)
	COL_ZoneSizeSet(C_zde_corps, cvector(2.0, 2.0, 2.0))

	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_VectorFriction | DYN_C_NeverDynamicFather | DYN_C_NeverDynamicHierarchy | DYN_C_HorizontalGrounds | DYN_C_SlipOnGroundEdge | DYN_C_ApplyRec | DYN_C_Col, none)
	DYN_GravitySet(cvector(0.0, 0.0, -40.0))

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
ti_flag_main = faux
ti_flag_boost = faux

tf_wanted_traction = 0.0

ti_flag_main = vrai
		
tv_joy_dir = glob_joyvector_get

if (Proc_JOY_Boost_Pressed())
	tf_wanted_traction = f_speed_max
else if (MATH_VecDotProduct(OBJ_SightGet(), tv_joy_dir) > Cf_Cos60)
	tf_wanted_traction = f_analog_speed * glob_joynorm_get

if ( MATH_VecSquareNorm(tv_joy_dir) < 0.001)
	tv_joy_dir = OBJ_SightGet()

tf_speed_coef = MATH_FloatLimit(f_real_speed * 0.5, 0.1, 1.0)
tf_wanted_traction *= tf_speed_coef

//if (i_flag_Y_slide && f_wanted_speed > f_real_speed + f_Y_limit_speed)
//{
//	// ANTI PATINAGE
//	tf_next_wanted_traction = f_wanted_speed + (f_acceleration * TIME_GetDt())
//	tf_wanted_traction = f_real_speed + f_Y_limit_speed - 0.1
//}

// COMPORTEMENT =========================================================
TROW_Sight_And_Banking(tv_joy_dir)
TROW_Apply_Traction_And_Choose_Action(tf_wanted_traction)

if (1)
{
	@get_Kamera OBJ_FlagInactiveSet(vrai)
	
//	tv_speed = DYN_SpeedGetVector()
//	tv_speed.z = 0.0
//	tf_hor_speed = MATH_VecSquareNorm(tv_speed)
//	if (tf_hor_speed)
//	{
//		tf_hor_speed = MATH_FloatSqrt(tf_hor_speed)
//		tv_speed /= tf_hor_speed
//	}
//	else
	{
		tv_speed = OBJ_SightGet()
	}
	
	tv_speed = OBJ_PosGet() - @get_Kamera OBJ_PosGet()
	tv_speed.z = 0.0
	MATH_VecSetNormalize(tv_speed)
	
	if (MATH_VecSquareNorm(IO_JoyGetMove1()) > tolerance_joynull * tolerance_joynull)
		tv_speed = MATH_VecRotate(tv_speed, Cv_VerticalVector, IO_JoyGetMove1().x * 4.0 * TIME_GetDt())

	tv_pos = OBJ_PosGet()
//	tv_pos -= OBJ_SightGet() * 10.0
	tv_pos -= tv_speed * 5.0
	tv_pos += OBJ_BankingGet() * 1.5
	
	tv_pos = OBJ_PosGet() + MATH_VecBlendRotate(@get_Kamera OBJ_PosGet() - OBJ_PosGet(), tv_pos - OBJ_PosGet(), 8.0 * TIME_GetDt())

	@get_Kamera OBJ_PosSet(tv_pos)
	
	tv_pos = OBJ_PosGet()
//	tv_pos += OBJ_SightGet() * 10.0
	tv_pos += tv_speed * 5.0
	
	@get_Kamera OBJ_SightGeneralSet(tv_pos - @get_Kamera OBJ_PosGet(), Cv_VerticalVector)
	
	@get_Kamera VIEW_AssignObject(0)
}
else if (@get_Kamera OBJ_FlagsControlGet() & OBJ_C_ControlFlag_ForceInactive)
{
	@get_Kamera OBJ_FlagInactiveSet(faux)
}

