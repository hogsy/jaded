#include "RM_Projectiles_defines.var"

vector		tv_vec
vector		tv_speed
vector		tv_initial_speed
vector		tv_normal

float			tf_speed
float			tf_v_speed
float			tf_tgt_speed
float			tf_z_speed

// SORTIE ETAT 	===================================================================
if( i_sort_etat )
{
	i_sort_etat = faux
	return
}

// INIT ETAT 	=====================================================================
if( i_etat_courant != RMP_ETAT_LAUNCHED)
{
	i_etat_courant = RMP_ETAT_LAUNCHED
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
	
	DYN_On()
	DYN_FlagsSet(DYN_C_BasicForces | DYN_C_HorizontalGrounds | DYN_C_Col, none)
	DYN_GravitySet(Cv_NormalGravity)
	DYN_FrictionSet(0.0)
	i_SND_fire = -1
	
//	// Position de la target à t + dt
//	tv_vec = @o_target OBJ_PosGet() - OBJ_PosGet()
//	tv_vec.z = OBJ_PosGet().z
//	
//	tv_initial_speed = @o_launcher DYN_SpeedGetVector()
//	tv_speed = MATH_VecCrossProduct(@o_launcher OBJ_SightGet(), Cv_VerticalVector)
//	MATH_VecSetNormalize(tv_speed)
//	tf_speed = MATH_VecDotProduct(tv_speed, tv_vec)
//	tv_speed = (tv_speed * tf_speed)
//	if (!MATH_VecNull(tv_speed))
//		MATH_VecSetNorm(tv_speed, 2.0)
//	tv_speed.z = -0.01
//	f_vertical_speed = tv_speed.z
//
////	DBG_RenderVector( OBJ_PosGet(), tv_speed, color_vert)
//
//	tv_speed +=  tv_initial_speed * 0.95
	
	if (i_type == RMP_TYPE_LARGUE)
	{
		// Booster le projectile si Rayman se déplace lentement
		tf_tgt_speed = @o_target DYN_SpeedGet()
		if ((tf_tgt_speed < 5.0) && (!RM_Projectiles_Target_Paffed()))
		{
			tv_vec = @o_target OBJ_PosGet() - OBJ_PosGet()
			tf_speed = ((5.0 - tf_tgt_speed) / 5.0) * MATH_VecNorm(tv_vec) / f_time_max
			tf_speed = MATH_FloatMin(tf_speed, f_speed * 6.0)
			tv_speed = MATH_VecNormalize(tv_vec) * tf_speed
			i_boosted = vrai
		}
		else
		{
			tv_initial_speed = @o_launcher DYN_SpeedGetVector()
			tv_speed =  tv_initial_speed * 0.8
		}
		
		tv_speed.z = -0.01
		v_initial_speed = tv_speed
		f_vertical_speed = tv_speed.z
		DYN_SpeedSetVector(tv_speed)
	}
	else if ((i_type == RMP_TYPE_MINE) || (i_type == RMP_TYPE_AIRE))
	{
//		tv_vec = @o_target OBJ_PosGet() - OBJ_PosGet()
//		tf_speed = (MATH_VecNorm(tv_vec) / f_time_max)
////		tf_speed = MATH_FloatMin(tf_speed, f_speed * 6.0)
//		tv_speed = MATH_VecNormalize(tv_vec) * tf_speed
////		tv_speed.z = MATH_VecNorm(tv_speed)
		tv_vec = @o_target OBJ_PosGet() - OBJ_PosGet()
		tf_speed = MATH_VecNorm(tv_vec)
		DYN_Impulsion(@o_target OBJ_PosGet() - (tv_vec * 0.0), tf_speed / 50.0)
		tv_speed = DYN_SpeedGetVector()
		f_vertical_speed = tv_speed.z
	}
	
	tv_vec = MATH_VecCrossProduct(tv_speed, Cv_VerticalVector)
	OBJ_Rotate_FromTo(cvector(1.0, 0.0, 0.0), MATH_VecGlobalToLocal(tv_vec))
	
//	DBG_RenderVector( OBJ_PosGet(), tv_speed, color_bleu)
//	DBG_RenderVector( OBJ_PosGet(), tv_initial_speed, color_rouge)
} 
else
{
	f_time_start_etat += TIME_GetDt()
}

// STIMULI =======================================================================
 if (f_time_start_etat >= f_time_max)
{
	if ((i_type == RMP_TYPE_MINE) || (i_type == RMP_TYPE_AIRE))
	{
		 if (i_started == 2)
		 {
			i_started = 3
			DYN_GravitySet(Cv_NormalGravity)
			DYN_Impulsion(OBJ_PosGet(), 1.0)
		}
	}
	else
		AI_Execute("RMP_exec_boom")
}

if (COL_ZDE_ZDECollide(AI_MainActorGet(0), C_zde_corps, C_zde_corps))
	AI_Execute("RMP_exec_boom")

if ((i_SND_fire != -1) && (!SND_IsPlaying(i_SND_fire)))
	i_SND_fire = -1

// COMPORTEMENT ================================================================

// Rebond ?
tf_v_speed = DYN_SpeedGetVector().z
if (MATH_FloatSign(tf_v_speed) != MATH_FloatSign(f_vertical_speed))
{
	i_rebound_count++
	
	if ((i_type == RMP_TYPE_MINE) || (i_type == RMP_TYPE_AIRE))
	{
 		if (i_started == 1)
		{
			tf_speed = DYN_SpeedGet()
//			if ((MATH_AbsFloat(tf_v_speed) < 1.0) && (MATH_AbsFloat(f_vertical_speed) < 1.0))
//				tf_speed = 0
//			if ((tf_speed < 3.0) && ((i_rebound_count & 1) == 1))
			if ((i_rebound_count & 1) == 0)
			{
				if (i_SND_fire == -1)
					i_SND_fire = SND_RequestPlay(RMP_SND_REBOUND)
					
				if (tf_speed < 1.0)
				{
					DYN_SpeedSetVector(Cv_NullVector)
					DYN_GravitySet(Cv_NullVector)
					i_started = 2
				}
				else
				{
					tv_speed = DYN_SpeedGetVector()
					tv_speed.z = -f_vertical_speed * 0.6
					tv_speed *= 0.5
					DYN_SpeedSetVector(tv_speed)
				}
			}
		}
		else if ((i_started == 3) && ((i_rebound_count & 1) == 0))
			AI_Execute("RMP_exec_boom")
	}
	else if (i_type == RMP_TYPE_LARGUE)
	{
		if ((i_rebound_count & 1) == 1)
		{
			if (i_SND_fire == -1)
				i_SND_fire = SND_RequestPlay(RMP_SND_REBOUND)
				
			tv_speed = DYN_SpeedGetVector()
			if (!MATH_VecNullEpsilon(tv_speed))
			{
				DBG_RenderVector(OBJ_PosGet(), tv_speed, color_vert)
								
				tf_speed = MATH_VecNorm(tv_speed)
				f_vertical_speed = MATH_FloatLimit(f_vertical_speed, -5.0, -1.0)
				if (!i_boosted)
				{
					tf_speed *= 0.9
					tv_speed.z = -f_vertical_speed
				}
				
				if (MATH_AbsFloat(tf_speed) > 1.0)
				{
					MATH_VecSetNorm(tv_speed, tf_speed)
					if (i_boosted)
						tv_speed.z = -f_vertical_speed
				}
				else
  					tv_speed = Cv_NullVector
				tf_speed = MATH_VecNorm(tv_speed)
				DYN_SpeedSetVector(tv_speed)
			}
		}
	}
//	else if (i_type == RMP_TYPE_AIRE)
//	{
//		AI_Execute("RMP_exec_boom")
//	}
}

//if ((i_type == RMP_TYPE_MINE) && (!f_vertical_speed) && (!tf_v_speed))
if ((!f_vertical_speed) && (!tf_v_speed))
{
	if ((i_type == RMP_TYPE_MINE) || (i_type == RMP_TYPE_AIRE))
	{
		DYN_SpeedSetVector(Cv_NullVector)
		DYN_GravitySet(Cv_NullVector)
		i_started = 2
	}
	else if (i_type == RMP_TYPE_LARGUE)
		DYN_SpeedSetVector(DYN_SpeedGetVector() * 0.9)
}

f_vertical_speed = tf_v_speed

if (i_type == RMP_TYPE_LARGUE)
{
	tv_speed = DYN_SpeedGetVector()
	if ((i_rebound_count > 0) && (!MATH_VecNullEpsilon(tv_speed)))
	{
		tv_vec = @o_target OBJ_PosGet() - OBJ_PosGet()
		tv_vec.z = 0.0
		tf_z_speed = tv_speed.z
		tf_speed = MATH_VecNorm(tv_speed)
		
		tv_normal = MATH_VecCrossProduct(tv_speed, Cv_VerticalVector)
		tv_normal.z = 0.0
 		tv_vec = @o_target OBJ_PosGet() - OBJ_PosGet()
		tv_vec.z = OBJ_PosGet().z 

		if (!i_boosted)
		{
			if (!MATH_VecNullEpsilon(tv_vec))
			{
				MATH_VecSetNormalize(tv_normal)
				
				tf_tgt_speed = MATH_VecDotProduct(tv_normal, tv_vec)
				tf_tgt_speed = MATH_FloatLimit(tf_tgt_speed, -2.0, 2.0)
				
				DBG_RenderVector(OBJ_PosGet(), tv_normal * tf_tgt_speed, color_bleu)
	 			DBG_RenderVector(OBJ_PosGet(), tv_speed, color_rouge)
				DBG_RenderVector(OBJ_PosGet(), v_initial_speed, color_jaune)
			}
			else
				tf_tgt_speed = 0.0
			
			tv_speed = MATH_VecBlendRotate(tv_speed, tv_speed + (tv_normal * tf_tgt_speed), f_adjustment_speed * TIME_GetDt())
		}
    		tv_speed = MATH_VecInCone(tv_speed, v_initial_speed, Cf_PiBy8, 0)

//		DBG_RenderCone(OBJ_PosGet(), v_initial_speed, Cf_PiBy8, color_bleu)

		if (!MATH_VecNullEpsilon(tv_vec) && (tf_speed != 0.0))
			MATH_VecSetNorm(tv_speed, tf_speed)
		tv_speed.z = tf_z_speed
		
		DBG_RenderVector(OBJ_PosGet(), tv_speed, color_vert)
		DYN_SpeedSetVector(tv_speed)

		tv_vec = MATH_VecCrossProduct(tv_speed, Cv_VerticalVector)
		tf_speed = MATH_VecDotProduct(MATH_VecNormalize(OBJ_HorizonGet()), MATH_VecNormalize(tv_vec))
		if (tf_speed < 0.98)
			OBJ_Rotate_FromTo(cvector(1.0, 0.0, 0.0), MATH_VecGlobalToLocal(tv_vec))
	}
}

// Faire tourner le projectile
if (((i_started == 1) || (i_started == 3)) && (!MATH_VecNullEpsilon(DYN_SpeedGetVector())))
	OBJ_RotateLocalX(-(TIME_GetDt() * ((DYN_SpeedGet() / 2) + 0.2)))

if ((i_type == RMP_TYPE_MINE) || (i_type == RMP_TYPE_AIRE))
{
	DBG_RenderVector(OBJ_PosGet(), @o_target OBJ_PosGet() - OBJ_PosGet(), color_rouge)
	DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_vert)

}	
//DBG_RenderVector(OBJ_PosGet(), DYN_SpeedGetVector(), color_rouge)
