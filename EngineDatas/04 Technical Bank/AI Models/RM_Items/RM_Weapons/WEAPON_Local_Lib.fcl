Include_UltraProcedure_Header
#include "weapon_defines.var"

procedure_local void	WEAPON_SEND_PAF()
{
	vector	tv_sens, tv_pos
	object	tao_zde_zde_list[20]
	object	to_target
	float		pf_dist
	int			ti_i
	int			ti_nb
	int			ti_type
	int			ti_ind
	
	switch( i_type )
	{
		case RM_WEAPON_TYPE_GRENADE :
		case RM_WEAPON_TYPE_GOURDIN :
			break
		default:
			return
	}
	SND_RequestPlay(Ci_SND_Explode)
	COL_ColSetActivationSet(C_bit_zde_fight, none)
	ti_nb = COL_ZDE_ZDEListGet( &tao_zde_zde_list[0], C_zde_fight, C_zde_corps, all, none, Ci_Filter_IdentityFlag)
	for (ti_i = 0; ti_i < ti_nb; ti_i++)
	{
		to_target = tao_zde_zde_list[ti_i]
		ti_ind = ARR_ObjSearch(&ao_frappe_target[0], i_frappe_target_nb, to_target)
		if( ti_ind == -1 )
		{
			ao_frappe_target[i_frappe_target_nb] = to_target
			i_frappe_target_nb++
			if( Proc_PNJ_Can_Protect_Weapon(to_target, o_actor_grab, i_type) )
			{
				Proc_PNJ_Protect_Actor_Set(to_target, o_actor_grab, i_type)
				continue
			}
			else if( Proc_PNJ_Can_Dodge_Weapon(to_target, o_actor_grab, i_type) )
			{
				Proc_PNJ_Dodge_Actor_Set(to_target, o_actor_grab, i_type)
				continue
			}
			tv_pos = OBJ_PosGet()
			tv_sens = @to_target OBJ_PosGet() - OBJ_PosGet()
			ti_type = C_PAF_RM_Fort
			switch( i_type )
			{
				case RM_WEAPON_TYPE_GRENADE :
					// paffer tout le monde
					ti_type = C_PAF_RM_Grenade + C_PAF_RM_Fort
					break
				case RM_WEAPON_TYPE_GOURDIN :
					if( to_target == o_actor_grab )
						return		// ne pas paffer le perso qui me tient
					i_duree_de_vie--
					break
			}
			pf_dist = f_aire_deffet * f_pct_paf_fort
			pf_dist *= pf_dist
			EVENT_AddEventPafCanal( C_EVENT_FILTER_Object, ti_type, o_actor_grab, Cf_EVENT_Duree_1Trame, to_target, -1, f_dommage, tv_sens, tv_pos)
		}
	}
}

procedure_local int WEAPON_HOTSPOT_ON()
{
	if( ! i_hotspot )
	{
		i_hotspot = vrai
		return HotSpot_Add_Obj(OBJ_Me(), 0)	
	}
	return -1
}


procedure_local void WEAPON_HOTSPOT_OFF()
{
	if( i_hotspot )
	{
		i_hotspot = faux
		HotSpot_Del_Obj(OBJ_Me())	
	}
}

procedure_local void WEAPON_MODE_SET(int pi_mode)
{
	object	to_dup
	object	to_canal
	object	to_mount
	vector	tv_speed
	vector	tv_banking
	vector	tv_temp
	vector	tv_pos
	int			ti_rayman_insensitive
	
	// CANCEL
	switch( i_mode)
	{
		case C_Mode_Weapon_Wait :
			break
		case C_Mode_Weapon_Drop :
		case C_Mode_Weapon_Proj :
			COL_ColSetActivationSet(none, C_bit_zde_fight)
			break
		case C_Mode_Weapon_Get :
			break
		case C_Mode_Weapon_Grabbed :	
			break
		case C_Mode_Weapon_Used :
			if( OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Dyna) )
			{
				DYN_TractionSet(Cv_NullVector)
			}
			break		
	}
	
	// INIT
	i_mode = pi_mode
	switch( i_mode )
	{
		case C_Mode_Weapon_Wait :
			WEAPON_HOTSPOT_ON()
			break
		case C_Mode_Weapon_Proj :
			SND_RequestPlay(Ci_SND_Drop)
			COL_ZoneSizeSet(C_zde_fight, cvector( 1.0, 1.0, 1.0))
			COL_ColSetActivationSet( C_bit_zde_fight, none)
			if ( o_actor_grab)
				DYN_SpeedSetVector( @o_actor_grab DYN_SpeedGetVector() + v_proj_sens)
			if( o_actor_grab )
			{
				AI_CBDel(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
				o_actor_grab = LNK_ServeurGet(Ci_LNK_GRAB_OBJECT, mid_grabbed_LNK_ID, faux, nofunc, nofunc)
			}
			break
		case C_Mode_Weapon_Drop :
			SND_RequestPlay(Ci_SND_Drop)
			if( o_actor_grab )
			{
				AI_CBDel(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
				o_actor_grab = LNK_ServeurGet(Ci_LNK_GRAB_OBJECT, mid_grabbed_LNK_ID, faux, nofunc, nofunc)
			}
			tv_speed = MATH_VecRotate(v_last_grab_actor_sight, Cv_VerticalVector, 45 * Cf_1Degre)
			tv_temp = MATH_VecCrossProduct(Cv_VerticalVector, v_last_grab_actor_sight)
			tv_speed = MATH_VecRotate(tv_speed, tv_temp, 80 * Cf_1Degre)	// vers le haut siouplait sinon çà peut passer sous le sol
			tv_speed *= - 20.0
			DBG_RenderVector(OBJ_PosGet(), tv_speed, color_jaune)
			DYN_SpeedSetVector(tv_speed)
			break
		case C_Mode_Weapon_Get :
			SND_RequestPlay(Ci_SND_Take)
			WEAPON_HOTSPOT_OFF()
			o_actor_grab = o_serveur_grab
			AI_CBAdd(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
			o_spawn_grab_actor = nobody		// plus de grab spécifique dorénavant...
			f_grab_coef = 0.0
			break
		case C_Mode_Weapon_Grabbed :	
			// grabbé par rayman
			if( o_serveur_grab == o_main_actor )
			{
				// SFpour les ptizetres
				
				// GESTION DES SFS
				if (!OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Generated))
				{
					if (i_type == RM_WEAPON_TYPE_CLE )
						SpecialFlag_set(SF_GrabbedOnce)
				}

				if( i_key_type == KEY_TYPE_PTIZETRE )
				{
					SpecialFlag_set(5000 + ( 2 * i_Objectif_ID + 1 ) )		// a été validé
					SpecialFlag_reset(5000 + ( 2 * i_Objectif_ID) )			// ne doit plus être affiché	
					SPEECH_RequestPost(OBJ_Me(), OBJ_Me(), C_TXT_Ptizetre, pz1_ride_jump1, SPEECH_Cte_TimeOutDefault + 0.5, SPEECH_Cte_PriorityDefault, SPEECH_Cte_RandomSize, 0, 0, 0)
				}
				// suppr secto
				SCT_SetOf(0,0,0,0)
			}
			if( AI_TriggerIsValid(TrigExec_Grabbed) )
				call_trigger(TrigExec_Grabbed)
			break
		case C_Mode_Weapon_Used :
			f_gourdin_last_use = TIME_Get()
			v_pos_old = OBJ_PosGet()
			SND_RequestPlay(Ci_SND_Use)
			switch( i_type )
			{
				case RM_WEAPON_TYPE_GRENADE :
					DYN_Impulsion(OBJ_PosGet() + v_used_sens, 2.0)
					AI_CBDel(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
					o_serveur_grab = LNK_ServeurGet(Ci_LNK_GRAB_OBJECT, mid_grabbed_LNK_ID, faux, nofunc, nofunc)					
					break
				case RM_WEAPON_TYPE_GUN :
//					to_canal = @o_serveur_grab ANI_CanalObjectGet(Anim_Canal_MainDroite)
//					to_dup = @get_Projectile OBJ_Duplicate(@to_canal OBJ_PosGet())
					if( i_mitraillette )
					{
						tv_pos = OBJ_PosGet() + (1.0 * OBJ_SightGet())
						tv_speed = Cv_NullVector
						v_used_sens = OBJ_SightGet()
					}
					else
					{
						ti_rayman_insensitive = @o_serveur_grab OBJ_FlagsControlGet() & OBJ_C_ControlFlag_RayInsensitive
						if( ! ti_rayman_insensitive )
							@o_serveur_grab OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
						if( o_serveur_grab == o_main_actor && @o_main_actor PROC_RM_ModeLookON() )
						{
							tv_pos = @get_Kamera OBJ_PosGet()
							tv_pos -= 0.15 * @get_Kamera OBJ_HorizonGet()
						}
						else
						{
							tv_pos = @o_serveur_grab OBJ_PosGet()
							tv_pos.z = OBJ_PosGet().z
						}
						DBG_RenderVector( tv_pos,OBJ_PosGet() - tv_pos, color_bleu)
						if( COL_RayObject_Vector( tv_pos, OBJ_PosGet() - tv_pos, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
							tv_pos = COL_RayObject_PosGet() +( COL_RayObject_NormalGet() * 0.1)
						else
							tv_pos = OBJ_PosGet()
						if( ! ti_rayman_insensitive )
							@o_serveur_grab  OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)
							
						if ( o_serveur_grab && o_serveur_grab == AI_MainActorGet(0))
							to_mount = @o_serveur_grab  PROC_RM_MontureGet()
						else
							to_mount = nobody
						if ( ! to_mount)
							to_mount =  o_serveur_grab 
						tv_speed = @to_mount DYN_SpeedGetVector()
					
					}
					
					to_dup = @get_Bullet OBJ_Duplicate(tv_pos)		// le gun est positionné
					if( i_must_miss )
						@get_RM_Bullet_path to_dup i_must_miss = vrai
					to_dup.des_float1 = f_dommage
					to_dup.des_float2 = f_portee
					
					tv_speed.z = 0.0
					tv_speed.x = MATH_VecNorm(tv_speed)
					to_dup.des_vec1 = tv_speed
					if( o_actor_grab )
						to_dup.des_object1 = o_actor_grab
					else
						to_dup.des_object1 = OBJ_Me()
					if( o_actor_grab )
						tv_banking = @o_actor_grab OBJ_BankingGet()
					else
						tv_banking = OBJ_SightGet()
					if( o_serveur_grab == o_main_actor && @get_rayman PROC_RM_ModeLookON() )
					{
						if( COL_RayObject_Vector( @get_Kamera OBJ_PosGet(), @get_Kamera OBJ_SightGet() * 30.0, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
							v_used_sens = COL_RayObject_PosGet() - @to_dup OBJ_PosGet()
					}
					DBG_RenderVector( OBJ_PosGet(), v_used_sens, color_vert)
					@to_dup OBJ_SightGeneralSet(v_used_sens, tv_banking)
					break
			}
			i_must_miss = faux		// flag miss pour 1 shoot uniquement
			break	
		case C_Mode_Weapon_Destroy :
			switch ( i_type )
			{
				case RM_WEAPON_TYPE_GRENADE :
					WEAPON_SEND_PAF()
					break					
			}
			if ( o_actor_grab)
				AI_CBDel(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
			o_actor_grab = LNK_ServeurGet(Ci_LNK_GRAB_OBJECT, mid_grabbed_LNK_ID, faux, nofunc, nofunc)					
			break
		case C_Mode_Weapon_Explosed_SND_delai :
			OBJ_FlagInvisibleSet(vrai)
			break
		case C_Mode_PZ_SteleIncante :
			SPEECH_RequestPost(OBJ_Me(), OBJ_Me(), C_TXT_Ptizetre, pz1_y_stele_arrival1, SPEECH_Cte_TimeOutDefault + 0.5, SPEECH_Cte_PriorityDefault, SPEECH_Cte_RandomSize, 0, 0, 0)
			if( o_actor_grab )
			{
				AI_CBDel(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
				o_actor_grab = LNK_ServeurGet(Ci_LNK_GRAB_OBJECT, mid_grabbed_LNK_ID, faux, nofunc, nofunc)
			}
			break
		case C_Mode_PZ_BassinSoin :
			SPEECH_RequestPost(OBJ_Me(), OBJ_Me(), C_TXT_Ptizetre, pz1_y_ride_down1, SPEECH_Cte_TimeOutDefault + 0.5, SPEECH_Cte_PriorityDefault, SPEECH_Cte_RandomSize, 0, 0, 0)
			if( o_actor_grab )
			{
				AI_CBDel(o_actor_grab, CallBack_After_Blend,"weapon_cb_set_pos")
				o_actor_grab = LNK_ServeurGet(Ci_LNK_GRAB_OBJECT, mid_grabbed_LNK_ID, faux, nofunc, nofunc)
			}
			OBJ_CapaSet(none,Obj_Capa_Switch)
			break

	}
}


procedure_local int WEAPON_CREATE_BOOM()
{
	//--------------------------------------
	//	ANCIEN GFX
	//--------------------------------------
	//	int		pi_GFX
	//	pi_GFX  = GFX_Add(21)
	//	GFX_FlagSet(pi_GFX , 4, 1)
	//	GFX_MaterialSet(pi_GFX , get_SFX_light_and_smoke, 0)	
	//	GFX_Setf(pi_GFX , 21002, 0.1)							// extraction par rapport au point de génération (vers la cam)
	//	GFX_Seti(pi_GFX , 21103, 1.0)		
	//	GFX_Seti(pi_GFX , 21101, 0xFFFFFF)
	//	GFX_Setv(pi_GFX , 21200, OBJ_PosGet())
		
	float tf_rayon_annexe, tf_friction_grow, tf_vitesse, tf_vitesse_X, tf_vitesse_Y, tf_vitesse_globale, tf_bright, tf_tmp_ID, tf_distance, tf_U, f_active_AE
	int ti_nb_sprites, ti_cpt1
	int i_GFX_Paf, i_GFX_Trainees[NB_TRAINEES], i_GFX_Rocks[NB_ROCKS], i_GFX_Etincelles, i_GFX_Nuage_cartoon, i_GFX_Nuage_cartoon2
	object	to_main_actor

	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	// 					GENERATEUR DE PARCITULES CATOON 1 : PAF
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------

	tf_tmp_ID = MATH_RandInt(0,3)
	i_GFX_Paf = GFX_Add(13)
	AE_Brightness(1.0)
	GFX_MaterialSet(i_GFX_Paf, get_SFX_light_and_smoke, -1)
	GFX_Seti(i_GFX_Paf, 13101,55+ tf_tmp_ID)											// ID de material du SFX Lgt&Smk
	GFX_FlagSet(i_GFX_Paf, 0 , 1)
	GFX_FlagSet(i_GFX_Paf, 2 , 1)
	GFX_Seti(i_GFX_Paf, 13100, 1)															// Nombre maxi de sprites
	GFX_Seti(i_GFX_Paf, 13106, 1)															// Nombre de sprites à générer
	GFX_Setf(i_GFX_Paf, 13003, 0.060000)												// duree de vie phase 1
	GFX_Setf(i_GFX_Paf, 13004, 0.0150000)												// duree de vie phase 2 
	GFX_Setf(i_GFX_Paf, 13012, 0.750000)												// Life time random
	GFX_Seti(i_GFX_Paf, 13107, 1)															// Tri des sprites
	GFX_Setf(i_GFX_Paf, 13000, 45.0000)													// Vitesse de croissance min
	GFX_Setf(i_GFX_Paf, 13001, 70.0000)													// Vitesse de croissance max
	GFX_Setf(i_GFX_Paf, 13002, 0.35)														// Friction sur la croissance
	GFX_Setf(i_GFX_Paf, 13005, 0.100000)												// Taille min à la création
	GFX_Setf(i_GFX_Paf, 13006, 0.100000)												// Taille max à la création
	GFX_Setf(i_GFX_Paf, 13007, 0.00000)													// Gravité
	GFX_Setv(i_GFX_Paf, 13203, cvector(0,0,0))											// Friction sur chaque axe
	GFX_Seti(i_GFX_Paf, 13103, 0xFFFFFFFF)											// Couleur phase 1
	GFX_Seti(i_GFX_Paf, 13104, 0xFFFFFFFF)											// Couleur phase 2
	GFX_Seti(i_GFX_Paf, 13105, 0x00FFFFFF)											// Couleur phase 3
	GFX_Setf(i_GFX_Paf, 13011, 0.0)														// Hauteur du sol
	GFX_Setv(i_GFX_Paf, 13200, OBJ_PosGet() + cvector(0.0, 0.0, 0.25))		//Position de création
	GFX_Setf(i_GFX_Paf, 13009, 0.0)														// Vitesse min
	GFX_Setf(i_GFX_Paf, 13010, 0.0)														// Vitesse max
	GFX_Setv(i_GFX_Paf, 13201, cvector(0,0,0))											// Vitesse min sur chaque axe
	GFX_Setv(i_GFX_Paf, 13202, cvector(0,0,0))											// Vitesse max sur chaque axe
	GFX_Setv(i_GFX_Paf, 13204, cvector(0.00000, 0.00000, 0.00000))			// Vent
	GFX_Setv(i_GFX_Paf, 13205, cvector(0.00000, 0.00000, 0.00000))			// Vitesse de la position de création
	GFX_Setv(i_GFX_Paf, 13206, cvector(0.00000, 0.00000, 0.00000))			// Friction de la position
	GFX_Setv(i_GFX_Paf, 13207, cvector(0.01,0.0,0.0))								// Volume de création 1
	GFX_Setv(i_GFX_Paf, 13208, cvector(0.0,0.01,0.0))								// Volume de création 2
	GFX_Setf(i_GFX_Paf, 13008, 0.000000)												// Taux de génération
	
	// Activation After FX
	f_active_AE = 1.0
	to_main_actor = AI_MainActorGet(0)
	tf_distance = MATH_VecDistance(OBJ_PosGet(),@to_main_actor OBJ_PosGet())

	tf_U = tf_distance / f_dist_max_AE
	if (tf_U>1.0)
		tf_U = 1.0
		
	f_active_AE = MATH_FloatBlend(f_active_AE,0.0,tf_U)
	
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	// 					GENERATEUR DE PARCITULES CATOON 2 : trainées
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	ti_nb_sprites = 25
	tf_friction_grow = 0.01
	tf_vitesse = 20.0
	
	for (ti_cpt1 = 0; ti_cpt1 < NB_TRAINEES; ti_cpt1++)
	{
		tf_vitesse_X = MATH_RandFloat(-tf_vitesse, tf_vitesse)
		tf_vitesse_Y = MATH_RandFloat(-tf_vitesse, tf_vitesse)
		tf_vitesse_globale = MATH_RandFloat(tf_vitesse/2,tf_vitesse)
		i_GFX_Trainees[ti_cpt1] = GFX_Add(13)
		GFX_MaterialSet(i_GFX_Trainees[ti_cpt1], get_SFX_light_and_smoke, -1)
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13101, 41)																	// ID de material du SFX Lgt&Smk
		GFX_FlagSet(i_GFX_Trainees[ti_cpt1], 0 , 1)
		GFX_FlagSet(i_GFX_Trainees[ti_cpt1], 2 , 1)
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13100, ti_nb_sprites )													// Nombre maxi de sprites
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13106, ti_nb_sprites )													// Nombre de sprites à générer
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13003, 0.300000)															// duree de vie phase 1
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13004, 0.150000)															// duree de vie phase 2 
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13012, 0.750000)															// Life time random
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13107, 1)																	// Tri des sprites
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13000, 0.10000)															// Vitesse de croissance min
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13001, 0.2000)															// Vitesse de croissance max
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13002, tf_friction_grow)													// Friction sur la croissance
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13005, 0.0500000)														// Taille min à la création
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13006, 0.100000)															// Taille max à la création
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13007, -18.00000)														// Gravité
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13203, cvector(0.0, 0.0, 0.0))											// Friction sur chaque axe
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13103, 0xFFFFFFFF)													// Couleur phase 1
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13104, 0x80808080)														// Couleur phase 2
		GFX_Seti(i_GFX_Trainees[ti_cpt1], 13105, 0x00808080)														// Couleur phase 3
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13011, 0.0)																	// Hauteur du sol
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13200, OBJ_PosGet() + cvector(0.0, 0.0, 0.0))					// Position de création
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13009, tf_vitesse_globale )												// Vitesse min
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13010, tf_vitesse_globale )												// Vitesse max
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13201, cvector(tf_vitesse_X, tf_vitesse_Y, tf_vitesse * MATH_RandFloat(0.1,2.0)))			// Vitesse min sur chaque axe
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13202, cvector(tf_vitesse_X, tf_vitesse_Y, tf_vitesse * MATH_RandFloat(0.1,2.0)))			// Vitesse max sur chaque axe
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13204, cvector(0.00000, 0.00000, 0.00000))						// Vent
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13205, cvector(0.00000, 0.00000, 0.00000))						// Vitesse de la position de création
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13206, cvector(0.00000, 0.00000, 0.00000))						// Friction de la position
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13207, cvector(0.01,0.0,0.0))											// Volume de création 1
		GFX_Setv(i_GFX_Trainees[ti_cpt1], 13208, cvector(0.0,0.01,0.0))											// Volume de création 2
		GFX_Setf(i_GFX_Trainees[ti_cpt1], 13008, 0.01)																// Taux de génération
	}
	
	
	
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	// 					GENERATEUR DE PARCITULES CATOON 3 : rochers
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	for (ti_cpt1 = 0; ti_cpt1 < NB_ROCKS; ti_cpt1++)
	{
		i_GFX_Rocks[ti_cpt1] = GFX_Add(13)
		GFX_MaterialSet(i_GFX_Rocks[ti_cpt1], get_SFX_light_and_smoke, -1)
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13101, 42)																		// ID de material du SFX Lgt&Smk
		GFX_FlagSet(i_GFX_Rocks[ti_cpt1], 0 , 1)
		GFX_FlagSet(i_GFX_Rocks[ti_cpt1], 2 , 1)
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13100, 20)																		// Nombre maxi de sprites
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13106, 20)																		// Nombre de sprites à générer
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13003, 1.0)																	// duree de vie phase 1
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13004, 0.5)																	// duree de vie phase 2 
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13012, 0.750000)															// Life time random
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13107, 1)																		// Tri des sprites
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13000, 1.0)																	// Vitesse de croissance min
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13001, 1.2)																	// Vitesse de croissance max
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13002, 1.0)																	// Friction sur la croissance
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13005, 0.05)																	// Taille min à la création
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13006, 0.1)																	// Taille max à la création
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13007, -20.00000)															// Gravité
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13203, Cv_NullVector)														// Friction sur chaque axe
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13103, 0xFFFFFFFF)														// Couleur phase 1
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13104, 0xFFFFFFFF)														// Couleur phase 2
		GFX_Seti(i_GFX_Rocks[ti_cpt1], 13105, 0x00000000)														// Couleur phase 3
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13011, OBJ_PosGet().z)													// Hauteur du sol
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13200, OBJ_PosGet())													// Position de création
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13009, 5.0)																	// Vitesse min
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13010, 30.0)																	// Vitesse max
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13201, cvector(-15, -15, 5.0))											// Vitesse min sur chaque axe
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13202, cvector(15, 15, 15.0))											// Vitesse max sur chaque axe
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13204, cvector(0.00000, 0.00000, 0.00000))						// Vent
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13205, Cv_NullVector)														// Vitesse de la position de création
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13206, Cv_NullVector)														// Friction de la position
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13207, cvector(0.01,0.0,0.0))											// Volume de création 1
		GFX_Setv(i_GFX_Rocks[ti_cpt1], 13208, cvector(0.0,0.01,0.0))											// Volume de création 2
		GFX_Setf(i_GFX_Rocks[ti_cpt1], 13008, 0.00)																	// Taux de génération
	}
	
	
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	// 					GENERATEUR DE PARCITULES CATOON 4 : étincelles
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	i_GFX_Etincelles = GFX_Add(9)
	GFX_FlagSet(i_GFX_Etincelles, 0,1)
	GFX_FlagSet(i_GFX_Etincelles, 2, 1)
	GFX_MaterialSet(i_GFX_Etincelles, get_SFX_light_and_smoke, 5)
	GFX_Seti(i_GFX_Etincelles, 9101, 0x40448DAB)																	// Couleur des particules
	GFX_Setv(i_GFX_Etincelles, 9200, OBJ_PosGet() + cvector(0.0,0.0,0.25))									// Position
	GFX_Setv(i_GFX_Etincelles, 9201, cvector(0.0, 0.0, 1.0) )														// Axe principal de génération
	GFX_Setv(i_GFX_Etincelles, 9202, cvector(0, 0, 0.0))																// Gravité
	GFX_Seti(i_GFX_Etincelles, 9100, 15)																					// Nombre de particules max
	GFX_Seti (i_GFX_Etincelles, 9102, 10)																				// Flags
	GFX_Setf(i_GFX_Etincelles, 9000, 3.0 )																				// Angle du cône, en radians
	GFX_Setf(i_GFX_Etincelles, 9001, 50)																					// Vitesse min
	GFX_Setf(i_GFX_Etincelles, 9002, 60)																					// Vitesse max
	GFX_Setf(i_GFX_Etincelles, 9003, 0.8)																				// Friction
	GFX_Setf(i_GFX_Etincelles, 9004, MATH_RandFloat(0.05,0.1))												// Epaisseur des étincelles
	GFX_Setf(i_GFX_Etincelles, 9005, 0.2)																				// Temps de vie minimum
	GFX_Setf(i_GFX_Etincelles, 9006, 0.6)																				// Temps de vie max
	GFX_Setf(i_GFX_Etincelles, 9007, 15)																					// Multiplicateur de longueur
	GFX_Setf(i_GFX_Etincelles, 9008, 0.0)																				// Temps entre la génération de 2 étincelles
	GFX_Setf(i_GFX_Etincelles, 9009, 0.2)																				// Temps de mort minimum
	GFX_Setf(i_GFX_Etincelles, 9010, 0.2)																				// Temps de mort maximum
	
	
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	// 					GENERATEUR DE PARCITULES CATOON 5 : nuage central 1
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	i_GFX_Nuage_cartoon = GFX_Add( 13)
	GFX_MaterialSet(i_GFX_Nuage_cartoon, get_SFX_light_and_smoke, -1)
	GFX_Seti(i_GFX_Nuage_cartoon, 13101,41)																			// ID de material du SFX Lgt&Smk
	GFX_FlagSet(i_GFX_Nuage_cartoon, 0 , 1)
	GFX_FlagSet(i_GFX_Nuage_cartoon, 2 , 1)
	GFX_Seti(i_GFX_Nuage_cartoon, 13100, 1)																			// Nombre maxi de sprites
	GFX_Seti(i_GFX_Nuage_cartoon, 13106, 1)																			// Nombre de sprites à générer
	GFX_Setf(i_GFX_Nuage_cartoon, 13003, 0.050000)																// duree de vie phase 1
	GFX_Setf(i_GFX_Nuage_cartoon, 13004, 0.200000)																// duree de vie phase 2 
	GFX_Setf(i_GFX_Nuage_cartoon, 13012, 0.750000)																// Life time random
	GFX_Seti(i_GFX_Nuage_cartoon, 13107, 1)																			// Tri des sprites
	GFX_Setf(i_GFX_Nuage_cartoon, 13000, -30.0)																		// Vitesse de croissance min
	GFX_Setf(i_GFX_Nuage_cartoon, 13001, -30.0)																		// Vitesse de croissance max
	GFX_Setf(i_GFX_Nuage_cartoon, 13002, -0.01)																		// Friction sur la croissance
	GFX_Setf(i_GFX_Nuage_cartoon, 13005, 5.5)																		// Taille min à la création
	GFX_Setf(i_GFX_Nuage_cartoon, 13006, 5.5)																		// Taille max à la création
	GFX_Setf(i_GFX_Nuage_cartoon, 13007, 0.0)																		// Gravité
	GFX_Setv(i_GFX_Nuage_cartoon, 13203, cvector(1.0,1.0,1.0))													// Friction sur chaque axe
	GFX_Seti(i_GFX_Nuage_cartoon , 13103, 0x00AFCBD5)														// Couleur phase 1
	GFX_Seti(i_GFX_Nuage_cartoon , 13104, 0xFFAFCBD5)														// Couleur phase 2
	GFX_Seti(i_GFX_Nuage_cartoon , 13105, 0x00AFCBD5)														// Couleur phase 3
	GFX_Setf(i_GFX_Nuage_cartoon, 13011, 0.0)																		// Hauteur du sol
	GFX_Setv(i_GFX_Nuage_cartoon, 13200, OBJ_PosGet() + cvector(0.0, 0.0, 0.5))						// Position de création
	GFX_Setf(i_GFX_Nuage_cartoon, 13009, 0.0)																		// Vitesse min
	GFX_Setf(i_GFX_Nuage_cartoon, 13010, 0.0)																		// Vitesse max
	GFX_Setv(i_GFX_Nuage_cartoon, 13201, cvector(0.0, 0.0, 0.0))												// Vitesse min sur chaque axe
	GFX_Setv(i_GFX_Nuage_cartoon, 13202, cvector(0.0, 0.0, 0.0))												// Vitesse max sur chaque axe
	GFX_Setv(i_GFX_Nuage_cartoon, 13204, cvector(0.0, 0.0, 0.0))												// Vent
	GFX_Setv(i_GFX_Nuage_cartoon, 13205, cvector(0.0, 0.0, 0.0))												// Vitesse de la position de création
	GFX_Setv(i_GFX_Nuage_cartoon, 13206, cvector(0.0, 0.0, 0.0))												// Friction de la position
	GFX_Setv(i_GFX_Nuage_cartoon, 13207, cvector(0.01,0.0,0.0))												// Volume de création 1
	GFX_Setv(i_GFX_Nuage_cartoon, 13208, cvector(0.0,0.01,0.0))												// Volume de création 2
	GFX_Setf(i_GFX_Nuage_cartoon, 13008, 0.0)																		// Taux de génération
	
	
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	// 					GENERATEUR DE PARCITULES CATOON 6 : nuage central 2
	//------------------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------------------
	i_GFX_Nuage_cartoon2 = GFX_Add( 13)
	GFX_MaterialSet(i_GFX_Nuage_cartoon2, get_SFX_light_and_smoke, -1)
	GFX_Seti(i_GFX_Nuage_cartoon2, 13101,41)																		// ID de material du SFX Lgt&Smk
	GFX_FlagSet(i_GFX_Nuage_cartoon2, 0 , 1)
	GFX_FlagSet(i_GFX_Nuage_cartoon2, 2 , 1)
	GFX_Seti(i_GFX_Nuage_cartoon2, 13100, 1)																		// Nombre maxi de sprites
	GFX_Seti(i_GFX_Nuage_cartoon2, 13106, 1)																		// Nombre de sprites à générer
	GFX_Setf(i_GFX_Nuage_cartoon2, 13003, 0.3)																		// duree de vie phase 1
	GFX_Setf(i_GFX_Nuage_cartoon2, 13004, 0.2)																		// duree de vie phase 2 
	GFX_Setf(i_GFX_Nuage_cartoon2, 13012, 0.750000)																// Life time random
	GFX_Seti(i_GFX_Nuage_cartoon2, 13107, 1)																		// Tri des sprites
	GFX_Setf(i_GFX_Nuage_cartoon2, 13000, 10.0000)																	// Vitesse de croissance min
	GFX_Setf(i_GFX_Nuage_cartoon2, 13001, 10.0000)																	// Vitesse de croissance max
	GFX_Setf(i_GFX_Nuage_cartoon2, 13002, 0.05)																	// Friction sur la croissance
	GFX_Setf(i_GFX_Nuage_cartoon2, 13005, 0.0)																		// Taille min à la création
	GFX_Setf(i_GFX_Nuage_cartoon2, 13006, 0.0)																		// Taille max à la création
	GFX_Setf(i_GFX_Nuage_cartoon2, 13007, 0.0)																		// Gravité
	GFX_Setv(i_GFX_Nuage_cartoon2, 13203, cvector(1.0,1.0,1.0))												// Friction sur chaque axe
	GFX_Seti(i_GFX_Nuage_cartoon2, 13103, 0x00AFCBD5)														// Couleur phase 1
	GFX_Seti(i_GFX_Nuage_cartoon2 , 13104, 0xFFAFCBD5)														// Couleur phase 2
	GFX_Seti(i_GFX_Nuage_cartoon2, 13105, 0x00AFCBD5)														// Couleur phase 3
	GFX_Setf(i_GFX_Nuage_cartoon2, 13011, 0.0)																		// Hauteur du sol
	GFX_Setv(i_GFX_Nuage_cartoon2, 13200, OBJ_PosGet() + cvector(0.0, 0.0, 0.5))						// Position de création
	GFX_Setf(i_GFX_Nuage_cartoon2, 13009, 0.0)																		// Vitesse min
	GFX_Setf(i_GFX_Nuage_cartoon2, 13010, 0.0)																		// Vitesse max
	GFX_Setv(i_GFX_Nuage_cartoon2, 13201, cvector(0.0, 0.0, 0.0))												// Vitesse min sur chaque axe
	GFX_Setv(i_GFX_Nuage_cartoon2, 13202, cvector(0.0, 0.0, 0.0))												// Vitesse max sur chaque axe
	GFX_Setv(i_GFX_Nuage_cartoon2, 13204, cvector(0.0, 0.0, 0.0))												// Vent
	GFX_Setv(i_GFX_Nuage_cartoon2, 13205, cvector(0.0, 0.0, 0.0))												// Vitesse de la position de création
	GFX_Setv(i_GFX_Nuage_cartoon2, 13206, cvector(0.0, 0.0, 0.0))												// Friction de la position
	GFX_Setv(i_GFX_Nuage_cartoon2, 13207, cvector(0.01,0.0,0.0))												// Volume de création 1
	GFX_Setv(i_GFX_Nuage_cartoon2, 13208, cvector(0.0,0.01,0.0))												// Volume de création 2
	GFX_Setf(i_GFX_Nuage_cartoon2, 13008, 0.0)																		// Taux de génération

	switch ( i_type)
	{
		case RM_WEAPON_TYPE_GRENADE :
			f_GFX_rayon = f_aire_deffet
			break
		case RM_WEAPON_TYPE_GUN:
			f_GFX_rayon = 1.0
			break
	}
	//return	pi_GFX
	return i_GFX_Paf
}

procedure_local int WEAPON_Collide_Ground()
{
	vector	tv_temp
	if( COL_CollideType(COL_C_Ground) )
	{
		tv_temp = COL_NormalGet(COL_C_Ground)
		if( tv_temp.z > 0.0 )		// les plafonds ne sont pas des sols
			return vrai
	}
	return faux
}