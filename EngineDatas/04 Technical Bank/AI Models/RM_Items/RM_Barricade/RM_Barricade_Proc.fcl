#include "RM_Barricade_defines.var"

procedure_local void RM_Barricade_DetruitPlanche(int i_numPlanche,vector vitesse)
{
	object	to_planche
	to_planche=ao_Planche[i_numPlanche]
	af_DelayDestroy[i_numPlanche]=2.0
	SND_RequestPlay(Ci_Barricade_SND_Degrade)
	@to_planche DYN_On()
	@to_planche DYN_FlagsSet(DYN_C_BasicForces | DYN_C_NeverDynamicFather | DYN_C_VectorFriction | DYN_C_GlobalFriction | DYN_C_SkipFrictionWhenSpeedFromAnim | DYN_C_HorizontalGrounds | DYN_C_SlipOnGroundEdge, none)
	@to_planche DYN_GravitySet(Cv_NormalGravity)
	@to_planche DYN_FrictionVectorSet(cvector(1.0,1.0,1.0))
	@to_planche DYN_SpeedSetVector(vitesse)
}

procedure_local void RM_Barricade_Detruit(vector v_direction,float f_dispertion)
{
	int			ti_i
	network	tn_net
	object	to_gao
	vector	tv_rand
	
	for(ti_i=0;ti_i<Ci_Barricade_MaxModule;ti_i++)
	{
		if(ao_Planche[ti_i] && af_DelayDestroy[ti_i]==-1.0)
		{
			tv_rand=cvector(MATH_RandFloat(-f_dispertion,f_dispertion),MATH_RandFloat(-f_dispertion,f_dispertion),MATH_RandFloat(-f_dispertion,f_dispertion))
			RM_Barricade_DetruitPlanche(ti_i,v_direction+tv_rand)
		}
	}
	
	if(i_GarderLaColMap==faux)
	{
		COL_ColMapActivationSet(none, all)
	}
	
	SND_RequestPlay(Ci_Barricade_SND_Destroy)
	COL_ColSetActivationSet(none,all)
 	
 	SpecialFlag_set(SF_ID)
 	
	tn_net = WAY_NetOfObj()
	// NET
	if (tn_net)
	{
		// C'est une porte reseau
		@get_global i_BVTerritory_LinkHasChanged = 2
		for (ti_i = 0; ti_i < WAY_GetNumLinks(tn_net, OBJ_Me()); ti_i++)
		{
			to_gao = WAY_NetNextWP(tn_net, OBJ_Me(), NetNextWP_Mode_choix_de_lindice, ti_i)
			WAY_LinkCapaSet(tn_net,OBJ_Me(),to_gao, OBJ_Capa_0, none)
		}
	}
	if(i_Targetable)
		RM_TARGET_Del(OBJ_Me())
	if(i_Grappinable)
		HotSpot_Del_Obj(OBJ_Me())
	
	OBJ_CapaSet(Obj_Capa_Switch,none)	

	if( AI_TriggerIsValid(TrigExec_Detruit) )
		call_trigger(TrigExec_Detruit)

	AI_TrackCurChange("RM_Barricade_ETAT_AVANT_DESTROY")
}

procedure_local void RM_Barricade_Chute()
{
	int	ti_i
	vector tv_rot_speed 
	for(ti_i=0;ti_i<Ci_Barricade_MaxModule;ti_i++)
	{
		if(af_DelayDestroy[ti_i]>0.0)
		{
			af_DelayDestroy[ti_i]-=MATH_FloatMin(TIME_GetDt(),af_DelayDestroy[ti_i])
			tv_rot_speed = MATH_VecRotate(@ao_Planche[ti_i] OBJ_SightGet(), av_AxeRotate[ti_i] ,2.0 * TIME_GetDt())
			@ao_Planche[ti_i] OBJ_SightGeneralSet(tv_rot_speed,@ao_Planche[ti_i] OBJ_BankingGet())	
		}
		else if(af_DelayDestroy[ti_i]==0.0)
		{
			if(ao_Planche[ti_i])
			{
				@ao_Planche[ti_i] OBJ_Destroy()
				ao_Planche[ti_i]=nobody				
			}
		}
	}
}

procedure_local void RM_Barricade_Tremble()
{
	int		ti_i
	vector	tv_Offset
	if(f_DelayTremble>0.0)
	{
		for(ti_i=i_NumModule;ti_i<Ci_Barricade_MaxModule;ti_i++)
		{
			if(ao_Planche[ti_i])
			{
				tv_Offset=cvector(MATH_RandFloat(-0.5,0.5),MATH_RandFloat(-0.5,0.5),MATH_RandFloat(-0.5,0.5))
				@ao_Planche[ti_i] OBJ_PosSet(av_PosInit[ti_i]+((tv_Offset*f_DelayTremble)*f_CoefTremblement))			}
		}
		f_DelayTremble-=TIME_GetDt()
	}
}