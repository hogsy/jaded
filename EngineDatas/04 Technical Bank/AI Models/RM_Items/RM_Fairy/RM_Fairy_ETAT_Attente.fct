#include "RM_Fairy_defines.var"

Include_UltraProcedure_Header

float		tf_dest_Z
float		tf_norm
float		tf_speed_coef

vector	tv_pos
vector	tv_pivot

object	to_monture

if (i_flag_sortie_etat)
{
	i_flag_sortie_etat = faux

	if (GFX_Halo != -1)
	{
		GFX_Del(GFX_Halo)
		GFX_Halo = -1
	}

	return
}

if (i_etat_courant != ETAT_Attente)
{
	// INTIALISATION
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Attente
	
	if (fct_last_etat)
	{
		i_flag_sortie_etat = vrai
		AI_Execute(fct_last_etat)
	}
	
	fct_last_etat = "RM_Fairy_ETAT_Attente"
	

	if (GFX_Halo == -1)
	{
		GFX_Halo = @o_main_actor GFX_Add(21)
		GFX_FlagSet(GFX_Halo, 4, 1)
		GFX_MaterialSet(GFX_Halo , get_SFX_light_and_smoke, 0)	
		GFX_Seti(GFX_Halo, 21100, 4)								// Flag : 4 => halo visible de dos
		GFX_Seti(GFX_Halo, 21103, 1)								// 0 : Flare mural / 1 : Flare simple
		GFX_Setf(GFX_Halo , 21000, 0.5)				// rayon du halo
		GFX_Setf(GFX_Halo, 21002, 0.1)			// extraction par rapport au point de génération (vers la cam)
		GFX_Seti(GFX_Halo, 21101, 0xFA467D)
	}

	OBJ_FlagInvisibleSet(vrai)
	f_blend_speed = 0.0

	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// ANALYSE ===============================================================
RM_Fairy_Fill_Info()

if ( o_info || i_mode_look )
	macro_change_etat("RM_Fairy_ETAT_Active")

tv_pivot = @o_main_actor OBJ_PosGet()
tv_pivot += @o_main_actor OBJ_BankingGet() * 0.5

tv_pos = tv_pivot
//tv_pos += OBJ_HorizonGet() * 1.5

tv_pos -= @o_main_actor OBJ_SightGet() * 0.5
if (MATH_VecDotProduct(OBJ_PosGet() - tv_pivot, @o_main_actor OBJ_HorizonGet()) > 0.0)
	tv_pos += @o_main_actor OBJ_HorizonGet() * 0.5
else
	tv_pos -= @o_main_actor OBJ_HorizonGet() * 0.5

to_monture = @o_main_actor PROC_RM_MontureGet() 
if (to_monture)
	tf_speed_coef = MATH_VecSquareNorm(@to_monture DYN_SpeedGetVector())
else
	tf_speed_coef = MATH_VecSquareNorm(@o_main_actor DYN_SpeedGetVector())
tf_speed_coef /= 400.0
tf_speed_coef = MATH_FloatMin(tf_speed_coef, 1.0)

if (@o_main_actor COL_CollideType(COL_C_Ground))
{
	v_ground_pos = @o_main_actor COL_CollidedPointGet(COL_C_Ground)
	v_ground_normal = @o_main_actor COL_NormalGet(COL_C_Ground)
}

if (MATH_VecSquareNorm(v_ground_pos - @o_main_actor OBJ_PosGet()) < 9.0)
	tv_pos -= MATH_FloatMin(MATH_VecDotProduct(tv_pos - v_ground_pos, v_ground_normal) - 0.5, 0.0) * v_ground_normal

if (@o_main_actor COL_CollideType(COL_C_Wall))
{
	v_wall_pos = @o_main_actor COL_CollidedPointGet(COL_C_Wall)
	v_wall_normal = @o_main_actor COL_NormalGet(COL_C_Wall)
}

if (MATH_VecSquareNorm(v_wall_pos - @o_main_actor OBJ_PosGet()) < 9.0)
	tv_pos -= MATH_FloatMin(MATH_VecDotProduct(tv_pos - v_wall_pos, v_wall_normal) - 0.5, 0.0) * v_wall_normal

DBG_RenderVector(tv_pivot, tv_pos - tv_pivot, color_jaune)

f_blend_speed += MATH_FloatMin(1.0 - f_blend_speed, TIME_GetDt())

tf_dest_Z = MATH_FloatBlend(OBJ_PosGet().z, tv_pos.z, f_blend_speed * 8.0 * TIME_GetDt())
tv_pos = tv_pivot + MATH_VecBlendRotate(OBJ_PosGet() - tv_pivot, tv_pos - tv_pivot, f_blend_speed * MATH_FloatBlend(2.0, 8.0, tf_speed_coef) * TIME_GetDt())
tv_pos.z = tf_dest_Z

OBJ_PosSet(tv_pos)
OBJ_SightGeneralSet(tv_pivot - OBJ_PosGet(), Cv_VerticalVector)
GFX_Setv(GFX_Halo, 21200, OBJ_PosGet())

