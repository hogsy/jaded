#include "Por_Defines.var"


int			ti_i
object	to_gao
int			ti_trig

// SORTIE ETAT ===================================================================
if (i_sort_etat)
{
	i_sort_etat = faux
	if (i_snd_loop != -1)
	{
		SND_Stop(i_snd_loop)
		i_snd_loop = -1
	}
		
	return
}

// INITIALISATION ETAT ==============================================================
if (i_etat_courant != ETAT_Porte_Ouverte)
{
	i_dernier_etat = i_etat_courant
	i_etat_courant = ETAT_Porte_Ouverte
	if (fct_last_etat)
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	fct_last_etat = AI_TrackCurGet()

	if (@get_global i_frame_nbr > 15)
	{
		SND_RequestPlay(Ci_Porte_Snd_Ouverture)
		i_snd_loop = SND_RequestPlayLoop(Ci_Porte_Snd_Ouverture_Loop)
		i_snd_end = faux
	}
	else
		i_snd_end = vrai
		
	OBJ_CapaSet(Obj_Capa_Switch,none)
}


// MOUVEMENT
switch(i_ouverture_methode)
{
	case Ci_Porte_Methode_Blend :
		f_progression = MATH_FloatBlend(f_progression, 1.0 , TIME_GetDt() * f_ouverture_vitesse)
		break

	case Ci_Porte_Methode_Lineaire :
		f_progression = MATH_FloatMin(1.0,f_progression + (TIME_GetDt() * f_ouverture_vitesse))
		break
		
	case Ci_Porte_Methode_LineaireAmortie :
		f_vitesse_cur = MATH_FloatBlend(f_vitesse_cur, f_fermeture_vitesse, 8.0 * TIME_GetDt())
		f_progression = MATH_FloatLimit(f_progression + (TIME_GetDt() * f_vitesse_cur), 0.0, 1.0)
		break
}		

// STATUS
if ((f_progression_old < i_pourcentage_open && f_progression >= i_pourcentage_open) || i_flag_init)
{
	if (i_flag_init)
	{
		i_flag_init = faux
		f_progression = 1.0
	}

	OBJ_CapaSet(OBJ_Capa_15,none)

	if (i_gestion_colmap_AI)
		COL_ColMapActivationSet(none, all)

	// SF
	if (i_etat_init == Ci_Porte_InitFerme)
		SpecialFlag_set(SF_ID)
	else
		SpecialFlag_reset(SF_ID)

	// NET
	if (n_net)
	{
		// C'est une porte reseau
		@get_global i_BVTerritory_LinkHasChanged = 2
		for (ti_i = 0; ti_i < WAY_GetNumLinks(n_net, OBJ_Me()); ti_i++)
		{
			to_gao = WAY_NetNextWP(n_net, OBJ_Me(), NetNextWP_Mode_choix_de_lindice, ti_i)
			WAY_LinkCapaSet(n_net,OBJ_Me(),to_gao,none,OBJ_Capa_0)
		}
	}

	// Trigger Ouverture
	for (ti_i = 0; ti_i<3; ti_i++)
	{
		if (AI_TriggerIsValid(t_ouverture_exec[ti_i]) )
			call_trigger( t_ouverture_exec[ti_i] )
	}
}
f_progression_old = f_progression

// LOCK ??
if (i_lock_if_new_status && ( MATH_FloatNullToler( f_progression -1.0, 0.01) && i_etat_init == Ci_Porte_InitFerme))
{
	// La porte est ouverte et je la bloque
	i_lock = vrai
}

// SND
if (!i_snd_end && MATH_FloatNullToler( f_progression -1.0, 0.01))
{
	if (i_snd_loop != -1)
	{
		SND_Stop(i_snd_loop)
		i_snd_loop = -1
	}
	
	SND_RequestPlay(Ci_Porte_Snd_Ouverture_End)
	i_snd_end = vrai
}

// TRIGGERS
if (!i_lock)
{
	if (AI_TriggerIsValid(t_fermeture))
		ti_trig = call_trigger(t_fermeture)
	else
		ti_trig = faux

	if ( ti_trig || ! OBJ_CapaTest(Obj_Capa_Switch) )
	{
		AI_TrackCurChange("Por_Etat_Ferme")
		return
	}
}	

// AFFICHAGE
Proc_Porte_Display(f_progression)