#include"r_defines.var"

int			ti_pos

float		tf_blend 
float		tf_dot 

vector	tv_banking 


// SORTIE ETAT 	===================================================================
if( i_sort_etat )
{
	o_climb_WP = nobody
	i_sort_etat = faux
	return
}

// INIT ETAT 	=====================================================================
if( i_etat_courant != ETAT_RM_accroch )
{
	i_etat_courant = ETAT_RM_accroch
	if( fct_last_etat )
	{
		i_sort_etat = vrai
		AI_Execute(fct_last_etat)
	}
	

	ACT_ActionSet( RM_Act_Accroch)
	MOVE_Set_Mode(C_Move_Accroch)
	COLSET_ON_OFF( C_bit_zdm_pied, OFF)
	DYN_GravitySet(Cv_NullVector)	
	DYN_TractionSet(Cv_NullVector)	

	fct_last_etat = AI_TrackCurGet()
	f_time_start_etat = 0.0
}
else
{
	f_time_start_etat += TIME_GetDt()
}

// DETECTIONS 	===================================================================

if( o_paf_detect_actor )
	AI_TrackCurChangeNow("raym_ETAT_paf")

// GRAPPIN LAUNCH / END
if ( i_flag_just_grappin )
{
	if( o_grappin)
		GRAPPIN_Return()		
}


// COMPORTEMENT 	===============================================================


v_climb_hand_offset = @o_climb_WP MATH_VecLocalToGlobal( v_anim_hand_accroch_offset)	// Décor en mouvement
if ( MATH_FloatNullEpsilon( f_joy_norm))
	i_move_valid = vrai					// Forcer le joueur a relacher le joy pour lancer la montée et éviter la remonté directement.

switch ( ACT_ActionGet())
{
	case RM_Act_Accroch :
		if ( ACT_ActionFinished())
		{
			// GO CYCL
			ACT_ActionSet( RM_Act_AccrochCycl)
		}
		ti_pos = vrai
		tf_blend = ANI_CurrentFrameGet(0) / ANI_PartialNbFrameGet(0)
		

		if ( i_move_valid && ! MATH_FloatNullEpsilon(f_joy_norm))
		{
			tf_dot = MATH_VecDotProduct( v_joy_sight_normalized, @o_climb_WP OBJ_SightGet())
			if ( tf_dot < -Cf_Cos30)
			{
				MOVE_CHANGE_To_Jump(cvector(0.0,0.0, -5.0), faux, vrai)
				goto GO_TO_MAIN					
			}
			else if ( ! MATH_FloatNullEpsilon(f_joy_norm) && tf_dot > Cf_Cos30)
			{
				// GO UP
				ACT_ActionSet( RM_Act_AccrochUp)
			}				
		}		
		if ( i_flag_just_jump)
		{
			// GO UP
			ACT_ActionSet( RM_Act_AccrochUp)
		}							
		break
	case RM_Act_AccrochCycl :
		ti_pos = vrai
		tf_blend = 1.0

		if ( i_move_valid && ! MATH_FloatNullEpsilon(f_joy_norm))
		{
			tf_dot = MATH_VecDotProduct( v_joy_sight_normalized, @o_climb_WP OBJ_SightGet())
			if ( tf_dot < -Cf_Cos30)
			{
				MOVE_CHANGE_To_Jump(cvector(0.0,0.0, -5.0), faux, vrai)
				goto GO_TO_MAIN					
			}
			else if ( ! MATH_FloatNullEpsilon(f_joy_norm) && tf_dot > Cf_Cos30)
			{
				// GO UP
				ACT_ActionSet( RM_Act_AccrochUp)
			}				
		}
		if ( i_flag_just_jump )
		{
			// GO UP
			ACT_ActionSet( RM_Act_AccrochUp)
		}				
		break
	case RM_Act_AccrochUp :
		if ( ACT_ActionFinished())
		{
			if ( ! i_keep_hierarchy)
				OBJ_HierarchyReset()
			f_ground_timer = 0.1	// RM un poil au dessus du dsol mais bon ne pas sauter
			i_ground_flag = vrai
			MOVE_CHANGE_To_Default()
			goto GO_TO_MAIN
		}
		if ( ! OBJ_HierarchyGet())
			OBJ_HierarchySet( o_climb_WP)
		
		ti_pos = faux

		break
}
		
if ( ti_pos)
{
	if ( MATH_VecDotProduct( @o_climb_WP OBJ_BankingGet(), Cv_VerticalVector) < Cf_Cos45 )
	{
		// TROP PENCHE: 2 CAS
		if ( MATH_VecDotProduct( @o_climb_WP OBJ_SightGet(), Cv_VerticalVector) > 0.0)
		{
			MOVE_CHANGE_To_Default()
			goto GO_TO_MAIN
		}
		else
		{
			MOVE_CHANGE_To_Jump(cvector(0.0,0.0, -5.0), faux, vrai)
			goto GO_TO_MAIN
		}
	}
	else
	{
		
		tv_banking = MATH_FloatMax( MATH_VecDotProduct( Cv_VerticalVector, @o_climb_WP OBJ_SightGet()), 0.0) * @o_climb_WP OBJ_SightGet()
		tv_banking += MATH_FloatMax( MATH_VecDotProduct( Cv_VerticalVector, @o_climb_WP OBJ_BankingGet()), 0.0) * @o_climb_WP OBJ_BankingGet()
		tv_banking += MATH_VecDotProduct( Cv_VerticalVector, @o_climb_WP OBJ_HorizonGet()) * @o_climb_WP OBJ_HorizonGet()
		
		OBJ_BankingGeneralSet( MATH_VecBlend(OBJ_SightGet(), @o_climb_WP OBJ_SightGet(), 12.0 * TIME_GetDt()), tv_banking)			
		
	
		v_climb_hand_offset = MATH_VecLocalToGlobal( v_anim_hand_accroch_offset)	// Décor en mouvement
		OBJ_PosSet( MATH_VecBlend(OBJ_PosGet(), @o_climb_WP OBJ_PosGet() - v_climb_hand_offset, MATH_FloatMin( f_time_start_etat * 3.0,  1.0)))
	}
}


return

GO_TO_MAIN:
AI_TrackCurChange("raym_ETAT_main")

