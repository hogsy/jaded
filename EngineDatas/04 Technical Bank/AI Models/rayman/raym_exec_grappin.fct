#include "r_defines.var"

int			ti_i
int			ti_GMAT
int			ti_tracte
int			ti_count
int			ti_break
int			ti_string_ID
int			ti_rope_index
int			ti_force_cpu_lray

float		tf_dist
float		tf_norm
float		tf_friction
float		tf_speed
float		tf_dist_renormalisation
float		tf_temp
float		tf_rope_length_blend
float		tf_rope_length_blend_inc

vector	tv_pos
vector	tv_temp
vector	tv_temp1
vector	tv_temp2
vector	tv_sight
vector	tv_speed
vector	tv_grappin_destpos
vector	tv_dir
vector	tv_dirN
vector	tv_force
vector	tv_friction
vector	tv_add
vector	tv_grappin_pos
vector	tv_pos1
vector	tv_horizon_ground
vector	tv_grappin_speed

object	to_main
object	to_obj
object	to_obj1
object	to_obj2
object	to_tete
object	to_torse

string		str_color

// CHECK NMI GRAPPIN DODGE ?
if( ! i_grappin_nmi_dodges )
	i_grappin_nmi_dodges = GRAPPIN_EnnemiDodge(o_grappin_hotspot)

if( ! i_grappin_nmi_protects )
	i_grappin_nmi_protects = GRAPPIN_EnnemiProtege(o_grappin_hotspot)

i_grappin_tiptop_nb = 0

// CREATION DU GRAPPIN -------------------------------------------------------------------------------------------------
if( i_grappin_must_be_launched 
	&& ACT_ActionGet() == RM_Act_Grappin_Launch 
	&& ANI_CurrentFrameGet(0) >= Ci_Grappin_FrameLance )
{
	
	// POSITION
	if( PROC_RM_ModeLookON() )
		tv_pos = @get_camera OBJ_PosGet()
	else
	{
		to_obj = ANI_CanalObjectGet(Anim_Canal_MainGauche)
		tv_pos = @to_obj OBJ_PosGet()
		to_torse = ANI_CanalObjectGet(Anim_Canal_Torse)
		if( COL_RayObject_Vector( @to_torse OBJ_PosGet(), tv_pos - @to_torse OBJ_PosGet(), all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable) )
			tv_pos = COL_RayObject_PosGet()
	}
	o_grappin = @o_Punch OBJ_Duplicate(tv_pos)
	SND_RequestPlay(C_SND_Lance_Grappin )
	if ( i_SND_Grappin )
	{
		SND_Destroy(i_SND_Grappin )
		i_SND_Grappin =0
	}
	i_SND_Grappin = SND_RequestPlayLoop(C_SND_Loop_Grappin)
	
	// ORIENTATION
	if( o_grappin_hotspot )
		v_grappin_launch_axis = HotSpot_PosGet(o_grappin_hotspot) - @o_grappin OBJ_PosGet()
	else if( i_ground_flag && ! PROC_RM_ModeLookON() )
	{
		// pas de hotspot, au sol et pas en look = lancer selon la pente
		tv_horizon_ground = MATH_VecCrossProduct(v_ground_normale, v_grappin_lance_memo_dir)
		v_grappin_launch_axis = MATH_VecCrossProduct(tv_horizon_ground, v_ground_normale)
		v_grappin_launch_axis = MATH_VecBlendRotate(v_grappin_lance_memo_dir, v_grappin_launch_axis, 0.5)
	}
	else
		v_grappin_launch_axis = v_grappin_lance_memo_dir		// pas de hotspot, en l'air ou en look -> axe mémorisé
	MATH_VecSetNormalize(v_grappin_launch_axis)
	@o_grappin OBJ_SightGeneralSet(v_grappin_launch_axis, - Cv_VerticalVector)
	
	// INIT GRAPPIN VARS
	f_grappin_zoom = Cf_grappin_zoom_init
	@o_grappin OBJ_ZoomSet(f_grappin_zoom)
	@o_grappin DYN_On()
	@o_grappin DYN_FlagsSet(DYN_C_BasicForces, none)
	@o_grappin DYN_GravitySet(Cv_NullVector)
	@o_grappin DYN_FrictionVectorSet(Cv_NullVector)
	@o_grappin DYN_TractionSet(Cv_NullVector)
	f_grappin_blend = 0.0
	f_grappin_life = 0.0
	f_grappin_nolife = 0.0
	f_grappin_rebound = 0.0
	v_grappin_rebound_dir = Cv_NullVector
	v_grappin_accroche_offset = Cv_NullVector
	v_grappin_accroche_dir = Cv_NullVector
	i_grappin_rebound = faux
	i_grappin_created = vrai
	i_grappin_accroche = faux		// not yet
	i_grappin_retour = faux
	i_grappin_must_be_launched = faux		// not yet
	f_grappin_collision_timer = 0.0
	f_grappin_speed = Cf_Grappin_Speed_Launch_Init + ( 10.0 * f_speed_hor )
	v_grappin_normale = Cv_NullVector		// on n'est pas planté dans un mur
	to_obj = ANI_CanalObjectGet(RM_Canal_Grappin)
	v_grappin_last_pos = @to_obj OBJ_PosGet() - OBJ_SightGet()
	i_grappin_mur = faux
	i_grappin_snap_to_dest = faux
	i_grappin_mur_accroch_mode = faux
	i_grappin_nmi_dodges = faux
	i_grappin_nmi_protects = faux
	// RAZ GFX
	i_grappin_gfx = -1
	for( ti_i = 0; ti_i < Ci_Grappin_TipTopNb; ti_i++ )
		ai_grappin_gfx[ti_i] = -1
	for (ti_i = 0; ti_i < Ci_Grappin_Corde_Segments_Nb; ti_i++)
		ai_grappin_gfx_corde[ti_i] = -1
	// GFX Matth
	to_obj = ANI_CanalObjectGet(RM_Canal_Grappin)
	v_grappin_gfx_corde_B_pos = @to_obj OBJ_PosGet()
	v_grappin_gfx_corde_B_speed = Cv_NullVector
	v_grappin_gfx_corde_C_pos = @to_obj OBJ_PosGet()
	v_grappin_gfx_corde_C_speed = Cv_NullVector
}

// GESTION LANCER / ACCROCHE / RETOUR -----------------------------------------------------------------------------
if( o_grappin )
{
//	if( ! i_grappin_retour && f_grappin_collision_timer > Cf_grappin_time_break_max )
//		GRAPPIN_Return()
	
	// Ennemi Grappiné just died -> grappin return ------------------------------------------------------------------------------
	if( @get_global i_grappin_hotspot_nmi_died )
	{
//		@get_global i_grappin_hotspot_nmi_died = faux			// RESETED PAR LE GLOBAL
//		DBG_TraceString("Grappin revient (nmi died)\n")
		GRAPPIN_Return()
	}
	
	// ZOOM --------------------------------------------------------------------------------------------------------------------------------
	if( i_grappin_retour )
		f_grappin_zoom = MATH_FloatBlend(f_grappin_zoom, Cf_grappin_zoom_init, 5.0 * TIME_GetDt())
	else
		f_grappin_zoom = MATH_FloatBlend(f_grappin_zoom, Cf_grappin_zoom_max, 5.0 * TIME_GetDt())
	@o_grappin OBJ_ZoomSet(f_grappin_zoom)
	
	if( i_grappin_retour )
	{
		// LE GRAPPIN EST EN TRAIN DE REVENIR ===============================================================
		GRAPPIN_RETOUR:
		f_grappin_nolife += TIME_GetDt()
		to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
		tv_dir = @to_main OBJ_PosGet() - @o_grappin OBJ_PosGet()
		if( f_grappin_nolife > 0.02 )
		{
			DBG_RenderVector(@o_grappin OBJ_PosGet(), tv_dir, color_jaune)
			tf_dist = MATH_VecNorm(tv_dir)
			tv_dir /= tf_dist
			if( tf_dist < 2.0 )
			{
				// le grappin revenu près de rayman -> destroy
				GRAPPIN_Destroy()
				goto END_OF_GRAPPIN
			}
			else
			{
				tv_temp1 = v_grappin_return_startpos - @to_main OBJ_PosGet()
				tv_temp2 = @o_grappin OBJ_PosGet() - @to_main OBJ_PosGet()
				DBG_RenderVector(@o_grappin OBJ_PosGet(), tv_temp1, color_jaune)
				DBG_RenderVector(@o_grappin OBJ_PosGet(), tv_temp2, color_rouge)
				if( MATH_VecDotProduct(tv_temp1, tv_temp2) < 0 )
				{
					// le grappin est passé dans mon dos -> destroy
					GRAPPIN_Destroy()
					goto END_OF_GRAPPIN
				}
			}
		}
		
		// GRAPPIN SPEED 
		f_grappin_speed = MATH_FloatBlend(f_grappin_speed, Cf_Grappin_Speed_Return, 15 * TIME_GetDt())
		v_grappin_launch_axis = MATH_VecNormalize(@to_main OBJ_PosGet() - @o_grappin OBJ_PosGet())
	}
	else if( i_grappin_rebound )
	{
		// MON GRAPPIN REBONDIT SUR LE BOUCLIER DE MON ENNEMI =============================================
		GRAPPIN_REBOUND:
		if( MATH_VecNullToler(v_grappin_rebound_dir, 0.01) )
		{
			// direction de rebond
			v_grappin_rebound_dir = cvector(MATH_RandFloat(-1.0,1.0),MATH_RandFloat(0,1.0),MATH_RandFloat(0,1.0))
			MATH_VecSetNormalize(v_grappin_rebound_dir)
			v_grappin_rebound_dir = MATH_VecLocalToGlobal(v_grappin_rebound_dir)
			DBG_RenderVector(@o_grappin OBJ_PosGet(), v_grappin_rebound_dir, color_rouge)
			v_grappin_launch_axis = v_grappin_rebound_dir
		}

		f_grappin_rebound += TIME_GetDt()
		if( f_grappin_rebound > 0.25 )
		{
//			DBG_TraceString("Grappin revient (après rebond sur bouclier)\n")
			GRAPPIN_Return()
			goto GRAPPIN_RETOUR
		}

		// GRAPPIN SPEED 
		f_grappin_speed = MATH_FloatBlend(f_grappin_speed, Cf_Grappin_Speed_Return, 15 * TIME_GetDt())
	}
	else if( i_grappin_accroche )
	{
		// MON GRAPPIN EST PLANTE DANS UN HOTSPOT OU UN DECOR ============================================
		if( f_grappin_collision_timer > Cf_grappin_time_break_max )
			GRAPPIN_Return()

		// le grappin exerce-t-il une traction sur rayman ? 
		to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
		tv_pos = @to_main OBJ_PosGet()
		tv_dir = @o_grappin OBJ_PosGet() - tv_pos
		tf_dist = MATH_VecNorm(tv_dir)
		tv_dirN = tv_dir / tf_dist
		
		if( tf_dist > f_grappin_dist_min_traction )
			v_grappin_orient = @o_grappin OBJ_PosGet() - OBJ_PosGet()		// Axe pour modifier le joy dans la track end
		
		// GRAPPIN SPEED
		f_grappin_speed = 0.0
	}
	else
	{
		f_grappin_speed = MATH_FloatBlend(f_grappin_speed, Cf_Grappin_Speed_Launch_Init, 5 * TIME_GetDt())
		
		// MON GRAPPIN EST LANCE MAIS IL N'EST PAS ENCORE PLANTE NI EN RETOUR ================================
		f_grappin_life += TIME_GetDt()
		if( o_grappin_hotspot )
		{
			// GRAPPIN LOCKE SUR UN HOTSPOT ----------------------------------------------
			if( i_grappin_nmi_protects )
			{
				// mon ennemi se protège de mon grappin avec un bouclier
				i_grappin_rebound = vrai
				goto GRAPPIN_REBOUND
			}
			else if( i_grappin_nmi_dodges )
			{
				// mon ennemi dodge mon grappin
				to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
				tv_dir = @o_grappin OBJ_PosGet() - @to_main OBJ_PosGet()
				tf_dist = MATH_VecNorm(tv_dir)
				if( tf_dist > f_grappin_lancer_distmax )
				{
//					DBG_TraceString("Grappin revient (dist max launch = ")
//					DBG_TraceInt(f_grappin_lancer_distmax)
//					DBG_TraceString(" m)\n")
					GRAPPIN_Return()
					goto GRAPPIN_RETOUR
				}
			}
			else
			{
				// mon ennemi est sans défense je fonce vers lui
				tv_dir = HotSpot_PosGet(o_grappin_hotspot) - @o_grappin OBJ_PosGet()
				tf_dist = MATH_VecNorm(tv_dir)
				v_grappin_launch_axis = MATH_VecNormalize(tv_dir)
				ti_force_cpu_lray = faux
				if( tf_dist < 0.1 )		// dist entre grappin et hotspot
				{
					i_grappin_accroche = vrai			// lray detection -> set hot spot too close from grappin -> force accorche
					f_grappin_blend = 1.0
					ti_force_cpu_lray = vrai
				}
				else
				{
					tv_dir /= tf_dist
					if( tf_dist < 5.0 || f_grappin_blend )		// passer à proximité du hotspot déclenche le téléguidage
					{
						// téléguidage
						f_grappin_blend += MATH_FloatMin(1.0 - f_grappin_blend, 5 * TIME_GetDt())
						if( f_grappin_blend == 1.0 )
						{
							i_grappin_accroche = vrai
							ti_force_cpu_lray = vrai
						}
					}
				}
				
				// FORCER UN TEST LRAY DANS LE CAS D'UNE BOX POUR CHOPPER SA COLMAP
				if( ti_force_cpu_lray )
				{
					if( @o_grappin_hotspot OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) && @o_grappin_hotspot AI_IsModel(get_RM_Box_path) && ! @o_grappin_hotspot Proc_Box_Explosive())
					{
						i_grappin_accroche = faux
						to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
						v_grappin_last_pos = @to_main OBJ_PosGet()
						goto TEST_LRAY
					}
					else
						GRAPPIN_SePlante()
				}
			}
		}
		else
		{
			// GRAPPIN SANS HOTSPOT -------------------------------------------------------
			to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
			tv_dir = @o_grappin OBJ_PosGet() - @to_main OBJ_PosGet()
			tf_dist = MATH_VecNorm(tv_dir)
			if( tf_dist > f_grappin_lancer_distmax )
			{
//				DBG_TraceString("Grappin revient (dist max launch = ")
//				DBG_TraceInt(f_grappin_lancer_distmax)
//				DBG_TraceString(" m)\n")
				GRAPPIN_Return()
				goto GRAPPIN_RETOUR
			}
		}
			
		
		// CHECK COLLISIONS =================================================================================
		TEST_LRAY:
		tv_grappin_pos = @o_grappin OBJ_PosGet()
		tv_dir = tv_grappin_pos - v_grappin_last_pos
		tf_dist = MATH_VecNorm(tv_dir)
		if( ! i_grappin_retour
			&& ! i_grappin_rebound
			&& ! i_grappin_accroche )
		{
			tv_dir /= tf_dist
			GRAPPIN_SetRayInsensitive(vrai)
			DBG_RenderVector(v_grappin_last_pos, tv_dir * tf_dist, color_vert)
			COL_SpecificCrossableSet(Gmat_RM_Crossable_Default | Gmat_RM_Crossable_Grappin)
			to_obj = COL_RayObject_Dist(v_grappin_last_pos, tv_dir, tf_dist, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable + COL_C_Ray_use_SpecificCrossableSet)
			if( to_obj )
			{
				ti_GMAT = COL_GMAT_FlagsGet( COL_C_Ray)
				if( ! (ti_GMAT & Gmat_RM_Ice) )
				{
					if( ! f_grappin_blend || ( @to_obj OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) && @to_obj AI_IsModel(get_RM_Box_path) ) )
					{
						// c'est une caisse ou alors je ne suis pas encore en téléguidage hotspot
						tv_pos1 = COL_RayObject_PosGet()
						tv_temp1 = COL_RayObject_NormalGet()
						DBG_RenderVector(tv_pos1, tv_temp1, color_rouge)
						if( @to_obj OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_AI) && @to_obj AI_IsModel(get_RM_Box_path) )
						{
							// je touche la colmap d'une caisse -> je choppe le hotspot mais je reste planté au point de collision
							v_grappin_accroche_offset = tv_pos1 - @to_obj OBJ_PosGet()
							v_grappin_accroche_dir = @to_obj MATH_VecGlobalToLocal(- tv_temp1)
							i_grappin_accroche = vrai
							DBG_RenderVector(@to_obj OBJ_PosGet(), v_grappin_accroche_offset, color_cyan)
							MATH_VecSetNorm(v_grappin_accroche_offset, MATH_VecNorm(v_grappin_accroche_offset) + 0.2)
							DBG_RenderVector(@to_obj OBJ_PosGet(), v_grappin_accroche_offset, color_cyan)
							v_grappin_accroche_offset = @to_obj MATH_VecGlobalToLocal(v_grappin_accroche_offset)
							o_grappin_hotspot = to_obj
							OBJ_RegisterKill( o_grappin_hotspot, &o_grappin_hotspot)
							GRAPPIN_SePlante()
						}
						else
						{
//							// je touche une colmap
//							if( tv_temp1.z > Cf_Cos45 || (COL_GMAT_FlagsGet(COL_C_Ray) & Gmat_RM_VarapInterdit))
//							{
////								DBG_TraceString("Grappin revient (sol)\n")
								GRAPPIN_Return()			// si je touche un sol
//							}
//							else
//							{
//								// si je touche un mur
//								@o_grappin_dup_wp OBJ_HierarchySet(to_obj)
//								@o_grappin_dup_wp OBJ_PosSet(tv_pos1)
//								o_grappin_hotspot = o_grappin_dup_wp
//								v_grappin_launch_axis = @o_grappin_hotspot OBJ_PosGet() - v_grappin_last_pos
//								v_grappin_normale = COL_RayObject_NormalGet()
//								i_grappin_accroche = vrai
//								f_grappin_blend = 1.0
//								GRAPPIN_SePlante()
//							}
						}
					}
				}
				else
				{
//					DBG_TraceString("Grappin revient (GMAT non valide)\n")
					GRAPPIN_Return()
				}
			}
			GRAPPIN_SetRayInsensitive(faux)
		}
	}
	
	// GRAPPIN SPEED ---------------------------------------------------------------------------------------------------------
//	@o_grappin DYN_SpeedSetVector(v_grappin_speed)
}
else
	i_grappin_snap_to_dest = faux


// SNAP TO HOTSPOT ----------------------------------------------------------------------------------------------------------------------------
to_main = ANI_CanalObjectGet(Anim_Canal_MainGauche)
@to_main OBJ_FlagInvisibleSet(faux)
if( o_grappin )
{
//	@to_main OBJ_FlagInvisibleSet(vrai)		// si j'ai lancé le grappin alors la main droite est désactivée
	// POSITION
	if( o_grappin_hotspot && ! i_grappin_nmi_dodges && ! i_grappin_nmi_protects && ! i_grappin_retour )
	{
		if( ! MATH_VecNullToler(v_grappin_accroche_offset, 0.01) )
		{
			tv_pos = @o_grappin_hotspot OBJ_PosGet()
			tv_pos += @o_grappin_hotspot MATH_VecLocalToGlobal(v_grappin_accroche_offset)
			@o_grappin OBJ_PosSet(tv_pos)
			@o_grappin OBJ_SightGeneralSet(v_grappin_accroche_dir, - Cv_VerticalVector)
			if( @"univ" i_cheat_page == 1 && @get_global i_DBG_Grappin )
				Str_DisplayTextOnce("pos accroche", cvector(0.8,0.9,0))
		}
		else if( f_grappin_blend )
		{
			tv_grappin_destpos = HotSpot_PosGet(o_grappin_hotspot)
			tv_pos = MATH_VecBlend(@o_grappin OBJ_PosGet(), tv_grappin_destpos, f_grappin_blend)
			@o_grappin OBJ_PosSet(tv_pos)
			if( @"univ" i_cheat_page == 1 && @get_global i_DBG_Grappin )
				Str_DisplayTextOnce("pos blend", cvector(0.8,0.9,0))
		}
	}
	// ORIENTATION
	if( i_grappin_retour || i_grappin_nmi_dodges || i_grappin_nmi_protects )
	{
		goto ORIENT_DEFAULT
	}
	else if( ! MATH_VecNullToler(v_grappin_normale, 0.01) )
	{
		tv_temp = @to_main OBJ_PosGet() - @o_grappin OBJ_PosGet()
		tv_temp = MATH_VecInCone(tv_temp, v_grappin_normale, Cf_PiBy2, 0)
		@o_grappin OBJ_SightGeneralSet(- tv_temp, - Cv_VerticalVector)
		@o_grappin DYN_SpeedSetVector(Cv_NullVector)
		if( @"univ" i_cheat_page == 1 && @get_global i_DBG_Grappin )
			Str_DisplayTextOnce("sight mur normale", cvector(0.8,0.95,0))
	}
	else if( ! MATH_VecNullToler(v_grappin_accroche_dir, 0.01) )
	{
		if ( ! o_grappin_hotspot)
			GRAPPIN_Return()
		else
		{
			@o_grappin OBJ_SightGeneralSet(@o_grappin_hotspot MATH_VecLocalToGlobal(v_grappin_accroche_dir), - Cv_VerticalVector)
			@o_grappin DYN_SpeedSetVector(Cv_NullVector)
			if( @"univ" i_cheat_page == 1 && @get_global i_DBG_Grappin )
				Str_DisplayTextOnce("sight accroche", cvector(0.8,0.95,0))
		}
	}
	else
	{
		ORIENT_DEFAULT:
		@o_grappin OBJ_SightGeneralSet(MATH_VecBlendRotate(OBJ_SightGet(), v_grappin_launch_axis, 5 * TIME_GetDt()), - Cv_VerticalVector)
		@o_grappin DYN_SpeedSetVector(v_grappin_launch_axis * f_grappin_speed)
		if( @"univ" i_cheat_page == 1 && @get_global i_DBG_Grappin )
			Str_DisplayTextOnce("sight default", cvector(0.8,0.95,0))
	}
	v_grappin_last_pos = @o_grappin OBJ_PosGet()
}


END_OF_GRAPPIN:

// ROPE MANAGER ================================================================
if( i_grappin_accroche )
{
	// Appliquer la traction à ma monture si je grappine (tout sauf un item)
	to_obj = OBJ_Me()
	if( ! @o_grappin_hotspot AI_IsModel(get_RM_Weapon_path) )
	{
		to_obj = PROC_RM_MontureGet()
		if( ! to_obj )
			to_obj = OBJ_Me()
	}	

	// Détection acrroché dans un mur
	if( ! i_grappin_mur
	&& ! MATH_VecNullToler(v_grappin_normale, 0.01) 	// dans un mur ou un sol
	&& v_grappin_normale.z < Cf_Cos45 		// pas le sol
	&& v_grappin_normale.z > - Cf_Cos45 ) 	// pas le plafond
	{
		i_grappin_mur = vrai
	}

	if( ! i_ground_flag 														// rayman pas au sol
	&& i_move_mode != C_Move_Rider 							// rayman pas en ride
	&& ( i_grappin_mur 													// On a chopé un MUR spiderman
	|| ( PROC_RM_IS_MOUNT( o_grappin_hotspot) && PROC_RM_IS_MOUNT_GAO_TAMED(o_grappin_hotspot))))		// On a chopé une monture
	{
		i_grappin_snap_to_dest = vrai								// SNAP TO TARGET
		i_jump_copter = faux
		if ( ! i_grappin_mur )
			RM_Proc_Uncol_Add( o_grappin_hotspot) // C'est une monture
	}
	
	// compute rope lenght & rope traction coef
	tf_dist_renormalisation = GRAPPIN_ComputeRopeDistRenormalisation(o_grappin_hotspot, tf_rope_length_blend)
	f_rope_coef = GRAPPIN_ComputeRopeTractionCoef(o_grappin_hotspot)
	ti_rope_index = @o_rope_manager Rope_Manager_Get_Corde_Index(o_grappin_start_actor, o_grappin_dest_actor)
	
	o_grappin_start_actor = to_obj
	o_grappin_dest_actor = o_grappin_hotspot

	// Add to rope manager
	if( ti_rope_index == -1 )
		ti_rope_index = @o_rope_manager Rope_Manager_Add(o_grappin_start_actor, o_grappin_dest_actor, tf_dist_renormalisation, tf_rope_length_blend, f_rope_coef)
	
	// Passage en mode Grappin Accroch Mur ????
	if( i_grappin_mur
		&& ! i_grappin_mur_accroch_mode
		&& @o_rope_manager Rope_Manager_RopeLengthGet(ti_rope_index) == Cf_grappin_mur_accroch_length )
			i_grappin_mur_accroch_mode = vrai
	
	// Update infos !!!
	if ( PROC_RM_Type_HotspotGet() == C_HS_Type_Crochet && ! i_ground_flag)
	{
		@o_rope_manager Rope_Manager_ModeSet(ti_rope_index, C_Rope_Mode_Tige)
		tf_rope_length_blend_inc = 2.5
	}
	else
	{
		@o_rope_manager Rope_Manager_ModeSet(ti_rope_index, C_Rope_Mode_Corde)
		tf_rope_length_blend_inc = tf_rope_length_blend
	}
	@o_rope_manager Rope_Manager_Update(ti_rope_index, o_grappin_start_actor, o_grappin_dest_actor, tf_dist_renormalisation, f_rope_coef, tf_rope_length_blend_inc, tf_rope_length_blend)
	f_rope_length = tf_dist_renormalisation

	@o_rope_manager Rope_Manager_Enable_Offset(ti_rope_index, vrai, @o_grappin_start_actor MATH_VecGlobalToLocal(OBJ_PosGet() + Cv_VerticalVector - @o_grappin_start_actor OBJ_PosGet()), vrai, @o_grappin_dest_actor MATH_VecGlobalToLocal(@o_grappin OBJ_PosGet() - @o_grappin_dest_actor OBJ_PosGet()))

	// Get weapon and cancel grappin
	if( @o_grappin_hotspot AI_IsModel(get_RM_Weapon_path) ) // && o_grab_object == o_grappin_hotspot )
	{
//		if( OBJ_SqrDist(o_grappin_hotspot) < 4.0 )
//			GRAPPIN_Destroy()		// l'item est à moi
//		else 
		if( o_grappin_hotspot == o_grab_object )
			GRAPPIN_Destroy()		// l'item est à moi
		else if( @o_grappin_hotspot OBJ_CapaTest(RM_WEAPON_CAPA_GRABBED) )
		{
			if( @get_RM_Weapon_path o_grappin_hotspot o_serveur_grab == OBJ_Me() )
				GRAPPIN_Destroy()		// l'item est à moi
			else
				GRAPPIN_Return()		// l'item s'est fait grabber par quelqu'un d'autre
		}
	}
}
else if (o_grappin_start_actor && o_grappin_dest_actor)
{
	// Suppression de l'indice dans le rope manager
	ti_rope_index = @o_rope_manager Rope_Manager_Get_Corde_Index(o_grappin_start_actor , o_grappin_dest_actor)
	if( ti_rope_index != -1 )
		ti_rope_index = @o_rope_manager Rope_Manager_Del(ti_rope_index)
		
	o_grappin_start_actor = nobody
	o_grappin_dest_actor = nobody
}

