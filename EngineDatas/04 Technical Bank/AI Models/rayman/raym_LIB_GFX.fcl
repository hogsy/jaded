#include "r_defines.var"


procedure_local void Proc_RM_GFX_Smoke()
{
	int		ti_GFX_Smoke	
	int		ti_terrain
	
	float		tf_speed

	vector	tv_pos
	vector	tv_wind
	vector	tv_pos_dir

	if (f_speed_hor < 2.0 && i_ground_flag)
		return

	tv_pos_dir = DYN_SpeedGetVector()
	tf_speed = MATH_VecNorm(tv_pos_dir)

	if (tf_speed > 1.0)
	{
		tv_pos_dir /= tf_speed
		tf_speed = MATH_FloatMin(tf_speed, 10.0)
	}
	else
	{
		tf_speed = 2.0
		tv_pos_dir = OBJ_SightGet()
	}

	tv_pos_dir *= 5.0

	{
		ti_GFX_Smoke = GFX_Add(13)															// Create the boum
		
		GFX_MaterialSet(ti_GFX_Smoke, get_SFX_light_and_smoke, -1)						// met le materiau
		GFX_Seti(ti_GFX_Smoke, 13101, 8)													// Materiau 0

		GFX_Seti(ti_GFX_Smoke, 13100, 5)													// *Buffer number of sprite
		GFX_Seti(ti_GFX_Smoke, 13106, 5)													// *number of sprite to generate
	
		GFX_Setf(ti_GFX_Smoke, 13003, 0.8)													// Time fase 1
		GFX_Setf(ti_GFX_Smoke, 13004, 1.75)												// Time fase 2
	
		GFX_Seti(ti_GFX_Smoke, 13107, 0)													// Sprites non triés
		GFX_FlagSet(ti_GFX_Smoke, 0 , 1)
		GFX_FlagSet(ti_GFX_Smoke, 2 , 1)
		
		GFX_Setf(ti_GFX_Smoke, 13012, 0.75)												// Time random
	
		GFX_Setf(ti_GFX_Smoke, 13005, 0.4)													// Creation size min
		GFX_Setf(ti_GFX_Smoke, 13006, 0.8)													// Creation size max
		
		GFX_Setv(ti_GFX_Smoke, 13201, tv_pos_dir + cvector(-1.0, -1.0, -1.0))							// Speed min
		GFX_Setv(ti_GFX_Smoke, 13202, tv_pos_dir + cvector(1.0, 1.0, 1.0))								// Speed max
		GFX_Setf(ti_GFX_Smoke, 13009, tf_speed * 0.75)							// Norm speed min
		GFX_Setf(ti_GFX_Smoke, 13010, tf_speed * 1.25)									// Norm speed max
		GFX_Setv(ti_GFX_Smoke, 13203, cvector(0.008, 0.008, 0.05))					// friction speed
		GFX_Setf(ti_GFX_Smoke, 13000, 0.5)														// Growing speed min
		GFX_Setf(ti_GFX_Smoke, 13001, 1.0)														// Growing speed max
		GFX_Setf(ti_GFX_Smoke, 13002, 0.0001)													// Friction Grow

		GFX_Setf(ti_GFX_Smoke, 13007, 0.0)														// Gravity

		GFX_Seti(ti_GFX_Smoke, 13103, COLOR_Blend(0x204FB9BD, 0x60000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 0
		GFX_Seti(ti_GFX_Smoke, 13104, COLOR_Blend(0x104FB9BD, 0x20000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 1
		GFX_Seti(ti_GFX_Smoke, 13105, COLOR_Blend(0x00879E8B, WOR_AmbiantColGet(0) & 0x00FFFFFF, 0.5))	// Color fase 2
		
		GFX_Setf(ti_GFX_Smoke, 13008, 0.001)														// generation rate
	
		GFX_Setv(ti_GFX_Smoke, 13205, Cv_NullVector)										// Mainposspeed
		GFX_Setv(ti_GFX_Smoke, 13206, Cv_NullVector)										// Mainpossfriction
	}
	
	tv_wind = Cv_NullVector
	GFX_Setv(ti_GFX_Smoke, 13204, tv_wind)												// wind

	tv_pos = OBJ_PosGet()
	tv_pos -= tv_wind * TIME_GetDt()
	GFX_Setv(ti_GFX_Smoke, 13200, tv_pos) 								// Creation Pos
	GFX_Setv(ti_GFX_Smoke, 13207, cvector(0.5, 0.0, 0.0))	// CreaPosAxe X
	GFX_Setv(ti_GFX_Smoke, 13208, cvector(0.0, 0.5, 0.0))	// CreaPosAxe Y
	GFX_Setv(ti_GFX_Smoke, 13209, cvector(0.0, 0.0, 0.25))	// CreaPosAxe Z
}

procedure_local void Proc_RM_GFX_GlisseMur()
{
	int		ti_GFX_Smoke	
	int		ti_terrain
	
	float		tf_speed

	vector	tv_pos
	vector	tv_wind
	vector	tv_pos_dir

	tv_pos_dir = DYN_SpeedGetVector()
	tf_speed = MATH_VecNorm(tv_pos_dir)

	if (tf_speed > 1.0)
	{
		tv_pos_dir /= tf_speed
		tf_speed = MATH_FloatMin(tf_speed, 10.0)
	}
	else
	{
		tf_speed = 2.0
		tv_pos_dir = OBJ_SightGet()
	}

	tv_pos_dir *= 5.0

	{
		ti_GFX_Smoke = GFX_Add(13)																// Create the boum
		
		GFX_MaterialSet(ti_GFX_Smoke, get_SFX_light_and_smoke, -1)						// met le materiau
		GFX_Seti(ti_GFX_Smoke, 13101, 8)															// Materiau 0

		GFX_Seti(ti_GFX_Smoke, 13100, 5)															// *Buffer number of sprite
		GFX_Seti(ti_GFX_Smoke, 13106, 5)														// *number of sprite to generate
	
		GFX_Setf(ti_GFX_Smoke, 13003, 0.1)														// Time fase 1
		GFX_Setf(ti_GFX_Smoke, 13004, 0.75)													// Time fase 2
	
		GFX_Seti(ti_GFX_Smoke, 13107, 0)														// Sprites non triés
	
		GFX_FlagSet(ti_GFX_Smoke, 0 , 1)
		GFX_FlagSet(ti_GFX_Smoke, 2 , 1)
		
		GFX_Setf(ti_GFX_Smoke, 13012, 0.75)													// Time random
	
		GFX_Setf(ti_GFX_Smoke, 13005, 0.1)														// Creation size min
		GFX_Setf(ti_GFX_Smoke, 13006, 0.2)														// Creation size max
		
		GFX_Setv(ti_GFX_Smoke, 13201, tv_pos_dir + cvector(-0.00, -0.00, -0.0))							// Speed min
		GFX_Setv(ti_GFX_Smoke, 13202, tv_pos_dir + cvector(0.00, 0.00, 1.0))								// Speed max
		GFX_Setf(ti_GFX_Smoke, 13009, tf_speed * 0.75)							// Norm speed min
		GFX_Setf(ti_GFX_Smoke, 13010, tf_speed * 1.25)									// Norm speed max
		GFX_Setv(ti_GFX_Smoke, 13203, cvector(0.008, 0.008, 0.05))					// friction speed
		GFX_Setf(ti_GFX_Smoke, 13000, 0.5)														// Growing speed min
		GFX_Setf(ti_GFX_Smoke, 13001, 1.0)														// Growing speed max
		GFX_Setf(ti_GFX_Smoke, 13002, 0.0001)												// Friction Grow

		GFX_Setf(ti_GFX_Smoke, 13007, 0.0)														// Gravity

		GFX_Seti(ti_GFX_Smoke, 13103, COLOR_Blend(0x204FB9BD, 0x60000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 0
		GFX_Seti(ti_GFX_Smoke, 13104, COLOR_Blend(0x104FB9BD, 0x20000000 | (WOR_AmbiantColGet(0) & 0x00FFFFFF), 0.5))	// Color fase 1
		GFX_Seti(ti_GFX_Smoke, 13105, COLOR_Blend(0x00879E8B, WOR_AmbiantColGet(0) & 0x00FFFFFF, 0.5))	// Color fase 2
		
		GFX_Setf(ti_GFX_Smoke, 13008, 0.01)													// generation rate
	
		GFX_Setv(ti_GFX_Smoke, 13205, Cv_NullVector)										// Mainposspeed
		GFX_Setv(ti_GFX_Smoke, 13206, Cv_NullVector)										// Mainpossfriction
	}
	
	tv_wind = Cv_NullVector
	GFX_Setv(ti_GFX_Smoke, 13204, tv_wind)												// wind

	tv_pos = OBJ_PosGet()
	tv_pos -= tv_wind * TIME_GetDt()
	GFX_Setv(ti_GFX_Smoke, 13200, tv_pos) 								// Creation Pos
	GFX_Setv(ti_GFX_Smoke, 13207, cvector(0.25, 0.0, 0.0))	// CreaPosAxe X
	GFX_Setv(ti_GFX_Smoke, 13208, cvector(0.0, 0.25, 0.0))	// CreaPosAxe Y
	GFX_Setv(ti_GFX_Smoke, 13209, cvector(0.0, 0.0, 0.25))	// CreaPosAxe Z
}


procedure_local void Proc_RM_GFX_Splash(vector tv_pos, float	tf_factorZ)
{
            float                  tf_facteur
            int                    i_GFX_Splash1, i_GFX_Splash2

            i_GFX_Splash1 = GFX_Add( 13)
            GFX_MaterialSet( i_GFX_Splash1, get_SFX_light_and_smoke, -1)
            GFX_Seti( i_GFX_Splash1, 13101,45)                                                                                                                                                             // ID de material du SFX Lgt&Smk
            GFX_FlagSet( i_GFX_Splash1, 0 , 1)
            GFX_FlagSet( i_GFX_Splash1, 2 , 1)
            GFX_Seti( i_GFX_Splash1, 13100,25)                                                                                                                                                             // Nombre maxi de sprites
            GFX_Seti( i_GFX_Splash1, 13106,25)                                                                                                                                                             // Nombre de sprites à générer
            GFX_Setf( i_GFX_Splash1, 13003,0.400000)                                                                                                                             // duree de vie phase 1
            GFX_Setf( i_GFX_Splash1, 13004,0.55000)                                                                                                                                         // duree de vie phase 2 
            GFX_Setf( i_GFX_Splash1, 13012,0.750000)                                                                                                                             // Life time random
            GFX_Seti( i_GFX_Splash1, 13107,0)                                                                                                                                                               // Tri des sprites
            GFX_Setf( i_GFX_Splash1, 13000,0.3250000)                                                                                                                           // Vitesse de croissance min
            GFX_Setf( i_GFX_Splash1, 13001,0.900000)                                                                                                                             // Vitesse de croissance max
            GFX_Setf( i_GFX_Splash1, 13002,0.0100000)                                                                                                                           // Friction sur la croissance
            GFX_Setf( i_GFX_Splash1, 13005,0.100000)                                                                                                                             // Taille min à la création
            GFX_Setf( i_GFX_Splash1, 13006,0.800000)                                                                                                                             // Taille max à la création
            GFX_Setf( i_GFX_Splash1, 13007,-1.000000)                                                                                                                            // Gravité
            GFX_Setv( i_GFX_Splash1, 13203,cvector(0.10, 0.10, 0.10))                                                                   // Friction sur chaque axe
            GFX_Seti( i_GFX_Splash1 , 13103,0xB9FFFFFF)                                                                                                                     // Couleur phase 1
            GFX_Seti( i_GFX_Splash1 , 13104,0xB9FFFFFF)                                                                                                                     // Couleur phase 2
            GFX_Seti( i_GFX_Splash1 , 13105,0x00FFFFFF)                                                                                                                      // Couleur phase 3
            GFX_Setf( i_GFX_Splash1, 13009,-2.5000000)                                                                                                                          // Vitesse min
            GFX_Setf( i_GFX_Splash1, 13010,-5.000000)                                                                                                                            // Vitesse max
            GFX_Setf( i_GFX_Splash1, 13011,-1000)                                                                                                                                                         // Hauteur du sol
            GFX_Setv( i_GFX_Splash1, 13200, tv_pos + cvector(0.00000, 0.00000, 0.00000)) //Position de création
            GFX_Setv( i_GFX_Splash1, 13201,cvector(0.00000, 0.00000, -0.075000))             // Vitesse min sur chaque axe
            GFX_Setv( i_GFX_Splash1, 13202,cvector(0.00000, 0.00000, -0.175000))             // Vitesse max sur chaque axe
            GFX_Setv( i_GFX_Splash1, 13204,cvector(0.00000, 0.00000, 0.00000))                           // Vent
            GFX_Setv( i_GFX_Splash1, 13205,cvector(0.00000, 0.00000, 0.00000))                           // Vitesse de la position de création
            GFX_Setv( i_GFX_Splash1, 13206,cvector(0.00000, 0.00000, 0.00000))                           // Friction de la position
            tf_facteur = MATH_RandFloat(1.0,2.0)
            GFX_Setv( i_GFX_Splash1, 13207,0.150000 * OBJ_HorizonGet()*tf_facteur)         // Volume de création 1
            GFX_Setv( i_GFX_Splash1, 13208,0.150000 * OBJ_SightGet()*tf_facteur)             // Volume de création 2
            if ( MATH_FloatNullEpsilon( tf_factorZ))
            		tf_factorZ = tf_facteur
            GFX_Setv( i_GFX_Splash1, 13209,0.100000 * OBJ_BankingGet()*tf_factorZ)        // Volume de création 3
            GFX_Setf( i_GFX_Splash1, 13008,0.000000)                                                                                                                             // Taux de génération


            //------------------------------------------------------------------------------------------------------------------
            //------------------------------------------------------------------------------------------------------------------
            //                                                                     GENERATEUR DE PARCITULES 2
            //------------------------------------------------------------------------------------------------------------------
            //------------------------------------------------------------------------------------------------------------------

            i_GFX_Splash2 = GFX_Add( 13)
            GFX_MaterialSet( i_GFX_Splash2 , get_SFX_light_and_smoke, -1)
            GFX_Seti( i_GFX_Splash2 , 13101,45)                                                                                                                                                            // ID de material du SFX Lgt&Smk
            GFX_FlagSet( i_GFX_Splash2 , 0 , 1)
            GFX_FlagSet( i_GFX_Splash2 , 2 , 1)
            GFX_Seti( i_GFX_Splash2 , 13100,10)                                                                                                                              // Nombre maxi de sprites
            GFX_Seti( i_GFX_Splash2 , 13106,10)                                                                                                                              // Nombre de sprites à générer
            GFX_Setf( i_GFX_Splash2 , 13003,0.400000)                                                                                                                    // duree de vie phase 1
            GFX_Setf( i_GFX_Splash2 , 13004,0.750000)                                                                                                                    // duree de vie phase 2 
            GFX_Setf( i_GFX_Splash2 , 13012,0.750000)                                                                                                                    // Life time random
            GFX_Seti( i_GFX_Splash2 , 13107,0)                                                                                                                             	 // Tri des sprites
            GFX_Setf( i_GFX_Splash2 , 13000,0.45000)                                                                                                                      // Vitesse de croissance min
            GFX_Setf( i_GFX_Splash2 , 13001,2.00000)                                                                                                                      // Vitesse de croissance max
            GFX_Setf( i_GFX_Splash2 , 13002,0.0200000)                                                                                                                  // Friction sur la croissance
            GFX_Setf( i_GFX_Splash2 , 13005,0.10000)                                                                                                                     // Taille min à la création
            GFX_Setf( i_GFX_Splash2 , 13006,0.400000)                                                                                                                   // Taille max à la création
            GFX_Setf( i_GFX_Splash2 , 13007,-2.500000)                                                                                                                  // Gravité
            GFX_Setv( i_GFX_Splash2 , 13203,cvector(0.0750, 0.0750, 0.0150))                                      				// Friction sur chaque axe
            GFX_Seti( i_GFX_Splash2 , 13103,0xFFFFFFFF)                                                                                                                     // Couleur phase 1
            GFX_Seti( i_GFX_Splash2 , 13104,0xB9FFFFFF)                                                                                                                     // Couleur phase 2
            GFX_Seti( i_GFX_Splash2 , 13105,0x00FFFFFF)                                                                                                                      // Couleur phase 3
            if ( MATH_FloatNullEpsilon( tf_factorZ))
            		tf_factorZ = 2.5
            GFX_Setf( i_GFX_Splash2 , 13009,-tf_factorZ)                                                                                                                         // Vitesse min
            GFX_Setf( i_GFX_Splash2  , 13010,-tf_factorZ * 2.0)                                                                                                                // Vitesse max
            GFX_Setf( i_GFX_Splash2  , 13011,-1000)                                                                                                                                 // Hauteur du sol
            GFX_Setv( i_GFX_Splash2  , 13200, tv_pos + cvector(0.00000, 0.00000, 0.00000))           //Position de création
            if ( MATH_FloatNullEpsilon( tf_factorZ))
            {
	        GFX_Setv( i_GFX_Splash2 , 13201,cvector(0.00000, 0.00000, -0.15000))              // Vitesse min sur chaque axe
            GFX_Setv( i_GFX_Splash2 , 13202,cvector(0.00000, 0.00000, -0.35000))              // Vitesse max sur chaque axe
            }
            else
            {
	        GFX_Setv( i_GFX_Splash2 , 13201,cvector(0.00000, 0.00000, -0.15000))              // Vitesse min sur chaque axe
            GFX_Setv( i_GFX_Splash2 , 13202,cvector(0.00000, 0.00000, -0.35000))              // Vitesse max sur chaque axe
            }
            GFX_Setv( i_GFX_Splash2 , 13204,cvector(0.00000, 0.00000, 0.00000))               // Vent
            GFX_Setv( i_GFX_Splash2 , 13205,cvector(0.00000, 0.00000, 0.00000))               // Vitesse de la position de création
            GFX_Setv( i_GFX_Splash2 , 13206,cvector(0.00000, 0.00000, 0.00000))               // Friction de la position
            tf_facteur = MATH_RandFloat(0.1,0.4)
            GFX_Setf( i_GFX_Splash2 , 13008,0.000000)                                                                                                                            // Taux de génération

}



procedure_local void GRAPPIN_GFX_1Spark(vector tv_pos)
{
	int		ti_GFX
	ti_GFX = GFX_Add(9)		// Etincelles
	GFX_FlagSet(ti_GFX , 0, 1)
	GFX_FlagSet(ti_GFX , 2, 1)
	GFX_MaterialSet(ti_GFX, get_SFX_light_and_smoke, 5)
	GFX_Setf(ti_GFX, 9000, 0)									// angle d'ouverture
	GFX_Setf(ti_GFX, 9001, 1.0)											// vitesse initiale minimum
	GFX_Setf(ti_GFX, 9002, 3.0)											// vitesse initiale maximum
	GFX_Setf(ti_GFX, 9003, 0.95 )											// friction
	GFX_Seti(ti_GFX, 9100, 5)												// Nombre
	GFX_Setf(ti_GFX, 9004, 0.15)											// épaisseur
	GFX_Setf(ti_GFX, 9005, 0.5)											// durée de vie minimum
	GFX_Setf(ti_GFX, 9006, 0.75)											// durée de vie maximum
	GFX_Setf(ti_GFX, 9008, 0.01 )										// generation périod
	GFX_Setf(ti_GFX, 9007, 4.0 )											// multiplicateur de longueur
	GFX_Setf(ti_GFX, 9009, 0.2)											// durée de mort minimun
	GFX_Setf(ti_GFX, 9010, 0.4)											// durée de mort maximun
	GFX_Seti(ti_GFX, 9102, 0b11000)									// Flags (1 => agrandissement centré)
	GFX_Setv(ti_GFX, 9200, tv_pos)			// Origine des étincelles
	GFX_Setv(ti_GFX, 9201, cvector(MATH_RandFloat(-1.0,1.0),MATH_RandFloat(-1.0,1.0),MATH_RandFloat(-1.0,1.0)))	// Direction
	GFX_Setv(ti_GFX, 9202, cvector(0.0, 0.0, 0.0) )					// gravity
	GFX_Seti(ti_GFX, 9101, i_grappin_gfx_color) 		
}

procedure_local void GRAPPIN_GFX_Sparks()
{
	object	to_main
	vector	tv_pos
	vector	tv_temp
	vector	tv_temp1
	float		tf_dist
	int			ti_i
	
	to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
	tv_pos = @to_main OBJ_PosGet()
	tv_temp = @o_grappin OBJ_PosGet() - tv_pos
	tf_dist = MATH_VecNorm(tv_temp)
	tv_temp1 = tv_temp
	MATH_VecSetNorm(tv_temp1, tf_dist / Cf_Grappin_FX_Nb)
	for( ti_i = 0; ti_i < Cf_Grappin_FX_Nb; ti_i++ )
	{
		GRAPPIN_GFX_1Spark(tv_pos)
		tv_pos += tv_temp1
	}
}

procedure_local void GRAPPIN_GFX_Line()
{
	object	to_main
	vector	tv_pos
	if( i_grappin_gfx == -1 )
	{
		i_grappin_gfx = GFX_Add(1)		// Ligne
		GFX_FlagSet(i_grappin_gfx , 0, 1)
		GFX_FlagSet(i_grappin_gfx, 2, 1)
		GFX_MaterialSet(i_grappin_gfx, get_SFX_light_and_smoke, 3)
		GFX_Setf(i_grappin_gfx, 1000, Cf_Grappin_largeur)		// Epaisseur de la ligne
		GFX_Seti(i_grappin_gfx, 1100, i_grappin_gfx_color)		// Couleur de la ligne
	}
	to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
	tv_pos = @to_main OBJ_PosGet()
	GFX_Setv(i_grappin_gfx, 1200, tv_pos)		// Coordonnée de la position 3D du début du faisceau
	tv_pos = @o_grappin OBJ_PosGet()
	GFX_Setv(i_grappin_gfx, 1201, tv_pos)		// Coordonnée de la position 3D de la fin du faisceau
//	GFX_Setv(i_grappin_gfx, 1202, @o_grappin OBJ_SightGet())	// Vecteur dorientation de la ligne
}


procedure_local void GRAPPIN_GFX_Line_Segment(int ti_i, vector tv_pos_start, vector tv_pos_end)
{
	if( ai_grappin_gfx[ti_i] == -1 )
	{
		ai_grappin_gfx[ti_i] = GFX_Add(1)		// Ligne
		GFX_FlagSet(ai_grappin_gfx[ti_i] , 0, 1)
		GFX_FlagSet(ai_grappin_gfx[ti_i], 2, 1)
		GFX_MaterialSet(ai_grappin_gfx[ti_i], get_SFX_light_and_smoke, 3)
		GFX_Setf(ai_grappin_gfx[ti_i], 1000, Cf_Grappin_largeur)		// Epaisseur de la ligne
		GFX_Seti(ai_grappin_gfx[ti_i], 1100, i_grappin_gfx_color)		// Couleur de la ligne
	}
	GFX_Setv(ai_grappin_gfx[ti_i], 1200, tv_pos_start)		// Coordonnée de la position 3D du début du faisceau	
	GFX_Setv(ai_grappin_gfx[ti_i], 1201, tv_pos_end)		// Coordonnée de la position 3D de la fin du faisceau
//	GFX_Setv(ai_grappin_gfx[ti_i], 1202, tv_pos_end - tv_pos_start)	// Vecteur dorientation de la ligne
}

procedure_local void GRAPPIN_GFX_Line_TipTop()
{
	int		ti_i
	vector	tv_pos
	object	to_main
	to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
	tv_pos = @to_main OBJ_PosGet()
	for( ti_i = 0; ti_i < Ci_Grappin_TipTopNb; ti_i++ )
	{
		if( ti_i < i_grappin_tiptop_nb )
		{
			GRAPPIN_GFX_Line_Segment(ti_i, tv_pos, av_grappin_tiptop[ti_i])
			tv_pos = av_grappin_tiptop[ti_i]
		}
		else if( ai_grappin_gfx[ti_i] != -1 )
		{
			GFX_Del(ai_grappin_gfx[ti_i])
			ai_grappin_gfx[ti_i] = -1
		}
	}
}

procedure_local void GRAPPIN_GFX_Lightning()
{
	object	to_main
	vector	tv_pos
	if( i_grappin_gfx == -1 )
	{
		i_grappin_gfx = GFX_Add(2)				// création de léclair
		GFX_FlagSet(i_grappin_gfx, 0, 1)		// activation
		GFX_FlagSet(i_grappin_gfx, 2, vrai)		// matériau transparent
		GFX_MaterialSet(i_grappin_gfx, get_SFX_light_and_smoke, 3)     // affectation du matériau
		GFX_Seti(i_grappin_gfx, 2100, 5)			// nombre de découpe (arrondie à 8)
		GFX_Seti(i_grappin_gfx, 2101, 2)			// la texture est plaquée quune fois sur tout le faisceau
		GFX_Seti(i_grappin_gfx, 2102, i_grappin_gfx_color)		// couleur
		GFX_Setf(i_grappin_gfx, 2000, 0.2)		// épaisseur
		GFX_Setf(i_grappin_gfx, 2001, Cf_PiBy3)	// rayon du cylindre dans lequel évolue l'éclair
	}
	// déplacement de lorigine et de lextrémité de léclair ( à faire une fois par trame si elles se déplacent)
	to_main = ANI_CanalObjectGet(RM_Canal_Grappin)
	tv_pos = @to_main OBJ_PosGet()
	GFX_Setv(i_grappin_gfx, 2200, tv_pos)
	tv_pos = @o_grappin OBJ_PosGet()
	GFX_Setv(i_grappin_gfx, 2201, tv_pos)
}

procedure_local void GRAPPIN_GFX_Corde(vector tv_A_pos, vector tv_D_pos)
{
	int			ti_i	
	int			ti_flag_halo	
	int			ti_ray_insensitive_A
	int			ti_ray_insensitive_B
	int			ti_index
	int			ti_ray_index
	color		tc_dest_color
	color		tc_dest_color2
	int			ti_test
	
	float		tf_coef
	float		tf_step
	float		tf_friction
	float		tf_exp_friction_m_dt
	float		tf_line_width
	float		tf_tension_coef
	float		tf_length

	vector	tv_ground_pos
	vector	tv_ground_normal

	vector	tv_start_pos
	vector	tv_dest_pos
	vector	tv_sight

	vector	tv_B_last_pos
	vector	tv_B_dest_pos
	vector	tv_B_force
	
	vector	tv_C_last_pos
	vector	tv_C_dest_pos	
	vector	tv_C_force
	
	vector	tv_col_pos_1
	vector	tv_col_normal_1
	vector	tv_col_pos_2
	vector	tv_col_normal_2
	vector	tv_intersection_pos
	
	object	to_obj
	object	to_monture
	object	to_gao

	float		tf_ray_length
	vector	tv_ray_dir
	
	float		tf_rope_length
	
	tv_ray_dir = tv_D_pos - tv_A_pos

	tv_ground_normal = tv_ray_dir
	if (tv_ground_normal.z > 0.0) 
		tv_ground_pos = tv_A_pos
	else
		tv_ground_pos = tv_D_pos	

	tf_ray_length = MATH_VecSquareNorm(tv_ray_dir)
	if (tf_ray_length)
	{
		tf_ray_length = MATH_FloatSqrt(tf_ray_length)
		tf_tension_coef = tf_ray_length
	
		tv_ray_dir /= tf_ray_length
		
		if( o_grappin_hotspot && Proc_PNJ_Grappin_GogoMode(o_grappin_hotspot) )
			tf_rope_length = 1.5
		else
			tf_rope_length = f_rope_length
		tf_tension_coef = MATH_FloatLimit(tf_tension_coef / tf_rope_length,  0.0, 1.0)
		tf_tension_coef *= tf_tension_coef
		tf_tension_coef *= tf_tension_coef
		tf_tension_coef *= tf_tension_coef
		tf_tension_coef *= tf_tension_coef
		tf_line_width = MATH_FloatBlend(Cf_Grappin_largeur, Cf_Grappin_largeur * 0.1, tf_tension_coef)
	}
	else 
	{
		tf_length = 0.0
		tf_tension_coef = 0.0
		tf_line_width = Cf_Grappin_largeur * 0.1
	}


	tv_sight = MATH_VecCrossProduct(tv_ground_normal, Cv_VerticalVector)
	tv_ground_normal = MATH_VecCrossProduct(tv_sight, tv_ground_normal)
	tf_coef = MATH_VecSquareNorm(tv_ground_normal)
	if (tf_coef)
		tv_ground_normal /= MATH_FloatSqrt(tf_coef)
	else
		tv_ground_normal = Cv_VerticalVector

	tf_friction = 3.0


	ti_flag_halo = faux
	tc_dest_color = i_grappin_gfx_color

	tv_B_dest_pos = MATH_VecBlend(tv_A_pos, tv_D_pos, 0.33)
	tv_C_dest_pos = MATH_VecBlend(tv_A_pos, tv_D_pos, 0.66)
	
//	ti_ray_insensitive_A = faux
//	ti_ray_insensitive_B = faux
//	
//	if (o_grappin_hotspot)
//	{
//		ti_ray_insensitive_A = @o_grappin_hotspot OBJ_FlagsControlGet() & OBJ_C_ControlFlag_RayInsensitive
//		if (@o_grappin_hotspot OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims))
//			@o_grappin_hotspot OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
//	}
//
//	to_obj = COL_RayObject_Vector(tv_A_pos, tv_D_pos - tv_A_pos, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//	if (to_obj && to_obj != o_grappin_hotspot)
//	{
//		tv_col_pos_1 = COL_RayObject_PosGet()
//		tv_col_normal_1 = COL_RayObject_NormalGet()
//		MATH_VecSetNormalize(tv_col_normal_1)
//
//		to_monture = PROC_RM_MontureGet()
//		if (to_monture)
//		{
//			ti_ray_insensitive_B = @to_monture OBJ_FlagsControlGet() & OBJ_C_ControlFlag_RayInsensitive
//			if (@to_monture OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims))
//				@to_monture OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
//		}
//
//		to_obj = COL_RayObject_Vector(tv_D_pos, tv_A_pos - tv_D_pos, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable)
//
//		if ( ! ti_ray_insensitive_B && to_monture )
//			@to_monture OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)
//
//		if (to_obj && to_obj != OBJ_Me())
//		{
//			ti_flag_halo = vrai	
//		
//			tv_col_pos_2 = COL_RayObject_PosGet()
//			tv_col_normal_2 = COL_RayObject_NormalGet()
//			MATH_VecSetNormalize(tv_col_normal_2)
//		
//			DBG_RenderVector(tv_col_pos_1, tv_col_normal_1, color_bleu)
//			DBG_RenderVector(tv_col_pos_2, tv_col_normal_2, color_bleu)
//
//			tv_sight	= tv_col_pos_2 - tv_col_pos_1
//			tf_length = MATH_VecSquareNorm(tv_sight)
//			tv_sight -= MATH_VecDotProduct(tv_sight, tv_col_normal_1) * tv_col_normal_1
//			tf_coef = MATH_VecSquareNorm(tv_sight)
//			if (tf_coef)
//			{
//				tv_sight /= MATH_FloatSqrt(tf_coef)
//		
//				if (MATH_LIB_Intersection_Line_Plane(tv_col_pos_1, tv_sight, tv_col_pos_2, tv_col_normal_2, tf_coef, tv_intersection_pos))
//				{
//					DBG_RenderVector(tv_col_pos_1, tv_intersection_pos - tv_col_pos_1, color_blanc)
//					DBG_RenderVector(tv_col_pos_2, tv_intersection_pos - tv_col_pos_2, color_blanc)
//				
//					tv_sight = tv_intersection_pos - tv_A_pos
//					tv_sight -= MATH_VecDotProduct(tv_sight, tv_ray_dir) * tv_ray_dir
//					tf_coef = MATH_VecSquareNorm(tv_sight)
//			
////					if (tf_coef < tf_length)
////					{
////						ti_flag_halo = faux	
////					
////						tf_friction = 12.0
////
//////						v_rope_dir = tv_sight
////					
////						tv_intersection_pos += MATH_VecBlendRotate(tv_col_normal_1, tv_col_normal_2, 0.5) * 0.5
////				
////						tv_B_dest_pos = tv_intersection_pos
////						tv_C_dest_pos = tv_intersection_pos
////					}
////					else
//					{
//						tc_dest_color = 0xFF	
//					
////						tf_coef = MATH_FloatSqrt(tf_coef)
////						tv_sight /= tf_coef
////
////						tf_length = MATH_FloatSqrt(tf_length)
////						
////						tv_B_dest_pos	 = tv_col_pos_1
////						tv_B_dest_pos += tv_sight * tf_length * 1.2
////					
////						tv_C_dest_pos	 = tv_col_pos_2
////						tv_C_dest_pos += tv_sight * tf_length * 1.2
//					}
//				}
//			}
//		}
//	}
//
//	if ( ! ti_ray_insensitive_A && o_grappin_hotspot )
//		@o_grappin_hotspot OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)


	ti_ray_insensitive_A = faux
	
	if (o_grappin_hotspot)
	{
		ti_ray_insensitive_A = @o_grappin_hotspot OBJ_FlagsControlGet() & OBJ_C_ControlFlag_RayInsensitive

		
//		if (@o_grappin_hotspot OBJ_FlagsIdentityTest(OBJ_C_IdentityFlag_Anims)) 
		// On ne grappine plus que des HOTSPOTS.
		@o_grappin_hotspot OBJ_FlagsControlSet(OBJ_C_ControlFlag_RayInsensitive, none)
	}
	// VINC
//	DBG_EraseAllVectors()
	DBG_RenderVector(tv_A_pos, tv_ray_dir * (tf_ray_length - 0.1), color_jaune)
	if( COL_RayIsCut_Dist(tv_A_pos, tv_ray_dir, tf_ray_length - 0.1, all, none, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable) )
	{
//		Str_DisplayGaoOnce(COL_Ray_CrossObjectGet(0), cvector(0.5,0.5,0))
//		Str_DisplayGaoOnce(COL_Ray_CrossObjectGet(1), cvector(0.5,0.55,0))
//		Str_DisplayIntOnce(COL_Ray_CrossObjectNumber(), cvector(0.5,0.6,0))
//		ti_flag_halo = vrai	
		tc_dest_color = 0xFF
	}
	
	if ( ! ti_ray_insensitive_A && o_grappin_hotspot )
		@o_grappin_hotspot OBJ_FlagsControlSet(none, OBJ_C_ControlFlag_RayInsensitive)

//	if (ti_flag_halo)
//	{
//		tf_tension_coef = 1.0
//		
//		f_grappin_collision_timer += TIME_GetDt()
//		
//		if (i_grappin_GFX_Halo1 == -1)
//		{
//			i_grappin_GFX_Halo1 = GFX_Add(21)
//			GFX_FlagSet(i_grappin_GFX_Halo1, 4, 1)
//			GFX_MaterialSet(i_grappin_GFX_Halo1, get_SFX_light_and_smoke, 0)	
//			GFX_Setf(i_grappin_GFX_Halo1, 21002, 0.1)							// extraction par rapport au point de génération (vers la cam)
//			GFX_Seti(i_grappin_GFX_Halo1, 21103, 1)		
//			GFX_Seti(i_grappin_GFX_Halo1, 21101, 0xFF)
//		}
//		
//		GFX_Setv(i_grappin_GFX_Halo1, 21200, tv_col_pos_1 + (tv_col_normal_1 * 0.5))
//		GFX_Setf(i_grappin_GFX_Halo1, 21000, MATH_RandFloat(0.75, 1.5))			// rayon
//
//		if (i_grappin_GFX_Halo2 == -1)
//		{
//			i_grappin_GFX_Halo2 = GFX_Add(21)
//			GFX_FlagSet(i_grappin_GFX_Halo2, 4, 1)
//			GFX_MaterialSet(i_grappin_GFX_Halo2, get_SFX_light_and_smoke, 0)	
//			GFX_Setf(i_grappin_GFX_Halo2, 21002, 0.1)							// extraction par rapport au point de génération (vers la cam)
//			GFX_Seti(i_grappin_GFX_Halo2, 21103, 1)		
//			GFX_Seti(i_grappin_GFX_Halo2, 21101, 0xFF)
//		}
//		
//		GFX_Setv(i_grappin_GFX_Halo2, 21200, tv_col_pos_2 - (tv_col_normal_1 * 0.5))
//		GFX_Setf(i_grappin_GFX_Halo2, 21000, MATH_RandFloat(0.75, 1.5))			// rayon
//	}
//	else
//	{
//		f_grappin_collision_timer = 0.0
//		
//		if (i_grappin_GFX_Halo1 != -1)
//		{
//			GFX_Del(i_grappin_GFX_Halo1)
//			i_grappin_GFX_Halo1 = -1
//		}
//
//		if (i_grappin_GFX_Halo2 != -1)
//		{
//			GFX_Del(i_grappin_GFX_Halo2)
//			i_grappin_GFX_Halo2 = -1
//		}
//	}
	
	tf_exp_friction_m_dt = MATH_Exp( - tf_friction * TIME_GetDt())

	tv_B_last_pos = v_grappin_gfx_corde_B_pos
	tv_B_force = cvector(0.0, 0.0, -10.0)
	tv_B_force += (tv_B_dest_pos - v_grappin_gfx_corde_B_pos) * 40.0
	tv_B_force /= tf_friction
	v_grappin_gfx_corde_B_speed = tv_B_force - ((tv_B_force - v_grappin_gfx_corde_B_speed) * tf_exp_friction_m_dt)

	tf_coef = MATH_VecSquareNorm(v_grappin_gfx_corde_B_speed)
	if (tf_coef > 900000.0)
	{
		tf_coef = MATH_FloatSqrt(tf_coef)
		v_grappin_gfx_corde_B_speed /= tf_coef
		v_grappin_gfx_corde_B_speed *= 300.0
	}

	v_grappin_gfx_corde_B_pos += v_grappin_gfx_corde_B_speed * TIME_GetDt()
	tf_coef = MATH_VecDotProduct(v_grappin_gfx_corde_B_pos - tv_ground_pos, tv_ground_normal)
	v_grappin_gfx_corde_B_pos -= MATH_FloatMin(tf_coef + 1.0, 0.0) * tv_ground_normal
	v_grappin_gfx_corde_B_pos = MATH_VecBlend(v_grappin_gfx_corde_B_pos, tv_B_dest_pos, tf_tension_coef)
	v_grappin_gfx_corde_B_speed = (v_grappin_gfx_corde_B_pos - tv_B_last_pos) / TIME_GetDt()

	tv_C_last_pos = v_grappin_gfx_corde_C_pos
	tv_C_force = cvector(0.0, 0.0, -10.0)
	tv_C_force += (tv_C_dest_pos - v_grappin_gfx_corde_C_pos) * 40.0
	tv_C_force /= tf_friction
	v_grappin_gfx_corde_C_speed = tv_C_force - ((tv_C_force - v_grappin_gfx_corde_C_speed) * tf_exp_friction_m_dt)

	tf_coef = MATH_VecSquareNorm(v_grappin_gfx_corde_C_speed)
	if (tf_coef > 900000.0)
	{
		tf_coef = MATH_FloatSqrt(tf_coef)
		v_grappin_gfx_corde_C_speed /= tf_coef
		v_grappin_gfx_corde_C_speed *= 300.0
	}

	v_grappin_gfx_corde_C_pos += v_grappin_gfx_corde_C_speed * TIME_GetDt()
	tf_coef = MATH_VecDotProduct(v_grappin_gfx_corde_C_pos - tv_ground_pos, tv_ground_normal)
	v_grappin_gfx_corde_C_pos -= MATH_FloatMin(tf_coef + 1.0, 0.0) * tv_ground_normal
	v_grappin_gfx_corde_C_pos = MATH_VecBlend(v_grappin_gfx_corde_C_pos, tv_C_dest_pos, tf_tension_coef)
	v_grappin_gfx_corde_C_speed = (v_grappin_gfx_corde_C_pos - tv_C_last_pos) / TIME_GetDt()

	
//	MATH_LIB_Bezier_Display(30, tv_A_pos, v_B_pos, v_C_pos, tv_D_pos)

	tv_dest_pos = tv_A_pos
	tf_step = 1.0 / Ci_Grappin_Corde_Segments_Nb
	tf_coef = tf_step
	
	DBG_RenderVector(tv_A_pos, v_grappin_gfx_corde_B_pos - tv_A_pos, color_rouge)
	DBG_RenderVector(v_grappin_gfx_corde_B_pos, v_grappin_gfx_corde_C_pos - v_grappin_gfx_corde_B_pos, color_vert)
	DBG_RenderVector(v_grappin_gfx_corde_C_pos, tv_D_pos - v_grappin_gfx_corde_C_pos, color_bleu)

	tc_dest_color = 0x01004499

	ti_test = vrai
	for (ti_i = 0; ti_i < Ci_Grappin_Corde_Segments_Nb; ti_i++)
	{
		tv_start_pos = tv_dest_pos
//		tv_dest_pos = MATH_LIB_Bezier_Pos_Get(tf_coef, tv_A_pos, v_grappin_gfx_corde_B_pos, v_grappin_gfx_corde_C_pos, tv_D_pos, tv_sight)
		tv_dest_pos = MATH_LIB_A_Bezier_Pos_Get(tf_coef, 1.0, 1.0, tv_A_pos, v_grappin_gfx_corde_B_pos, v_grappin_gfx_corde_C_pos, tv_D_pos)
		tf_coef += tf_step

		if( ai_grappin_gfx_corde[ti_i] == -1 )
			if (ti_test)
			{
				ti_test = faux
				tc_dest_color2 = PROC_INVERT_COLOR(tc_dest_color)
				ai_grappin_gfx_corde[ti_i] = PROC_SFX_GRAPPIN_01(tv_dest_pos, tc_dest_color2, Cf_Grappin_largeur)
			}
			else
			{
				ti_test = vrai
				ai_grappin_gfx_corde[ti_i] = PROC_SFX_GRAPPIN_01(tv_dest_pos, tc_dest_color, Cf_Grappin_largeur * 0.5)
			}

		GFX_Setv(ai_grappin_gfx_corde[ti_i], 21200, tv_dest_pos)											// Position du premier flare

	}
}




//---------------------------------------
// SFX TRAINEE DE FEU
//---------------------------------------
procedure_local void Proc_RM_GFX_Fire()
{
	vector	tv_pos, tv_wind, tv_speed
	int			ti_color

//	tv_wind = DYN_SpeedGetVector()
	tv_wind = Cv_NullVector
	tv_speed = DYN_SpeedGetVector()  
	tv_speed.z = MATH_FloatMax( tv_speed.z, 0.0)
	tv_pos = OBJ_PosGet()
	tv_pos += tv_speed * TIME_GetDt() * 2.0

	PROC_SFX_TRAINEE_BOUCLIER_FEU(i_GFX_Feu_torche, i_GFX_Rochers_torche, tv_pos, tv_wind, OBJ_SightGet())

	//------------------------------------------------------------------
	// Placement du bouclier de feu devant RM
	//------------------------------------------------------------------
	if (get_Bouclier_feu)
	{
		ti_color = 255 - (f_speed_hor * 7.5)

		if (ti_color > 255)
			ti_color = 255
		else
		if (ti_color < 0)
			ti_color = 0


		@get_Bouclier_feu OBJ_FlagInvisibleSet(faux)
		@get_Bouclier_feu PROC_RLI_DEST_SET(COLOR_SetRGBA(ti_color,ti_color,ti_color,ti_color))
		@get_Bouclier_feu OBJ_PosSet(tv_pos + cvector(MATH_RandFloat(-0.1,0.1), MATH_RandFloat(-0.1,0.1),MATH_RandFloat(0.5, 0.65)))
		@get_Bouclier_feu OBJ_SightSet(OBJ_SightGet())

//		@o_bouclier_feu OBJ_FlagInvisibleSet(faux)
//		@o_bouclier_feu PROC_RLI_DEST_SET(COLOR_SetRGBA(ti_color,ti_color,ti_color,ti_color))
//		@o_bouclier_feu OBJ_PosSet(tv_pos + cvector(MATH_RandFloat(-0.1,0.1), MATH_RandFloat(-0.1,0.1),MATH_RandFloat(0.5, 0.65)))
//		@o_bouclier_feu OBJ_SightSet(OBJ_SightGet())

//		@o_bouclier_feu OBJ_RotateLocalY(MATH_RandFloat(0,360))
	}

	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	// Steph, panique pas ! J'ai gardé tel quel ton SFX de feu et je l'ai mis dans la fonction PROC_SFX_TRAINEE_BOUCLIER_FEU dans ma LIB de SFX
	//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
}


//---------------------------------------------------------------------
// DESTRUCTION DU SFX TRAINEE DE FEU
//---------------------------------------------------------------------
procedure_local void Proc_RM_DESTROY_GFX_Fire()
{
	PROC_DESTROY_2_SFX(i_GFX_Feu_torche, i_GFX_Rochers_torche)
	@get_Bouclier_feu OBJ_FlagInvisibleSet(vrai)
//	@o_bouclier_feu OBJ_FlagInvisibleSet(vrai)
}


//-------------------------------
// SFX BIG BOOST
//-------------------------------
procedure_local void	Proc_RM_GFX_Boost()
{
	vector	tv_pos_temp
	float		tf_far_SFX_speed, tf_temp
	color		tc_speed_RM
	int			ti_i
	
//	f_speed_norm > Cf_Speeed_Fly
	if ( (i_move_mode == C_Move_Jump && ACT_ActionGet() == RM_Act_Jump_Fly && ! i_grappin_accroche) 
	|| ( i_move_mode != C_Move_Jump && f_speed_hor > Cf_Speed_For_TGV ))//	if (f_speed_hor > Cf_Speed_For_TGV)
	{
		@get_SFX_Speed_RM OBJ_FlagInvisibleSet(faux)

		if (@get_SFX_Speed_RM OBJ_IsValidGAO())
			@get_SFX_Speed_RM OBJ_FlagInvisibleSet(faux)
		v_pos_RM_old = v_pos_RM
		v_pos_RM = OBJ_PosGet()
		v_dir_cam = v_pos_RM - v_pos_RM_old
		
		// Détermination de la position de la caméra
		v_pos_cam_old = v_pos_cam
		v_pos_cam = @get_camera OBJ_PosGet()
		
		// Détermination de l'alpha du cylindre englobant
		tf_temp = 128 * (1 - (f_speed_hor * 0.03))
		if (tf_temp < 0.0)
			tf_temp = 0.0
		tc_speed_RM = COLOR_SetRGBA(0,0,0,tf_temp)
	
		// On affiche le cylindre de vent, on applique sa couleur et on met son Sight correctement
//		if (v_dir_cam.x > 0.0 || (v_dir_cam.y > 0.0 || v_dir_cam.z > 0.0))
//			@get_SFX_Speed_RM OBJ_SightSet(v_dir_cam)
		@get_SFX_Speed_RM OBJ_SightSet(@get_camera OBJ_SightGet())

		
//		@get_SFX_Speed_RM PROC_RLI_DEST_SET(tc_speed_RM)
		@get_SFX_Speed_RM PROC_RLI_DEST_SET(COLOR_SetRGBA(0,0,0,255))
		@get_SFX_Speed_RM OBJ_PosSet(v_pos_cam + @get_camera MATH_VecLocalToGlobal(cvector(0.0,-0.75,0.0)))
	
	
		//---------------------------------------------------------
		// Gestion des particules en XMen
		//---------------------------------------------------------
		tf_temp = (2.56 * f_speed_hor) - 20.0
	
		if (tf_temp < 0.0)
			tf_temp = 0.0
	
		tc_speed_RM = COLOR_SetRGBA(tf_temp,tf_temp,tf_temp,0)
		@get_SFX_Speed_RM MAT_ConstantSet(tc_speed_RM,0x1B004E96)
	
		for (ti_i = 0; ti_i < C_SFX_NB_SPEED_PARTICLES; ti_i++)
		{
			// On récupère la position actuelle de la particule
			tv_pos_temp = @o_speed_RM_particules[ti_i] OBJ_PosGet()
	
			@o_speed_RM_particules[ti_i] MAT_ConstantSet(tc_speed_RM, 0x1B004E96)
		
			// On regarde si elle est arrivée en bout de course, dans ce cas on la réinitialise au début. Sinon, on la fait avancer
			tf_temp = TIME_GetDt()
			tf_far_SFX_speed = (50 - (f_speed_hor * 200.0 * tf_temp)) * MATH_RandFloat(0.4,1.6)
	
			if (tf_far_SFX_speed < 10.0)
				tf_far_SFX_speed = 10.0
	
			if (i_cpt_speed_particules[ti_i] < tf_far_SFX_speed)
			{
				i_cpt_speed_particules[ti_i]++
				if (ti_i >= 0)
					@o_speed_RM_particules[ti_i] OBJ_FlagInvisibleSet(faux)
	
				@o_speed_RM_particules[ti_i] OBJ_PosSet(tv_pos_temp + (v_dir_speed_particules[ti_i] * TIME_GetDt()))// * -f_speed_hor * TIME_GetDt()))
			}
			else
			{
				i_cpt_speed_particules[ti_i] = 0
				v_dir_speed_particules[ti_i] = -v_dir_cam * 50.0
				tv_pos_temp = v_dir_speed_particules[ti_i]
				tf_temp = 2 + (f_speed_hor * 0.0)
				@o_speed_RM_particules[ti_i] OBJ_FlagInvisibleSet(vrai)
				@o_speed_RM_particules[ti_i] OBJ_PosSet(v_pos_RM + cvector(0.0,0.0,v_dir_cam.z*8.0) + (OBJ_SightGet( )* 15.0) + cvector(MATH_RandFloat(-tf_temp, tf_temp), MATH_RandFloat(-tf_temp, tf_temp), MATH_RandFloat(0.5,2.5)))
	//			@o_speed_RM_particules[ti_i] OBJ_PosSet(v_pos_RM + cvector(0.0,0.0,v_dir_cam.z*8.0) + (OBJ_SightGet( )* 15.0) + cvector(MATH_RandFloat(-2.0,2.0), MATH_RandFloat(-2.0,2.0), MATH_RandFloat(-2.0,2.0)))// + MATH_VecLocalToGlobal(cvector(0.0,-f_speed_hor * 1.5,0.0)))
			}
		}
	}
	else
		@get_SFX_Speed_RM OBJ_FlagInvisibleSet(vrai)
}