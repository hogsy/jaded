	#include "r_defines.var"

procedure_local void Rayman_Init_IK()
{
	int			ti_i
	int			ti_k
	int			ti_membre_index

	object	to_bone	

	o_bassin = ANI_CanalObjectGet(Anim_Canal_Bassin)

	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		switch(ti_i)
		{
			case Ci_IK_pied_gauche :
				ti_membre_index = Anim_Canal_PiedGauche
				break
			case Ci_IK_pied_droit :
				ti_membre_index = Anim_Canal_PiedDroit
				break
		}	
	
		for (ti_k = 0; ti_k < 3; ti_k++)
		{
			to_bone = ANI_CanalObjectGet(ti_membre_index + (2 - ti_k))
	//		DBG_RenderVector(@to_bone OBJ_PosGet(), @to_bone OBJ_BankingGet(), color_bleu)
			ao_IK_bones[ti_i][ti_k] = to_bone
		}
	
		switch(ti_i)
		{
			case Ci_IK_pied_gauche :
				ti_membre_index = Anim_Canal_OrteilGauche
				break
			case Ci_IK_pied_droit :
				ti_membre_index = Anim_Canal_OrteilDroit
				break
		}	
	
		ao_IK_bones[ti_i][3] = ANI_CanalObjectGet(ti_membre_index)
			
		af_IK_bones_length[ti_i][0] = MATH_VecNorm(@ao_IK_bones[ti_i][1] OBJ_PosGet() - @ao_IK_bones[ti_i][0] OBJ_PosGet())
		af_IK_bones_length[ti_i][1] = MATH_VecNorm(@ao_IK_bones[ti_i][2] OBJ_PosGet() - @ao_IK_bones[ti_i][1] OBJ_PosGet())
		af_IK_bones_length[ti_i][2] = MATH_VecNorm(@ao_IK_bones[ti_i][3] OBJ_PosGet() - @ao_IK_bones[ti_i][2] OBJ_PosGet())
	
		f_IK_leg_length[ti_i] = af_IK_bones_length[ti_i][0]
		f_IK_leg_length[ti_i] += af_IK_bones_length[ti_i][1]
	
//		if (ti_i < 2)
//			v_IK_feet_Z_axis[ti_i] = @ao_IK_bones[ti_i][3] MATH_VecGlobalToLocal(Cv_VerticalVector)	
	}
}

procedure_local void Rayman_Reset_IK()
{
	int			ti_i	

	// IK LEG
	f_bassin_Z_offset = 0.0

	v_IK_ref_ground_pos = OBJ_PosGet()

	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		i_flag_leg_IK[ti_i] = faux

		f_IK_Z_offset[ti_i] = 0.0
		f_IK_coef[ti_i] = 0.0
		f_IK_ground_coef[ti_i] = 0.0
	}
}

procedure_local void Rayman_IK()
{
	int			ti_i
	int			ti_k
	int			ti_frame_num
	int			ti_flag_collision
	int			ti_flag_ok
	int			ti_action
		
	float		tf_angle
	float		tf_offset
	float		tf_bassin_offset
	float		tf_norm
	float		tf_coef
	float		tf_IK_coef
	float		tf_size_coef
	float		tf_ray_start_offset
	float		tf_dot_product
	float		tf_ray_length
	
	vector	tv_pied_pos
	vector	tv_collide_pos
	vector	tv_ray_start
	vector	tv_ray_dir
	vector	tv_start_axis
	vector	tv_dest_axis
	vector	tv_ray_normale
	vector	tv_bassin_dest_pos
	vector	tv_temp
	vector	tav_pied_pos[2]
	vector	tv_IK_bone_last_valid_sight[2]
	vector	tv_IK_bone_last_valid_banking[2]
	
	object	to_target
	object	to_bone
	
	//vector	tv_queue_banking
	//object	to_queue
	
	#define Cf_offset_min						-100.0
	#define Cf_offset_max						100.0
	#define Cf_walk_Z_blend_speed			12.0
	
	#define Ci_bone_pos_index				2
	
	//v_IK_ref_ground_pos = OBJ_PosGet()
	
//	tf_coef = OBJ_LodVisGet() 
//	if ( tf_coef < 0.6 )
//	{
//		Rayman_Reset_IK()
//		return
//	}

//	if( MOVE_MODE() == C_Move_Swim)	
//	{
//		Rayman_Reset_IK()
//		return
//	}

//	if (ACT_ActionGet() == RM_Act_SpiderAtt)
//	{
//		v_IK_ref_ground_pos	 = COL_ZonePosGet(C_zdm_pied)
//		v_IK_ref_ground_pos += OBJ_SightGet() * COL_ZoneSizeGet(C_zdm_pied)
//
//		tv_ray_dir = OBJ_SightGet()
//	}
//	else
	{
		v_IK_ref_ground_pos	 = OBJ_PosGet()
		tv_ray_dir = -OBJ_BankingGet()
	}
	
	//to_queue = ANI_CanalObjectGet(Anim_Canal_Queue)
	//tv_queue_banking = @to_queue OBJ_BankingGet()
	
	tf_size_coef = 1.0
	
	tf_ray_start_offset = 0.15
	
	// EST-CE QU'ON S'ADAPTE AU RELIEF DU SOL ??? =============================================================
	tf_bassin_offset = 0.0
	
	ti_action = ACT_ActionGet()
	
	tf_coef = DYN_SpeedGet()
	
	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		if( MOVE_MODE() == C_Move_Swim)	
			i_flag_leg_IK[ti_i]	= faux
		else if (PROC_RM_MontureIDGet() != C_ID_Rayman)
			i_flag_leg_IK[ti_i]	= faux
		else if (ACT_ActionGet() == RM_Act_SpiderAtt)
			i_flag_leg_IK[ti_i]	= faux
		else if ( f_speed_hor > 4.0)
			i_flag_leg_IK[ti_i]	= faux
		else
			i_flag_leg_IK[ti_i]	= vrai
	
		if (! i_flag_leg_IK[ti_i] && ! f_IK_coef[ti_i])
			continue
	
		tv_IK_bone_last_valid_sight[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet()
		tv_IK_bone_last_valid_banking[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet()
	
		ti_flag_collision = faux
	
		tf_ray_length = f_IK_leg_length[ti_i] + 0.35

		ti_flag_ok = faux
		if ( ! (COL_ColSetActivationGet() & C_bit_zdm_pied) )
			ti_flag_ok = vrai
		else if (MATH_VecSquareNorm(v_ground_edge_pos - v_IK_ref_ground_pos) < 0.25)
			ti_flag_ok = vrai
		else if (COL_CollideType(COL_C_Wall))
			ti_flag_ok = vrai
		else if ( OBJ_HierarchyGet())
			ti_flag_ok = vrai

		if (ti_flag_ok)
		{
			//====================================================================================================================
			// LANCER DE RAYON
			//====================================================================================================================

			tv_pied_pos = @ao_IK_bones[ti_i][Ci_bone_pos_index + 1] OBJ_PosGet()
			tv_ray_start = tv_pied_pos
			tv_ray_start -= MATH_VecDotProduct(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_ray_dir) * tv_ray_dir
	
			if (COL_RayObject_Dist(tv_ray_start, tv_ray_dir, tf_ray_length, all, OBJ_C_IdentityFlag_Anims, Ci_Filter_IdentityFlag, COL_C_Ray_on_ColMap_NoCrossable))
			{
				// OK ON TOUCHE UN SOL, ON VA POUVOIR POSITIONNER EN IK ==============================================
				tv_collide_pos = COL_RayObject_PosGet()
				tv_ray_normale = COL_RayObject_NormalGet()
				
				if (tv_ray_normale.z > Cf_Cos60)
				{
//					DBG_RenderVector(tv_ray_start, tv_collide_pos - tv_ray_start, color_vert)
//					DBG_RenderVector(tv_collide_pos, tv_ray_normale * 0.5, color_jaune)
			
					tv_pied_pos = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet()
					tv_ray_start = tv_pied_pos
					tv_ray_start -= MATH_VecDotProduct(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_ray_dir) * tv_ray_dir
					MATH_LIB_Intersection_Line_Plane(tv_ray_start, tv_ray_dir, tv_collide_pos, tv_ray_normale, tf_offset, tv_collide_pos)
			
					tf_offset = MATH_VecDotProduct(tv_collide_pos - tv_ray_start, tv_ray_dir)
					if (tf_offset >= tf_ray_start_offset)
						ti_flag_collision = vrai
					else
						ti_flag_collision = faux
				}
			}
			else
			{
//				DBG_RenderVector(tv_ray_start, tv_ray_dir * tf_ray_length, color_rouge)
			}
		}
		else
		{
			//====================================================================================================================
			// COLLISION MATHEMATIQUE PLAN 
			//====================================================================================================================
	
			tv_pied_pos = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet()
		
			tf_dot_product = MATH_VecDotProduct(tv_pied_pos - @ao_IK_bones[ti_i][0] OBJ_PosGet(), tv_ray_dir)
		
			tv_ray_start = tv_pied_pos
			tv_ray_start -= tf_dot_product * tv_ray_dir
	
			tv_ray_normale = v_ground_normale
			MATH_LIB_Intersection_Line_Plane(tv_ray_start, tv_ray_dir, v_ground_pos, tv_ray_normale, tf_offset, tv_collide_pos)
	
			tf_offset = MATH_VecDotProduct(tv_collide_pos - tv_ray_start, tv_ray_dir)
			if (tf_offset >= tf_ray_start_offset && tf_offset < tf_ray_length)
			{
//				DBG_RenderVector(tv_ray_start, tv_collide_pos - tv_ray_start, color_vert)
//				DBG_RenderVector(tv_collide_pos, tv_ray_normale * 0.5, color_jaune)
				
				ti_flag_collision = vrai
			}
			else
			{
//				DBG_RenderVector(tv_ray_start, tv_ray_dir * tf_ray_length, color_rouge)	
			
				ti_flag_collision = faux
			}
		}

		f_IK_ground_coef[ti_i] = MATH_VecDotProduct(@ao_IK_bones[ti_i][Ci_bone_pos_index + 1] OBJ_PosGet() - v_IK_ref_ground_pos, -tv_ray_dir)
		if (f_IK_ground_coef[ti_i] < 0.2)
			f_IK_ground_coef[ti_i] = 1.0 
		else
			f_IK_ground_coef[ti_i] = 0.0
	
		if (ti_flag_collision)
		{
			v_IK_ground_normale[ti_i] = MATH_VecBlendRotate(v_IK_ground_normale[ti_i], tv_ray_normale, 8.0 * TIME_GetDt())
//			v_IK_ground_normale[ti_i] = tv_ray_normale
			tf_offset = MATH_VecDotProduct(tv_collide_pos - v_IK_ref_ground_pos, tv_ray_dir)
			
			tf_dot_product = MATH_VecDotProduct(tv_pied_pos - v_IK_ref_ground_pos, tv_ray_dir)
			tf_offset -= tf_dot_product
			tf_offset += tf_dot_product /  MATH_VecDotProduct(- tv_ray_dir, tv_ray_normale)
		}
		else
		{
			v_IK_ground_normale[ti_i] = MATH_VecBlendRotate(v_IK_ground_normale[ti_i], OBJ_BankingGet(), 4.0 * TIME_GetDt())
			tf_offset = 0.0	
		}		
			
		if (tf_offset && tf_offset > f_IK_Z_offset[ti_i])
			f_IK_Z_offset[ti_i] = MATH_FloatBlend(f_IK_Z_offset[ti_i], tf_offset, 20.0 * TIME_GetDt())
		else
			f_IK_Z_offset[ti_i] = MATH_FloatBlend(f_IK_Z_offset[ti_i], tf_offset, Cf_walk_Z_blend_speed * TIME_GetDt())
//		f_IK_Z_offset[ti_i] = tf_offset

		tav_pied_pos[ti_i] = @ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_PosGet()
		tav_pied_pos[ti_i] += tv_ray_dir * f_IK_Z_offset[ti_i]
	}
	
	tf_IK_coef = f_IK_coef[Ci_IK_pied_gauche]
	
	// DECALAGE EN Z DU BASSIN POUR QUE LES PIEDS PUISSENT TOUCHER LE SOL ====================================
	if (COL_ColSetActivationGet() & C_bit_zdm_pied)
	{
		tf_bassin_offset = MATH_FloatMax(f_IK_Z_offset[Ci_IK_pied_gauche], f_IK_Z_offset[Ci_IK_pied_droit])
		tf_bassin_offset = MATH_FloatMin(tf_bassin_offset, 0.35)
	}
	else
	{
		tf_bassin_offset = 0.0
	}
		
	f_bassin_Z_offset	= MATH_FloatBlend(f_bassin_Z_offset, tf_bassin_offset, 6.0 * TIME_GetDt())
	
	tv_bassin_dest_pos = @o_bassin OBJ_PosGet()
	tv_bassin_dest_pos += tv_ray_dir * (f_bassin_Z_offset * f_IK_coef[Ci_IK_pied_gauche])
	
	@o_bassin OBJ_PosSet(tv_bassin_dest_pos)
	
	// ON EXECUTE L'IK =============================================================================================================
	for (ti_i = 0; ti_i < 2; ti_i++)
	{
		if (i_flag_leg_IK[ti_i])
		{
			f_IK_coef[ti_i] += MATH_FloatMin(1.0 - f_IK_coef[ti_i], TIME_GetDt() * 4.0)	
		}
		else if (f_IK_coef[ti_i])
		{
			f_IK_coef[ti_i] -= MATH_FloatMin(f_IK_coef[ti_i], 4.0 * TIME_GetDt())
		}
		else
		{
			v_IK_ground_normale[ti_i] = OBJ_BankingGet()
			continue
		}
	
		f_IK_Z_offset[ti_i] *= f_IK_coef[ti_i]
		f_IK_ground_coef[ti_i] *= f_IK_coef[ti_i]
	
	//	OBJ_LIB_IK(	ao_IK_bones[ti_i][0], ao_IK_bones[ti_i][1],
	//						af_IK_bones_length[ti_i][0], af_IK_bones_length[ti_i][1],
	//						tav_pied_pos[ti_i],
	//						Cv_NullVector,
	//						f_IK_coef[ti_i] )
	
		OBJ_LIB_IK(	ao_IK_bones[ti_i][0], ao_IK_bones[ti_i][1],
							af_IK_bones_length[ti_i][0], af_IK_bones_length[ti_i][1],
							tav_pied_pos[ti_i],
							- @ao_IK_bones[ti_i][1] OBJ_BankingGet(),
							f_IK_coef[ti_i] )
	
		@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGeneralSet(
			MATH_VecBlend(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_SightGet(), tv_IK_bone_last_valid_sight[ti_i], f_IK_coef[ti_i]) , 
			MATH_VecBlend(@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_BankingGet(), tv_IK_bone_last_valid_banking[ti_i], f_IK_coef[ti_i]) )
	
		if (f_IK_ground_coef[ti_i])
		{
			tv_start_axis = @ao_IK_bones[ti_i][Ci_bone_pos_index] MATH_VecGlobalToLocal(-tv_ray_dir)
			
			tv_dest_axis = v_IK_ground_normale[ti_i]
//			tv_dest_axis = MATH_VecInCone(tv_dest_axis, - @ao_IK_bones[ti_i][1] OBJ_BankingGet(), Cf_PiBy6, 1)
			tv_dest_axis = @ao_IK_bones[ti_i][Ci_bone_pos_index] MATH_VecGlobalToLocal(tv_dest_axis)
			tv_dest_axis = MATH_VecBlend(tv_start_axis, tv_dest_axis, f_IK_ground_coef[ti_i])
			@ao_IK_bones[ti_i][Ci_bone_pos_index] OBJ_Rotate_FromTo(tv_start_axis, tv_dest_axis)
		}
	}
	
	return
}
