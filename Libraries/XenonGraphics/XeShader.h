#ifndef XESHADER_HEADER
#define XESHADER_HEADER


#if defined(_XENON)
template < class ShaderInterface >
struct FastConstAPI {};

template<>
struct FastConstAPI<LPDIRECT3DVERTEXSHADER9>
{
    static inline void Begin( LPDIRECT3DDEVICE9 pDevice, UINT StartRegister, D3DVECTOR4** ppConstantData, UINT Vector4fCount ) 
    {
       ERR_X_Assert( pDevice && ppConstantData);
       pDevice->BeginVertexShaderConstantF1(StartRegister, ppConstantData, Vector4fCount); 
       ERR_X_Assert(*ppConstantData)
    }
    static inline void End( LPDIRECT3DDEVICE9 pDevice ) 
    { 
        ERR_X_Assert( pDevice );
        pDevice->EndVertexShaderConstantF1(); 
    }
};

template<>
struct FastConstAPI<LPDIRECT3DPIXELSHADER9>
{
    static inline void Begin( LPDIRECT3DDEVICE9 pDevice, UINT StartRegister, D3DVECTOR4** ppConstantData, UINT Vector4fCount ) 
    {
        ERR_X_Assert( pDevice && ppConstantData);
        pDevice->BeginPixelShaderConstantF1(StartRegister, ppConstantData, Vector4fCount); 
    }
    static inline void End( LPDIRECT3DDEVICE9 pDevice ) 
    { 
        ERR_X_Assert( pDevice );
        pDevice->EndPixelShaderConstantF1(); 
    }
};
#endif

#define  InterpolatorMask_W (1<<0)
#define  InterpolatorMask_X (1<<1)
#define  InterpolatorMask_Y (1<<2)
#define  InterpolatorMask_Z (1<<3)

#define  ShaderUsage_Color0     0
#define  ShaderUsage_Color1     1
#define  ShaderUsage_Texcoord0  2
#define  ShaderUsage_Texcoord1  3
#define  ShaderUsage_Texcoord2  4
#define  ShaderUsage_Texcoord3  5
#define  ShaderUsage_Texcoord4  6
#define  ShaderUsage_Texcoord5  7
#define  ShaderUsage_Texcoord6  8
#define  ShaderUsage_Texcoord7  9


template <class ShaderInterface, ULONG ulConstCount>
class XeShader
{
public:

    M_DeclareOperatorNewAndDelete();

#if defined(_XENON)
    typedef FastConstAPI< ShaderInterface > FastConst;
#endif

    XeShader();
    virtual ~XeShader();

    // utility
    void SetGlobalVector(ULONG _eConst, VECTOR4FLOAT *_pVector);
    void SetGlobalVectorArray(ULONG _eConst, VECTOR4FLOAT *_pVector, INT _iCount);
    void SetGlobalMatrix(ULONG _eConst, const D3DXMATRIX *_pMatrix);
    void SetGlobalMatrixArray(ULONG _eConst, D3DXMATRIX *_pMatrixArray, INT _iCount);
    void SetGlobalFloat(ULONG _eConst, FLOAT _fValue);
    void SetGlobalFloatArray(ULONG _eConst, FLOAT *_pfValue, INT _iCount);
    void SetGlobalInt(ULONG _eConst, INT _iValue);
    void SetGlobalIntArray(ULONG _eConst, INT *_piValue, INT _iCount);
    void SetGlobalVectorStruct(ULONG _eConst, VECTOR4FLOAT *_pVector);
    void SetGlobalRawData(ULONG _eConst, VECTOR4FLOAT *_pVector, ULONG ulVectorCount);
    void SetGlobalMatrixAsFloat4x3(ULONG _eConst, const D3DXMATRIX *_pMatrix);
    void SetGlobalMatrixAsFloat4x2(ULONG _eConst, const D3DXMATRIX *_pMatrix);
    void SetGlobalFloat4x3(ULONG _eConst, const Float4x3 *_pMatrix);
    void SetGlobalFloat4x2(ULONG _eConst, const Float4x2 *_pMatrix);

    inline ShaderInterface GetShaderInterface() { return m_pShaderInterface; }
    BOOL IsGlobalConstPresent(ULONG _eConst);
    inline void SetAutoGenerated(BOOL _bAutoGenerated) { m_bAutoGenerated = _bAutoGenerated; }
    inline BOOL IsAutoGenerated(void) { return m_bAutoGenerated; }
    void SetConstantTable(ID3DXConstantTable* _pTable);

    BOOL IsDefault( ) { return m_bIsDefault; }
    void IsDefault( BOOL _bIsDefault ) { m_bIsDefault = _bIsDefault; }

#ifdef _XENON
    inline void FastConstBegin( UINT _eConst, VECTOR4FLOAT** ppConstantData, UINT Vector4fCount ) 
    {   
        ERR_X_Assert( m_lRegister[_eConst] != -1 );

#ifdef _DEBUG
        D3DXCONSTANT_DESC oDesc;
        UINT uiCount=1;
        HRESULT hr = m_pConstantTable->GetConstantDesc(m_ahConstant[_eConst], &oDesc, &uiCount);
        ERR_X_Assert( SUCCEEDED(hr) && oDesc.RegisterCount >= Vector4fCount );
#endif
        FastConst::Begin( m_pD3DDevice, m_lRegister[_eConst], (D3DVECTOR4**)ppConstantData, Vector4fCount );
    }
    inline void FastConstEnd()  { FastConst::End( m_pD3DDevice ); }
#endif

    static LPDIRECT3DDEVICE9 m_pD3DDevice;
    ShaderInterface          m_pShaderInterface;
    LPD3DXCONSTANTTABLE      m_pConstantTable;
    D3DXHANDLE               m_ahConstant[ulConstCount];
    LONG                     m_lRegister[ulConstCount];

    BOOL                     m_bAutoGenerated;
    BOOL                     m_bIsDefault;

   #ifdef _DEBUG
    std::string              m_shaderText;
    inline void              SetFilename(TCHAR *_szFilename);
    TCHAR                    m_Filename[MAX_PATH];      // shader file name for debugging purposes
  #endif
};

//////////////////////////////////////////////////////////////////////////////////////////////////
// vertex shader class and global constant definition
//////////////////////////////////////////////////////////////////////////////////////////////////

// custom vertex shaders id
#define CUSTOM_VS_INVALID           0
#define CUSTOM_VS_SPG2              1
#define CUSTOM_VS_AFTEREFFECTS      2
#define CUSTOM_VS_SHADOW            3
#define CUSTOM_VS_LIGHTSHAFT        4
#define CUSTOM_VS_WATER             5
#define CUSTOM_VS_HEATSHIMMERING    6
#define CUSTOM_VS_FUR               7
#define CUSTOM_VS_RAIN              8
#define CUSTOM_VS_SHADOWQUAD        9
#define CUSTOM_VS_BLURSHADOW        10
#define CUSTOM_VS_WYB               11
#define CUSTOM_VS_SYMMETRY          12
#define CUSTOM_VS_SPRITE            13
#define CUSTOM_VS_REFLECTION        14

enum XeGlobalConstant {
    VS_GLOBAL_CONSTANT_WORLDVIEWPROJ    = 0,
    VS_GLOBAL_CONSTANT_WORLDVIEW,
    VS_GLOBAL_CONSTANT_INVTRANSWORLDVIEW,
    VS_GLOBAL_CONSTANT_INVTRANSWORLD,
    VS_GLOBAL_CONSTANT_PROJECTION,
    VS_GLOBAL_CONSTANT_SKINNING,
    VS_GLOBAL_CONSTANT_MAXWEIGHT,
    VS_GLOBAL_CONSTANT_TEXTUREMATRIX0,
    VS_GLOBAL_CONSTANT_TANGENTTRANSFORM,
    VS_GLOBAL_CONSTANT_TEXTUREMATRIX1,
    VS_GLOBAL_CONSTANT_TEXTUREMATRIX2,
    VS_GLOBAL_CONSTANT_TEXTUREMATRIX3,
    VS_GLOBAL_CONSTANT_FOG,
    VS_GLOBAL_CONSTANT_AMBIENT_COLOR,
    VS_GLOBAL_CONSTANT_MAT_DIFFUSE,
    VS_GLOBAL_CONSTANT_MAT_CONSTANT,
    VS_GLOBAL_CONSTANT_MAT_SPECULAR,
    VS_GLOBAL_CONSTANT_LIGHTS_ARRAY,
    VS_GLOBAL_CONSTANT_LIGHT_COUNTS,
    VS_GLOBAL_CONSTANT_PER_PIXEL_LIGHT,
    VS_GLOBAL_CONSTANT_VIEWER_VECTOR,
    VS_GLOBAL_CONSTANT_SCALING,
    VS_GLOBAL_CONSTANT_SPG2_UVMANIP,
    VS_GLOBAL_CONSTANT_SPG2_GLOBALPOS,
    VS_GLOBAL_CONSTANT_SPG2_GLOBALZADD,
    VS_GLOBAL_CONSTANT_SPG2_WIND,
    VS_GLOBAL_CONSTANT_SPG2_XCAM,
    VS_GLOBAL_CONSTANT_SPG2_YCAM,
    VS_GLOBAL_CONSTANT_SPG2_GLOBALCOLORWIND,
    //VS_GLOBAL_CONSTANT_SPG2_MIXED1,
    //VS_GLOBAL_CONSTANT_SPG2_MIXED2,
    VS_GLOBAL_CONSTANT_SPG2_RATIO,
    VS_GLOBAL_CONSTANT_SPG2_GLOBALSCALE,
    VS_GLOBAL_CONSTANT_SPG2_NUMSEG,
    VS_GLOBAL_CONSTANT_SPG2_TRAPEZE,
    VS_GLOBAL_CONSTANT_SPG2_TRAPEZEDELTA,
    VS_GLOBAL_CONSTANT_SPG2_EOHP,
    VS_GLOBAL_CONSTANT_SPG2_SPRITERADIUS,
    VS_GLOBAL_CONSTANT_FUR_PARAMS,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_PLANEPARAMS,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_VOLUME,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_MATRIX,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_NOISEMATRIX1,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_NOISEMATRIX2,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_INVWORLDVIEW,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_SHADOWMATRIX,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_TEXOFFSET0_1,
    VS_GLOBAL_CONSTANT_LIGHTSHAFT_TEXOFFSET2_3,
    VS_GLOBAL_CONSTANT_TIME,
    VS_GLOBAL_CONSTANT_REFLECTION_PLANE,
    VS_GLOBAL_CONSTANT_REFLECTION_PLANE_ORIGIN,
    VS_GLOBAL_CONSTANT_VIEWPORTUV,
    VS_GLOBAL_CONSTANT_RESOLUTION,
    VS_GLOBAL_CONSTANT_RAIN_TEXCOORDMDF,
    VS_GLOBAL_CONSTANT_RAIN_TEXCOORDPOS,
    VS_GLOBAL_CONSTANT_RAIN_WINDVECTOR,
    VS_GLOBAL_CONSTANT_RAIN_BLURTEXCOORDOFS0_1,
    VS_GLOBAL_CONSTANT_RAIN_BLURTEXCOORDOFS2_3,
    VS_GLOBAL_CONSTANT_RAIN_BLURPOSOFS,
    VS_GLOBAL_CONSTANT_RAIN_TEXCOORDXFORM,
    VS_GLOBAL_CONSTANT_RIMLIGHT_HEIGHT_ATTENUATION,
    VS_GLOBAL_CONSTANT_WORLD,
    VS_GLOBAL_CONSTANT_HEAT_SHIMMER_CENTER,
    VS_GLOBAL_CONSTANT_HEAT_SHIMMER_SHAPE,
    VS_GLOBAL_CONSTANT_HEAT_SHIMMER_PARAMS,
    VS_GLOBAL_CONSTANT_HEAT_SHIMMER_PROJ,
    VS_GLOBAL_CONSTANT_WORLDSPACE_PLANE_NORMAL,
    VS_GLOBAL_CONSTANT_ZOOM_BLUR_ALPHA,
    VS_GLOBAL_CONSTANT_ZOOM_BLUR_SCALE,
    VS_GLOBAL_CONSTANT_ZOOM_BLUR_TRANSLATE,
    VS_GLOBAL_CONSTANT_ZOOM_BLUR_RATIOS,
    VS_GLOBAL_CONSTANT_HALF_VIEWPORT_TEXEL,
    VS_GLOBAL_CONSTANT_AE_GLOW_INPUT_REGION,
    VS_GLOBAL_CONSTANT_AE_GLOW_OUTPUT_REGION,
    VS_GLOBAL_CONSTANT_AE_BLURDIRECTION,
    VS_GLOBAL_CONSTANT_FOG_PROJECTION,
    VS_GLOBAL_CONSTANT_CAMERA,
    VS_GLOBAL_CONSTANT_FOG_PITCH_ATTENUATION,
    VS_GLOBAL_CONSTANT_AE_BIG_BLUR_FACTOR,
    VS_GLOBAL_CONSTANT_SHADOWBLUROFFSETS,
    VS_GLOBAL_CONSTANT_MIXED2,
    VS_GLOBAL_CONSTANT_WYB_AXES,
    VS_GLOBAL_CONSTANT_WYB_CONDITIONS,
    VS_GLOBAL_CONSTANT_WYB_VALUES,
    VS_GLOBAL_CONSTANT_GODRAY_ADJUST,
    VS_GLOBAL_CONSTANT_SYMMETRY_OFFSET,
    VS_GLOBAL_CONSTANT_LIGHT_BASE,
    VS_GLOBAL_CONSTANT_BORDER_BRIGHTNESS,
    VS_GLOBAL_CONSTANT_SPINSMOOTH_TRANSFORM,
    VS_GLOBAL_CONSTANT_TEXOFFSET01,
    VS_GLOBAL_CONSTANT_TEXOFFSET23,

    VS_GLOBAL_CONSTANT_COUNT,
};

// vertex shader global constant HLSL names
const CHAR g_aszVSGlobalContName[VS_GLOBAL_CONSTANT_COUNT][32] = {
    "g_mWorldViewProj",                 // VS_GLOBAL_CONSTANT_WORLDVIEWPROJ
    "g_mWorldView",                     // VS_GLOBAL_CONSTANT_WORLDVIEW
    "g_mInvTransWorldView",             // VS_GLOBAL_CONSTANT_INVTRANSWORLDVIEW
    "g_mInvTransWorld",                 // VS_GLOBAL_CONSTANT_INVTRANSWORLD
    "g_mProjection",                    // VS_GLOBAL_CONSTANT_PROJECTION
    "g_amSkinning",                     // VS_GLOBAL_CONSTANT_SKINNING
    "g_iMaxWeight",                     // VS_GLOBAL_CONSTANT_MAXWEIGHT
    "g_mTextureTransform0",             // VS_GLOBAL_CONSTANT_TEXTUREMATRIX0
    "g_mTangentTransform",              // VS_GLOBAL_CONSTANT_TANGENTTRANSFORM
    "g_mTextureTransform1",             // VS_GLOBAL_CONSTANT_TEXTUREMATRIX1
    "g_mTextureTransform2",             // VS_GLOBAL_CONSTANT_TEXTUREMATRIX2
    "g_mTextureTransform3",             // VS_GLOBAL_CONSTANT_TEXTUREMATRIX3
    "g_vFogParams",                     // VS_GLOBAL_CONSTANT_FOG
    "g_vAmbientColor",                  // VS_GLOBAL_CONSTANT_AMBIENT_COLOR
    "g_vMatDiffuseColor",               // VS_GLOBAL_CONSTANT_MAT_DIFFUSE
    "g_vMatConstantColor",              // VS_GLOBAL_CONSTANT_MAT_CONSTANT
    "g_vMatSpecularColor",              // VS_GLOBAL_CONSTANT_MAT_SPECULAR
    "g_aoLights",                       // VS_GLOBAL_CONSTANT_LIGHTS_ARRAY
    "g_iLightCounts",                   // VS_GLOBAL_CONSTANT_LIGHT_COUNTS
    "g_aiPerPixelLight",                // VS_GLOBAL_CONSTANT_PER_PIXEL_LIGHT
    "g_vViewerPosition",                // VS_GLOBAL_CONSTANT_VIEWER_VECTOR
    "g_vScalingXForm",                  // VS_GLOBAL_CONSTANT_SCALING
    "g_vSPG2UVManip",                   // VS_GLOBAL_CONSTANT_SPG2_UVMANIP
    "g_vSPG2GlobalPos",                 // VS_GLOBAL_CONSTANT_SPG2_GLOBALPOS
    "g_vSPG2GlobalZAdd",                // VS_GLOBAL_CONSTANT_SPG2_GLOBALZADD
    "g_avSPG2Wind",                     // VS_GLOBAL_CONSTANT_SPG2_WIND
    "g_vSPG2XCam",                      // VS_GLOBAL_CONSTANT_SPG2_XCAM
    "g_vSPG2YCam",                      // VS_GLOBAL_CONSTANT_SPG2_YCAM
    "g_vSPG2GlobalColorWind",           // VS_GLOBAL_CONSTANT_SPG2_GLOBALCOLORWIND
    //"g_vSPG2Mixed1",                    // VS_GLOBAL_CONSTANT_SPG2_MIXED1
    //"g_vSPG2Mixed2",                    // VS_GLOBAL_CONSTANT_SPG2_MIXED2
    "g_fSPG2Ratio",                     // VS_GLOBAL_CONSTANT_SPG2_RATIO
    "g_fSPG2GlobalScale",               // VS_GLOBAL_CONSTANT_SPG2_GLOBALSCALE
    "g_fSPG2OoNumOfSeg",                // VS_GLOBAL_CONSTANT_SPG2_NUMSEG
    "g_fSPG2Trapeze",                   // VS_GLOBAL_CONSTANT_SPG2_TRAPEZE
    "g_fSPG2TrapezeDelta",              // VS_GLOBAL_CONSTANT_SPG2_TRAPEZEDELTA
    "g_fSPG2EOHP",                      // VS_GLOBAL_CONSTANT_SPG2_EOHP
    "g_fSPG2SpriteRadius",              // VS_GLOBAL_CONSTANT_SPG2_SPRITERADIUS
    "g_vFURParams",                     // VS_GLOBAL_CONSTANT_FUR_PARAMS
    "g_vLightShaftPlaneParams",         // VS_GLOBAL_CONSTANT_LIGHTSHAFT_PLANEPARAMS,
    "g_vLightShaftVolume",              // VS_GLOBAL_CONSTANT_LIGHTSHAFT_VOLUME,
    "g_mLightShaftMatrix",              // VS_GLOBAL_CONSTANT_LIGHTSHAFT_MATRIX,
    "g_mLightShaftNoise1",              // VS_GLOBAL_CONSTANT_LIGHTSHAFT_NOISEMATRIX1
    "g_mLightShaftNoise2",              // VS_GLOBAL_CONSTANT_LIGHTSHAFT_NOISEMATRIX2
    "g_mLightShaftInvWorldView",        // VS_GLOBAL_CONSTANT_LIGHTSHAFT_INVWORLDVIEW
    "g_mLightShaftShadowMatrix",        // VS_GLOBAL_CONSTANT_LIGHTSHAFT_SHADOWMATRIX
    "g_vLightShaftTexOffset0_1",        // VS_GLOBAL_CONSTANT_LIGHTSHAFT_TEXOFFSET0_1
    "g_vLightShaftTexOffset2_3",        // VS_GLOBAL_CONSTANT_LIGHTSHAFT_TEXOFFSET2_3
    "g_vTime",                          // VS_GLOBAL_CONSTANT_TIME
    "g_vReflectionPlane",               // VS_GLOBAL_CONSTANT_REFLECTION_PLANE
    "g_vReflectionPlaneOrigin",         // VS_GLOBAL_CONSTANT_REFLECTION_PLANE_ORIGIN
    "g_vViewportUV",                    // VS_GLOBAL_CONSTANT_VIEWPORTUV
    "g_vResolution",                    // VS_GLOBAL_CONSTANT_RESOLUTION
    "g_vRainTexCoordModifiers",         // VS_GLOBAL_CONSTANT_RAIN_TEXCOORDMDF
    "g_vRainTexCoordPosition",          // VS_GLOBAL_CONSTANT_RAIN_TEXCOORDPOS
    "g_vRainWindVector",                // VS_GLOBAL_CONSTANT_RAIN_WINDVECTOR
    "g_vRainBlurTexOffset0_1",          // VS_GLOBAL_CONSTANT_RAIN_BLURTEXCOORDOFS0_1
    "g_vRainBlurTexOffset2_3",          // VS_GLOBAL_CONSTANT_RAIN_BLURTEXCOORDOFS2_3
    "g_vRainBlurPosOffset",             // VS_GLOBAL_CONSTANT_RAIN_BLURPOSOFS
    "g_mRainTexCoordMatrix",            // VS_GLOBAL_CONSTANT_RAIN_TEXCOORDXFORM
    "g_fRimLightHeightAttenuation",     // VS_GLOBAL_CONSTANT_RIMLIGHT_ATTENUATION_WORLD_MIN
    "g_mWorld",                         // VS_GLOBAL_CONSTANT_WORLD
    "g_vHeatShimmerCenter",             // VS_GLOBAL_CONSTANT_HEAT_SHIMMER_CENTER
    "g_vHeatShimmerShape",              // VS_GLOBAL_CONSTANT_HEAT_SHIMMER_SHAPE
    "g_vHeatShimmerParams",             // VS_GLOBAL_CONSTANT_HEAT_SHIMMER_PARAMS
    "g_mHeatShimmerProj",               // VS_GLOBAL_CONSTANT_HEAT_SHIMMER_PROJ
    "g_vWorldSpacePlaneNormal",         // VS_GLOBAL_CONSTANT_WORLDSPACE_PLANE_NORMAL
    "g_fZoomBlurAlpha",                 // VS_GLOBAL_CONSTANT_ZOOM_BLUR_ALPHA
    "g_vZoomBlurScale",                 // VS_GLOBAL_CONSTANT_ZOOM_BLUR_SCALE
    "g_vZoomBlurTranslate",             // VS_GLOBAL_CONSTANT_ZOOM_BLUR_TRANSLATE
    "g_vZoomBlurRatios",                // VS_GLOBAL_CONSTANT_ZOOM_BLUR_RATIOS
    "g_vHalfViewportTexel",             // VS_GLOBAL_CONSTANT_HALF_VIEWPORT_TEXEL
    "g_iAEGlowInputRegion",             // VS_GLOBAL_CONSTANT_AE_GLOW_INPUT_REGION
    "g_iAEGlowOutputRegion",            // VS_GLOBAL_CONSTANT_AE_GLOW_OUTPUT_REGION
    "g_vAEGlowBlurDirection",           // VS_GLOBAL_CONSTANT_AE_BLURDIRECTION
    "g_vFogProjection",                 // VS_GLOBAL_CONSTANT_FOG_PROJECTION
    "g_mCamera",                        // VS_GLOBAL_CONSTANT_CAMERA
    "g_vFogPitchAttenuation",           // VS_GLOBAL_CONSTANT_FOG_PITCH_ATTENUATION
    "g_fBigBlurFactor",                 // VS_GLOBAL_CONSTANT_AE_BIG_BLUR_FACTOR
    "g_afShadowBlurOffsetsAndWeights",  // VS_GLOBAL_CONSTANT_SHADOWBLUROFFSETS
    "g_vMixed2",                        // VS_GLOBAL_CONSTANT_MIXED2
    "g_vWYB_Axes",                      // VS_GLOBAL_CONSTANT_WYB_AXES
    "g_vWYB_Conditions",                // VS_GLOBAL_CONSTANT_WYB_CONDITIONS
    "g_vWYB_Values",                    // VS_GLOBAL_CONSTANT_WYB_VALUES
    "g_vGodRayAdjust",                  // VS_GLOBAL_CONSTANT_GODRAY_ADJUST
    "g_fSymmetryOffset",                // VS_GLOBAL_CONSTANT_SYMMETRY_OFFSET
    "g_iLightBase",                     // VS_GLOBAL_CONSTANT_LIGHT_BASE
    "g_vBorderBrightness",              // VS_GLOBAL_CONSTANT_BORDER_BRIGHTNESS
    "g_mSpinSmoothTransform",           // VS_GLOBAL_CONSTANT_SPINSMOOTH_TRANSFORM
    "g_vTexOffset0_1",                  // VS_GLOBAL_CONSTANT_TEXOFFSET01
    "g_vTexOffset2_3",                  // VS_GLOBAL_CONSTANT_TEXOFFSET23
};

class XePixelShader;

// XeVertexShader class definition
class XeVertexShader : public XeShader<LPDIRECT3DVERTEXSHADER9, VS_GLOBAL_CONSTANT_COUNT>
{
public:

    M_DeclareOperatorNewAndDelete();
    XeVertexShader() : m_ulOutputSemantics( 0 ), m_bIsRequestQueued( FALSE ) {}

    inline BOOL ReInit(const DWORD *_pShaderStream, BOOL _bIsDualStream = TRUE);

    inline XeVertexShader* Duplicate(void) const;

    BOOL        IsRequestQueued( ) { return m_bIsRequestQueued; }
    void        IsRequestQueued( BOOL _bIsRequestQueued ) { m_bIsRequestQueued = _bIsRequestQueued; }

    void        SetOutputSemantics( ULONG64 _ulOutputSemantics) { m_ulOutputSemantics = _ulOutputSemantics; }
    ULONG64     GetOutputSemantics( ) { return m_ulOutputSemantics; }

private:
    ULONG64                 m_ulOutputSemantics;
    BOOL                    m_bIsRequestQueued;
};

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
BOOL XeVertexShader::ReInit(const DWORD *_pShaderStream, BOOL _bIsDualStream)
{
    HRESULT hr;

    const DWORD * pStream = _pShaderStream;
    const DWORD * pStreamConstantTable = _pShaderStream;

#ifdef _XENON
    // On Xenon, _pShaderStream constains the patched stream for vertex shader creation and 
    // the unpatched stream for contant table creation
    if( _bIsDualStream )
    {
        ULONG * pSizes = (ULONG*)_pShaderStream;
        pStream = _pShaderStream + 2;
        pStreamConstantTable = (DWORD*) (((BYTE*)pStream) + pSizes[0]);
    }
#endif

    // create shader interface
    hr = m_pD3DDevice->CreateVertexShader( pStream, &m_pShaderInterface );
    XeValidateRet(SUCCEEDED(hr), FALSE, "Device vertex shader creation failed");

    if (m_pConstantTable == NULL)
    {
        // get constant table
        hr = D3DXGetShaderConstantTable(pStreamConstantTable, &m_pConstantTable);
        if (FAILED(hr))
        {
            // destroy shader interface
            SAFE_RELEASE(m_pShaderInterface);
            SAFE_RELEASE(m_pConstantTable);

            XeValidateRet(SUCCEEDED(hr), FALSE, "Unable to access a vertex shader's constant table");
        }
    }

    // get all global constant handles
    for (ULONG ulCurGlobalConst = 0; ulCurGlobalConst < VS_GLOBAL_CONSTANT_COUNT; ulCurGlobalConst++)
    {
        m_ahConstant[ulCurGlobalConst] = m_pConstantTable->GetConstantByName(NULL, g_aszVSGlobalContName[ulCurGlobalConst]);

        if( m_ahConstant[ulCurGlobalConst] )
        {
            D3DXCONSTANT_DESC oDesc;
            UINT uiCount=1;
            hr = m_pConstantTable->GetConstantDesc(m_ahConstant[ulCurGlobalConst], &oDesc, &uiCount);
            ERR_X_Assert( SUCCEEDED(hr) );
            m_lRegister[ulCurGlobalConst] = oDesc.RegisterIndex;
        }
        else
        {
            m_lRegister[ulCurGlobalConst] = -1;
        }
    }

    D3DXCONSTANT_DESC oDesc[256];
    UINT uiCount = 256;

    if (m_ahConstant[VS_GLOBAL_CONSTANT_LIGHTS_ARRAY] != 0)
    {
        m_pConstantTable->GetConstantDesc(m_ahConstant[VS_GLOBAL_CONSTANT_LIGHTS_ARRAY], &oDesc[0], &uiCount);
    }

#if 0
#if defined(_DEBUG) && defined(_XENON)
    ID3DXBuffer * pDisass = NULL;
    hr = D3DXDisassembleShaderEx(pStream, 0, NULL, &pDisass );
    ERR_X_Assert( SUCCEEDED(hr) );

    m_shaderText = (const char*) pDisass->GetBufferPointer();
    SAFE_RELEASE( pDisass );
#endif
#endif

    return TRUE;
}

inline XeVertexShader* XeVertexShader::Duplicate(void) const
{
    XeVertexShader* pNewShader = new XeVertexShader();

    pNewShader->m_pShaderInterface = m_pShaderInterface;
    pNewShader->m_pConstantTable   = m_pConstantTable;
    pNewShader->m_bAutoGenerated   = m_bAutoGenerated;

    L_memcpy(pNewShader->m_ahConstant, m_ahConstant, VS_GLOBAL_CONSTANT_COUNT * sizeof(D3DXHANDLE));
    L_memcpy(pNewShader->m_lRegister,  m_lRegister,  VS_GLOBAL_CONSTANT_COUNT * sizeof(LONG));

    if (pNewShader->m_pShaderInterface != NULL)
    {
        pNewShader->m_pShaderInterface->AddRef();
    }

    if (pNewShader->m_pConstantTable != NULL)
    {
        pNewShader->m_pConstantTable->AddRef();
    }

#if defined(_DEBUG)
    strcpy(pNewShader->m_Filename, m_Filename);
#endif

    pNewShader->m_ulOutputSemantics = m_ulOutputSemantics;
    pNewShader->m_bIsDefault = m_bIsDefault;

    return pNewShader;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
// pixel shader class and global constant definition
//////////////////////////////////////////////////////////////////////////////////////////////////

// custom pixel shaders id
#define CUSTOM_PS_INVALID           0
#define CUSTOM_PS_AFTEREFFECTS      1
#define CUSTOM_PS_RENDERSHADOW      2
#define CUSTOM_PS_APPLYSHADOW       3
#define CUSTOM_PS_LIGHTSHAFT        4
#define CUSTOM_PS_WATER             5
#define CUSTOM_PS_SPG2PLANT         6
#define CUSTOM_PS_HEATSHIMMERING    7
#define CUSTOM_PS_BLURSHADOW        8
#define CUSTOM_PS_RAIN              9
#define CUSTOM_PS_SHADOWQUAD        10
#define CUSTOM_PS_COMPOSITESHADOW   11
#define CUSTOM_PS_BLURSHADOWPC      12
#define CUSTOM_PS_FUR               13
#define CUSTOM_PS_SPRITE            14
#define CUSTOM_PS_OCEAN             15
#define CUSTOM_PS_REFLECTION        16

enum XePSGlobalConstant {
    PS_GLOBAL_CONSTANT_ENVMAP_COLOR = 0,
    PS_GLOBAL_CONSTANT_AMBIENT_COLOR,
    PS_GLOBAL_CONSTANT_FOGCOLOR,
    PS_GLOBAL_CONSTANT_CONSTANTCOLOR,
    PS_GLOBAL_CONSTANT_MAT_DIFFUSE,
    PS_GLOBAL_CONSTANT_MAT_SPECULAR,
    PS_GLOBAL_CONSTANT_SHADOWCOLOR,
    PS_GLOBAL_CONSTANT_LIGHTSHAFT_COLOR,
    PS_GLOBAL_CONSTANT_LIGHTSHAFT_ATTENUATION,
    PS_GLOBAL_CONSTANT_HEAT_SHIMMER_SCALE,
    PS_GLOBAL_CONSTANT_SHADOWBLUROFFSETS,
    PS_GLOBAL_CONSTANT_SHADOWPARAMS,
    PS_GLOBAL_CONSTANT_RLIBLENDINGSCALE,
    PS_GLOBAL_CONSTANT_RLIBLENDINGOFFSET,
    PS_GLOBAL_CONSTANT_RAIN_ALPHA_BOOST,
    PS_GLOBAL_CONSTANT_RAIN_ALPHA_INTENSITY,
    PS_GLOBAL_CONSTANT_RAIN_COLOR,
    PS_GLOBAL_CONSTANT_RIMLIGHT_COLOR,
    PS_GLOBAL_CONSTANT_FOG_COLOR,
    PS_GLOBAL_CONSTANT_FOG,
    PS_GLOBAL_CONSTANT_FOG_NORMALIZING,
    PS_GLOBAL_CONSTANT_RESOLUTION,
    PS_GLOBAL_CONSTANT_SHADOWCHANNELS,
    PS_GLOBAL_CONSTANT_ALPHATEST_PARAMS,
    PS_GLOBAL_CONSTANT_MOSS_DIFFUSE,
    PS_GLOBAL_CONSTANT_MOSS_MINUS_MAT_DIFFUSE,
    PS_GLOBAL_CONSTANT_CAMERAPARAMS,
    PS_GLOBAL_CONSTANT_CAMTOLIGHTMATRIX,
    PS_GLOBAL_CONSTANT_MIXED1,
    PS_GLOBAL_CONSTANT_MIXED2,
    PS_GLOBAL_CONSTANT_MIXED3,
    PS_GLOBAL_CONSTANT_RIMLIGHT_PARAMS,
    PS_GLOBAL_CONSTANT_WATERMIXED1,
    PS_GLOBAL_CONSTANT_WATERMIXED2,
    PS_GLOBAL_CONSTANT_CASTSHADOWONSTATIC,
    PS_GLOBAL_CONSTANT_MOSS_SPECULAR_FACTOR,
    PS_GLOBAL_CONSTANT_GLOWPARAMS1,
    PS_GLOBAL_CONSTANT_GLOWPARAMS2,
    PS_GLOBAL_CONSTANT_GLOWCOLOR,
    PS_GLOBAL_CONSTANT_GLOW_BLUR_KERNEL,
    PS_GLOBAL_CONSTANT_FOG_PITCH_ATTENUATION,
    PS_GLOBAL_CONSTANT_MOTION_BLUR_ALPHA,
    PS_GLOBAL_CONSTANT_REMANANCE_FACTOR,
    PS_GLOBAL_CONSTANT_COLOR_BALANCE,
    PS_GLOBAL_CONSTANT_BRIGHTNESS,
    PS_GLOBAL_CONSTANT_COUNT,
};

// Pixel shader global constant HLSL names
const CHAR g_aszPSGlobalContName[PS_GLOBAL_CONSTANT_COUNT][32] = {
    "g_vEnvMapColor",                   // PS_GLOBAL_CONSTANT_ENVMAP_COLOR
    "g_vAmbientColor",                  // PS_GLOBAL_CONSTANT_AMBIENT_COLOR
    "g_fFogColor",                      // PS_GLOBAL_CONSTANT_FOGCOLOR
    "g_vConstantColor",                 // PS_GLOBAL_CONSTANT_CONSTANTCOLOR
    "g_avMatDiffuseColor",              // PS_GLOBAL_CONSTANT_MAT_DIFFUSE
    "g_avMatSpecularColor",             // PS_GLOBAL_CONSTANT_MAT_SPECULAR
    "g_fShadowColor",                   // PS_GLOBAL_CONSTANT_SHADOWCOLOR
    "g_vLightShaftColor",               // PS_GLOBAL_CONSTANT_LIGHTSHAFT_COLOR
    "g_vLightShaftAttenuation",         // PS_GLOBAL_CONSTANT_LIGHTSHAFT_ATTENUATION
    "g_vHeatShimmerScale",              // PS_GLOBAL_CONSTANT_HEAT_SHIMMER_SCALE
    "g_afShadowBlurOffsetsAndWeights",  // PS_GLOBAL_CONSTANT_SHADOWBLUROFFSETS
    "g_vShadowParams",                  // PS_GLOBAL_CONSTANT_SHADOWPARAMS
    "g_afRLIBlendingScale",             // PS_GLOBAL_CONSTANT_RLIBLENDINGSCALE
    "g_afRLIBlendingOffset",            // PS_GLOBAL_CONSTANT_RLIBLENDINGOFFSET
    "g_fRainAlphaBoost",                // PS_GLOBAL_CONSTANT_RAIN_ALPHA_BOOST,
    "g_fRainAlphaIntensity",            // PS_GLOBAL_CONSTANT_RAIN_ALPHA_INTENSITY,
    "g_vRainColor",                     // PS_GLOBAL_CONSTANT_RAIN_COLOR
    "g_vRimLightColor",                 // PS_GLOBAL_CONSTANT_RIMLIGHT_COLOR
    "g_vFogColor",                      // PS_GLOBAL_CONSTANT_FOG_COLOR
    "g_vFogParams",                     // PS_GLOBAL_CONSTANT_FOG                     
    "g_vFogNormalizing",                // PS_GLOBAL_CONSTANT_FOG_NORMALIZING
    "g_vResolution",                    // PS_GLOBAL_CONSTANT_RESOLUTION
    "g_vShadowChannels",                // PS_GLOBAL_CONSTANT_SHADOWCHANNELS
    "g_vAlphaTestParams",               // PS_GLOBAL_CONSTANT_ALPHATEST_PARAMS
    "g_avMossColor",                    // PS_GLOBAL_CONSTANT_MOSS_DIFFUSE
    "g_avMossMinusMatDiffuseColor",     // PS_GLOBAL_CONSTANT_MOSS_MINUS_MAT_DIFFUSE
    "g_vCameraParams",                  // PS_GLOBAL_CONSTANT_CAMERAPARAMS
    "g_mCamToLightMatrix",              // PS_GLOBAL_CONSTANT_CAMTOLIGHTMATRIX
    "g_vMixed1",                        // PS_GLOBAL_CONSTANT_MIXED1
    "g_vMixed2",                        // PS_GLOBAL_CONSTANT_MIXED2
    "g_vMixed3",                        // PS_GLOBAL_CONSTANT_MIXED3
    "g_vRimLightParams",                // PS_GLOBAL_CONSTANT_RIMLIGHT_PARAMS
    "g_vWaterMixed1",                   // PS_GLOBAL_CONSTANT_WATERMIXED1
    "g_vWaterMixed2",                   // PS_GLOBAL_CONSTANT_WATERMIXED2
    "g_vCastOnStatic",                  // PS_GLOBAL_CONSTANT_CASTSHADOWONSTATIC
    "g_fMossSpecularFactor",            // PS_GLOBAL_CONSTANT_MOSS_SPECULAR_FACTOR
    "g_vGlowParams1",                   // PS_GLOBAL_CONSTANT_GLOWPARAMS1
    "g_vGlowParams2",                   // PS_GLOBAL_CONSTANT_GLOWPARAMS2
    "g_vGlowColor",                     // PS_GLOBAL_CONSTANT_GLOWCOLOR
    "g_vGlowBlurKernel",                // PS_GLOBAL_CONSTANT_GLOW_BLUR_KERNEL
    "g_vFogPitchAttenuation",           // PS_GLOBAL_CONSTANT_FOG_PITCH_ATTENUATION
    "g_fMotionBlurAlpha",               // PS_GLOBAL_CONSTANT_MOTION_BLUR_ALPHA
    "g_fRemananceFactor",               // PS_GLOBAL_CONSTANT_REMANANCE_FACTOR
    "g_vColorBalance",                  // PS_GLOBAL_CONSTANT_COLOR_BALANCE
    "g_vBrightness",                    // PS_GLOBAL_CONSTANT_BRIGHTNESS
};

// XePixelShader class definition
class XePixelShader : public XeShader<LPDIRECT3DPIXELSHADER9, PS_GLOBAL_CONSTANT_COUNT>
{
public:

    M_DeclareOperatorNewAndDelete();

    XePixelShader() : m_ulInputSemantics( 0 ) {}

    inline BOOL ReInit(const DWORD *_pShaderStream);

    inline XePixelShader*  Duplicate(void) const;

public:
    ULONG64                GetInputSemantics( ) { return m_ulInputSemantics; }
    void                   SetInputSemantics( ULONG64 _ulInputSemantics ) { m_ulInputSemantics = _ulInputSemantics; }
private:
    ULONG64                m_ulInputSemantics;
};

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
BOOL XePixelShader::ReInit(const DWORD *_pShaderStream)
{
    HRESULT hr;

    // create shader interface
    hr = m_pD3DDevice->CreatePixelShader( _pShaderStream, &m_pShaderInterface );
    XeValidateRet(SUCCEEDED(hr), FALSE, "Device pixel shader creation failed");

    if (m_pConstantTable == NULL)
    {
        // get constant table
        hr = D3DXGetShaderConstantTable(_pShaderStream, &m_pConstantTable);
        if (FAILED(hr))
        {
            // destroy shader interface
            SAFE_RELEASE(m_pShaderInterface);
            SAFE_RELEASE(m_pConstantTable);

            XeValidateRet(SUCCEEDED(hr), FALSE, "Unable to access a pixel shader's constant table");
        }
    }

    // get all global constant handles
    for (ULONG ulCurGlobalConst = 0; ulCurGlobalConst < PS_GLOBAL_CONSTANT_COUNT; ulCurGlobalConst++)
    {
        m_ahConstant[ulCurGlobalConst] = m_pConstantTable->GetConstantByName(NULL, g_aszPSGlobalContName[ulCurGlobalConst]);

        if( m_ahConstant[ulCurGlobalConst] )
        {
            D3DXCONSTANT_DESC oDesc;
            UINT uiCount=1;
            hr = m_pConstantTable->GetConstantDesc(m_ahConstant[ulCurGlobalConst], &oDesc, &uiCount);
            ERR_X_Assert( SUCCEEDED(hr) );
            m_lRegister[ulCurGlobalConst] = oDesc.RegisterIndex;
        }
        else
        {
            m_lRegister[ulCurGlobalConst] = -1;
        }
    }

#if 0
#if defined(_DEBUG) && defined(_XENON)
    ID3DXBuffer * pDisass = NULL;
    hr = D3DXDisassembleShaderEx(_pShaderStream, 0, NULL, &pDisass );
    ERR_X_Assert( SUCCEEDED(hr) );

    m_shaderText = (const char*) pDisass->GetBufferPointer();
    SAFE_RELEASE( pDisass );
#endif
#endif

    return TRUE;
}

inline XePixelShader* XePixelShader::Duplicate(void) const
{
    XePixelShader* pNewShader = new XePixelShader();

    pNewShader->m_pShaderInterface = m_pShaderInterface;
    pNewShader->m_pConstantTable   = m_pConstantTable;
    pNewShader->m_bAutoGenerated   = m_bAutoGenerated;

    L_memcpy(pNewShader->m_ahConstant, m_ahConstant, PS_GLOBAL_CONSTANT_COUNT * sizeof(D3DXHANDLE));
    L_memcpy(pNewShader->m_lRegister,  m_lRegister,  PS_GLOBAL_CONSTANT_COUNT * sizeof(LONG));

    if (pNewShader->m_pShaderInterface != NULL)
    {
        pNewShader->m_pShaderInterface->AddRef();
    }

    if (pNewShader->m_pConstantTable != NULL)
    {
        pNewShader->m_pConstantTable->AddRef();
    }

#if defined(_DEBUG)
    strcpy(pNewShader->m_Filename, m_Filename);
#endif

    pNewShader->m_ulInputSemantics = m_ulInputSemantics;
    pNewShader->m_bIsDefault = m_bIsDefault;

    return pNewShader;
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
XeShader<ShaderInterface, ulConstCount>::XeShader()
{
    m_pShaderInterface  = NULL;
    m_pConstantTable    = NULL;
    m_bAutoGenerated    = FALSE;
    m_bIsDefault        = FALSE;

#if defined(_DEBUG)
    m_Filename[0] = 0;
#endif
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
XeShader<ShaderInterface, ulConstCount>::~XeShader()
{
    SAFE_RELEASE(m_pShaderInterface);
    SAFE_RELEASE(m_pConstantTable);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalVector(ULONG _eConst, VECTOR4FLOAT *_pVector)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetVector(m_pD3DDevice, m_ahConstant[_eConst], (D3DXVECTOR4*) _pVector);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalVectorArray(ULONG _eConst, VECTOR4FLOAT *_pVector, INT _iCount)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetVectorArray(m_pD3DDevice, m_ahConstant[_eConst], (D3DXVECTOR4*) _pVector, _iCount);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalMatrix(ULONG _eConst, const D3DXMATRIX *_pMatrix)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetMatrix(m_pD3DDevice, m_ahConstant[_eConst], _pMatrix);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalMatrixArray(ULONG _eConst, D3DXMATRIX *_pMatrixArray, INT _iCount)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetMatrixArray(m_pD3DDevice, m_ahConstant[_eConst], _pMatrixArray, _iCount);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalFloat(ULONG _eConst, FLOAT _fValue)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetFloat(m_pD3DDevice, m_ahConstant[_eConst], _fValue);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalFloatArray(ULONG _eConst, FLOAT *_pfValue, INT _iCount)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetFloatArray(m_pD3DDevice, m_ahConstant[_eConst], _pfValue, _iCount);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalInt(ULONG _eConst, INT _iValue)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetInt(m_pD3DDevice, m_ahConstant[_eConst], _iValue);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalIntArray(ULONG _eConst, INT *_piValue, INT _iCount)
{
    ERR_X_Assert(_eConst < ulConstCount);
    m_pConstantTable->SetIntArray(m_pD3DDevice, m_ahConstant[_eConst], _piValue, _iCount);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalVectorStruct(ULONG _eConst, VECTOR4FLOAT *_pVector)
{
    ERR_X_Assert(_eConst < ulConstCount);
    
    D3DXCONSTANT_DESC   oArrayDesc, oElementDesc;
    UINT                uiCount = 1;

    // TODO Optimize : Members handle should be cached somewhere
    
    m_pConstantTable->GetConstantDesc(m_ahConstant[_eConst], &oArrayDesc, &uiCount);

    // loop for all elements
    for (UINT uiCurElement = 0; uiCurElement < oArrayDesc.Elements; uiCurElement++)
    {
        D3DXHANDLE hElementHandle = m_pConstantTable->GetConstantElement(m_ahConstant[_eConst], uiCurElement);
        m_pConstantTable->GetConstantDesc(hElementHandle, &oElementDesc, &uiCount);

        // loop for all members
        for (UINT uiCurMember = 0; uiCurMember < oElementDesc.StructMembers; uiCurMember++)
        {
            D3DXHANDLE hMemberHandle = m_pConstantTable->GetConstant(hElementHandle, uiCurMember);
            m_pConstantTable->SetVector(m_pD3DDevice, hMemberHandle, (D3DXVECTOR4*) &_pVector[uiCurElement*oElementDesc.StructMembers + uiCurMember]);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetGlobalRawData(ULONG _eConst, VECTOR4FLOAT *_pVector, ULONG ulVectorCount)
{
    HRESULT hr;
    ERR_X_Assert(_eConst < ulConstCount && m_lRegister[_eConst] != -1);

#ifdef _DEBUG
    D3DXCONSTANT_DESC oDesc;
    UINT uiCount=1;
    hr = m_pConstantTable->GetConstantDesc(m_ahConstant[_eConst], &oDesc, &uiCount);
    ERR_X_Assert( SUCCEEDED(hr) && oDesc.RegisterCount >= ulVectorCount );
#endif

    hr = m_pD3DDevice->SetVertexShaderConstantF( m_lRegister[_eConst], (const float*)_pVector, ulVectorCount);
    ERR_X_Assert(SUCCEEDED(hr)); 
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params :  
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
inline BOOL XeShader<ShaderInterface, ulConstCount>::IsGlobalConstPresent(ULONG _eConst)
{
    return (m_ahConstant[_eConst] != 0);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetConstantTable(ID3DXConstantTable* _pTable)
{
    ERR_X_Assert(_pTable != NULL);

    m_pConstantTable = _pTable;
    m_pConstantTable->AddRef();
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------

template <class ShaderInterface, ULONG ulConstCount>
inline
void XeShader<ShaderInterface, ulConstCount>::SetGlobalMatrixAsFloat4x3(ULONG _eConst, const D3DXMATRIX *_pMatrix)
{
    ERR_X_Assert(_pMatrix);

#if defined (_XENON)
    Float4x3 * pResult = NULL;
    FastConstBegin( _eConst, (VECTOR4FLOAT**) &pResult, 3 );
    XeConvertToFloat4x3( *pResult, *_pMatrix );
    FastConstEnd();
#else
     Float4x3 oMatrix;
     XeConvertToFloat4x3( oMatrix, *_pMatrix);
     SetGlobalRawData( _eConst, (VECTOR4FLOAT*)&oMatrix, 3 );
#endif
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------

template <class ShaderInterface, ULONG ulConstCount>
inline
void XeShader<ShaderInterface, ulConstCount>::SetGlobalMatrixAsFloat4x2(ULONG _eConst, const D3DXMATRIX *_pMatrix)
{
    ERR_X_Assert(_pMatrix);

#if defined (_XENON)
    Float4x2 * pResult = NULL;
    FastConstBegin( _eConst, (VECTOR4FLOAT**) &pResult, 2 );
    XeConvertToFloat4x2( *pResult, *_pMatrix );
    FastConstEnd();
#else
    Float4x2 oMatrix;
    XeConvertToFloat4x2( oMatrix, *_pMatrix);
    SetGlobalRawData( _eConst, (VECTOR4FLOAT*)&oMatrix, 2 );
#endif
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
inline
void XeShader<ShaderInterface, ulConstCount>::SetGlobalFloat4x3(ULONG _eConst, const Float4x3 *_pFloat4x3 )
{
    ERR_X_Assert(_pFloat4x3);
    SetGlobalRawData( _eConst, (VECTOR4FLOAT*)_pFloat4x3, 3);
}

// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
inline
void XeShader<ShaderInterface, ulConstCount>::SetGlobalFloat4x2(ULONG _eConst, const Float4x2 *_pFloat4x2 )
{
    ERR_X_Assert(_pFloat4x2);
    SetGlobalRawData( _eConst, (VECTOR4FLOAT*)_pFloat4x2, 2);
}


#ifdef _DEBUG
// ------------------------------------------------------------------------------------------------
// Name   : 
// Params : 
// RetVal :
// Descr. : 
// ------------------------------------------------------------------------------------------------
template <class ShaderInterface, ULONG ulConstCount>
void XeShader<ShaderInterface, ulConstCount>::SetFilename(TCHAR *_szFilename)
{
    if (_szFilename != NULL)
    {
        L_strcpy(m_Filename, _szFilename);
    }
}
#endif

#endif // XESHADER_HEADER
